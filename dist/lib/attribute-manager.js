'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint-disable guard-for-in */


var _luma = require('luma.gl');

var _utils = require('./utils');

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function noop() {}

var AttributeManager = function () {
  /**
   * @classdesc
   * Automated attribute generation and management. Suitable when a set of
   * vertex shader attributes are generated by iteration over a data array,
   * and updates to these attributes are needed either when the data itself
   * changes, or when other data relevant to the calculations change.
   *
   * - First the application registers descriptions of its dynamic vertex
   *   attributes using AttributeManager.add().
   * - Then, when any change that affects attributes is detected by the
   *   application, the app will call AttributeManager.invalidate().
   * - Finally before it renders, it calls AttributeManager.update() to
   *   ensure that attributes are automatically rebuilt if anything has been
   *   invalidated.
   *
   * The application provided update functions describe how attributes
   * should be updated from a data array and are expected to traverse
   * that data array (or iterable) and fill in the attribute's typed array.
   *
   * Note that the attribute manager intentionally does not do advanced
   * change detection, but instead makes it easy to build such detection
   * by offering the ability to "invalidate" each attribute separately.
   *
   * Summary:
   * - keeps track of valid state for each attribute
   * - auto reallocates attributes when needed
   * - auto updates attributes with registered updater functions
   * - allows overriding with application supplied buffers
   *
   * Limitations:
   * - There are currently no provisions for only invalidating a range of
   *   indices in an attribute.
   *
   * @class
   * @param {Object} [props]
   * @param {String} [props.id] - identifier (for debugging)
   */
  function AttributeManager() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$id = _ref.id,
        id = _ref$id === undefined ? 'attribute-manager' : _ref$id;

    _classCallCheck(this, AttributeManager);

    this.id = id;
    this.attributes = {};
    this.updateTriggers = {};
    this.allocedInstances = -1;
    this.needsRedraw = true;
    this.userData = {};

    this.onUpdateStart = noop;
    this.onUpdateEnd = noop;
    this.onLog = this._defaultLog;

    // For debugging sanity, prevent uninitialized members
    Object.seal(this);
  }

  /**
   * Adds attributes
   * Takes a map of attribute descriptor objects
   * - keys are attribute names
   * - values are objects with attribute fields
   *
   * attribute.size - number of elements per object
   * attribute.updater - number of elements
   * attribute.instanced=0 - is this is an instanced attribute (a.k.a. divisor)
   * attribute.noAlloc=false - if this attribute should not be allocated
   *
   * @example
   * attributeManager.add({
   *   positions: {size: 2, update: calculatePositions}
   *   colors: {size: 3, update: calculateColors}
   * });
   *
   * @param {Object} attributes - attribute map (see above)
   * @param {Object} updaters - separate map of update functions (deprecated)
   */


  _createClass(AttributeManager, [{
    key: 'add',
    value: function add(attributes) {
      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._add(attributes, updaters);
    }

    /* Marks an attribute for update
     * @param {string} triggerName: attribute or accessor name
     */

  }, {
    key: 'invalidate',
    value: function invalidate(triggerName) {
      var attributes = this.attributes,
          updateTriggers = this.updateTriggers;

      var attributesToUpdate = updateTriggers[triggerName];

      if (!attributesToUpdate) {
        var message = 'invalidating non-existent attribute ' + triggerName + ' for ' + this.id + '\n';
        message += 'Valid attributes: ' + Object.keys(attributes).join(', ');
        (0, _assert2.default)(attributesToUpdate, message);
      }
      attributesToUpdate.forEach(function (name) {
        var attribute = attributes[name];
        if (attribute) {
          attribute.needsUpdate = true;
        }
      });
      // For performance tuning
      this.onLog(1, 'invalidated attribute ' + attributesToUpdate + ' for ' + this.id);
    }
  }, {
    key: 'invalidateAll',
    value: function invalidateAll() {
      var attributes = this.attributes;

      for (var attributeName in attributes) {
        this.invalidate(attributeName);
      }
    }

    /**
     * Ensure all attribute buffers are updated from props or data.
     *
     * Note: Any preallocated buffers in "buffers" matching registered attribute
     * names will be used. No update will happen in this case.
     * Note: Calls onUpdateStart and onUpdateEnd log callbacks before and after.
     *
     * @param {Object} opts - options
     * @param {Object} opts.data - data (iterable object)
     * @param {Object} opts.numInstances - count of data
     * @param {Object} opts.buffers = {} - pre-allocated buffers
     * @param {Object} opts.props - passed to updaters
     * @param {Object} opts.context - Used as "this" context for updaters
     */

  }, {
    key: 'update',
    value: function update() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          data = _ref2.data,
          numInstances = _ref2.numInstances,
          _ref2$props = _ref2.props,
          props = _ref2$props === undefined ? {} : _ref2$props,
          _ref2$buffers = _ref2.buffers,
          buffers = _ref2$buffers === undefined ? {} : _ref2$buffers,
          _ref2$context = _ref2.context,
          context = _ref2$context === undefined ? {} : _ref2$context,
          _ref2$ignoreUnknownAt = _ref2.ignoreUnknownAttributes,
          ignoreUnknownAttributes = _ref2$ignoreUnknownAt === undefined ? false : _ref2$ignoreUnknownAt;

      // First apply any application provided buffers
      this._checkExternalBuffers({ buffers: buffers, ignoreUnknownAttributes: ignoreUnknownAttributes });
      this._setExternalBuffers(buffers);

      // Only initiate alloc/update (and logging) if actually needed
      if (this._analyzeBuffers({ numInstances: numInstances })) {
        this.onUpdateStart(this.id);
        this._updateBuffers({ numInstances: numInstances, data: data, props: props, context: context });
        this.onUpdateEnd(this.id);
      }
    }

    /**
     * Sets log functions to help trace or time attribute updates.
     * Default logging uses luma logger.
     *
     * Note that the app may not be in control of when update is called,
     * so hooks are provided for update start and end.
     *
     * @param {Object} [opts]
     * @param {String} [opts.onLog=] - called to print
     * @param {String} [opts.onUpdateStart=] - called before update() starts
     * @param {String} [opts.onUpdateEnd=] - called after update() ends
     */

  }, {
    key: 'setLogFunctions',
    value: function setLogFunctions() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          onLog = _ref3.onLog,
          onUpdateStart = _ref3.onUpdateStart,
          onUpdateEnd = _ref3.onUpdateEnd;

      this.onLog = onLog !== undefined ? onLog : this.onLog;
      this.onUpdateStart = onUpdateStart !== undefined ? onUpdateStart : this.onUpdateStart;
      this.onUpdateEnd = onUpdateEnd !== undefined ? onUpdateEnd : this.onUpdateEnd;
    }

    /**
     * Returns all attribute descriptors
     * Note: Format matches luma.gl Model/Program.setAttributes()
     * @return {Object} attributes - descriptors
     */

  }, {
    key: 'getAttributes',
    value: function getAttributes() {
      return this.attributes;
    }

    /**
     * Returns changed attribute descriptors
     * This indicates which WebGLBuggers need to be updated
     * @return {Object} attributes - descriptors
     */

  }, {
    key: 'getChangedAttributes',
    value: function getChangedAttributes(_ref4) {
      var _ref4$clearChangedFla = _ref4.clearChangedFlags,
          clearChangedFlags = _ref4$clearChangedFla === undefined ? false : _ref4$clearChangedFla;
      var attributes = this.attributes;

      var changedAttributes = {};
      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];
        if (attribute.changed) {
          attribute.changed = attribute.changed && !clearChangedFlags;
          changedAttributes[attributeName] = attribute;
        }
      }
      return changedAttributes;
    }

    /**
     * Returns the redraw flag, optionally clearing it.
     * Redraw flag will be set if any attributes attributes changed since
     * flag was last cleared.
     *
     * @param {Object} [opts]
     * @param {String} [opts.clearRedrawFlags=false] - whether to clear the flag
     * @return {Boolean} - whether a redraw is needed.
     */

  }, {
    key: 'getNeedsRedraw',
    value: function getNeedsRedraw() {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref5$clearRedrawFlag = _ref5.clearRedrawFlags,
          clearRedrawFlags = _ref5$clearRedrawFlag === undefined ? false : _ref5$clearRedrawFlag;

      var redraw = this.needsRedraw;
      redraw = redraw || this.needsRedraw;
      this.needsRedraw = this.needsRedraw && !clearRedrawFlags;
      return redraw;
    }

    /**
     * Sets the redraw flag.
     * @param {Boolean} redraw=true
     * @return {AttributeManager} - for chaining
     */

  }, {
    key: 'setNeedsRedraw',
    value: function setNeedsRedraw() {
      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this.needsRedraw = true;
      return this;
    }

    // DEPRECATED METHODS

    /**
     * @deprecated since version 2.5, use add() instead
     * Adds attributes
     * @param {Object} attributes - attribute map (see above)
     * @param {Object} updaters - separate map of update functions (deprecated)
     */

  }, {
    key: 'addDynamic',
    value: function addDynamic(attributes) {
      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._add(attributes, updaters);
    }

    /**
     * @deprecated since version 2.5, use add() instead
     * Adds attributes
     * @param {Object} attributes - attribute map (see above)
     * @param {Object} updaters - separate map of update functions (deprecated)
     */

  }, {
    key: 'addInstanced',
    value: function addInstanced(attributes) {
      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._add(attributes, updaters, { instanced: 1 });
    }

    // PRIVATE METHODS

    // Default logger

  }, {
    key: '_defaultLog',
    value: function _defaultLog(level, message) {
      _utils.log.log(level, message);
    }

    // Used to register an attribute

  }, {
    key: '_add',
    value: function _add(attributes) {
      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _extraProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var newAttributes = {};

      for (var attributeName in attributes) {
        // support for separate update function map
        // For now, just copy any attributes from that map into the main map
        // TODO - Attribute maps are a deprecated feature, remove
        if (attributeName in updaters) {
          attributes[attributeName] = Object.assign({}, attributes[attributeName], updaters[attributeName]);
        }

        var attribute = attributes[attributeName];

        var isIndexed = attribute.isIndexed || attribute.elements;
        var size = attribute.elements && 1 || attribute.size;
        var value = attribute.value || null;

        // Initialize the attribute descriptor, with WebGL and metadata fields
        var attributeData = Object.assign({
          // Ensure that fields are present before Object.seal()
          target: undefined,
          userData: {} // Reserved for application
        },
        // Metadata
        attribute, {
          // State
          isExternalBuffer: false,
          needsAlloc: false,
          needsUpdate: false,
          changed: false,

          // Luma fields
          isIndexed: isIndexed,
          size: size,
          value: value
        }, _extraProps);
        // Sanity - no app fields on our attributes. Use userData instead.
        Object.seal(attributeData);

        // Check all fields and generate helpful error messages
        this._validateAttributeDefinition(attributeName, attributeData);

        // Add to both attributes list (for registration with model)
        newAttributes[attributeName] = attributeData;
      }

      Object.assign(this.attributes, newAttributes);

      this._mapUpdateTriggersToAttributes();
    }

    // build updateTrigger name to attribute name mapping

  }, {
    key: '_mapUpdateTriggersToAttributes',
    value: function _mapUpdateTriggersToAttributes() {
      var _this = this;

      var triggers = {};

      var _loop = function _loop(attributeName) {
        var attribute = _this.attributes[attributeName];
        var accessor = attribute.accessor;

        // use attribute name as update trigger key

        triggers[attributeName] = [attributeName];

        // use accessor name as update trigger key
        if (typeof accessor === 'string') {
          accessor = [accessor];
        }
        if (Array.isArray(accessor)) {
          accessor.forEach(function (accessorName) {
            if (!triggers[accessorName]) {
              triggers[accessorName] = [];
            }
            triggers[accessorName].push(attributeName);
          });
        }
      };

      for (var attributeName in this.attributes) {
        _loop(attributeName);
      }

      this.updateTriggers = triggers;
    }
  }, {
    key: '_validateAttributeDefinition',
    value: function _validateAttributeDefinition(attributeName, attribute) {
      (0, _assert2.default)(attribute.size >= 1 && attribute.size <= 4, 'Attribute definition for ' + attributeName + ' invalid size');

      // Check that either 'accessor' or 'update' is a valid function
      var hasUpdater = attribute.noAlloc || typeof attribute.update === 'function' || typeof attribute.accessor === 'string';
      if (!hasUpdater) {
        throw new Error('Attribute ' + attributeName + ' missing update or accessor');
      }
    }

    // Checks that any attribute buffers in props are valid
    // Note: This is just to help app catch mistakes

  }, {
    key: '_checkExternalBuffers',
    value: function _checkExternalBuffers() {
      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref6$buffers = _ref6.buffers,
          buffers = _ref6$buffers === undefined ? {} : _ref6$buffers,
          _ref6$ignoreUnknownAt = _ref6.ignoreUnknownAttributes,
          ignoreUnknownAttributes = _ref6$ignoreUnknownAt === undefined ? false : _ref6$ignoreUnknownAt;

      var attributes = this.attributes;

      for (var attributeName in buffers) {
        var attribute = attributes[attributeName];
        if (!attribute && !ignoreUnknownAttributes) {
          throw new Error('Unknown attribute prop ' + attributeName);
        }
        // const buffer = buffers[attributeName];
        // TODO - check buffer type
      }
    }

    // Set the buffers for the supplied attributes
    // Update attribute buffers from any attributes in props
    // Detach any previously set buffers, marking all
    // Attributes for auto allocation
    /* eslint-disable max-statements */

  }, {
    key: '_setExternalBuffers',
    value: function _setExternalBuffers(bufferMap) {
      var attributes = this.attributes,
          numInstances = this.numInstances;

      // Copy the refs of any supplied buffers in the props

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];
        var buffer = bufferMap[attributeName];
        attribute.isExternalBuffer = false;
        if (buffer) {
          if (!(buffer instanceof Float32Array)) {
            throw new Error('Attribute properties must be of type Float32Array');
          }
          if (attribute.auto && buffer.length <= numInstances * attribute.size) {
            throw new Error('Attribute prop array must match length and size');
          }

          attribute.isExternalBuffer = true;
          attribute.needsUpdate = false;
          if (attribute.value !== buffer) {
            attribute.value = buffer;
            attribute.changed = true;
            this.needsRedraw = true;
          }
        }
      }
    }
    /* eslint-enable max-statements */

    /* Checks that typed arrays for attributes are big enough
     * sets alloc flag if not
     * @return {Boolean} whether any updates are needed
     */

  }, {
    key: '_analyzeBuffers',
    value: function _analyzeBuffers(_ref7) {
      var numInstances = _ref7.numInstances;
      var attributes = this.attributes;

      (0, _assert2.default)(numInstances !== undefined, 'numInstances not defined');

      // Track whether any allocations or updates are needed
      var needsUpdate = false;

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];
        if (!attribute.isExternalBuffer) {
          // Do we need to reallocate the attribute's typed array?
          var needsAlloc = attribute.value === null || attribute.value.length / attribute.size < numInstances;
          if (needsAlloc && (attribute.update || attribute.accessor)) {
            attribute.needsAlloc = true;
            needsUpdate = true;
          }
          if (attribute.needsUpdate) {
            needsUpdate = true;
          }
        }
      }

      return needsUpdate;
    }

    /**
     * @private
     * Calls update on any buffers that need update
     * TODO? - If app supplied all attributes, no need to iterate over data
     *
     * @param {Object} opts - options
     * @param {Object} opts.data - data (iterable object)
     * @param {Object} opts.numInstances - count of data
     * @param {Object} opts.buffers = {} - pre-allocated buffers
     * @param {Object} opts.props - passed to updaters
     * @param {Object} opts.context - Used as "this" context for updaters
     */
    /* eslint-disable max-statements, complexity */

  }, {
    key: '_updateBuffers',
    value: function _updateBuffers(_ref8) {
      var numInstances = _ref8.numInstances,
          data = _ref8.data,
          props = _ref8.props,
          context = _ref8.context;
      var attributes = this.attributes;

      // Allocate at least one element to ensure a valid buffer

      var allocCount = Math.max(numInstances, 1);

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];

        // Allocate a new typed array if needed
        if (attribute.needsAlloc) {
          var ArrayType = (0, _luma.glArrayFromType)(attribute.type || _luma.GL.FLOAT);
          attribute.value = new ArrayType(attribute.size * allocCount);
          this.onLog(2, this.id + ':' + attributeName + ' allocated ' + allocCount);
          attribute.needsAlloc = false;
          attribute.needsUpdate = true;
        }

        // Call updater function if needed
        if (attribute.needsUpdate) {
          this._updateBuffer({ attribute: attribute, attributeName: attributeName, numInstances: numInstances, data: data, props: props, context: context });
        }
      }

      this.allocedInstances = allocCount;
    }
  }, {
    key: '_updateBuffer',
    value: function _updateBuffer(_ref9) {
      var attribute = _ref9.attribute,
          attributeName = _ref9.attributeName,
          numInstances = _ref9.numInstances,
          data = _ref9.data,
          props = _ref9.props,
          context = _ref9.context;
      var update = attribute.update,
          accessor = attribute.accessor;

      if (update) {
        // Custom updater - typically for non-instanced layers
        this.onLog(2, this.id + ':' + attributeName + ' updating ' + numInstances);
        update.call(context, attribute, { data: data, props: props, numInstances: numInstances });
        this._checkAttributeArray(attribute, attributeName);
      } else if (accessor) {
        // Standard updater
        this._updateBufferViaStandardAccessor({ attribute: attribute, data: data, props: props });
        this._checkAttributeArray(attribute, attributeName);
      } else {
        this.onLog(2, this.id + ':' + attributeName + ' missing update function');
      }

      attribute.needsUpdate = false;
      attribute.changed = true;
      this.needsRedraw = true;
    }
    /* eslint-enable max-statements */

  }, {
    key: '_updateBufferViaStandardAccessor',
    value: function _updateBufferViaStandardAccessor(_ref10) {
      var attribute = _ref10.attribute,
          data = _ref10.data,
          props = _ref10.props;
      var accessor = attribute.accessor,
          value = attribute.value,
          size = attribute.size;

      var accessorFunc = props[accessor];

      (0, _assert2.default)(typeof accessorFunc === 'function', 'accessor "' + accessor + '" is not a function');

      var _attribute$defaultVal = attribute.defaultValue,
          defaultValue = _attribute$defaultVal === undefined ? [0, 0, 0, 0] : _attribute$defaultVal;

      defaultValue = Array.isArray(defaultValue) ? defaultValue : [defaultValue];
      var i = 0;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;

          var objectValue = accessorFunc(object);
          objectValue = Array.isArray(objectValue) ? objectValue : [objectValue];
          /* eslint-disable no-fallthrough, default-case */
          switch (size) {
            case 4:
              value[i + 3] = Number.isFinite(objectValue[3]) ? objectValue[3] : defaultValue[3];
            case 3:
              value[i + 2] = Number.isFinite(objectValue[2]) ? objectValue[2] : defaultValue[2];
            case 2:
              value[i + 1] = Number.isFinite(objectValue[1]) ? objectValue[1] : defaultValue[1];
            case 1:
              value[i + 0] = Number.isFinite(objectValue[0]) ? objectValue[0] : defaultValue[0];
          }
          i += size;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: '_checkAttributeArray',
    value: function _checkAttributeArray(attribute, attributeName) {
      var value = attribute.value;

      if (value && value.length >= 4) {
        var valid = Number.isFinite(value[0]) && Number.isFinite(value[1]) && Number.isFinite(value[2]) && Number.isFinite(value[3]);
        if (!valid) {
          throw new Error('Illegal attribute generated for ' + attributeName);
        }
      }
    }
  }]);

  return AttributeManager;
}();

exports.default = AttributeManager;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvYXR0cmlidXRlLW1hbmFnZXIuanMiXSwibmFtZXMiOlsibm9vcCIsIkF0dHJpYnV0ZU1hbmFnZXIiLCJpZCIsImF0dHJpYnV0ZXMiLCJ1cGRhdGVUcmlnZ2VycyIsImFsbG9jZWRJbnN0YW5jZXMiLCJuZWVkc1JlZHJhdyIsInVzZXJEYXRhIiwib25VcGRhdGVTdGFydCIsIm9uVXBkYXRlRW5kIiwib25Mb2ciLCJfZGVmYXVsdExvZyIsIk9iamVjdCIsInNlYWwiLCJ1cGRhdGVycyIsIl9hZGQiLCJ0cmlnZ2VyTmFtZSIsImF0dHJpYnV0ZXNUb1VwZGF0ZSIsIm1lc3NhZ2UiLCJrZXlzIiwiam9pbiIsImZvckVhY2giLCJhdHRyaWJ1dGUiLCJuYW1lIiwibmVlZHNVcGRhdGUiLCJhdHRyaWJ1dGVOYW1lIiwiaW52YWxpZGF0ZSIsImRhdGEiLCJudW1JbnN0YW5jZXMiLCJwcm9wcyIsImJ1ZmZlcnMiLCJjb250ZXh0IiwiaWdub3JlVW5rbm93bkF0dHJpYnV0ZXMiLCJfY2hlY2tFeHRlcm5hbEJ1ZmZlcnMiLCJfc2V0RXh0ZXJuYWxCdWZmZXJzIiwiX2FuYWx5emVCdWZmZXJzIiwiX3VwZGF0ZUJ1ZmZlcnMiLCJ1bmRlZmluZWQiLCJjbGVhckNoYW5nZWRGbGFncyIsImNoYW5nZWRBdHRyaWJ1dGVzIiwiY2hhbmdlZCIsImNsZWFyUmVkcmF3RmxhZ3MiLCJyZWRyYXciLCJpbnN0YW5jZWQiLCJsZXZlbCIsImxvZyIsIl9leHRyYVByb3BzIiwibmV3QXR0cmlidXRlcyIsImFzc2lnbiIsImlzSW5kZXhlZCIsImVsZW1lbnRzIiwic2l6ZSIsInZhbHVlIiwiYXR0cmlidXRlRGF0YSIsInRhcmdldCIsImlzRXh0ZXJuYWxCdWZmZXIiLCJuZWVkc0FsbG9jIiwiX3ZhbGlkYXRlQXR0cmlidXRlRGVmaW5pdGlvbiIsIl9tYXBVcGRhdGVUcmlnZ2Vyc1RvQXR0cmlidXRlcyIsInRyaWdnZXJzIiwiYWNjZXNzb3IiLCJBcnJheSIsImlzQXJyYXkiLCJhY2Nlc3Nvck5hbWUiLCJwdXNoIiwiaGFzVXBkYXRlciIsIm5vQWxsb2MiLCJ1cGRhdGUiLCJFcnJvciIsImJ1ZmZlck1hcCIsImJ1ZmZlciIsIkZsb2F0MzJBcnJheSIsImF1dG8iLCJsZW5ndGgiLCJhbGxvY0NvdW50IiwiTWF0aCIsIm1heCIsIkFycmF5VHlwZSIsInR5cGUiLCJGTE9BVCIsIl91cGRhdGVCdWZmZXIiLCJjYWxsIiwiX2NoZWNrQXR0cmlidXRlQXJyYXkiLCJfdXBkYXRlQnVmZmVyVmlhU3RhbmRhcmRBY2Nlc3NvciIsImFjY2Vzc29yRnVuYyIsImRlZmF1bHRWYWx1ZSIsImkiLCJvYmplY3QiLCJvYmplY3RWYWx1ZSIsIk51bWJlciIsImlzRmluaXRlIiwidmFsaWQiXSwibWFwcGluZ3MiOiI7Ozs7OztxakJBQUE7OztBQUNBOztBQUNBOztBQUNBOzs7Ozs7OztBQUNBLFNBQVNBLElBQVQsR0FBZ0IsQ0FBRTs7SUFFR0MsZ0I7QUFDbkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQ0EsOEJBQTZDO0FBQUEsbUZBQUosRUFBSTtBQUFBLHVCQUFoQ0MsRUFBZ0M7QUFBQSxRQUFoQ0EsRUFBZ0MsMkJBQTNCLG1CQUEyQjs7QUFBQTs7QUFDM0MsU0FBS0EsRUFBTCxHQUFVQSxFQUFWO0FBQ0EsU0FBS0MsVUFBTCxHQUFrQixFQUFsQjtBQUNBLFNBQUtDLGNBQUwsR0FBc0IsRUFBdEI7QUFDQSxTQUFLQyxnQkFBTCxHQUF3QixDQUFDLENBQXpCO0FBQ0EsU0FBS0MsV0FBTCxHQUFtQixJQUFuQjtBQUNBLFNBQUtDLFFBQUwsR0FBZ0IsRUFBaEI7O0FBRUEsU0FBS0MsYUFBTCxHQUFxQlIsSUFBckI7QUFDQSxTQUFLUyxXQUFMLEdBQW1CVCxJQUFuQjtBQUNBLFNBQUtVLEtBQUwsR0FBYSxLQUFLQyxXQUFsQjs7QUFFQTtBQUNBQyxXQUFPQyxJQUFQLENBQVksSUFBWjtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7d0JBb0JJVixVLEVB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QWIsQ0FBbEU7QUFDUixpQkFBSyxDQUFMO0FBQVFqQyxvQkFBTWtDLElBQUksQ0FBVixJQUFlRyxPQUFPQyxRQUFQLENBQWdCRixZQUFZLENBQVosQ0FBaEIsSUFBa0NBLFlBQVksQ0FBWixDQUFsQyxHQUFtREgsYUFBYSxDQUFiLENBQWxFO0FBQ1IsaUJBQUssQ0FBTDtBQUFRakMsb0JBQU1rQyxJQUFJLENBQVYsSUFBZUcsT0FBT0MsUUFBUCxDQUFnQkYsWUFBWSxDQUFaLENBQWhCLElBQWtDQSxZQUFZLENBQVosQ0FBbEMsR0FBbURILGFBQWEsQ0FBYixDQUFsRTtBQUpSO0FBTUFDLGVBQUtuQyxJQUFMO0FBQ0Q7QUFwQndEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFxQjFEOzs7eUNBRW9CN0IsUyxFQUFXRyxhLEVBQWU7QUFBQSxVQUN0QzJCLEtBRHNDLEdBQzdCOUIsU0FENkIsQ0FDdEM4QixLQURzQzs7QUFFN0MsVUFBSUEsU0FBU0EsTUFBTXFCLE1BQU4sSUFBZ0IsQ0FBN0IsRUFBZ0M7QUFDOUIsWUFBTWtCLFFBQ0pGLE9BQU9DLFFBQVAsQ0FBZ0J0QyxNQUFNLENBQU4sQ0FBaEIsS0FBNkJxQyxPQUFPQyxRQUFQLENBQWdCdEMsTUFBTSxDQUFOLENBQWhCLENBQTdCLElBQ0FxQyxPQUFPQyxRQUFQLENBQWdCdEMsTUFBTSxDQUFOLENBQWhCLENBREEsSUFDNkJxQyxPQUFPQyxRQUFQLENBQWdCdEMsTUFBTSxDQUFOLENBQWhCLENBRi9CO0FBR0EsWUFBSSxDQUFDdUMsS0FBTCxFQUFZO0FBQ1YsZ0JBQU0sSUFBSXZCLEtBQUosc0NBQTZDM0MsYUFBN0MsQ0FBTjtBQUNEO0FBQ0Y7QUFDRjs7Ozs7O2tCQTFnQmtCeEIsZ0IiLCJmaWxlIjoiYXR0cmlidXRlLW1hbmFnZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBndWFyZC1mb3ItaW4gKi9cbmltcG9ydCB7R0wsIGdsQXJyYXlGcm9tVHlwZX0gZnJvbSAnbHVtYS5nbCc7XG5pbXBvcnQge2xvZ30gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5mdW5jdGlvbiBub29wKCkge31cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXR0cmlidXRlTWFuYWdlciB7XG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIEF1dG9tYXRlZCBhdHRyaWJ1dGUgZ2VuZXJhdGlvbiBhbmQgbWFuYWdlbWVudC4gU3VpdGFibGUgd2hlbiBhIHNldCBvZlxuICAgKiB2ZXJ0ZXggc2hhZGVyIGF0dHJpYnV0ZXMgYXJlIGdlbmVyYXRlZCBieSBpdGVyYXRpb24gb3ZlciBhIGRhdGEgYXJyYXksXG4gICAqIGFuZCB1cGRhdGVzIHRvIHRoZXNlIGF0dHJpYnV0ZXMgYXJlIG5lZWRlZCBlaXRoZXIgd2hlbiB0aGUgZGF0YSBpdHNlbGZcbiAgICogY2hhbmdlcywgb3Igd2hlbiBvdGhlciBkYXRhIHJlbGV2YW50IHRvIHRoZSBjYWxjdWxhdGlvbnMgY2hhbmdlLlxuICAgKlxuICAgKiAtIEZpcnN0IHRoZSBhcHBsaWNhdGlvbiByZWdpc3RlcnMgZGVzY3JpcHRpb25zIG9mIGl0cyBkeW5hbWljIHZlcnRleFxuICAgKiAgIGF0dHJpYnV0ZXMgdXNpbmcgQXR0cmlidXRlTWFuYWdlci5hZGQoKS5cbiAgICogLSBUaGVuLCB3aGVuIGFueSBjaGFuZ2UgdGhhdCBhZmZlY3RzIGF0dHJpYnV0ZXMgaXMgZGV0ZWN0ZWQgYnkgdGhlXG4gICAqICAgYXBwbGljYXRpb24sIHRoZSBhcHAgd2lsbCBjYWxsIEF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZSgpLlxuICAgKiAtIEZpbmFsbHkgYmVmb3JlIGl0IHJlbmRlcnMsIGl0IGNhbGxzIEF0dHJpYnV0ZU1hbmFnZXIudXBkYXRlKCkgdG9cbiAgICogICBlbnN1cmUgdGhhdCBhdHRyaWJ1dGVzIGFyZSBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgaWYgYW55dGhpbmcgaGFzIGJlZW5cbiAgICogICBpbnZhbGlkYXRlZC5cbiAgICpcbiAgICogVGhlIGFwcGxpY2F0aW9uIHByb3ZpZGVkIHVwZGF0ZSBmdW5jdGlvbnMgZGVzY3JpYmUgaG93IGF0dHJpYnV0ZXNcbiAgICogc2hvdWxkIGJlIHVwZGF0ZWQgZnJvbSBhIGRhdGEgYXJyYXkgYW5kIGFyZSBleHBlY3RlZCB0byB0cmF2ZXJzZVxuICAgKiB0aGF0IGRhdGEgYXJyYXkgKG9yIGl0ZXJhYmxlKSBhbmQgZmlsbCBpbiB0aGUgYXR0cmlidXRlJ3MgdHlwZWQgYXJyYXkuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgYXR0cmlidXRlIG1hbmFnZXIgaW50ZW50aW9uYWxseSBkb2VzIG5vdCBkbyBhZHZhbmNlZFxuICAgKiBjaGFuZ2UgZGV0ZWN0aW9uLCBidXQgaW5zdGVhZCBtYWtlcyBpdCBlYXN5IHRvIGJ1aWxkIHN1Y2ggZGV0ZWN0aW9uXG4gICAqIGJ5IG9mZmVyaW5nIHRoZSBhYmlsaXR5IHRvIFwiaW52YWxpZGF0ZVwiIGVhY2ggYXR0cmlidXRlIHNlcGFyYXRlbHkuXG4gICAqXG4gICAqIFN1bW1hcnk6XG4gICAqIC0ga2VlcHMgdHJhY2sgb2YgdmFsaWQgc3RhdGUgZm9yIGVhY2ggYXR0cmlidXRlXG4gICAqIC0gYXV0byByZWFsbG9jYXRlcyBhdHRyaWJ1dGVzIHdoZW4gbmVlZGVkXG4gICAqIC0gYXV0byB1cGRhdGVzIGF0dHJpYnV0ZXMgd2l0aCByZWdpc3RlcmVkIHVwZGF0ZXIgZnVuY3Rpb25zXG4gICAqIC0gYWxsb3dzIG92ZXJyaWRpbmcgd2l0aCBhcHBsaWNhdGlvbiBzdXBwbGllZCBidWZmZXJzXG4gICAqXG4gICAqIExpbWl0YXRpb25zOlxuICAgKiAtIFRoZXJlIGFyZSBjdXJyZW50bHkgbm8gcHJvdmlzaW9ucyBmb3Igb25seSBpbnZhbGlkYXRpbmcgYSByYW5nZSBvZlxuICAgKiAgIGluZGljZXMgaW4gYW4gYXR0cmlidXRlLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc11cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wcy5pZF0gLSBpZGVudGlmaWVyIChmb3IgZGVidWdnaW5nKVxuICAgKi9cbiAgY29uc3RydWN0b3Ioe2lkID0gJ2F0dHJpYnV0ZS1tYW5hZ2VyJ30gPSB7fSkge1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICB0aGlzLnVwZGF0ZVRyaWdnZXJzID0ge307XG4gICAgdGhpcy5hbGxvY2VkSW5zdGFuY2VzID0gLTE7XG4gICAgdGhpcy5uZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgdGhpcy51c2VyRGF0YSA9IHt9O1xuXG4gICAgdGhpcy5vblVwZGF0ZVN0YXJ0ID0gbm9vcDtcbiAgICB0aGlzLm9uVXBkYXRlRW5kID0gbm9vcDtcbiAgICB0aGlzLm9uTG9nID0gdGhpcy5fZGVmYXVsdExvZztcblxuICAgIC8vIEZvciBkZWJ1Z2dpbmcgc2FuaXR5LCBwcmV2ZW50IHVuaW5pdGlhbGl6ZWQgbWVtYmVyc1xuICAgIE9iamVjdC5zZWFsKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYXR0cmlidXRlc1xuICAgKiBUYWtlcyBhIG1hcCBvZiBhdHRyaWJ1dGUgZGVzY3JpcHRvciBvYmplY3RzXG4gICAqIC0ga2V5cyBhcmUgYXR0cmlidXRlIG5hbWVzXG4gICAqIC0gdmFsdWVzIGFyZSBvYmplY3RzIHdpdGggYXR0cmlidXRlIGZpZWxkc1xuICAgKlxuICAgKiBhdHRyaWJ1dGUuc2l6ZSAtIG51bWJlciBvZiBlbGVtZW50cyBwZXIgb2JqZWN0XG4gICAqIGF0dHJpYnV0ZS51cGRhdGVyIC0gbnVtYmVyIG9mIGVsZW1lbnRzXG4gICAqIGF0dHJpYnV0ZS5pbnN0YW5jZWQ9MCAtIGlzIHRoaXMgaXMgYW4gaW5zdGFuY2VkIGF0dHJpYnV0ZSAoYS5rLmEuIGRpdmlzb3IpXG4gICAqIGF0dHJpYnV0ZS5ub0FsbG9jPWZhbHNlIC0gaWYgdGhpcyBhdHRyaWJ1dGUgc2hvdWxkIG5vdCBiZSBhbGxvY2F0ZWRcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYXR0cmlidXRlTWFuYWdlci5hZGQoe1xuICAgKiAgIHBvc2l0aW9uczoge3NpemU6IDIsIHVwZGF0ZTogY2FsY3VsYXRlUG9zaXRpb25zfVxuICAgKiAgIGNvbG9yczoge3NpemU6IDMsIHVwZGF0ZTogY2FsY3VsYXRlQ29sb3JzfVxuICAgKiB9KTtcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXMgLSBhdHRyaWJ1dGUgbWFwIChzZWUgYWJvdmUpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB1cGRhdGVycyAtIHNlcGFyYXRlIG1hcCBvZiB1cGRhdGUgZnVuY3Rpb25zIChkZXByZWNhdGVkKVxuICAgKi9cbiAgYWRkKGF0dHJpYnV0ZXMsIHVwZGF0ZXJzID0ge30pIHtcbiAgICB0aGlzLl9hZGQoYXR0cmlidXRlcywgdXBkYXRlcnMpO1xuICB9XG5cbiAgLyogTWFya3MgYW4gYXR0cmlidXRlIGZvciB1cGRhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRyaWdnZXJOYW1lOiBhdHRyaWJ1dGUgb3IgYWNjZXNzb3IgbmFtZVxuICAgKi9cbiAgaW52YWxpZGF0ZSh0cmlnZ2VyTmFtZSkge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVzLCB1cGRhdGVUcmlnZ2Vyc30gPSB0aGlzO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXNUb1VwZGF0ZSA9IHVwZGF0ZVRyaWdnZXJzW3RyaWdnZXJOYW1lXTtcblxuICAgIGlmICghYXR0cmlidXRlc1RvVXBkYXRlKSB7XG4gICAgICBsZXQgbWVzc2FnZSA9XG4gICAgICAgIGBpbnZhbGlkYXRpbmcgbm9uLWV4aXN0ZW50IGF0dHJpYnV0ZSAke3RyaWdnZXJOYW1lfSBmb3IgJHt0aGlzLmlkfVxcbmA7XG4gICAgICBtZXNzYWdlICs9IGBWYWxpZCBhdHRyaWJ1dGVzOiAke09iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmpvaW4oJywgJyl9YDtcbiAgICAgIGFzc2VydChhdHRyaWJ1dGVzVG9VcGRhdGUsIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBhdHRyaWJ1dGVzVG9VcGRhdGUuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICBpZiAoYXR0cmlidXRlKSB7XG4gICAgICAgIGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gRm9yIHBlcmZvcm1hbmNlIHR1bmluZ1xuICAgIHRoaXMub25Mb2coMSwgYGludmFsaWRhdGVkIGF0dHJpYnV0ZSAke2F0dHJpYnV0ZXNUb1VwZGF0ZX0gZm9yICR7dGhpcy5pZH1gKTtcbiAgfVxuXG4gIGludmFsaWRhdGVBbGwoKSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZXN9ID0gdGhpcztcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbnN1cmUgYWxsIGF0dHJpYnV0ZSBidWZmZXJzIGFyZSB1cGRhdGVkIGZyb20gcHJvcHMgb3IgZGF0YS5cbiAgICpcbiAgICogTm90ZTogQW55IHByZWFsbG9jYXRlZCBidWZmZXJzIGluIFwiYnVmZmVyc1wiIG1hdGNoaW5nIHJlZ2lzdGVyZWQgYXR0cmlidXRlXG4gICAqIG5hbWVzIHdpbGwgYmUgdXNlZC4gTm8gdXBkYXRlIHdpbGwgaGFwcGVuIGluIHRoaXMgY2FzZS5cbiAgICogTm90ZTogQ2FsbHMgb25VcGRhdGVTdGFydCBhbmQgb25VcGRhdGVFbmQgbG9nIGNhbGxiYWNrcyBiZWZvcmUgYW5kIGFmdGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuZGF0YSAtIGRhdGEgKGl0ZXJhYmxlIG9iamVjdClcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMubnVtSW5zdGFuY2VzIC0gY291bnQgb2YgZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5idWZmZXJzID0ge30gLSBwcmUtYWxsb2NhdGVkIGJ1ZmZlcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMucHJvcHMgLSBwYXNzZWQgdG8gdXBkYXRlcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuY29udGV4dCAtIFVzZWQgYXMgXCJ0aGlzXCIgY29udGV4dCBmb3IgdXBkYXRlcnNcbiAgICovXG4gIHVwZGF0ZSh7XG4gICAgZGF0YSxcbiAgICBudW1JbnN0YW5jZXMsXG4gICAgcHJvcHMgPSB7fSxcbiAgICBidWZmZXJzID0ge30sXG4gICAgY29udGV4dCA9IHt9LFxuICAgIGlnbm9yZVVua25vd25BdHRyaWJ1dGVzID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgLy8gRmlyc3QgYXBwbHkgYW55IGFwcGxpY2F0aW9uIHByb3ZpZGVkIGJ1ZmZlcnNcbiAgICB0aGlzLl9jaGVja0V4dGVybmFsQnVmZmVycyh7YnVmZmVycywgaWdub3JlVW5rbm93bkF0dHJpYnV0ZXN9KTtcbiAgICB0aGlzLl9zZXRFeHRlcm5hbEJ1ZmZlcnMoYnVmZmVycyk7XG5cbiAgICAvLyBPbmx5IGluaXRpYXRlIGFsbG9jL3VwZGF0ZSAoYW5kIGxvZ2dpbmcpIGlmIGFjdHVhbGx5IG5lZWRlZFxuICAgIGlmICh0aGlzLl9hbmFseXplQnVmZmVycyh7bnVtSW5zdGFuY2VzfSkpIHtcbiAgICAgIHRoaXMub25VcGRhdGVTdGFydCh0aGlzLmlkKTtcbiAgICAgIHRoaXMuX3VwZGF0ZUJ1ZmZlcnMoe251bUluc3RhbmNlcywgZGF0YSwgcHJvcHMsIGNvbnRleHR9KTtcbiAgICAgIHRoaXMub25VcGRhdGVFbmQodGhpcy5pZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgbG9nIGZ1bmN0aW9ucyB0byBoZWxwIHRyYWNlIG9yIHRpbWUgYXR0cmlidXRlIHVwZGF0ZXMuXG4gICAqIERlZmF1bHQgbG9nZ2luZyB1c2VzIGx1bWEgbG9nZ2VyLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIGFwcCBtYXkgbm90IGJlIGluIGNvbnRyb2wgb2Ygd2hlbiB1cGRhdGUgaXMgY2FsbGVkLFxuICAgKiBzbyBob29rcyBhcmUgcHJvdmlkZWQgZm9yIHVwZGF0ZSBzdGFydCBhbmQgZW5kLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0cy5vbkxvZz1dIC0gY2FsbGVkIHRvIHByaW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0cy5vblVwZGF0ZVN0YXJ0PV0gLSBjYWxsZWQgYmVmb3JlIHVwZGF0ZSgpIHN0YXJ0c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdHMub25VcGRhdGVFbmQ9XSAtIGNhbGxlZCBhZnRlciB1cGRhdGUoKSBlbmRzXG4gICAqL1xuICBzZXRMb2dGdW5jdGlvbnMoe1xuICAgIG9uTG9nLFxuICAgIG9uVXBkYXRlU3RhcnQsXG4gICAgb25VcGRhdGVFbmRcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5vbkxvZyA9IG9uTG9nICE9PSB1bmRlZmluZWQgPyBvbkxvZyA6IHRoaXMub25Mb2c7XG4gICAgdGhpcy5vblVwZGF0ZVN0YXJ0ID1cbiAgICAgIG9uVXBkYXRlU3RhcnQgIT09IHVuZGVmaW5lZCA/IG9uVXBkYXRlU3RhcnQgOiB0aGlzLm9uVXBkYXRlU3RhcnQ7XG4gICAgdGhpcy5vblVwZGF0ZUVuZCA9XG4gICAgICBvblVwZGF0ZUVuZCAhPT0gdW5kZWZpbmVkID8gb25VcGRhdGVFbmQgOiB0aGlzLm9uVXBkYXRlRW5kO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGF0dHJpYnV0ZSBkZXNjcmlwdG9yc1xuICAgKiBOb3RlOiBGb3JtYXQgbWF0Y2hlcyBsdW1hLmdsIE1vZGVsL1Byb2dyYW0uc2V0QXR0cmlidXRlcygpXG4gICAqIEByZXR1cm4ge09iamVjdH0gYXR0cmlidXRlcyAtIGRlc2NyaXB0b3JzXG4gICAqL1xuICBnZXRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBjaGFuZ2VkIGF0dHJpYnV0ZSBkZXNjcmlwdG9yc1xuICAgKiBUaGlzIGluZGljYXRlcyB3aGljaCBXZWJHTEJ1Z2dlcnMgbmVlZCB0byBiZSB1cGRhdGVkXG4gICAqIEByZXR1cm4ge09iamVjdH0gYXR0cmlidXRlcyAtIGRlc2NyaXB0b3JzXG4gICAqL1xuICBnZXRDaGFuZ2VkQXR0cmlidXRlcyh7Y2xlYXJDaGFuZ2VkRmxhZ3MgPSBmYWxzZX0pIHtcbiAgICBjb25zdCB7YXR0cmlidXRlc30gPSB0aGlzO1xuICAgIGNvbnN0IGNoYW5nZWRBdHRyaWJ1dGVzID0ge307XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICBpZiAoYXR0cmlidXRlLmNoYW5nZWQpIHtcbiAgICAgICAgYXR0cmlidXRlLmNoYW5nZWQgPSBhdHRyaWJ1dGUuY2hhbmdlZCAmJiAhY2xlYXJDaGFuZ2VkRmxhZ3M7XG4gICAgICAgIGNoYW5nZWRBdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdID0gYXR0cmlidXRlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZEF0dHJpYnV0ZXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVkcmF3IGZsYWcsIG9wdGlvbmFsbHkgY2xlYXJpbmcgaXQuXG4gICAqIFJlZHJhdyBmbGFnIHdpbGwgYmUgc2V0IGlmIGFueSBhdHRyaWJ1dGVzIGF0dHJpYnV0ZXMgY2hhbmdlZCBzaW5jZVxuICAgKiBmbGFnIHdhcyBsYXN0IGNsZWFyZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c11cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRzLmNsZWFyUmVkcmF3RmxhZ3M9ZmFsc2VdIC0gd2hldGhlciB0byBjbGVhciB0aGUgZmxhZ1xuICAgKiBAcmV0dXJuIHtCb29sZWFufSAtIHdoZXRoZXIgYSByZWRyYXcgaXMgbmVlZGVkLlxuICAgKi9cbiAgZ2V0TmVlZHNSZWRyYXcoe2NsZWFyUmVkcmF3RmxhZ3MgPSBmYWxzZX0gPSB7fSkge1xuICAgIGxldCByZWRyYXcgPSB0aGlzLm5lZWRzUmVkcmF3O1xuICAgIHJlZHJhdyA9IHJlZHJhdyB8fCB0aGlzLm5lZWRzUmVkcmF3O1xuICAgIHRoaXMubmVlZHNSZWRyYXcgPSB0aGlzLm5lZWRzUmVkcmF3ICYmICFjbGVhclJlZHJhd0ZsYWdzO1xuICAgIHJldHVybiByZWRyYXc7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcmVkcmF3IGZsYWcuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVkcmF3PXRydWVcbiAgICogQHJldHVybiB7QXR0cmlidXRlTWFuYWdlcn0gLSBmb3IgY2hhaW5pbmdcbiAgICovXG4gIHNldE5lZWRzUmVkcmF3KHJlZHJhdyA9IHRydWUpIHtcbiAgICB0aGlzLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIERFUFJFQ0FURUQgTUVUSE9EU1xuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNSwgdXNlIGFkZCgpIGluc3RlYWRcbiAgICogQWRkcyBhdHRyaWJ1dGVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzIC0gYXR0cmlidXRlIG1hcCAoc2VlIGFib3ZlKVxuICAgKiBAcGFyYW0ge09iamVjdH0gdXBkYXRlcnMgLSBzZXBhcmF0ZSBtYXAgb2YgdXBkYXRlIGZ1bmN0aW9ucyAoZGVwcmVjYXRlZClcbiAgICovXG4gIGFkZER5bmFtaWMoYXR0cmlidXRlcywgdXBkYXRlcnMgPSB7fSkge1xuICAgIHRoaXMuX2FkZChhdHRyaWJ1dGVzLCB1cGRhdGVycyk7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjUsIHVzZSBhZGQoKSBpbnN0ZWFkXG4gICAqIEFkZHMgYXR0cmlidXRlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlcyAtIGF0dHJpYnV0ZSBtYXAgKHNlZSBhYm92ZSlcbiAgICogQHBhcmFtIHtPYmplY3R9IHVwZGF0ZXJzIC0gc2VwYXJhdGUgbWFwIG9mIHVwZGF0ZSBmdW5jdGlvbnMgKGRlcHJlY2F0ZWQpXG4gICAqL1xuICBhZGRJbnN0YW5jZWQoYXR0cmlidXRlcywgdXBkYXRlcnMgPSB7fSkge1xuICAgIHRoaXMuX2FkZChhdHRyaWJ1dGVzLCB1cGRhdGVycywge2luc3RhbmNlZDogMX0pO1xuICB9XG5cbiAgLy8gUFJJVkFURSBNRVRIT0RTXG5cbiAgLy8gRGVmYXVsdCBsb2dnZXJcbiAgX2RlZmF1bHRMb2cobGV2ZWwsIG1lc3NhZ2UpIHtcbiAgICBsb2cubG9nKGxldmVsLCBtZXNzYWdlKTtcbiAgfVxuXG4gIC8vIFVzZWQgdG8gcmVnaXN0ZXIgYW4gYXR0cmlidXRlXG4gIF9hZGQoYXR0cmlidXRlcywgdXBkYXRlcnMgPSB7fSwgX2V4dHJhUHJvcHMgPSB7fSkge1xuXG4gICAgY29uc3QgbmV3QXR0cmlidXRlcyA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIC8vIHN1cHBvcnQgZm9yIHNlcGFyYXRlIHVwZGF0ZSBmdW5jdGlvbiBtYXBcbiAgICAgIC8vIEZvciBub3csIGp1c3QgY29weSBhbnkgYXR0cmlidXRlcyBmcm9tIHRoYXQgbWFwIGludG8gdGhlIG1haW4gbWFwXG4gICAgICAvLyBUT0RPIC0gQXR0cmlidXRlIG1hcHMgYXJlIGEgZGVwcmVjYXRlZCBmZWF0dXJlLCByZW1vdmVcbiAgICAgIGlmIChhdHRyaWJ1dGVOYW1lIGluIHVwZGF0ZXJzKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0gPVxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0sIHVwZGF0ZXJzW2F0dHJpYnV0ZU5hbWVdKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcblxuICAgICAgY29uc3QgaXNJbmRleGVkID0gYXR0cmlidXRlLmlzSW5kZXhlZCB8fCBhdHRyaWJ1dGUuZWxlbWVudHM7XG4gICAgICBjb25zdCBzaXplID0gKGF0dHJpYnV0ZS5lbGVtZW50cyAmJiAxKSB8fCBhdHRyaWJ1dGUuc2l6ZTtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXR0cmlidXRlLnZhbHVlIHx8IG51bGw7XG5cbiAgICAgIC8vIEluaXRpYWxpemUgdGhlIGF0dHJpYnV0ZSBkZXNjcmlwdG9yLCB3aXRoIFdlYkdMIGFuZCBtZXRhZGF0YSBmaWVsZHNcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZURhdGEgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICB7XG4gICAgICAgICAgLy8gRW5zdXJlIHRoYXQgZmllbGRzIGFyZSBwcmVzZW50IGJlZm9yZSBPYmplY3Quc2VhbCgpXG4gICAgICAgICAgdGFyZ2V0OiB1bmRlZmluZWQsXG4gICAgICAgICAgdXNlckRhdGE6IHt9ICAgICAgICAvLyBSZXNlcnZlZCBmb3IgYXBwbGljYXRpb25cbiAgICAgICAgfSxcbiAgICAgICAgLy8gTWV0YWRhdGFcbiAgICAgICAgYXR0cmlidXRlLFxuICAgICAgICB7XG4gICAgICAgICAgLy8gU3RhdGVcbiAgICAgICAgICBpc0V4dGVybmFsQnVmZmVyOiBmYWxzZSxcbiAgICAgICAgICBuZWVkc0FsbG9jOiBmYWxzZSxcbiAgICAgICAgICBuZWVkc1VwZGF0ZTogZmFsc2UsXG4gICAgICAgICAgY2hhbmdlZDogZmFsc2UsXG5cbiAgICAgICAgICAvLyBMdW1hIGZpZWxkc1xuICAgICAgICAgIGlzSW5kZXhlZCxcbiAgICAgICAgICBzaXplLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0sXG4gICAgICAgIF9leHRyYVByb3BzXG4gICAgICApO1xuICAgICAgLy8gU2FuaXR5IC0gbm8gYXBwIGZpZWxkcyBvbiBvdXIgYXR0cmlidXRlcy4gVXNlIHVzZXJEYXRhIGluc3RlYWQuXG4gICAgICBPYmplY3Quc2VhbChhdHRyaWJ1dGVEYXRhKTtcblxuICAgICAgLy8gQ2hlY2sgYWxsIGZpZWxkcyBhbmQgZ2VuZXJhdGUgaGVscGZ1bCBlcnJvciBtZXNzYWdlc1xuICAgICAgdGhpcy5fdmFsaWRhdGVBdHRyaWJ1dGVEZWZpbml0aW9uKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZURhdGEpO1xuXG4gICAgICAvLyBBZGQgdG8gYm90aCBhdHRyaWJ1dGVzIGxpc3QgKGZvciByZWdpc3RyYXRpb24gd2l0aCBtb2RlbClcbiAgICAgIG5ld0F0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0gPSBhdHRyaWJ1dGVEYXRhO1xuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24odGhpcy5hdHRyaWJ1dGVzLCBuZXdBdHRyaWJ1dGVzKTtcblxuICAgIHRoaXMuX21hcFVwZGF0ZVRyaWdnZXJzVG9BdHRyaWJ1dGVzKCk7XG4gIH1cblxuICAvLyBidWlsZCB1cGRhdGVUcmlnZ2VyIG5hbWUgdG8gYXR0cmlidXRlIG5hbWUgbWFwcGluZ1xuICBfbWFwVXBkYXRlVHJpZ2dlcnNUb0F0dHJpYnV0ZXMoKSB7XG4gICAgY29uc3QgdHJpZ2dlcnMgPSB7fTtcblxuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGxldCB7YWNjZXNzb3J9ID0gYXR0cmlidXRlO1xuXG4gICAgICAvLyB1c2UgYXR0cmlidXRlIG5hbWUgYXMgdXBkYXRlIHRyaWdnZXIga2V5XG4gICAgICB0cmlnZ2Vyc1thdHRyaWJ1dGVOYW1lXSA9IFthdHRyaWJ1dGVOYW1lXTtcblxuICAgICAgLy8gdXNlIGFjY2Vzc29yIG5hbWUgYXMgdXBkYXRlIHRyaWdnZXIga2V5XG4gICAgICBpZiAodHlwZW9mIGFjY2Vzc29yID09PSAnc3RyaW5nJykge1xuICAgICAgICBhY2Nlc3NvciA9IFthY2Nlc3Nvcl07XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhY2Nlc3NvcikpIHtcbiAgICAgICAgYWNjZXNzb3IuZm9yRWFjaChhY2Nlc3Nvck5hbWUgPT4ge1xuICAgICAgICAgIGlmICghdHJpZ2dlcnNbYWNjZXNzb3JOYW1lXSkge1xuICAgICAgICAgICAgdHJpZ2dlcnNbYWNjZXNzb3JOYW1lXSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cmlnZ2Vyc1thY2Nlc3Nvck5hbWVdLnB1c2goYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudXBkYXRlVHJpZ2dlcnMgPSB0cmlnZ2VycztcbiAgfVxuXG4gIF92YWxpZGF0ZUF0dHJpYnV0ZURlZmluaXRpb24oYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlKSB7XG4gICAgYXNzZXJ0KGF0dHJpYnV0ZS5zaXplID49IDEgJiYgYXR0cmlidXRlLnNpemUgPD0gNCxcbiAgICAgIGBBdHRyaWJ1dGUgZGVmaW5pdGlvbiBmb3IgJHthdHRyaWJ1dGVOYW1lfSBpbnZhbGlkIHNpemVgKTtcblxuICAgIC8vIENoZWNrIHRoYXQgZWl0aGVyICdhY2Nlc3Nvcicgb3IgJ3VwZGF0ZScgaXMgYSB2YWxpZCBmdW5jdGlvblxuICAgIGNvbnN0IGhhc1VwZGF0ZXIgPSBhdHRyaWJ1dGUubm9BbGxvYyB8fFxuICAgICAgdHlwZW9mIGF0dHJpYnV0ZS51cGRhdGUgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBhdHRyaWJ1dGUuYWNjZXNzb3IgPT09ICdzdHJpbmcnO1xuICAgIGlmICghaGFzVXBkYXRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRyaWJ1dGUgJHthdHRyaWJ1dGVOYW1lfSBtaXNzaW5nIHVwZGF0ZSBvciBhY2Nlc3NvcmApO1xuICAgIH1cbiAgfVxuXG4gIC8vIENoZWNrcyB0aGF0IGFueSBhdHRyaWJ1dGUgYnVmZmVycyBpbiBwcm9wcyBhcmUgdmFsaWRcbiAgLy8gTm90ZTogVGhpcyBpcyBqdXN0IHRvIGhlbHAgYXBwIGNhdGNoIG1pc3Rha2VzXG4gIF9jaGVja0V4dGVybmFsQnVmZmVycyh7XG4gICAgYnVmZmVycyA9IHt9LFxuICAgIGlnbm9yZVVua25vd25BdHRyaWJ1dGVzID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZXN9ID0gdGhpcztcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYnVmZmVycykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGlmICghYXR0cmlidXRlICYmICFpZ25vcmVVbmtub3duQXR0cmlidXRlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gYXR0cmlidXRlIHByb3AgJHthdHRyaWJ1dGVOYW1lfWApO1xuICAgICAgfVxuICAgICAgLy8gY29uc3QgYnVmZmVyID0gYnVmZmVyc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIC8vIFRPRE8gLSBjaGVjayBidWZmZXIgdHlwZVxuICAgIH1cbiAgfVxuXG4gIC8vIFNldCB0aGUgYnVmZmVycyBmb3IgdGhlIHN1cHBsaWVkIGF0dHJpYnV0ZXNcbiAgLy8gVXBkYXRlIGF0dHJpYnV0ZSBidWZmZXJzIGZyb20gYW55IGF0dHJpYnV0ZXMgaW4gcHJvcHNcbiAgLy8gRGV0YWNoIGFueSBwcmV2aW91c2x5IHNldCBidWZmZXJzLCBtYXJraW5nIGFsbFxuICAvLyBBdHRyaWJ1dGVzIGZvciBhdXRvIGFsbG9jYXRpb25cbiAgLyogZXNsaW50LWRpc2FibGUgbWF4LXN0YXRlbWVudHMgKi9cbiAgX3NldEV4dGVybmFsQnVmZmVycyhidWZmZXJNYXApIHtcbiAgICBjb25zdCB7YXR0cmlidXRlcywgbnVtSW5zdGFuY2VzfSA9IHRoaXM7XG5cbiAgICAvLyBDb3B5IHRoZSByZWZzIG9mIGFueSBzdXBwbGllZCBidWZmZXJzIGluIHRoZSBwcm9wc1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgY29uc3QgYnVmZmVyID0gYnVmZmVyTWFwW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgYXR0cmlidXRlLmlzRXh0ZXJuYWxCdWZmZXIgPSBmYWxzZTtcbiAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgaWYgKCEoYnVmZmVyIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0cmlidXRlIHByb3BlcnRpZXMgbXVzdCBiZSBvZiB0eXBlIEZsb2F0MzJBcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyaWJ1dGUuYXV0byAmJiBidWZmZXIubGVuZ3RoIDw9IG51bUluc3RhbmNlcyAqIGF0dHJpYnV0ZS5zaXplKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRyaWJ1dGUgcHJvcCBhcnJheSBtdXN0IG1hdGNoIGxlbmd0aCBhbmQgc2l6ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0cmlidXRlLmlzRXh0ZXJuYWxCdWZmZXIgPSB0cnVlO1xuICAgICAgICBhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZS52YWx1ZSAhPT0gYnVmZmVyKSB7XG4gICAgICAgICAgYXR0cmlidXRlLnZhbHVlID0gYnVmZmVyO1xuICAgICAgICAgIGF0dHJpYnV0ZS5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG1heC1zdGF0ZW1lbnRzICovXG5cbiAgLyogQ2hlY2tzIHRoYXQgdHlwZWQgYXJyYXlzIGZvciBhdHRyaWJ1dGVzIGFyZSBiaWcgZW5vdWdoXG4gICAqIHNldHMgYWxsb2MgZmxhZyBpZiBub3RcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciBhbnkgdXBkYXRlcyBhcmUgbmVlZGVkXG4gICAqL1xuICBfYW5hbHl6ZUJ1ZmZlcnMoe251bUluc3RhbmNlc30pIHtcbiAgICBjb25zdCB7YXR0cmlidXRlc30gPSB0aGlzO1xuICAgIGFzc2VydChudW1JbnN0YW5jZXMgIT09IHVuZGVmaW5lZCwgJ251bUluc3RhbmNlcyBub3QgZGVmaW5lZCcpO1xuXG4gICAgLy8gVHJhY2sgd2hldGhlciBhbnkgYWxsb2NhdGlvbnMgb3IgdXBkYXRlcyBhcmUgbmVlZGVkXG4gICAgbGV0IG5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGlmICghYXR0cmlidXRlLmlzRXh0ZXJuYWxCdWZmZXIpIHtcbiAgICAgICAgLy8gRG8gd2UgbmVlZCB0byByZWFsbG9jYXRlIHRoZSBhdHRyaWJ1dGUncyB0eXBlZCBhcnJheT9cbiAgICAgICAgY29uc3QgbmVlZHNBbGxvYyA9XG4gICAgICAgICAgYXR0cmlidXRlLnZhbHVlID09PSBudWxsIHx8XG4gICAgICAgICAgYXR0cmlidXRlLnZhbHVlLmxlbmd0aCAvIGF0dHJpYnV0ZS5zaXplIDwgbnVtSW5zdGFuY2VzO1xuICAgICAgICBpZiAobmVlZHNBbGxvYyAmJiAoYXR0cmlidXRlLnVwZGF0ZSB8fCBhdHRyaWJ1dGUuYWNjZXNzb3IpKSB7XG4gICAgICAgICAgYXR0cmlidXRlLm5lZWRzQWxsb2MgPSB0cnVlO1xuICAgICAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cmlidXRlLm5lZWRzVXBkYXRlKSB7XG4gICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5lZWRzVXBkYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIENhbGxzIHVwZGF0ZSBvbiBhbnkgYnVmZmVycyB0aGF0IG5lZWQgdXBkYXRlXG4gICAqIFRPRE8/IC0gSWYgYXBwIHN1cHBsaWVkIGFsbCBhdHRyaWJ1dGVzLCBubyBuZWVkIHRvIGl0ZXJhdGUgb3ZlciBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5kYXRhIC0gZGF0YSAoaXRlcmFibGUgb2JqZWN0KVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5udW1JbnN0YW5jZXMgLSBjb3VudCBvZiBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmJ1ZmZlcnMgPSB7fSAtIHByZS1hbGxvY2F0ZWQgYnVmZmVyc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5wcm9wcyAtIHBhc3NlZCB0byB1cGRhdGVyc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5jb250ZXh0IC0gVXNlZCBhcyBcInRoaXNcIiBjb250ZXh0IGZvciB1cGRhdGVyc1xuICAgKi9cbiAgLyogZXNsaW50LWRpc2FibGUgbWF4LXN0YXRlbWVudHMsIGNvbXBsZXhpdHkgKi9cbiAgX3VwZGF0ZUJ1ZmZlcnMoe251bUluc3RhbmNlcywgZGF0YSwgcHJvcHMsIGNvbnRleHR9KSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZXN9ID0gdGhpcztcblxuICAgIC8vIEFsbG9jYXRlIGF0IGxlYXN0IG9uZSBlbGVtZW50IHRvIGVuc3VyZSBhIHZhbGlkIGJ1ZmZlclxuICAgIGNvbnN0IGFsbG9jQ291bnQgPSBNYXRoLm1heChudW1JbnN0YW5jZXMsIDEpO1xuXG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG5cbiAgICAgIC8vIEFsbG9jYXRlIGEgbmV3IHR5cGVkIGFycmF5IGlmIG5lZWRlZFxuICAgICAgaWYgKGF0dHJpYnV0ZS5uZWVkc0FsbG9jKSB7XG4gICAgICAgIGNvbnN0IEFycmF5VHlwZSA9IGdsQXJyYXlGcm9tVHlwZShhdHRyaWJ1dGUudHlwZSB8fCBHTC5GTE9BVCk7XG4gICAgICAgIGF0dHJpYnV0ZS52YWx1ZSA9IG5ldyBBcnJheVR5cGUoYXR0cmlidXRlLnNpemUgKiBhbGxvY0NvdW50KTtcbiAgICAgICAgdGhpcy5vbkxvZygyLCBgJHt0aGlzLmlkfToke2F0dHJpYnV0ZU5hbWV9IGFsbG9jYXRlZCAke2FsbG9jQ291bnR9YCk7XG4gICAgICAgIGF0dHJpYnV0ZS5uZWVkc0FsbG9jID0gZmFsc2U7XG4gICAgICAgIGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGwgdXBkYXRlciBmdW5jdGlvbiBpZiBuZWVkZWRcbiAgICAgIGlmIChhdHRyaWJ1dGUubmVlZHNVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlQnVmZmVyKHthdHRyaWJ1dGUsIGF0dHJpYnV0ZU5hbWUsIG51bUluc3RhbmNlcywgZGF0YSwgcHJvcHMsIGNvbnRleHR9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFsbG9jZWRJbnN0YW5jZXMgPSBhbGxvY0NvdW50O1xuICB9XG5cbiAgX3VwZGF0ZUJ1ZmZlcih7YXR0cmlidXRlLCBhdHRyaWJ1dGVOYW1lLCBudW1JbnN0YW5jZXMsIGRhdGEsIHByb3BzLCBjb250ZXh0fSkge1xuICAgIGNvbnN0IHt1cGRhdGUsIGFjY2Vzc29yfSA9IGF0dHJpYnV0ZTtcbiAgICBpZiAodXBkYXRlKSB7XG4gICAgICAvLyBDdXN0b20gdXBkYXRlciAtIHR5cGljYWxseSBmb3Igbm9uLWluc3RhbmNlZCBsYXllcnNcbiAgICAgIHRoaXMub25Mb2coMiwgYCR7dGhpcy5pZH06JHthdHRyaWJ1dGVOYW1lfSB1cGRhdGluZyAke251bUluc3RhbmNlc31gKTtcbiAgICAgIHVwZGF0ZS5jYWxsKGNvbnRleHQsIGF0dHJpYnV0ZSwge2RhdGEsIHByb3BzLCBudW1JbnN0YW5jZXN9KTtcbiAgICAgIHRoaXMuX2NoZWNrQXR0cmlidXRlQXJyYXkoYXR0cmlidXRlLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICB9IGVsc2UgaWYgKGFjY2Vzc29yKSB7XG4gICAgICAvLyBTdGFuZGFyZCB1cGRhdGVyXG4gICAgICB0aGlzLl91cGRhdGVCdWZmZXJWaWFTdGFuZGFyZEFjY2Vzc29yKHthdHRyaWJ1dGUsIGRhdGEsIHByb3BzfSk7XG4gICAgICB0aGlzLl9jaGVja0F0dHJpYnV0ZUFycmF5KGF0dHJpYnV0ZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub25Mb2coMiwgYCR7dGhpcy5pZH06JHthdHRyaWJ1dGVOYW1lfSBtaXNzaW5nIHVwZGF0ZSBmdW5jdGlvbmApO1xuICAgIH1cblxuICAgIGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgIGF0dHJpYnV0ZS5jaGFuZ2VkID0gdHJ1ZTtcbiAgICB0aGlzLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG1heC1zdGF0ZW1lbnRzICovXG5cbiAgX3VwZGF0ZUJ1ZmZlclZpYVN0YW5kYXJkQWNjZXNzb3Ioe2F0dHJpYnV0ZSwgZGF0YSwgcHJvcHN9KSB7XG4gICAgY29uc3Qge2FjY2Vzc29yLCB2YWx1ZSwgc2l6ZX0gPSBhdHRyaWJ1dGU7XG4gICAgY29uc3QgYWNjZXNzb3JGdW5jID0gcHJvcHNbYWNjZXNzb3JdO1xuXG4gICAgYXNzZXJ0KHR5cGVvZiBhY2Nlc3NvckZ1bmMgPT09ICdmdW5jdGlvbicsIGBhY2Nlc3NvciBcIiR7YWNjZXNzb3J9XCIgaXMgbm90IGEgZnVuY3Rpb25gKTtcblxuICAgIGxldCB7ZGVmYXVsdFZhbHVlID0gWzAsIDAsIDAsIDBdfSA9IGF0dHJpYnV0ZTtcbiAgICBkZWZhdWx0VmFsdWUgPSBBcnJheS5pc0FycmF5KGRlZmF1bHRWYWx1ZSkgPyBkZWZhdWx0VmFsdWUgOiBbZGVmYXVsdFZhbHVlXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgZGF0YSkge1xuICAgICAgbGV0IG9iamVjdFZhbHVlID0gYWNjZXNzb3JGdW5jKG9iamVjdCk7XG4gICAgICBvYmplY3RWYWx1ZSA9IEFycmF5LmlzQXJyYXkob2JqZWN0VmFsdWUpID8gb2JqZWN0VmFsdWUgOiBbb2JqZWN0VmFsdWVdO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tZmFsbHRocm91Z2gsIGRlZmF1bHQtY2FzZSAqL1xuICAgICAgc3dpdGNoIChzaXplKSB7XG4gICAgICBjYXNlIDQ6IHZhbHVlW2kgKyAzXSA9IE51bWJlci5pc0Zpbml0ZShvYmplY3RWYWx1ZVszXSkgPyBvYmplY3RWYWx1ZVszXSA6IGRlZmF1bHRWYWx1ZVszXTtcbiAgICAgIGNhc2UgMzogdmFsdWVbaSArIDJdID0gTnVtYmVyLmlzRmluaXRlKG9iamVjdFZhbHVlWzJdKSA/IG9iamVjdFZhbHVlWzJdIDogZGVmYXVsdFZhbHVlWzJdO1xuICAgICAgY2FzZSAyOiB2YWx1ZVtpICsgMV0gPSBOdW1iZXIuaXNGaW5pdGUob2JqZWN0VmFsdWVbMV0pID8gb2JqZWN0VmFsdWVbMV0gOiBkZWZhdWx0VmFsdWVbMV07XG4gICAgICBjYXNlIDE6IHZhbHVlW2kgKyAwXSA9IE51bWJlci5pc0Zpbml0ZShvYmplY3RWYWx1ZVswXSkgPyBvYmplY3RWYWx1ZVswXSA6IGRlZmF1bHRWYWx1ZVswXTtcbiAgICAgIH1cbiAgICAgIGkgKz0gc2l6ZTtcbiAgICB9XG4gIH1cblxuICBfY2hlY2tBdHRyaWJ1dGVBcnJheShhdHRyaWJ1dGUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBjb25zdCB7dmFsdWV9ID0gYXR0cmlidXRlO1xuICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5sZW5ndGggPj0gNCkge1xuICAgICAgY29uc3QgdmFsaWQgPVxuICAgICAgICBOdW1iZXIuaXNGaW5pdGUodmFsdWVbMF0pICYmIE51bWJlci5pc0Zpbml0ZSh2YWx1ZVsxXSkgJiZcbiAgICAgICAgTnVtYmVyLmlzRmluaXRlKHZhbHVlWzJdKSAmJiBOdW1iZXIuaXNGaW5pdGUodmFsdWVbM10pO1xuICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYElsbGVnYWwgYXR0cmlidXRlIGdlbmVyYXRlZCBmb3IgJHthdHRyaWJ1dGVOYW1lfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIl19