"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
// Copyright (c) 2016 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

exports.default = "uniform float ONE;\n\nconst vec2 E_FP64 = vec2(2.7182817459106445e+00, 8.254840366817007e-08);\nconst vec2 LOG2_FP64 = vec2(0.6931471824645996e+00, -1.9046542121259336e-09);\nconst vec2 PI_FP64 = vec2(3.1415927410125732, -8.742278012618954e-8);\nconst vec2 TWO_PI_FP64 = vec2(6.2831854820251465, -1.7484556025237907e-7);\nconst vec2 PI_2_FP64 = vec2(1.5707963705062866, -4.371139006309477e-8);\nconst vec2 PI_4_FP64 = vec2(0.7853981852531433, -2.1855695031547384e-8);\nconst vec2 PI_16_FP64 = vec2(0.19634954631328583, -5.463923757886846e-9);\nconst vec2 PI_16_2_FP64 = vec2(0.39269909262657166, -1.0927847515773692e-8);\nconst vec2 PI_16_3_FP64 = vec2(0.5890486240386963, -1.4906100798128818e-9);\nconst vec2 PI_180_FP64 = vec2(0.01745329238474369, 1.3519960498364902e-10);\n\nconst vec2 SIN_TABLE_0_FP64 = vec2(0.19509032368659973, -1.6704714833615242e-9);\nconst vec2 SIN_TABLE_1_FP64 = vec2(0.3826834261417389, 6.22335089017767e-9);\nconst vec2 SIN_TABLE_2_FP64 = vec2(0.5555702447891235, -1.1769521357507529e-8);\nconst vec2 SIN_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617041793133e-8);\n\nconst vec2 COS_TABLE_0_FP64 = vec2(0.9807852506637573, 2.9739473106360492e-8);\nconst vec2 COS_TABLE_1_FP64 = vec2(0.9238795042037964, 2.8307490351764386e-8);\nconst vec2 COS_TABLE_2_FP64 = vec2(0.8314695954322815, 1.6870263741530778e-8);\nconst vec2 COS_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617152815436e-8);\n\nconst vec2 INVERSE_FACTORIAL_3_FP64 = vec2(1.666666716337204e-01, -4.967053879312289e-09); // 1/3!\nconst vec2 INVERSE_FACTORIAL_4_FP64 = vec2(4.16666679084301e-02, -1.2417634698280722e-09); // 1/4!\nconst vec2 INVERSE_FACTORIAL_5_FP64 = vec2(8.333333767950535e-03, -4.34617203337595e-10); // 1/5!\nconst vec2 INVERSE_FACTORIAL_6_FP64 = vec2(1.3888889225199819e-03, -3.3631094437103215e-11); // 1/6!\nconst vec2 INVERSE_FACTORIAL_7_FP64 = vec2(1.9841270113829523e-04,  -2.725596874933456e-12); // 1/7!\nconst vec2 INVERSE_FACTORIAL_8_FP64 = vec2(2.4801587642286904e-05, -3.406996025904184e-13); // 1/8!\nconst vec2 INVERSE_FACTORIAL_9_FP64 = vec2(2.75573188446287533e-06, 3.7935713937038186e-14); // 1/9!\nconst vec2 INVERSE_FACTORIAL_10_FP64 = vec2(2.755731998149713e-07, -7.575112367869873e-15); // 1/10!\n\nfloat nint(float d) {\n    if (d == floor(d)) return d;\n    return floor(d + 0.5);\n}\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\nvec2 split(float a) {\n  const float SPLIT = 4097.0;\n  float t = a * SPLIT;\n  float a_hi = t * ONE - (t - a);\n  float a_lo = a * ONE - a_hi;\n  return vec2(a_hi, a_lo);\n}\n#else\nvec2 split(float a) {\n  const float SPLIT = 4097.0;\n  float t = a * SPLIT;\n  float a_hi = t - (t - a);\n  float a_lo = a - a_hi;\n  return vec2(a_hi, a_lo);\n}\n#endif\n\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\nvec2 quickTwoSum(float a, float b) {\n  float sum = (a + b) * ONE;\n  float err = b - (sum - a) * ONE;\n  return vec2(sum, err);\n}\n#else\nvec2 quickTwoSum(float a, float b) {\n  float sum = a + b;\n  float err = b - (sum - a);\n  return vec2(sum, err);\n}\n#endif\n\nvec2 nint_fp64(vec2 a) {\n    float hi = nint(a.x);\n    float lo;\n    vec2 tmp;\n    if (hi == a.x) {\n        lo = nint(a.y);\n        tmp = quickTwoSum(hi, lo);\n    } else {\n        lo = 0.0;\n        if (abs(hi - a.x) == 0.5 && a.y < 0.0) {\n            hi -= 1.0;\n        }\n        tmp = vec2(hi, lo);\n    }\n    return tmp;\n}\n\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\n\n/* The purpose of this workaround is to prevent compilers from\noptimizing away necessary arithmetic operations by swapping their sequences\nor transform the equation to some 'equivalent' from.\n\nThe method is to multiply an artifical variable, ONE, which will be known to\nthe compiler to be one only at the runtime. The whole expression is then represented\nas a polynomial with respective to ONE. In the coefficients of all terms, only one a\nand one b should appear\n\nerr = (a + b) * ONE^6 - a * ONE^5 - (a + b) * ONE^4 + a * ONE^3 - b - (a + b) * ONE^2 + a * ONE\n*/\n\nvec2 twoSum(float a, float b) {\n  float s = (a + b);\n  float v = (s * ONE - a) * ONE;\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);\n  return vec2(s, err);\n}\n#else\nvec2 twoSum(float a, float b) {\n  float s = a + b;\n  float v = s - a;\n  float err = (a - (s - v)) + (b - v);\n  return vec2(s, err);\n}\n#endif\n\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\n/* Same thing as in twoSum() */\nvec2 twoSub(float a, float b) {\n  float s = (a - b);\n  float v = (s * ONE - a) * ONE;\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);\n  return vec2(s, err);\n}\n#else\nvec2 twoSub(float a, float b) {\n  float s = a - b;\n  float v = s - a;\n  float err = (a - (s - v)) - (b + v);\n  return vec2(s, err);\n}\n#endif\n\nvec2 twoProd(float a, float b) {\n  float prod = a * b;\n  vec2 a_fp64 = split(a);\n  vec2 b_fp64 = split(b);\n  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +\n    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;\n  return vec2(prod, err);\n}\n\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\nvec2 twoSqr(float a) {\n  float prod = a * a;\n  vec2 a_fp64 = split(a);\n\n  float err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x *\n    a_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;\n  return vec2(prod, err);\n}\n#else\nvec2 twoSqr(float a) {\n  float prod = a * a;\n  vec2 a_fp64 = split(a);\n\n  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;\n  return vec2(prod, err);\n}\n#endif\n\nvec2 sum_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSum(a.x, b.x);\n  t = twoSum(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 sub_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSub(a.x, b.x);\n  t = twoSub(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 mul_fp64(vec2 a, vec2 b) {\n  vec2 prod = twoProd(a.x, b.x);\n  // y component is for the error\n  prod.y += a.x * b.y;\n  prod.y += a.y * b.x;\n  prod = quickTwoSum(prod.x, prod.y);\n  return prod;\n}\n\nvec2 div_fp64(vec2 a, vec2 b) {\n  float xn = 1.0 / b.x;\n  vec2 yn = a * xn;\n  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;\n  vec2 prod = twoProd(xn, diff);\n  return sum_fp64(yn, prod);\n}\n\nvec2 sqrt_fp64(vec2 a) {\n\n  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n\n  float x = 1.0 / sqrt(a.x);\n  float yn = a.x * x;\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  vec2 yn_sqr = twoSqr(yn) * ONE;\n#else\n  vec2 yn_sqr = twoSqr(yn);\n#endif\n  float diff = sub_fp64(a, yn_sqr).x;\n  vec2 prod = twoProd(x * 0.5, diff);\n  return sum_fp64(vec2(yn, 0.0), prod);\n}\n\n/* k_power controls how much range reduction we would like to have\nRange reduction uses the following method:\nassume a = k_power * r + m * log(2), k and m being integers.\nSet k_power = 4 (we can choose other k to trade accuracy with performance.\nwe only need to calculate exp(r) and using exp(a) = 2^m * exp(r)^k_power;\n*/\n\nvec2 exp_fp64(vec2 a) {\n  // We need to make sure these two numbers match\n  // as bit-wise shift is not available in GLSL 1.0\n  const int k_power = 4;\n  const float k = 16.0;\n\n  const float inv_k = 1.0 / k;\n\n  if (a.x <= -88.0) return vec2(0.0, 0.0);\n  if (a.x >= 88.0) return vec2(1.0 / 0.0, 1.0 / 0.0);\n  if (a.x == 0.0 && a.y == 0.0) return vec2(1.0, 0.0);\n  if (a.x == 1.0 && a.y == 0.0) return E_FP64;\n\n  float m = floor(a.x / LOG2_FP64.x + 0.5);\n  vec2 r = sub_fp64(a, mul_fp64(LOG2_FP64, vec2(m, 0.0))) * inv_k;\n  vec2 s, t, p;\n\n  p = mul_fp64(r, r);\n  s = sum_fp64(r, p * 0.5);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_3_FP64);\n\n  s = sum_fp64(s, t);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_4_FP64);\n\n  s = sum_fp64(s, t);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_5_FP64);\n\n  // s = sum_fp64(s, t);\n  // p = mul_fp64(p, r);\n  // t = mul_fp64(p, INVERSE_FACTORIAL_6_FP64);\n\n  // s = sum_fp64(s, t);\n  // p = mul_fp64(p, r);\n  // t = mul_fp64(p, INVERSE_FACTORIAL_7_FP64);\n\n  s = sum_fp64(s, t);\n\n\n  // At this point, s = exp(r) - 1; but after following 4 recursions, we will get exp(r) ^ 512 - 1.\n  for (int i = 0; i < k_power; i++) {\n    s = sum_fp64(s * 2.0, mul_fp64(s, s));\n  }\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s = sum_fp64(s, vec2(ONE, 0.0));\n#else\n  s = sum_fp64(s, vec2(1.0, 0.0));\n#endif\n\n  return s * pow(2.0, m);\n//   return r;\n}\n\nvec2 log_fp64(vec2 a)\n{\n  if (a.x == 1.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x <= 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n  vec2 x = vec2(log(a.x), 0.0);\n  vec2 s;\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s = vec2(ONE, 0.0);\n#else\n  s = vec2(1.0, 0.0);\n#endif\n\n  x = sub_fp64(sum_fp64(x, mul_fp64(a, exp_fp64(-x))), s);\n  return x;\n}\n\nvec2 sin_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x == 0.0 && a.y == 0.0) {\n    return vec2(0.0, 0.0);\n  }\n\n  x = -mul_fp64(a, a);\n  s = a;\n  r = a;\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_3_FP64);\n  s = sum_fp64(s, t);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_5_FP64);\n  s = sum_fp64(s, t);\n\n  /* keep the following commented code in case we need them\n  for extra accuracy from the Taylor expansion*/\n\n  // r = mul_fp64(r, x);\n  // t = mul_fp64(r, INVERSE_FACTORIAL_7_FP64);\n  // s = sum_fp64(s, t);\n\n  // r = mul_fp64(r, x);\n  // t = mul_fp64(r, INVERSE_FACTORIAL_9_FP64);\n  // s = sum_fp64(s, t);\n\n  return s;\n}\n\nvec2 cos_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x == 0.0 && a.y == 0.0) {\n    return vec2(1.0, 0.0);\n  }\n\n  x = -mul_fp64(a, a);\n  r = x;\n  s = sum_fp64(vec2(1.0, 0.0), r * 0.5);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_4_FP64);\n  s = sum_fp64(s, t);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_6_FP64);\n  s = sum_fp64(s, t);\n\n  /* keep the following commented code in case we need them\n  for extra accuracy from the Taylor expansion*/\n\n  // r = mul_fp64(r, x);\n  // t = mul_fp64(r, INVERSE_FACTORIAL_8_FP64);\n  // s = sum_fp64(s, t);\n\n  // r = mul_fp64(r, x);\n  // t = mul_fp64(r, INVERSE_FACTORIAL_10_FP64);\n  // s = sum_fp64(s, t);\n\n  return s;\n}\n\nvoid sincos_taylor_fp64(vec2 a, out vec2 sin_t, out vec2 cos_t) {\n  if (a.x == 0.0 && a.y == 0.0) {\n    sin_t = vec2(0.0, 0.0);\n    cos_t = vec2(1.0, 0.0);\n  }\n\n  sin_t = sin_taylor_fp64(a);\n  cos_t = sqrt_fp64(sub_fp64(vec2(1.0, 0.0), mul_fp64(sin_t, sin_t)));\n}\n\nvec2 sin_fp64(vec2 a) {\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(0.0, 0.0);\n    }\n\n    // 2pi range reduction\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n\n    if (k == 0) {\n        if (j == 0) {\n            return sin_taylor_fp64(t);\n        } else if (j == 1) {\n            return cos_taylor_fp64(t);\n        } else if (j == -1) {\n            return -cos_taylor_fp64(t);\n        } else {\n            return -sin_taylor_fp64(t);\n        }\n    }\n\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) < 0.5) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k == 1) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs_k == 2) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs_k == 3) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs_k == 4) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n\n\n    vec2 result = vec2(0.0, 0.0);\n    if (j == 0) {\n        if (k > 0) {\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else if (j == 1) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j == -1) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result = -sum_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        }\n    } else {\n        if (k > 0) {\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 cos_fp64(vec2 a) {\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(1.0, 0.0);\n    }\n\n    // 2pi range reduction\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n\n    if (k == 0) {\n        if (j == 0) {\n            return cos_taylor_fp64(t);\n        } else if (j == 1) {\n            return -sin_taylor_fp64(t);\n        } else if (j == -1) {\n            return sin_taylor_fp64(t);\n        } else {\n            return -cos_taylor_fp64(t);\n        }\n    }\n\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) < 0.5) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k == 1) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs_k == 2) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs_k == 3) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs_k == 4) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    vec2 result = vec2(0.0, 0.0);\n    if (j == 0) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j == 1) {\n        if (k > 0) {\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    } else if (j == -1) {\n        if (k > 0) {\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result = -sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 tan_fp64(vec2 a) {\n    vec2 sin_a;\n    vec2 cos_a;\n\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(0.0, 0.0);\n    }\n\n    // 2pi range reduction\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    // We just can't get PI/16 * 3.0 very accurately.\n    // so let's just store it\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n    vec2 sin_t, cos_t;\n    vec2 s, c;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0_FP64;\n            v = SIN_TABLE_0_FP64;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1_FP64;\n            v = SIN_TABLE_1_FP64;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2_FP64;\n            v = SIN_TABLE_2_FP64;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3_FP64;\n            v = SIN_TABLE_3_FP64;\n        }\n#else\n        if (abs_k == 1) {\n            u = COS_TABLE_0_FP64;\n            v = SIN_TABLE_0_FP64;\n        } else if (abs_k == 2) {\n            u = COS_TABLE_1_FP64;\n            v = SIN_TABLE_1_FP64;\n        } else if (abs_k == 3) {\n            u = COS_TABLE_2_FP64;\n            v = SIN_TABLE_2_FP64;\n        } else if (abs_k == 4) {\n            u = COS_TABLE_3_FP64;\n            v = SIN_TABLE_3_FP64;\n        }\n#endif\n        if (k > 0) {\n            s = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            s = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return div_fp64(sin_a, cos_a);\n}\n\nvec2 radians_fp64(vec2 degree) {\n  return mul_fp64(degree, PI_180_FP64);\n}\n\nvec2 mix_fp64(vec2 a, vec2 b, float x) {\n  vec2 range = sub_fp64(b, a);\n  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));\n}\n\n// Vector functions\n// vec2 functions\nvoid vec2_sum_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = sum_fp64(a[0], b[0]);\n    out_val[1] = sum_fp64(a[1], b[1]);\n}\n\nvoid vec2_sub_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = sub_fp64(a[0], b[0]);\n    out_val[1] = sub_fp64(a[1], b[1]);\n}\n\nvoid vec2_mul_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = mul_fp64(a[0], b[0]);\n    out_val[1] = mul_fp64(a[1], b[1]);\n}\n\nvoid vec2_div_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = div_fp64(a[0], b[0]);\n    out_val[1] = div_fp64(a[1], b[1]);\n}\n\nvoid vec2_mix_fp64(vec2 x[2], vec2 y[2], float a, out vec2 out_val[2]) {\n  vec2 range[2];\n  vec2_sub_fp64(y, x, range);\n  vec2 portion[2];\n  portion[0] = range[0] * a;\n  portion[1] = range[1] * a;\n  vec2_sum_fp64(x, portion, out_val);\n}\n\nvec2 vec2_length_fp64(vec2 x[2]) {\n  return sqrt_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])));\n}\n\nvoid vec2_normalize_fp64(vec2 x[2], out vec2 out_val[2]) {\n  vec2 length = vec2_length_fp64(x);\n  vec2 length_vec2[2];\n  length_vec2[0] = length;\n  length_vec2[1] = length;\n\n  vec2_div_fp64(x, length_vec2, out_val);\n}\n\nvec2 vec2_distance_fp64(vec2 x[2], vec2 y[2]) {\n  vec2 diff[2];\n  vec2_sub_fp64(x, y, diff);\n  return vec2_length_fp64(diff);\n}\n\nvec2 vec2_dot_fp64(vec2 a[2], vec2 b[2]) {\n  vec2 v[2];\n\n  v[0] = mul_fp64(a[0], b[0]);\n  v[1] = mul_fp64(a[1], b[1]);\n\n  return sum_fp64(v[0], v[1]);\n}\n\n// vec3 functions\nvoid vec3_sub_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i = 0; i < 3; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec3_sum_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i = 0; i < 3; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvec2 vec3_length_fp64(vec2 x[3]) {\n  return sqrt_fp64(sum_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])),\n    mul_fp64(x[2], x[2])));\n}\n\nvec2 vec3_distance_fp64(vec2 x[3], vec2 y[3]) {\n  vec2 diff[3];\n  vec3_sub_fp64(x, y, diff);\n  return vec3_length_fp64(diff);\n}\n\n// vec4 functions\nvoid vec4_fp64(vec4 a, out vec2 out_val[4]) {\n  out_val[0].x = a[0];\n  out_val[0].y = 0.0;\n\n  out_val[1].x = a[1];\n  out_val[1].y = 0.0;\n\n  out_val[2].x = a[2];\n  out_val[2].y = 0.0;\n\n  out_val[3].x = a[3];\n  out_val[3].y = 0.0;\n}\n\nvoid vec4_scalar_mul_fp64(vec2 a[4], vec2 b, out vec2 out_val[4]) {\n  out_val[0] = mul_fp64(a[0], b);\n  out_val[1] = mul_fp64(a[1], b);\n  out_val[2] = mul_fp64(a[2], b);\n  out_val[3] = mul_fp64(a[3], b);\n}\n\nvoid vec4_sum_fp64(vec2 a[4], vec2 b[4], out vec2 out_val[4]) {\n  for (int i = 0; i < 4; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec4_dot_fp64(vec2 a[4], vec2 b[4], out vec2 out_val) {\n  vec2 v[4];\n\n  v[0] = mul_fp64(a[0], b[0]);\n  v[1] = mul_fp64(a[1], b[1]);\n  v[2] = mul_fp64(a[2], b[2]);\n  v[3] = mul_fp64(a[3], b[3]);\n\n  out_val = sum_fp64(sum_fp64(v[0], v[1]), sum_fp64(v[2], v[3]));\n}\n\nvoid mat4_vec4_mul_fp64(vec2 b[16], vec2 a[4], out vec2 out_val[4]) {\n  vec2 tmp[4];\n\n  for (int i = 0; i < 4; i++)\n  {\n    for (int j = 0; j < 4; j++)\n    {\n      tmp[j] = b[j + i * 4];\n    }\n    vec4_dot_fp64(a, tmp, out_val[i]);\n  }\n}\n";
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zaGFkZXJsaWIvZnA2NC9tYXRoLWZwNjQuZ2xzbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Im1hdGgtZnA2NC5nbHNsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE2IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuZXhwb3J0IGRlZmF1bHQgYFxcXG51bmlmb3JtIGZsb2F0IE9ORTtcblxuY29uc3QgdmVjMiBFX0ZQNjQgPSB2ZWMyKDIuNzE4MjgxNzQ1OTEwNjQ0NWUrMDAsIDguMjU0ODQwMzY2ODE3MDA3ZS0wOCk7XG5jb25zdCB2ZWMyIExPRzJfRlA2NCA9IHZlYzIoMC42OTMxNDcxODI0NjQ1OTk2ZSswMCwgLTEuOTA0NjU0MjEyMTI1OTMzNmUtMDkpO1xuY29uc3QgdmVjMiBQSV9GUDY0ID0gdmVjMigzLjE0MTU5Mjc0MTAxMjU3MzIsIC04Ljc0MjI3ODAxMjYxODk1NGUtOCk7XG5jb25zdCB2ZWMyIFRXT19QSV9GUDY0ID0gdmVjMig2LjI4MzE4NTQ4MjAyNTE0NjUsIC0xLjc0ODQ1NTYwMjUyMzc5MDdlLTcpO1xuY29uc3QgdmVjMiBQSV8yX0ZQNjQgPSB2ZWMyKDEuNTcwNzk2MzcwNTA2Mjg2NiwgLTQuMzcxMTM5MDA2MzA5NDc3ZS04KTtcbmNvbnN0IHZlYzIgUElfNF9GUDY0ID0gdmVjMigwLjc4NTM5ODE4NTI1MzE0MzMsIC0yLjE4NTU2OTUwMzE1NDczODRlLTgpO1xuY29uc3QgdmVjMiBQSV8xNl9GUDY0ID0gdmVjMigwLjE5NjM0OTU0NjMxMzI4NTgzLCAtNS40NjM5MjM3NTc4ODY4NDZlLTkpO1xuY29uc3QgdmVjMiBQSV8xNl8yX0ZQNjQgPSB2ZWMyKDAuMzkyNjk5MDkyNjI2NTcxNjYsIC0xLjA5Mjc4NDc1MTU3NzM2OTJlLTgpO1xuY29uc3QgdmVjMiBQSV8xNl8zX0ZQNjQgPSB2ZWMyKDAuNTg5MDQ4NjI0MDM4Njk2MywgLTEuNDkwNjEwMDc5ODEyODgxOGUtOSk7XG5jb25zdCB2ZWMyIFBJXzE4MF9GUDY0ID0gdmVjMigwLjAxNzQ1MzI5MjM4NDc0MzY5LCAxLjM1MTk5NjA0OTgzNjQ5MDJlLTEwKTtcblxuY29uc3QgdmVjMiBTSU5fVEFCTEVfMF9GUDY0ID0gdmVjMigwLjE5NTA5MDMyMzY4NjU5OTczLCAtMS42NzA0NzE0ODMzNjE1MjQyZS05KTtcbmNvbnN0IHZlYzIgU0lOX1RBQkxFXzFfRlA2NCA9IHZlYzIoMC4zODI2ODM0MjYxNDE3Mzg5LCA2LjIyMzM1MDg5MDE3NzY3ZS05KTtcbmNvbnN0IHZlYzIgU0lOX1RBQkxFXzJfRlA2NCA9IHZlYzIoMC41NTU1NzAyNDQ3ODkxMjM1LCAtMS4xNzY5NTIxMzU3NTA3NTI5ZS04KTtcbmNvbnN0IHZlYzIgU0lOX1RBQkxFXzNfRlA2NCA9IHZlYzIoMC43MDcxMDY3NjkwODQ5MzA0LCAxLjIxMDE2MTcwNDE3OTMxMzNlLTgpO1xuXG5jb25zdCB2ZWMyIENPU19UQUJMRV8wX0ZQNjQgPSB2ZWMyKDAuOTgwNzg1MjUwNjYzNzU3MywgMi45NzM5NDczMTA2MzYwNDkyZS04KTtcbmNvbnN0IHZlYzIgQ09TX1RBQkxFXzFfRlA2NCA9IHZlYzIoMC45MjM4Nzk1MDQyMDM3OTY0LCAyLjgzMDc0OTAzNTE3NjQzODZlLTgpO1xuY29uc3QgdmVjMiBDT1NfVEFCTEVfMl9GUDY0ID0gdmVjMigwLjgzMTQ2OTU5NTQzMjI4MTUsIDEuNjg3MDI2Mzc0MTUzMDc3OGUtOCk7XG5jb25zdCB2ZWMyIENPU19UQUJMRV8zX0ZQNjQgPSB2ZWMyKDAuNzA3MTA2NzY5MDg0OTMwNCwgMS4yMTAxNjE3MTUyODE1NDM2ZS04KTtcblxuY29uc3QgdmVjMiBJTlZFUlNFX0ZBQ1RPUklBTF8zX0ZQNjQgPSB2ZWMyKDEuNjY2NjY2NzE2MzM3MjA0ZS0wMSwgLTQuOTY3MDUzODc5MzEyMjg5ZS0wOSk7IC8vIDEvMyFcbmNvbnN0IHZlYzIgSU5WRVJTRV9GQUNUT1JJQUxfNF9GUDY0ID0gdmVjMig0LjE2NjY2Njc5MDg0MzAxZS0wMiwgLTEuMjQxNzYzNDY5ODI4MDcyMmUtMDkpOyAvLyAxLzQhXG5jb25zdCB2ZWMyIElOVkVSU0VfRkFDVE9SSUFMXzVfRlA2NCA9IHZlYzIoOC4zMzMzMzM3Njc5NTA1MzVlLTAzLCAtNC4zNDYxNzIwMzMzNzU5NWUtMTApOyAvLyAxLzUhXG5jb25zdCB2ZWMyIElOVkVSU0VfRkFDVE9SSUFMXzZfRlA2NCA9IHZlYzIoMS4zODg4ODg5MjI1MTk5ODE5ZS0wMywgLTMuMzYzMTA5NDQzNzEwMzIxNWUtMTEpOyAvLyAxLzYhXG5jb25zdCB2ZWMyIElOVkVSU0VfRkFDVE9SSUFMXzdfRlA2NCA9IHZlYzIoMS45ODQxMjcwMTEzODI5NTIzZS0wNCwgIC0yLjcyNTU5Njg3NDkzMzQ1NmUtMTIpOyAvLyAxLzchXG5jb25zdCB2ZWMyIElOVkVSU0VfRkFDVE9SSUFMXzhfRlA2NCA9IHZlYzIoMi40ODAxNTg3NjQyMjg2OTA0ZS0wNSwgLTMuNDA2OTk2MDI1OTA0MTg0ZS0xMyk7IC8vIDEvOCFcbmNvbnN0IHZlYzIgSU5WRVJTRV9GQUNUT1JJQUxfOV9GUDY0ID0gdmVjMigyLjc1NTczMTg4NDQ2Mjg3NTMzZS0wNiwgMy43OTM1NzEzOTM3MDM4MTg2ZS0xNCk7IC8vIDEvOSFcbmNvbnN0IHZlYzIgSU5WRVJTRV9GQUNUT1JJQUxfMTBfRlA2NCA9IHZlYzIoMi43NTU3MzE5OTgxNDk3MTNlLTA3LCAtNy41NzUxMTIzNjc4Njk4NzNlLTE1KTsgLy8gMS8xMCFcblxuZmxvYXQgbmludChmbG9hdCBkKSB7XG4gICAgaWYgKGQgPT0gZmxvb3IoZCkpIHJldHVybiBkO1xuICAgIHJldHVybiBmbG9vcihkICsgMC41KTtcbn1cblxuI2lmIGRlZmluZWQoTlZJRElBX0ZQNjRfV09SS0FST1VORCkgfHwgZGVmaW5lZChJTlRFTF9GUDY0X1dPUktBUk9VTkQpXG52ZWMyIHNwbGl0KGZsb2F0IGEpIHtcbiAgY29uc3QgZmxvYXQgU1BMSVQgPSA0MDk3LjA7XG4gIGZsb2F0IHQgPSBhICogU1BMSVQ7XG4gIGZsb2F0IGFfaGkgPSB0ICogT05FIC0gKHQgLSBhKTtcbiAgZmxvYXQgYV9sbyA9IGEgKiBPTkUgLSBhX2hpO1xuICByZXR1cm4gdmVjMihhX2hpLCBhX2xvKTtcbn1cbiNlbHNlXG52ZWMyIHNwbGl0KGZsb2F0IGEpIHtcbiAgY29uc3QgZmxvYXQgU1BMSVQgPSA0MDk3LjA7XG4gIGZsb2F0IHQgPSBhICogU1BMSVQ7XG4gIGZsb2F0IGFfaGkgPSB0IC0gKHQgLSBhKTtcbiAgZmxvYXQgYV9sbyA9IGEgLSBhX2hpO1xuICByZXR1cm4gdmVjMihhX2hpLCBhX2xvKTtcbn1cbiNlbmRpZlxuXG4jaWYgZGVmaW5lZChOVklESUFfRVFVQVRJT05fV09SS0FST1VORCkgfHwgZGVmaW5lZChJTlRFTF9FUVVBVElPTl9XT1JLQVJPVU5EKVxudmVjMiBxdWlja1R3b1N1bShmbG9hdCBhLCBmbG9hdCBiKSB7XG4gIGZsb2F0IHN1bSA9IChhICsgYikgKiBPTkU7XG4gIGZsb2F0IGVyciA9IGIgLSAoc3VtIC0gYSkgKiBPTkU7XG4gIHJldHVybiB2ZWMyKHN1bSwgZXJyKTtcbn1cbiNlbHNlXG52ZWMyIHF1aWNrVHdvU3VtKGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgZmxvYXQgc3VtID0gYSArIGI7XG4gIGZsb2F0IGVyciA9IGIgLSAoc3VtIC0gYSk7XG4gIHJldHVybiB2ZWMyKHN1bSwgZXJyKTtcbn1cbiNlbmRpZlxuXG52ZWMyIG5pbnRfZnA2NCh2ZWMyIGEpIHtcbiAgICBmbG9hdCBoaSA9IG5pbnQoYS54KTtcbiAgICBmbG9hdCBsbztcbiAgICB2ZWMyIHRtcDtcbiAgICBpZiAoaGkgPT0gYS54KSB7XG4gICAgICAgIGxvID0gbmludChhLnkpO1xuICAgICAgICB0bXAgPSBxdWlja1R3b1N1bShoaSwgbG8pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxvID0gMC4wO1xuICAgICAgICBpZiAoYWJzKGhpIC0gYS54KSA9PSAwLjUgJiYgYS55IDwgMC4wKSB7XG4gICAgICAgICAgICBoaSAtPSAxLjA7XG4gICAgICAgIH1cbiAgICAgICAgdG1wID0gdmVjMihoaSwgbG8pO1xuICAgIH1cbiAgICByZXR1cm4gdG1wO1xufVxuXG4jaWYgZGVmaW5lZChOVklESUFfRVFVQVRJT05fV09SS0FST1VORCkgfHwgZGVmaW5lZChJTlRFTF9FUVVBVElPTl9XT1JLQVJPVU5EKVxuXG4vKiBUaGUgcHVycG9zZSBvZiB0aGlzIHdvcmthcm91bmQgaXMgdG8gcHJldmVudCBjb21waWxlcnMgZnJvbVxub3B0aW1pemluZyBhd2F5IG5lY2Vzc2FyeSBhcml0aG1ldGljIG9wZXJhdGlvbnMgYnkgc3dhcHBpbmcgdGhlaXIgc2VxdWVuY2VzXG5vciB0cmFuc2Zvcm0gdGhlIGVxdWF0aW9uIHRvIHNvbWUgJ2VxdWl2YWxlbnQnIGZyb20uXG5cblRoZSBtZXRob2QgaXMgdG8gbXVsdGlwbHkgYW4gYXJ0aWZpY2FsIHZhcmlhYmxlLCBPTkUsIHdoaWNoIHdpbGwgYmUga25vd24gdG9cbnRoZSBjb21waWxlciB0byBiZSBvbmUgb25seSBhdCB0aGUgcnVudGltZS4gVGhlIHdob2xlIGV4cHJlc3Npb24gaXMgdGhlbiByZXByZXNlbnRlZFxuYXMgYSBwb2x5bm9taWFsIHdpdGggcmVzcGVjdGl2ZSB0byBPTkUuIEluIHRoZSBjb2VmZmljaWVudHMgb2YgYWxsIHRlcm1zLCBvbmx5IG9uZSBhXG5hbmQgb25lIGIgc2hvdWxkIGFwcGVhclxuXG5lcnIgPSAoYSArIGIpICogT05FXjYgLSBhICogT05FXjUgLSAoYSArIGIpICogT05FXjQgKyBhICogT05FXjMgLSBiIC0gKGEgKyBiKSAqIE9ORV4yICsgYSAqIE9ORVxuKi9cblxudmVjMiB0d29TdW0oZmxvYXQgYSwgZmxvYXQgYikge1xuICBmbG9hdCBzID0gKGEgKyBiKTtcbiAgZmxvYXQgdiA9IChzICogT05FIC0gYSkgKiBPTkU7XG4gIGZsb2F0IGVyciA9IChhIC0gKHMgLSB2KSAqIE9ORSkgKiBPTkUgKiBPTkUgKiBPTkUgKyAoYiAtIHYpO1xuICByZXR1cm4gdmVjMihzLCBlcnIpO1xufVxuI2Vsc2VcbnZlYzIgdHdvU3VtKGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgZmxvYXQgcyA9IGEgKyBiO1xuICBmbG9hdCB2ID0gcyAtIGE7XG4gIGZsb2F0IGVyciA9IChhIC0gKHMgLSB2KSkgKyAoYiAtIHYpO1xuICByZXR1cm4gdmVjMihzLCBlcnIpO1xufVxuI2VuZGlmXG5cbiNpZiBkZWZpbmVkKE5WSURJQV9FUVVBVElPTl9XT1JLQVJPVU5EKSB8fCBkZWZpbmVkKElOVEVMX0VRVUFUSU9OX1dPUktBUk9VTkQpXG4vKiBTYW1lIHRoaW5nIGFzIGluIHR3b1N1bSgpICovXG52ZWMyIHR3b1N1YihmbG9hdCBhLCBmbG9hdCBiKSB7XG4gIGZsb2F0IHMgPSAoYSAtIGIpO1xuICBmbG9hdCB2ID0gKHMgKiBPTkUgLSBhKSAqIE9ORTtcbiAgZmxvYXQgZXJyID0gKGEgLSAocyAtIHYpICogT05FKSAqIE9ORSAqIE9ORSAqIE9ORSAtIChiICsgdik7XG4gIHJldHVybiB2ZWMyKHMsIGVycik7XG59XG4jZWxzZVxudmVjMiB0d29TdWIoZmxvYXQgYSwgZmxvYXQgYikge1xuICBmbG9hdCBzID0gYSAtIGI7XG4gIGZsb2F0IHYgPSBzIC0gYTtcbiAgZmxvYXQgZXJyID0gKGEgLSAocyAtIHYpKSAtIChiICsgdik7XG4gIHJldHVybiB2ZWMyKHMsIGVycik7XG59XG4jZW5kaWZcblxudmVjMiB0d29Qcm9kKGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgZmxvYXQgcHJvZCA9IGEgKiBiO1xuICB2ZWMyIGFfZnA2NCA9IHNwbGl0KGEpO1xuICB2ZWMyIGJfZnA2NCA9IHNwbGl0KGIpO1xuICBmbG9hdCBlcnIgPSAoKGFfZnA2NC54ICogYl9mcDY0LnggLSBwcm9kKSArIGFfZnA2NC54ICogYl9mcDY0LnkgK1xuICAgIGFfZnA2NC55ICogYl9mcDY0LngpICsgYV9mcDY0LnkgKiBiX2ZwNjQueTtcbiAgcmV0dXJuIHZlYzIocHJvZCwgZXJyKTtcbn1cblxuI2lmIGRlZmluZWQoTlZJRElBX0VRVUFUSU9OX1dPUktBUk9VTkQpIHx8IGRlZmluZWQoSU5URUxfRVFVQVRJT05fV09SS0FST1VORClcbnZlYzIgdHdvU3FyKGZsb2F0IGEpIHtcbiAgZmxvYXQgcHJvZCA9IGEgKiBhO1xuICB2ZWMyIGFfZnA2NCA9IHNwbGl0KGEpO1xuXG4gIGZsb2F0IGVyciA9ICgoYV9mcDY0LnggKiBhX2ZwNjQueCAtIHByb2QpICogT05FICsgMi4wICogYV9mcDY0LnggKlxuICAgIGFfZnA2NC55ICogT05FICogT05FKSArIGFfZnA2NC55ICogYV9mcDY0LnkgKiBPTkUgKiBPTkUgKiBPTkU7XG4gIHJldHVybiB2ZWMyKHByb2QsIGVycik7XG59XG4jZWxzZVxudmVjMiB0d29TcXIoZmxvYXQgYSkge1xuICBmbG9hdCBwcm9kID0gYSAqIGE7XG4gIHZlYzIgYV9mcDY0ID0gc3BsaXQoYSk7XG5cbiAgZmxvYXQgZXJyID0gKChhX2ZwNjQueCAqIGFfZnA2NC54IC0gcHJvZCkgKyAyLjAgKiBhX2ZwNjQueCAqIGFfZnA2NC55KSArIGFfZnA2NC55ICogYV9mcDY0Lnk7XG4gIHJldHVybiB2ZWMyKHByb2QsIGVycik7XG59XG4jZW5kaWZcblxudmVjMiBzdW1fZnA2NCh2ZWMyIGEsIHZlYzIgYikge1xuICB2ZWMyIHMsIHQ7XG4gIHMgPSB0d29TdW0oYS54LCBiLngpO1xuICB0ID0gdHdvU3VtKGEueSwgYi55KTtcbiAgcy55ICs9IHQueDtcbiAgcyA9IHF1aWNrVHdvU3VtKHMueCwgcy55KTtcbiAgcy55ICs9IHQueTtcbiAgcyA9IHF1aWNrVHdvU3VtKHMueCwgcy55KTtcbiAgcmV0dXJuIHM7XG59XG5cbnZlYzIgc3ViX2ZwNjQodmVjMiBhLCB2ZWMyIGIpIHtcbiAgdmVjMiBzLCB0O1xuICBzID0gdHdvU3ViKGEueCwgYi54KTtcbiAgdCA9IHR3b1N1YihhLnksIGIueSk7XG4gIHMueSArPSB0Lng7XG4gIHMgPSBxdWlja1R3b1N1bShzLngsIHMueSk7XG4gIHMueSArPSB0Lnk7XG4gIHMgPSBxdWlja1R3b1N1bShzLngsIHMueSk7XG4gIHJldHVybiBzO1xufVxuXG52ZWMyIG11bF9mcDY0KHZlYzIgYSwgdmVjMiBiKSB7XG4gIHZlYzIgcHJvZCA9IHR3b1Byb2QoYS54LCBiLngpO1xuICAvLyB5IGNvbXBvbmVudCBpcyBmb3IgdGhlIGVycm9yXG4gIHByb2QueSArPSBhLnggKiBiLnk7XG4gIHByb2QueSArPSBhLnkgKiBiLng7XG4gIHByb2QgPSBxdWlja1R3b1N1bShwcm9kLngsIHByb2QueSk7XG4gIHJldHVybiBwcm9kO1xufVxuXG52ZWMyIGRpdl9mcDY0KHZlYzIgYSwgdmVjMiBiKSB7XG4gIGZsb2F0IHhuID0gMS4wIC8gYi54O1xuICB2ZWMyIHluID0gYSAqIHhuO1xuICBmbG9hdCBkaWZmID0gKHN1Yl9mcDY0KGEsIG11bF9mcDY0KGIsIHluKSkpLng7XG4gIHZlYzIgcHJvZCA9IHR3b1Byb2QoeG4sIGRpZmYpO1xuICByZXR1cm4gc3VtX2ZwNjQoeW4sIHByb2QpO1xufVxuXG52ZWMyIHNxcnRfZnA2NCh2ZWMyIGEpIHtcblxuICBpZiAoYS54ID09IDAuMCAmJiBhLnkgPT0gMC4wKSByZXR1cm4gdmVjMigwLjAsIDAuMCk7XG4gIGlmIChhLnggPCAwLjApIHJldHVybiB2ZWMyKDAuMCAvIDAuMCwgMC4wIC8gMC4wKTtcblxuICBmbG9hdCB4ID0gMS4wIC8gc3FydChhLngpO1xuICBmbG9hdCB5biA9IGEueCAqIHg7XG4jaWYgZGVmaW5lZChOVklESUFfRlA2NF9XT1JLQVJPVU5EKSB8fCBkZWZpbmVkKElOVEVMX0ZQNjRfV09SS0FST1VORClcbiAgdmVjMiB5bl9zcXIgPSB0d29TcXIoeW4pICogT05FO1xuI2Vsc2VcbiAgdmVjMiB5bl9zcXIgPSB0d29TcXIoeW4pO1xuI2VuZGlmXG4gIGZsb2F0IGRpZmYgPSBzdWJfZnA2NChhLCB5bl9zcXIpLng7XG4gIHZlYzIgcHJvZCA9IHR3b1Byb2QoeCAqIDAuNSwgZGlmZik7XG4gIHJldHVybiBzdW1fZnA2NCh2ZWMyKHluLCAwLjApLCBwcm9kKTtcbn1cblxuLyoga19wb3dlciBjb250cm9scyBob3cgbXVjaCByYW5nZSByZWR1Y3Rpb24gd2Ugd291bGQgbGlrZSB0byBoYXZlXG5SYW5nZSByZWR1Y3Rpb24gdXNlcyB0aGUgZm9sbG93aW5nIG1ldGhvZDpcbmFzc3VtZSBhID0ga19wb3dlciAqIHIgKyBtICogbG9nKDIpLCBrIGFuZCBtIGJlaW5nIGludGVnZXJzLlxuU2V0IGtfcG93ZXIgPSA0ICh3ZSBjYW4gY2hvb3NlIG90aGVyIGsgdG8gdHJhZGUgYWNjdXJhY3kgd2l0aCBwZXJmb3JtYW5jZS5cbndlIG9ubHkgbmVlZCB0byBjYWxjdWxhdGUgZXhwKHIpIGFuZCB1c2luZyBleHAoYSkgPSAyXm0gKiBleHAocilea19wb3dlcjtcbiovXG5cbnZlYzIgZXhwX2ZwNjQodmVjMiBhKSB7XG4gIC8vIFdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoZXNlIHR3byBudW1iZXJzIG1hdGNoXG4gIC8vIGFzIGJpdC13aXNlIHNoaWZ0IGlzIG5vdCBhdmFpbGFibGUgaW4gR0xTTCAxLjBcbiAgY29uc3QgaW50IGtfcG93ZXIgPSA0O1xuICBjb25zdCBmbG9hdCBrID0gMTYuMDtcblxuICBjb25zdCBmbG9hdCBpbnZfayA9IDEuMCAvIGs7XG5cbiAgaWYgKGEueCA8PSAtODguMCkgcmV0dXJuIHZlYzIoMC4wLCAwLjApO1xuICBpZiAoYS54ID49IDg4LjApIHJldHVybiB2ZWMyKDEuMCAvIDAuMCwgMS4wIC8gMC4wKTtcbiAgaWYgKGEueCA9PSAwLjAgJiYgYS55ID09IDAuMCkgcmV0dXJuIHZlYzIoMS4wLCAwLjApO1xuICBpZiAoYS54ID09IDEuMCAmJiBhLnkgPT0gMC4wKSByZXR1cm4gRV9GUDY0O1xuXG4gIGZsb2F0IG0gPSBmbG9vcihhLnggLyBMT0cyX0ZQNjQueCArIDAuNSk7XG4gIHZlYzIgciA9IHN1Yl9mcDY0KGEsIG11bF9mcDY0KExPRzJfRlA2NCwgdmVjMihtLCAwLjApKSkgKiBpbnZfaztcbiAgdmVjMiBzLCB0LCBwO1xuXG4gIHAgPSBtdWxfZnA2NChyLCByKTtcbiAgcyA9IHN1bV9mcDY0KHIsIHAgKiAwLjUpO1xuICBwID0gbXVsX2ZwNjQocCwgcik7XG4gIHQgPSBtdWxfZnA2NChwLCBJTlZFUlNFX0ZBQ1RPUklBTF8zX0ZQNjQpO1xuXG4gIHMgPSBzdW1fZnA2NChzLCB0KTtcbiAgcCA9IG11bF9mcDY0KHAsIHIpO1xuICB0ID0gbXVsX2ZwNjQocCwgSU5WRVJTRV9GQUNUT1JJQUxfNF9GUDY0KTtcblxuICBzID0gc3VtX2ZwNjQocywgdCk7XG4gIHAgPSBtdWxfZnA2NChwLCByKTtcbiAgdCA9IG11bF9mcDY0KHAsIElOVkVSU0VfRkFDVE9SSUFMXzVfRlA2NCk7XG5cbiAgLy8gcyA9IHN1bV9mcDY0KHMsIHQpO1xuICAvLyBwID0gbXVsX2ZwNjQocCwgcik7XG4gIC8vIHQgPSBtdWxfZnA2NChwLCBJTlZFUlNFX0ZBQ1RPUklBTF82X0ZQNjQpO1xuXG4gIC8vIHMgPSBzdW1fZnA2NChzLCB0KTtcbiAgLy8gcCA9IG11bF9mcDY0KHAsIHIpO1xuICAvLyB0ID0gbXVsX2ZwNjQocCwgSU5WRVJTRV9GQUNUT1JJQUxfN19GUDY0KTtcblxuICBzID0gc3VtX2ZwNjQocywgdCk7XG5cblxuICAvLyBBdCB0aGlzIHBvaW50LCBzID0gZXhwKHIpIC0gMTsgYnV0IGFmdGVyIGZvbGxvd2luZyA0IHJlY3Vyc2lvbnMsIHdlIHdpbGwgZ2V0IGV4cChyKSBeIDUxMiAtIDEuXG4gIGZvciAoaW50IGkgPSAwOyBpIDwga19wb3dlcjsgaSsrKSB7XG4gICAgcyA9IHN1bV9mcDY0KHMgKiAyLjAsIG11bF9mcDY0KHMsIHMpKTtcbiAgfVxuXG4jaWYgZGVmaW5lZChOVklESUFfRlA2NF9XT1JLQVJPVU5EKSB8fCBkZWZpbmVkKElOVEVMX0ZQNjRfV09SS0FST1VORClcbiAgcyA9IHN1bV9mcDY0KHMsIHZlYzIoT05FLCAwLjApKTtcbiNlbHNlXG4gIHMgPSBzdW1fZnA2NChzLCB2ZWMyKDEuMCwgMC4wKSk7XG4jZW5kaWZcblxuICByZXR1cm4gcyAqIHBvdygyLjAsIG0pO1xuLy8gICByZXR1cm4gcjtcbn1cblxudmVjMiBsb2dfZnA2NCh2ZWMyIGEpXG57XG4gIGlmIChhLnggPT0gMS4wICYmIGEueSA9PSAwLjApIHJldHVybiB2ZWMyKDAuMCwgMC4wKTtcbiAgaWYgKGEueCA8PSAwLjApIHJldHVybiB2ZWMyKDAuMCAvIDAuMCwgMC4wIC8gMC4wKTtcbiAgdmVjMiB4ID0gdmVjMihsb2coYS54KSwgMC4wKTtcbiAgdmVjMiBzO1xuI2lmIGRlZmluZWQoTlZJRElBX0ZQNjRfV09SS0FST1VORCkgfHwgZGVmaW5lZChJTlRFTF9GUDY0X1dPUktBUk9VTkQpXG4gIHMgPSB2ZWMyKE9ORSwgMC4wKTtcbiNlbHNlXG4gIHMgPSB2ZWMyKDEuMCwgMC4wKTtcbiNlbmRpZlxuXG4gIHggPSBzdWJfZnA2NChzdW1fZnA2NCh4LCBtdWxfZnA2NChhLCBleHBfZnA2NCgteCkpKSwgcyk7XG4gIHJldHVybiB4O1xufVxuXG52ZWMyIHNpbl90YXlsb3JfZnA2NCh2ZWMyIGEpIHtcbiAgdmVjMiByLCBzLCB0LCB4O1xuXG4gIGlmIChhLnggPT0gMC4wICYmIGEueSA9PSAwLjApIHtcbiAgICByZXR1cm4gdmVjMigwLjAsIDAuMCk7XG4gIH1cblxuICB4ID0gLW11bF9mcDY0KGEsIGEpO1xuICBzID0gYTtcbiAgciA9IGE7XG5cbiAgciA9IG11bF9mcDY0KHIsIHgpO1xuICB0ID0gbXVsX2ZwNjQociwgSU5WRVJTRV9GQUNUT1JJQUxfM19GUDY0KTtcbiAgcyA9IHN1bV9mcDY0KHMsIHQpO1xuXG4gIHIgPSBtdWxfZnA2NChyLCB4KTtcbiAgdCA9IG11bF9mcDY0KHIsIElOVkVSU0VfRkFDVE9SSUFMXzVfRlA2NCk7XG4gIHMgPSBzdW1fZnA2NChzLCB0KTtcblxuICAvKiBrZWVwIHRoZSBmb2xsb3dpbmcgY29tbWVudGVkIGNvZGUgaW4gY2FzZSB3ZSBuZWVkIHRoZW1cbiAgZm9yIGV4dHJhIGFjY3VyYWN5IGZyb20gdGhlIFRheWxvciBleHBhbnNpb24qL1xuXG4gIC8vIHIgPSBtdWxfZnA2NChyLCB4KTtcbiAgLy8gdCA9IG11bF9mcDY0KHIsIElOVkVSU0VfRkFDVE9SSUFMXzdfRlA2NCk7XG4gIC8vIHMgPSBzdW1fZnA2NChzLCB0KTtcblxuICAvLyByID0gbXVsX2ZwNjQociwgeCk7XG4gIC8vIHQgPSBtdWxfZnA2NChyLCBJTlZFUlNFX0ZBQ1RPUklBTF85X0ZQNjQpO1xuICAvLyBzID0gc3VtX2ZwNjQocywgdCk7XG5cbiAgcmV0dXJuIHM7XG59XG5cbnZlYzIgY29zX3RheWxvcl9mcDY0KHZlYzIgYSkge1xuICB2ZWMyIHIsIHMsIHQsIHg7XG5cbiAgaWYgKGEueCA9PSAwLjAgJiYgYS55ID09IDAuMCkge1xuICAgIHJldHVybiB2ZWMyKDEuMCwgMC4wKTtcbiAgfVxuXG4gIHggPSAtbXVsX2ZwNjQoYSwgYSk7XG4gIHIgPSB4O1xuICBzID0gc3VtX2ZwNjQodmVjMigxLjAsIDAuMCksIHIgKiAwLjUpO1xuXG4gIHIgPSBtdWxfZnA2NChyLCB4KTtcbiAgdCA9IG11bF9mcDY0KHIsIElOVkVSU0VfRkFDVE9SSUFMXzRfRlA2NCk7XG4gIHMgPSBzdW1fZnA2NChzLCB0KTtcblxuICByID0gbXVsX2ZwNjQociwgeCk7XG4gIHQgPSBtdWxfZnA2NChyLCBJTlZFUlNFX0ZBQ1RPUklBTF82X0ZQNjQpO1xuICBzID0gc3VtX2ZwNjQocywgdCk7XG5cbiAgLyoga2VlcCB0aGUgZm9sbG93aW5nIGNvbW1lbnRlZCBjb2RlIGluIGNhc2Ugd2UgbmVlZCB0aGVtXG4gIGZvciBleHRyYSBhY2N1cmFjeSBmcm9tIHRoZSBUYXlsb3IgZXhwYW5zaW9uKi9cblxuICAvLyByID0gbXVsX2ZwNjQociwgeCk7XG4gIC8vIHQgPSBtdWxfZnA2NChyLCBJTlZFUlNFX0ZBQ1RPUklBTF84X0ZQNjQpO1xuICAvLyBzID0gc3VtX2ZwNjQocywgdCk7XG5cbiAgLy8gciA9IG11bF9mcDY0KHIsIHgpO1xuICAvLyB0ID0gbXVsX2ZwNjQociwgSU5WRVJTRV9GQUNUT1JJQUxfMTBfRlA2NCk7XG4gIC8vIHMgPSBzdW1fZnA2NChzLCB0KTtcblxuICByZXR1cm4gcztcbn1cblxudm9pZCBzaW5jb3NfdGF5bG9yX2ZwNjQodmVjMiBhLCBvdXQgdmVjMiBzaW5fdCwgb3V0IHZlYzIgY29zX3QpIHtcbiAgaWYgKGEueCA9PSAwLjAgJiYgYS55ID09IDAuMCkge1xuICAgIHNpbl90ID0gdmVjMigwLjAsIDAuMCk7XG4gICAgY29zX3QgPSB2ZWMyKDEuMCwgMC4wKTtcbiAgfVxuXG4gIHNpbl90ID0gc2luX3RheWxvcl9mcDY0KGEpO1xuICBjb3NfdCA9IHNxcnRfZnA2NChzdWJfZnA2NCh2ZWMyKDEuMCwgMC4wKSwgbXVsX2ZwNjQoc2luX3QsIHNpbl90KSkpO1xufVxuXG52ZWMyIHNpbl9mcDY0KHZlYzIgYSkge1xuICAgIGlmIChhLnggPT0gMC4wICYmIGEueSA9PSAwLjApIHtcbiAgICAgICAgcmV0dXJuIHZlYzIoMC4wLCAwLjApO1xuICAgIH1cblxuICAgIC8vIDJwaSByYW5nZSByZWR1Y3Rpb25cbiAgICB2ZWMyIHogPSBuaW50X2ZwNjQoZGl2X2ZwNjQoYSwgVFdPX1BJX0ZQNjQpKTtcbiAgICB2ZWMyIHIgPSBzdWJfZnA2NChhLCBtdWxfZnA2NChUV09fUElfRlA2NCwgeikpO1xuXG4gICAgdmVjMiB0O1xuICAgIGZsb2F0IHEgPSBmbG9vcihyLnggLyBQSV8yX0ZQNjQueCArIDAuNSk7XG4gICAgaW50IGogPSBpbnQocSk7XG5cbiAgICBpZiAoaiA8IC0yIHx8IGogPiAyKSB7XG4gICAgICAgIHJldHVybiB2ZWMyKDAuMCAvIDAuMCwgMC4wIC8gMC4wKTtcbiAgICB9XG5cbiAgICB0ID0gc3ViX2ZwNjQociwgbXVsX2ZwNjQoUElfMl9GUDY0LCB2ZWMyKHEsIDAuMCkpKTtcblxuICAgIHEgPSBmbG9vcih0LnggLyBQSV8xNl9GUDY0LnggKyAwLjUpO1xuICAgIGludCBrID0gaW50KHEpO1xuXG4gICAgaWYgKGsgPT0gMCkge1xuICAgICAgICBpZiAoaiA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gc2luX3RheWxvcl9mcDY0KHQpO1xuICAgICAgICB9IGVsc2UgaWYgKGogPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvc190YXlsb3JfZnA2NCh0KTtcbiAgICAgICAgfSBlbHNlIGlmIChqID09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gLWNvc190YXlsb3JfZnA2NCh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtc2luX3RheWxvcl9mcDY0KHQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW50IGFic19rID0gaW50KGFicyhmbG9hdChrKSkpO1xuXG4gICAgaWYgKGFic19rID4gNCkge1xuICAgICAgICByZXR1cm4gdmVjMigwLjAgLyAwLjAsIDAuMCAvIDAuMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdCA9IHN1Yl9mcDY0KHQsIG11bF9mcDY0KFBJXzE2X0ZQNjQsIHZlYzIocSwgMC4wKSkpO1xuICAgIH1cblxuICAgIHZlYzIgdSA9IHZlYzIoMC4wLCAwLjApO1xuICAgIHZlYzIgdiA9IHZlYzIoMC4wLCAwLjApO1xuXG4jaWYgZGVmaW5lZChOVklESUFfRVFVQVRJT05fV09SS0FST1VORCkgfHwgZGVmaW5lZChJTlRFTF9FUVVBVElPTl9XT1JLQVJPVU5EKVxuICAgIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gMS4wKSA8IDAuNSkge1xuICAgICAgICB1ID0gQ09TX1RBQkxFXzBfRlA2NDtcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8wX0ZQNjQ7XG4gICAgfSBlbHNlIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gMi4wKSA8IDAuNSkge1xuICAgICAgICB1ID0gQ09TX1RBQkxFXzFfRlA2NDtcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8xX0ZQNjQ7XG4gICAgfSBlbHNlIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gMy4wKSA8IDAuNSkge1xuICAgICAgICB1ID0gQ09TX1RBQkxFXzJfRlA2NDtcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8yX0ZQNjQ7XG4gICAgfSBlbHNlIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gNC4wKSA8IDAuNSkge1xuICAgICAgICB1ID0gQ09TX1RBQkxFXzNfRlA2NDtcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8zX0ZQNjQ7XG4gICAgfVxuI2Vsc2VcbiAgICBpZiAoYWJzX2sgPT0gMSkge1xuICAgICAgICB1ID0gQ09TX1RBQkxFXzBfRlA2NDtcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8wX0ZQNjQ7XG4gICAgfSBlbHNlIGlmIChhYnNfayA9PSAyKSB7XG4gICAgICAgIHUgPSBDT1NfVEFCTEVfMV9GUDY0O1xuICAgICAgICB2ID0gU0lOX1RBQkxFXzFfRlA2NDtcbiAgICB9IGVsc2UgaWYgKGFic19rID09IDMpIHtcbiAgICAgICAgdSA9IENPU19UQUJMRV8yX0ZQNjQ7XG4gICAgICAgIHYgPSBTSU5fVEFCTEVfMl9GUDY0O1xuICAgIH0gZWxzZSBpZiAoYWJzX2sgPT0gNCkge1xuICAgICAgICB1ID0gQ09TX1RBQkxFXzNfRlA2NDtcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8zX0ZQNjQ7XG4gICAgfVxuI2VuZGlmXG5cbiAgICB2ZWMyIHNpbl90LCBjb3NfdDtcbiAgICBzaW5jb3NfdGF5bG9yX2ZwNjQodCwgc2luX3QsIGNvc190KTtcblxuXG5cbiAgICB2ZWMyIHJlc3VsdCA9IHZlYzIoMC4wLCAwLjApO1xuICAgIGlmIChqID09IDApIHtcbiAgICAgICAgaWYgKGsgPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzdW1fZnA2NChtdWxfZnA2NCh1LCBzaW5fdCksIG11bF9mcDY0KHYsIGNvc190KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzdWJfZnA2NChtdWxfZnA2NCh1LCBzaW5fdCksIG11bF9mcDY0KHYsIGNvc190KSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGogPT0gMSkge1xuICAgICAgICBpZiAoayA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHN1Yl9mcDY0KG11bF9mcDY0KHUsIGNvc190KSwgbXVsX2ZwNjQodiwgc2luX3QpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHN1bV9mcDY0KG11bF9mcDY0KHUsIGNvc190KSwgbXVsX2ZwNjQodiwgc2luX3QpKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaiA9PSAtMSkge1xuICAgICAgICBpZiAoayA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHN1Yl9mcDY0KG11bF9mcDY0KHYsIHNpbl90KSwgbXVsX2ZwNjQodSwgY29zX3QpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IC1zdW1fZnA2NChtdWxfZnA2NCh2LCBzaW5fdCksIG11bF9mcDY0KHUsIGNvc190KSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoayA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IC1zdW1fZnA2NChtdWxfZnA2NCh1LCBzaW5fdCksIG11bF9mcDY0KHYsIGNvc190KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzdWJfZnA2NChtdWxfZnA2NCh2LCBjb3NfdCksIG11bF9mcDY0KHUsIHNpbl90KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG52ZWMyIGNvc19mcDY0KHZlYzIgYSkge1xuICAgIGlmIChhLnggPT0gMC4wICYmIGEueSA9PSAwLjApIHtcbiAgICAgICAgcmV0dXJuIHZlYzIoMS4wLCAwLjApO1xuICAgIH1cblxuICAgIC8vIDJwaSByYW5nZSByZWR1Y3Rpb25cbiAgICB2ZWMyIHogPSBuaW50X2ZwNjQoZGl2X2ZwNjQoYSwgVFdPX1BJX0ZQNjQpKTtcbiAgICB2ZWMyIHIgPSBzdWJfZnA2NChhLCBtdWxfZnA2NChUV09fUElfRlA2NCwgeikpO1xuXG4gICAgdmVjMiB0O1xuICAgIGZsb2F0IHEgPSBmbG9vcihyLnggLyBQSV8yX0ZQNjQueCArIDAuNSk7XG4gICAgaW50IGogPSBpbnQocSk7XG5cbiAgICBpZiAoaiA8IC0yIHx8IGogPiAyKSB7XG4gICAgICAgIHJldHVybiB2ZWMyKDAuMCAvIDAuMCwgMC4wIC8gMC4wKTtcbiAgICB9XG5cbiAgICB0ID0gc3ViX2ZwNjQociwgbXVsX2ZwNjQoUElfMl9GUDY0LCB2ZWMyKHEsIDAuMCkpKTtcblxuICAgIHEgPSBmbG9vcih0LnggLyBQSV8xNl9GUDY0LnggKyAwLjUpO1xuICAgIGludCBrID0gaW50KHEpO1xuXG4gICAgaWYgKGsgPT0gMCkge1xuICAgICAgICBpZiAoaiA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY29zX3RheWxvcl9mcDY0KHQpO1xuICAgICAgICB9IGVsc2UgaWYgKGogPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIC1zaW5fdGF5bG9yX2ZwNjQodCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaiA9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpbl90YXlsb3JfZnA2NCh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtY29zX3RheWxvcl9mcDY0KHQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW50IGFic19rID0gaW50KGFicyhmbG9hdChrKSkpO1xuXG4gICAgaWYgKGFic19rID4gNCkge1xuICAgICAgICByZXR1cm4gdmVjMigwLjAgLyAwLjAsIDAuMCAvIDAuMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdCA9IHN1Yl9mcDY0KHQsIG11bF9mcDY0KFBJXzE2X0ZQNjQsIHZlYzIocSwgMC4wKSkpO1xuICAgIH1cblxuICAgIHZlYzIgdSA9IHZlYzIoMC4wLCAwLjApO1xuICAgIHZlYzIgdiA9IHZlYzIoMC4wLCAwLjApO1xuXG4jaWYgZGVmaW5lZChOVklESUFfRVFVQVRJT05fV09SS0FST1VORCkgfHwgZGVmaW5lZChJTlRFTF9FUVVBVElPTl9XT1JLQVJPVU5EKVxuICAgIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gMS4wKSA8IDAuNSkge1xuICAgICAgICB1ID0gQ09TX1RBQkxFXzBfRlA2NDtcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8wX0ZQNjQ7XG4gICAgfSBlbHNlIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gMi4wKSA8IDAuNSkge1xuICAgICAgICB1ID0gQ09TX1RBQkxFXzFfRlA2NDtcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8xX0ZQNjQ7XG4gICAgfSBlbHNlIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gMy4wKSA8IDAuNSkge1xuICAgICAgICB1ID0gQ09TX1RBQkxFXzJfRlA2NDtcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8yX0ZQNjQ7XG4gICAgfSBlbHNlIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gNC4wKSA8IDAuNSkge1xuICAgICAgICB1ID0gQ09TX1RBQkxFXzNfRlA2NDtcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8zX0ZQNjQ7XG4gICAgfVxuI2Vsc2VcbiAgICBpZiAoYWJzX2sgPT0gMSkge1xuICAgICAgICB1ID0gQ09TX1RBQkxFXzBfRlA2NDtcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8wX0ZQNjQ7XG4gICAgfSBlbHNlIGlmIChhYnNfayA9PSAyKSB7XG4gICAgICAgIHUgPSBDT1NfVEFCTEVfMV9GUDY0O1xuICAgICAgICB2ID0gU0lOX1RBQkxFXzFfRlA2NDtcbiAgICB9IGVsc2UgaWYgKGFic19rID09IDMpIHtcbiAgICAgICAgdSA9IENPU19UQUJMRV8yX0ZQNjQ7XG4gICAgICAgIHYgPSBTSU5fVEFCTEVfMl9GUDY0O1xuICAgIH0gZWxzZSBpZiAoYWJzX2sgPT0gNCkge1xuICAgICAgICB1ID0gQ09TX1RBQkxFXzNfRlA2NDtcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8zX0ZQNjQ7XG4gICAgfVxuI2VuZGlmXG5cbiAgICB2ZWMyIHNpbl90LCBjb3NfdDtcbiAgICBzaW5jb3NfdGF5bG9yX2ZwNjQodCwgc2luX3QsIGNvc190KTtcblxuICAgIHZlYzIgcmVzdWx0ID0gdmVjMigwLjAsIDAuMCk7XG4gICAgaWYgKGogPT0gMCkge1xuICAgICAgICBpZiAoayA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHN1Yl9mcDY0KG11bF9mcDY0KHUsIGNvc190KSwgbXVsX2ZwNjQodiwgc2luX3QpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHN1bV9mcDY0KG11bF9mcDY0KHUsIGNvc190KSwgbXVsX2ZwNjQodiwgc2luX3QpKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaiA9PSAxKSB7XG4gICAgICAgIGlmIChrID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gLXN1bV9mcDY0KG11bF9mcDY0KHUsIHNpbl90KSwgbXVsX2ZwNjQodiwgY29zX3QpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHN1Yl9mcDY0KG11bF9mcDY0KHYsIGNvc190KSwgbXVsX2ZwNjQodSwgc2luX3QpKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaiA9PSAtMSkge1xuICAgICAgICBpZiAoayA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHN1bV9mcDY0KG11bF9mcDY0KHUsIHNpbl90KSwgbXVsX2ZwNjQodiwgY29zX3QpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHN1Yl9mcDY0KG11bF9mcDY0KHUsIHNpbl90KSwgbXVsX2ZwNjQodiwgY29zX3QpKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChrID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gc3ViX2ZwNjQobXVsX2ZwNjQodiwgc2luX3QpLCBtdWxfZnA2NCh1LCBjb3NfdCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gLXN1bV9mcDY0KG11bF9mcDY0KHUsIGNvc190KSwgbXVsX2ZwNjQodiwgc2luX3QpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbnZlYzIgdGFuX2ZwNjQodmVjMiBhKSB7XG4gICAgdmVjMiBzaW5fYTtcbiAgICB2ZWMyIGNvc19hO1xuXG4gICAgaWYgKGEueCA9PSAwLjAgJiYgYS55ID09IDAuMCkge1xuICAgICAgICByZXR1cm4gdmVjMigwLjAsIDAuMCk7XG4gICAgfVxuXG4gICAgLy8gMnBpIHJhbmdlIHJlZHVjdGlvblxuICAgIHZlYzIgeiA9IG5pbnRfZnA2NChkaXZfZnA2NChhLCBUV09fUElfRlA2NCkpO1xuICAgIHZlYzIgciA9IHN1Yl9mcDY0KGEsIG11bF9mcDY0KFRXT19QSV9GUDY0LCB6KSk7XG5cbiAgICB2ZWMyIHQ7XG4gICAgZmxvYXQgcSA9IGZsb29yKHIueCAvIFBJXzJfRlA2NC54ICsgMC41KTtcbiAgICBpbnQgaiA9IGludChxKTtcblxuXG4gICAgaWYgKGogPCAtMiB8fCBqID4gMikge1xuICAgICAgICByZXR1cm4gdmVjMigwLjAgLyAwLjAsIDAuMCAvIDAuMCk7XG4gICAgfVxuXG4gICAgdCA9IHN1Yl9mcDY0KHIsIG11bF9mcDY0KFBJXzJfRlA2NCwgdmVjMihxLCAwLjApKSk7XG5cbiAgICBxID0gZmxvb3IodC54IC8gUElfMTZfRlA2NC54ICsgMC41KTtcbiAgICBpbnQgayA9IGludChxKTtcbiAgICBpbnQgYWJzX2sgPSBpbnQoYWJzKGZsb2F0KGspKSk7XG5cbiAgICAvLyBXZSBqdXN0IGNhbid0IGdldCBQSS8xNiAqIDMuMCB2ZXJ5IGFjY3VyYXRlbHkuXG4gICAgLy8gc28gbGV0J3MganVzdCBzdG9yZSBpdFxuICAgIGlmIChhYnNfayA+IDQpIHtcbiAgICAgICAgcmV0dXJuIHZlYzIoMC4wIC8gMC4wLCAwLjAgLyAwLjApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHQgPSBzdWJfZnA2NCh0LCBtdWxfZnA2NChQSV8xNl9GUDY0LCB2ZWMyKHEsIDAuMCkpKTtcbiAgICB9XG5cblxuICAgIHZlYzIgdSA9IHZlYzIoMC4wLCAwLjApO1xuICAgIHZlYzIgdiA9IHZlYzIoMC4wLCAwLjApO1xuXG4gICAgdmVjMiBzaW5fdCwgY29zX3Q7XG4gICAgdmVjMiBzLCBjO1xuICAgIHNpbmNvc190YXlsb3JfZnA2NCh0LCBzaW5fdCwgY29zX3QpO1xuXG4gICAgaWYgKGsgPT0gMCkge1xuICAgICAgICBzID0gc2luX3Q7XG4gICAgICAgIGMgPSBjb3NfdDtcbiAgICB9IGVsc2Uge1xuI2lmIGRlZmluZWQoTlZJRElBX0VRVUFUSU9OX1dPUktBUk9VTkQpIHx8IGRlZmluZWQoSU5URUxfRVFVQVRJT05fV09SS0FST1VORClcbiAgICAgICAgaWYgKGFicyhmbG9hdChhYnNfaykgLSAxLjApIDwgMC41KSB7XG4gICAgICAgICAgICB1ID0gQ09TX1RBQkxFXzBfRlA2NDtcbiAgICAgICAgICAgIHYgPSBTSU5fVEFCTEVfMF9GUDY0O1xuICAgICAgICB9IGVsc2UgaWYgKGFicyhmbG9hdChhYnNfaykgLSAyLjApIDwgMC41KSB7XG4gICAgICAgICAgICB1ID0gQ09TX1RBQkxFXzFfRlA2NDtcbiAgICAgICAgICAgIHYgPSBTSU5fVEFCTEVfMV9GUDY0O1xuICAgICAgICB9IGVsc2UgaWYgKGFicyhmbG9hdChhYnNfaykgLSAzLjApIDwgMC41KSB7XG4gICAgICAgICAgICB1ID0gQ09TX1RBQkxFXzJfRlA2NDtcbiAgICAgICAgICAgIHYgPSBTSU5fVEFCTEVfMl9GUDY0O1xuICAgICAgICB9IGVsc2UgaWYgKGFicyhmbG9hdChhYnNfaykgLSA0LjApIDwgMC41KSB7XG4gICAgICAgICAgICB1ID0gQ09TX1RBQkxFXzNfRlA2NDtcbiAgICAgICAgICAgIHYgPSBTSU5fVEFCTEVfM19GUDY0O1xuICAgICAgICB9XG4jZWxzZVxuICAgICAgICBpZiAoYWJzX2sgPT0gMSkge1xuICAgICAgICAgICAgdSA9IENPU19UQUJMRV8wX0ZQNjQ7XG4gICAgICAgICAgICB2ID0gU0lOX1RBQkxFXzBfRlA2NDtcbiAgICAgICAgfSBlbHNlIGlmIChhYnNfayA9PSAyKSB7XG4gICAgICAgICAgICB1ID0gQ09TX1RBQkxFXzFfRlA2NDtcbiAgICAgICAgICAgIHYgPSBTSU5fVEFCTEVfMV9GUDY0O1xuICAgICAgICB9IGVsc2UgaWYgKGFic19rID09IDMpIHtcbiAgICAgICAgICAgIHUgPSBDT1NfVEFCTEVfMl9GUDY0O1xuICAgICAgICAgICAgdiA9IFNJTl9UQUJMRV8yX0ZQNjQ7XG4gICAgICAgIH0gZWxzZSBpZiAoYWJzX2sgPT0gNCkge1xuICAgICAgICAgICAgdSA9IENPU19UQUJMRV8zX0ZQNjQ7XG4gICAgICAgICAgICB2ID0gU0lOX1RBQkxFXzNfRlA2NDtcbiAgICAgICAgfVxuI2VuZGlmXG4gICAgICAgIGlmIChrID4gMCkge1xuICAgICAgICAgICAgcyA9IHN1bV9mcDY0KG11bF9mcDY0KHUsIHNpbl90KSwgbXVsX2ZwNjQodiwgY29zX3QpKTtcbiAgICAgICAgICAgIGMgPSBzdWJfZnA2NChtdWxfZnA2NCh1LCBjb3NfdCksIG11bF9mcDY0KHYsIHNpbl90KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzID0gc3ViX2ZwNjQobXVsX2ZwNjQodSwgc2luX3QpLCBtdWxfZnA2NCh2LCBjb3NfdCkpO1xuICAgICAgICAgICAgYyA9IHN1bV9mcDY0KG11bF9mcDY0KHUsIGNvc190KSwgbXVsX2ZwNjQodiwgc2luX3QpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChqID09IDApIHtcbiAgICAgICAgc2luX2EgPSBzO1xuICAgICAgICBjb3NfYSA9IGM7XG4gICAgfSBlbHNlIGlmIChqID09IDEpIHtcbiAgICAgICAgc2luX2EgPSBjO1xuICAgICAgICBjb3NfYSA9IC1zO1xuICAgIH0gZWxzZSBpZiAoaiA9PSAtMSkge1xuICAgICAgICBzaW5fYSA9IC1jO1xuICAgICAgICBjb3NfYSA9IHM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2luX2EgPSAtcztcbiAgICAgICAgY29zX2EgPSAtYztcbiAgICB9XG4gICAgcmV0dXJuIGRpdl9mcDY0KHNpbl9hLCBjb3NfYSk7XG59XG5cbnZlYzIgcmFkaWFuc19mcDY0KHZlYzIgZGVncmVlKSB7XG4gIHJldHVybiBtdWxfZnA2NChkZWdyZWUsIFBJXzE4MF9GUDY0KTtcbn1cblxudmVjMiBtaXhfZnA2NCh2ZWMyIGEsIHZlYzIgYiwgZmxvYXQgeCkge1xuICB2ZWMyIHJhbmdlID0gc3ViX2ZwNjQoYiwgYSk7XG4gIHJldHVybiBzdW1fZnA2NChhLCBtdWxfZnA2NChyYW5nZSwgdmVjMih4LCAwLjApKSk7XG59XG5cbi8vIFZlY3RvciBmdW5jdGlvbnNcbi8vIHZlYzIgZnVuY3Rpb25zXG52b2lkIHZlYzJfc3VtX2ZwNjQodmVjMiBhWzJdLCB2ZWMyIGJbMl0sIG91dCB2ZWMyIG91dF92YWxbMl0pIHtcbiAgICBvdXRfdmFsWzBdID0gc3VtX2ZwNjQoYVswXSwgYlswXSk7XG4gICAgb3V0X3ZhbFsxXSA9IHN1bV9mcDY0KGFbMV0sIGJbMV0pO1xufVxuXG52b2lkIHZlYzJfc3ViX2ZwNjQodmVjMiBhWzJdLCB2ZWMyIGJbMl0sIG91dCB2ZWMyIG91dF92YWxbMl0pIHtcbiAgICBvdXRfdmFsWzBdID0gc3ViX2ZwNjQoYVswXSwgYlswXSk7XG4gICAgb3V0X3ZhbFsxXSA9IHN1Yl9mcDY0KGFbMV0sIGJbMV0pO1xufVxuXG52b2lkIHZlYzJfbXVsX2ZwNjQodmVjMiBhWzJdLCB2ZWMyIGJbMl0sIG91dCB2ZWMyIG91dF92YWxbMl0pIHtcbiAgICBvdXRfdmFsWzBdID0gbXVsX2ZwNjQoYVswXSwgYlswXSk7XG4gICAgb3V0X3ZhbFsxXSA9IG11bF9mcDY0KGFbMV0sIGJbMV0pO1xufVxuXG52b2lkIHZlYzJfZGl2X2ZwNjQodmVjMiBhWzJdLCB2ZWMyIGJbMl0sIG91dCB2ZWMyIG91dF92YWxbMl0pIHtcbiAgICBvdXRfdmFsWzBdID0gZGl2X2ZwNjQoYVswXSwgYlswXSk7XG4gICAgb3V0X3ZhbFsxXSA9IGRpdl9mcDY0KGFbMV0sIGJbMV0pO1xufVxuXG52b2lkIHZlYzJfbWl4X2ZwNjQodmVjMiB4WzJdLCB2ZWMyIHlbMl0sIGZsb2F0IGEsIG91dCB2ZWMyIG91dF92YWxbMl0pIHtcbiAgdmVjMiByYW5nZVsyXTtcbiAgdmVjMl9zdWJfZnA2NCh5LCB4LCByYW5nZSk7XG4gIHZlYzIgcG9ydGlvblsyXTtcbiAgcG9ydGlvblswXSA9IHJhbmdlWzBdICogYTtcbiAgcG9ydGlvblsxXSA9IHJhbmdlWzFdICogYTtcbiAgdmVjMl9zdW1fZnA2NCh4LCBwb3J0aW9uLCBvdXRfdmFsKTtcbn1cblxudmVjMiB2ZWMyX2xlbmd0aF9mcDY0KHZlYzIgeFsyXSkge1xuICByZXR1cm4gc3FydF9mcDY0KHN1bV9mcDY0KG11bF9mcDY0KHhbMF0sIHhbMF0pLCBtdWxfZnA2NCh4WzFdLCB4WzFdKSkpO1xufVxuXG52b2lkIHZlYzJfbm9ybWFsaXplX2ZwNjQodmVjMiB4WzJdLCBvdXQgdmVjMiBvdXRfdmFsWzJdKSB7XG4gIHZlYzIgbGVuZ3RoID0gdmVjMl9sZW5ndGhfZnA2NCh4KTtcbiAgdmVjMiBsZW5ndGhfdmVjMlsyXTtcbiAgbGVuZ3RoX3ZlYzJbMF0gPSBsZW5ndGg7XG4gIGxlbmd0aF92ZWMyWzFdID0gbGVuZ3RoO1xuXG4gIHZlYzJfZGl2X2ZwNjQoeCwgbGVuZ3RoX3ZlYzIsIG91dF92YWwpO1xufVxuXG52ZWMyIHZlYzJfZGlzdGFuY2VfZnA2NCh2ZWMyIHhbMl0sIHZlYzIgeVsyXSkge1xuICB2ZWMyIGRpZmZbMl07XG4gIHZlYzJfc3ViX2ZwNjQoeCwgeSwgZGlmZik7XG4gIHJldHVybiB2ZWMyX2xlbmd0aF9mcDY0KGRpZmYpO1xufVxuXG52ZWMyIHZlYzJfZG90X2ZwNjQodmVjMiBhWzJdLCB2ZWMyIGJbMl0pIHtcbiAgdmVjMiB2WzJdO1xuXG4gIHZbMF0gPSBtdWxfZnA2NChhWzBdLCBiWzBdKTtcbiAgdlsxXSA9IG11bF9mcDY0KGFbMV0sIGJbMV0pO1xuXG4gIHJldHVybiBzdW1fZnA2NCh2WzBdLCB2WzFdKTtcbn1cblxuLy8gdmVjMyBmdW5jdGlvbnNcbnZvaWQgdmVjM19zdWJfZnA2NCh2ZWMyIGFbM10sIHZlYzIgYlszXSwgb3V0IHZlYzIgb3V0X3ZhbFszXSkge1xuICBmb3IgKGludCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIG91dF92YWxbaV0gPSBzdW1fZnA2NChhW2ldLCBiW2ldKTtcbiAgfVxufVxuXG52b2lkIHZlYzNfc3VtX2ZwNjQodmVjMiBhWzNdLCB2ZWMyIGJbM10sIG91dCB2ZWMyIG91dF92YWxbM10pIHtcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICBvdXRfdmFsW2ldID0gc3VtX2ZwNjQoYVtpXSwgYltpXSk7XG4gIH1cbn1cblxudmVjMiB2ZWMzX2xlbmd0aF9mcDY0KHZlYzIgeFszXSkge1xuICByZXR1cm4gc3FydF9mcDY0KHN1bV9mcDY0KHN1bV9mcDY0KG11bF9mcDY0KHhbMF0sIHhbMF0pLCBtdWxfZnA2NCh4WzFdLCB4WzFdKSksXG4gICAgbXVsX2ZwNjQoeFsyXSwgeFsyXSkpKTtcbn1cblxudmVjMiB2ZWMzX2Rpc3RhbmNlX2ZwNjQodmVjMiB4WzNdLCB2ZWMyIHlbM10pIHtcbiAgdmVjMiBkaWZmWzNdO1xuICB2ZWMzX3N1Yl9mcDY0KHgsIHksIGRpZmYpO1xuICByZXR1cm4gdmVjM19sZW5ndGhfZnA2NChkaWZmKTtcbn1cblxuLy8gdmVjNCBmdW5jdGlvbnNcbnZvaWQgdmVjNF9mcDY0KHZlYzQgYSwgb3V0IHZlYzIgb3V0X3ZhbFs0XSkge1xuICBvdXRfdmFsWzBdLnggPSBhWzBdO1xuICBvdXRfdmFsWzBdLnkgPSAwLjA7XG5cbiAgb3V0X3ZhbFsxXS54ID0gYVsxXTtcbiAgb3V0X3ZhbFsxXS55ID0gMC4wO1xuXG4gIG91dF92YWxbMl0ueCA9IGFbMl07XG4gIG91dF92YWxbMl0ueSA9IDAuMDtcblxuICBvdXRfdmFsWzNdLnggPSBhWzNdO1xuICBvdXRfdmFsWzNdLnkgPSAwLjA7XG59XG5cbnZvaWQgdmVjNF9zY2FsYXJfbXVsX2ZwNjQodmVjMiBhWzRdLCB2ZWMyIGIsIG91dCB2ZWMyIG91dF92YWxbNF0pIHtcbiAgb3V0X3ZhbFswXSA9IG11bF9mcDY0KGFbMF0sIGIpO1xuICBvdXRfdmFsWzFdID0gbXVsX2ZwNjQoYVsxXSwgYik7XG4gIG91dF92YWxbMl0gPSBtdWxfZnA2NChhWzJdLCBiKTtcbiAgb3V0X3ZhbFszXSA9IG11bF9mcDY0KGFbM10sIGIpO1xufVxuXG52b2lkIHZlYzRfc3VtX2ZwNjQodmVjMiBhWzRdLCB2ZWMyIGJbNF0sIG91dCB2ZWMyIG91dF92YWxbNF0pIHtcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBvdXRfdmFsW2ldID0gc3VtX2ZwNjQoYVtpXSwgYltpXSk7XG4gIH1cbn1cblxudm9pZCB2ZWM0X2RvdF9mcDY0KHZlYzIgYVs0XSwgdmVjMiBiWzRdLCBvdXQgdmVjMiBvdXRfdmFsKSB7XG4gIHZlYzIgdls0XTtcblxuICB2WzBdID0gbXVsX2ZwNjQoYVswXSwgYlswXSk7XG4gIHZbMV0gPSBtdWxfZnA2NChhWzFdLCBiWzFdKTtcbiAgdlsyXSA9IG11bF9mcDY0KGFbMl0sIGJbMl0pO1xuICB2WzNdID0gbXVsX2ZwNjQoYVszXSwgYlszXSk7XG5cbiAgb3V0X3ZhbCA9IHN1bV9mcDY0KHN1bV9mcDY0KHZbMF0sIHZbMV0pLCBzdW1fZnA2NCh2WzJdLCB2WzNdKSk7XG59XG5cbnZvaWQgbWF0NF92ZWM0X211bF9mcDY0KHZlYzIgYlsxNl0sIHZlYzIgYVs0XSwgb3V0IHZlYzIgb3V0X3ZhbFs0XSkge1xuICB2ZWMyIHRtcFs0XTtcblxuICBmb3IgKGludCBpID0gMDsgaSA8IDQ7IGkrKylcbiAge1xuICAgIGZvciAoaW50IGogPSAwOyBqIDwgNDsgaisrKVxuICAgIHtcbiAgICAgIHRtcFtqXSA9IGJbaiArIGkgKiA0XTtcbiAgICB9XG4gICAgdmVjNF9kb3RfZnA2NChhLCB0bXAsIG91dF92YWxbaV0pO1xuICB9XG59XG5gO1xuIl19