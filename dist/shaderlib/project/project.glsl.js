"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
// Copyright (c) 2016 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

exports.default = "const float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / (PI * 2.0);\n\n// ref: lib/constants.js\nconst float PROJECT_IDENTITY = 0.;\nconst float PROJECT_MERCATOR = 1.;\nconst float PROJECT_MERCATOR_OFFSETS = 2.;\n\nuniform float projectionMode;\nuniform float projectionScale;\nuniform vec4 projectionCenter;\nuniform vec3 projectionPixelsPerUnit;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 projectionMatrixUncentered;\n\n#ifdef INTEL_TAN_WORKAROUND\n\n// All these functions are for substituting tan() function from Intel GPU only\nconst float TWO_PI = 6.2831854820251465;\nconst float PI_2 = 1.5707963705062866;\nconst float PI_16 = 0.1963495463132858;\n\nconst float SIN_TABLE_0 = 0.19509032368659973;\nconst float SIN_TABLE_1 = 0.3826834261417389;\nconst float SIN_TABLE_2 = 0.5555702447891235;\nconst float SIN_TABLE_3 = 0.7071067690849304;\n\nconst float COS_TABLE_0 = 0.9807852506637573;\nconst float COS_TABLE_1 = 0.9238795042037964;\nconst float COS_TABLE_2 = 0.8314695954322815;\nconst float COS_TABLE_3 = 0.7071067690849304;\n\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01; // 1/3!\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03; // 1/5!\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04; // 1/7!\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06; // 1/9!\n\nfloat sin_taylor_fp32(float a) {\n  float r, s, t, x;\n\n  if (a == 0.0) {\n    return 0.0;\n  }\n\n  x = -a * a;\n  s = a;\n  r = a;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_3;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_5;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_7;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_9;\n  s = s + t;\n\n  return s;\n}\n\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\n  if (a == 0.0) {\n    sin_t = 0.0;\n    cos_t = 1.0;\n  }\n  sin_t = sin_taylor_fp32(a);\n  cos_t = sqrt(1.0 - sin_t * sin_t);\n}\n\nfloat tan_taylor_fp32(float a) {\n    float sin_a;\n    float cos_a;\n\n    if (a == 0.0) {\n        return 0.0;\n    }\n\n    // 2pi range reduction\n    float z = floor(a / TWO_PI);\n    float r = a - TWO_PI * z;\n\n    float t;\n    float q = floor(r / PI_2 + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return 0.0 / 0.0;\n    }\n\n    t = r - PI_2 * q;\n\n    q = floor(t / PI_16 + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return 0.0 / 0.0;\n    } else {\n        t = t - PI_16 * q;\n    }\n\n    float u = 0.0;\n    float v = 0.0;\n\n    float sin_t, cos_t;\n    float s, c;\n    sincos_taylor_fp32(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0;\n            v = SIN_TABLE_0;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1;\n            v = SIN_TABLE_1;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2;\n            v = SIN_TABLE_2;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3;\n            v = SIN_TABLE_3;\n        }\n        if (k > 0) {\n            s = u * sin_t + v * cos_t;\n            c = u * cos_t - v * sin_t;\n        } else {\n            s = u * sin_t - v * cos_t;\n            c = u * cos_t + v * sin_t;\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return sin_a / cos_a;\n}\n#endif\n\nfloat tan_fp32(float a) {\n#ifdef INTEL_TAN_WORKAROUND\n  return tan_taylor_fp32(a);\n#else\n  return tan(a);\n#endif\n}\n\n//\n// Scaling offsets\n//\n\nfloat project_scale(float meters) {\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\n    return meters;\n  } else {\n    return meters * projectionPixelsPerUnit.x;\n  }\n}\n\nvec2 project_scale(vec2 meters) {\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\n    return meters;\n  } else {\n    return vec2(\n      meters.x * projectionPixelsPerUnit.x,\n      meters.y * projectionPixelsPerUnit.x\n    );\n  }\n}\n\nvec3 project_scale(vec3 meters) {\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\n    return meters;\n  } else {\n    return vec3(\n      meters.x * projectionPixelsPerUnit.x,\n      meters.y * projectionPixelsPerUnit.x,\n      meters.z * projectionPixelsPerUnit.x\n    );\n  }\n}\n\nvec4 project_scale(vec4 meters) {\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\n    return meters;\n  } else {\n    return vec4(\n      meters.x * projectionPixelsPerUnit.x,\n      meters.y * projectionPixelsPerUnit.x,\n      meters.z * projectionPixelsPerUnit.x,\n      meters.w\n    );\n  }\n}\n\n//\n// Projecting positions\n//\n\n// non-linear projection: lnglats => unit tile [0-1, 0-1]\nvec2 project_mercator_(vec2 lnglat) {\n  return vec2(\n    radians(lnglat.x) + PI,\n    PI - log(tan_fp32(PI * 0.25 + radians(lnglat.y) * 0.5))\n  );\n}\n\nvec2 project_position(vec2 position) {\n  if (projectionMode == PROJECT_IDENTITY) {\n    return position;\n  }\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\n    return position;\n    return project_scale(position);\n  }\n  // Covers projectionMode == PROJECT_MERCATOR\n  return project_mercator_(position) * WORLD_SCALE * projectionScale;\n}\n\nvec3 project_position(vec3 position) {\n  return vec3(project_position(position.xy), project_scale(position.z));\n}\n\nvec4 project_position(vec4 position) {\n  return vec4(project_position(position.xyz), position.w);\n}\n\n//\n\nvec4 project_to_viewspace(vec4 position) {\n  return modelViewMatrix * position;\n}\n\nvec4 project_to_clipspace(vec4 position) {\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\n    position = position * projectionPixelsPerUnit.x;\n  }\n  return projectionMatrix * position + projectionCenter;\n}\n\n// Backwards compatibility\n\nfloat scale(float position) {\n  return project_scale(position);\n}\n\nvec2 scale(vec2 position) {\n  return project_scale(position);\n}\n\nvec3 scale(vec3 position) {\n  return project_scale(position);\n}\n\nvec4 scale(vec4 position) {\n  return project_scale(position);\n}\n\nvec2 preproject(vec2 position) {\n  return project_position(position);\n}\n\nvec3 preproject(vec3 position) {\n  return project_position(position);\n}\n\nvec4 preproject(vec4 position) {\n  return project_position(position);\n}\n\nvec4 project(vec4 position) {\n  return project_to_clipspace(position);\n}\n";
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zaGFkZXJsaWIvcHJvamVjdC9wcm9qZWN0Lmdsc2wuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJwcm9qZWN0Lmdsc2wuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTYgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbmNvbnN0IGZsb2F0IFRJTEVfU0laRSA9IDUxMi4wO1xuY29uc3QgZmxvYXQgUEkgPSAzLjE0MTU5MjY1MzY7XG5jb25zdCBmbG9hdCBXT1JMRF9TQ0FMRSA9IFRJTEVfU0laRSAvIChQSSAqIDIuMCk7XG5cbi8vIHJlZjogbGliL2NvbnN0YW50cy5qc1xuY29uc3QgZmxvYXQgUFJPSkVDVF9JREVOVElUWSA9IDAuO1xuY29uc3QgZmxvYXQgUFJPSkVDVF9NRVJDQVRPUiA9IDEuO1xuY29uc3QgZmxvYXQgUFJPSkVDVF9NRVJDQVRPUl9PRkZTRVRTID0gMi47XG5cbnVuaWZvcm0gZmxvYXQgcHJvamVjdGlvbk1vZGU7XG51bmlmb3JtIGZsb2F0IHByb2plY3Rpb25TY2FsZTtcbnVuaWZvcm0gdmVjNCBwcm9qZWN0aW9uQ2VudGVyO1xudW5pZm9ybSB2ZWMzIHByb2plY3Rpb25QaXhlbHNQZXJVbml0O1xuXG51bmlmb3JtIG1hdDQgbW9kZWxWaWV3TWF0cml4O1xudW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7XG51bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeFVuY2VudGVyZWQ7XG5cbiNpZmRlZiBJTlRFTF9UQU5fV09SS0FST1VORFxuXG4vLyBBbGwgdGhlc2UgZnVuY3Rpb25zIGFyZSBmb3Igc3Vic3RpdHV0aW5nIHRhbigpIGZ1bmN0aW9uIGZyb20gSW50ZWwgR1BVIG9ubHlcbmNvbnN0IGZsb2F0IFRXT19QSSA9IDYuMjgzMTg1NDgyMDI1MTQ2NTtcbmNvbnN0IGZsb2F0IFBJXzIgPSAxLjU3MDc5NjM3MDUwNjI4NjY7XG5jb25zdCBmbG9hdCBQSV8xNiA9IDAuMTk2MzQ5NTQ2MzEzMjg1ODtcblxuY29uc3QgZmxvYXQgU0lOX1RBQkxFXzAgPSAwLjE5NTA5MDMyMzY4NjU5OTczO1xuY29uc3QgZmxvYXQgU0lOX1RBQkxFXzEgPSAwLjM4MjY4MzQyNjE0MTczODk7XG5jb25zdCBmbG9hdCBTSU5fVEFCTEVfMiA9IDAuNTU1NTcwMjQ0Nzg5MTIzNTtcbmNvbnN0IGZsb2F0IFNJTl9UQUJMRV8zID0gMC43MDcxMDY3NjkwODQ5MzA0O1xuXG5jb25zdCBmbG9hdCBDT1NfVEFCTEVfMCA9IDAuOTgwNzg1MjUwNjYzNzU3MztcbmNvbnN0IGZsb2F0IENPU19UQUJMRV8xID0gMC45MjM4Nzk1MDQyMDM3OTY0O1xuY29uc3QgZmxvYXQgQ09TX1RBQkxFXzIgPSAwLjgzMTQ2OTU5NTQzMjI4MTU7XG5jb25zdCBmbG9hdCBDT1NfVEFCTEVfMyA9IDAuNzA3MTA2NzY5MDg0OTMwNDtcblxuY29uc3QgZmxvYXQgSU5WRVJTRV9GQUNUT1JJQUxfMyA9IDEuNjY2NjY2NzE2MzM3MjA0ZS0wMTsgLy8gMS8zIVxuY29uc3QgZmxvYXQgSU5WRVJTRV9GQUNUT1JJQUxfNSA9IDguMzMzMzMzNzY3OTUwNTM1ZS0wMzsgLy8gMS81IVxuY29uc3QgZmxvYXQgSU5WRVJTRV9GQUNUT1JJQUxfNyA9IDEuOTg0MTI3MDExMzgyOTUyM2UtMDQ7IC8vIDEvNyFcbmNvbnN0IGZsb2F0IElOVkVSU0VfRkFDVE9SSUFMXzkgPSAyLjc1NTczMTg4NDQ2Mjg3NTMzZS0wNjsgLy8gMS85IVxuXG5mbG9hdCBzaW5fdGF5bG9yX2ZwMzIoZmxvYXQgYSkge1xuICBmbG9hdCByLCBzLCB0LCB4O1xuXG4gIGlmIChhID09IDAuMCkge1xuICAgIHJldHVybiAwLjA7XG4gIH1cblxuICB4ID0gLWEgKiBhO1xuICBzID0gYTtcbiAgciA9IGE7XG5cbiAgciA9IHIgKiB4O1xuICB0ID0gciAqIElOVkVSU0VfRkFDVE9SSUFMXzM7XG4gIHMgPSBzICsgdDtcblxuICByID0gciAqIHg7XG4gIHQgPSByICogSU5WRVJTRV9GQUNUT1JJQUxfNTtcbiAgcyA9IHMgKyB0O1xuXG4gIHIgPSByICogeDtcbiAgdCA9IHIgKiBJTlZFUlNFX0ZBQ1RPUklBTF83O1xuICBzID0gcyArIHQ7XG5cbiAgciA9IHIgKiB4O1xuICB0ID0gciAqIElOVkVSU0VfRkFDVE9SSUFMXzk7XG4gIHMgPSBzICsgdDtcblxuICByZXR1cm4gcztcbn1cblxudm9pZCBzaW5jb3NfdGF5bG9yX2ZwMzIoZmxvYXQgYSwgb3V0IGZsb2F0IHNpbl90LCBvdXQgZmxvYXQgY29zX3QpIHtcbiAgaWYgKGEgPT0gMC4wKSB7XG4gICAgc2luX3QgPSAwLjA7XG4gICAgY29zX3QgPSAxLjA7XG4gIH1cbiAgc2luX3QgPSBzaW5fdGF5bG9yX2ZwMzIoYSk7XG4gIGNvc190ID0gc3FydCgxLjAgLSBzaW5fdCAqIHNpbl90KTtcbn1cblxuZmxvYXQgdGFuX3RheWxvcl9mcDMyKGZsb2F0IGEpIHtcbiAgICBmbG9hdCBzaW5fYTtcbiAgICBmbG9hdCBjb3NfYTtcblxuICAgIGlmIChhID09IDAuMCkge1xuICAgICAgICByZXR1cm4gMC4wO1xuICAgIH1cblxuICAgIC8vIDJwaSByYW5nZSByZWR1Y3Rpb25cbiAgICBmbG9hdCB6ID0gZmxvb3IoYSAvIFRXT19QSSk7XG4gICAgZmxvYXQgciA9IGEgLSBUV09fUEkgKiB6O1xuXG4gICAgZmxvYXQgdDtcbiAgICBmbG9hdCBxID0gZmxvb3IociAvIFBJXzIgKyAwLjUpO1xuICAgIGludCBqID0gaW50KHEpO1xuXG4gICAgaWYgKGogPCAtMiB8fCBqID4gMikge1xuICAgICAgICByZXR1cm4gMC4wIC8gMC4wO1xuICAgIH1cblxuICAgIHQgPSByIC0gUElfMiAqIHE7XG5cbiAgICBxID0gZmxvb3IodCAvIFBJXzE2ICsgMC41KTtcbiAgICBpbnQgayA9IGludChxKTtcbiAgICBpbnQgYWJzX2sgPSBpbnQoYWJzKGZsb2F0KGspKSk7XG5cbiAgICBpZiAoYWJzX2sgPiA0KSB7XG4gICAgICAgIHJldHVybiAwLjAgLyAwLjA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdCA9IHQgLSBQSV8xNiAqIHE7XG4gICAgfVxuXG4gICAgZmxvYXQgdSA9IDAuMDtcbiAgICBmbG9hdCB2ID0gMC4wO1xuXG4gICAgZmxvYXQgc2luX3QsIGNvc190O1xuICAgIGZsb2F0IHMsIGM7XG4gICAgc2luY29zX3RheWxvcl9mcDMyKHQsIHNpbl90LCBjb3NfdCk7XG5cbiAgICBpZiAoayA9PSAwKSB7XG4gICAgICAgIHMgPSBzaW5fdDtcbiAgICAgICAgYyA9IGNvc190O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gMS4wKSA8IDAuNSkge1xuICAgICAgICAgICAgdSA9IENPU19UQUJMRV8wO1xuICAgICAgICAgICAgdiA9IFNJTl9UQUJMRV8wO1xuICAgICAgICB9IGVsc2UgaWYgKGFicyhmbG9hdChhYnNfaykgLSAyLjApIDwgMC41KSB7XG4gICAgICAgICAgICB1ID0gQ09TX1RBQkxFXzE7XG4gICAgICAgICAgICB2ID0gU0lOX1RBQkxFXzE7XG4gICAgICAgIH0gZWxzZSBpZiAoYWJzKGZsb2F0KGFic19rKSAtIDMuMCkgPCAwLjUpIHtcbiAgICAgICAgICAgIHUgPSBDT1NfVEFCTEVfMjtcbiAgICAgICAgICAgIHYgPSBTSU5fVEFCTEVfMjtcbiAgICAgICAgfSBlbHNlIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gNC4wKSA8IDAuNSkge1xuICAgICAgICAgICAgdSA9IENPU19UQUJMRV8zO1xuICAgICAgICAgICAgdiA9IFNJTl9UQUJMRV8zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrID4gMCkge1xuICAgICAgICAgICAgcyA9IHUgKiBzaW5fdCArIHYgKiBjb3NfdDtcbiAgICAgICAgICAgIGMgPSB1ICogY29zX3QgLSB2ICogc2luX3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzID0gdSAqIHNpbl90IC0gdiAqIGNvc190O1xuICAgICAgICAgICAgYyA9IHUgKiBjb3NfdCArIHYgKiBzaW5fdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChqID09IDApIHtcbiAgICAgICAgc2luX2EgPSBzO1xuICAgICAgICBjb3NfYSA9IGM7XG4gICAgfSBlbHNlIGlmIChqID09IDEpIHtcbiAgICAgICAgc2luX2EgPSBjO1xuICAgICAgICBjb3NfYSA9IC1zO1xuICAgIH0gZWxzZSBpZiAoaiA9PSAtMSkge1xuICAgICAgICBzaW5fYSA9IC1jO1xuICAgICAgICBjb3NfYSA9IHM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2luX2EgPSAtcztcbiAgICAgICAgY29zX2EgPSAtYztcbiAgICB9XG4gICAgcmV0dXJuIHNpbl9hIC8gY29zX2E7XG59XG4jZW5kaWZcblxuZmxvYXQgdGFuX2ZwMzIoZmxvYXQgYSkge1xuI2lmZGVmIElOVEVMX1RBTl9XT1JLQVJPVU5EXG4gIHJldHVybiB0YW5fdGF5bG9yX2ZwMzIoYSk7XG4jZWxzZVxuICByZXR1cm4gdGFuKGEpO1xuI2VuZGlmXG59XG5cbi8vXG4vLyBTY2FsaW5nIG9mZnNldHNcbi8vXG5cbmZsb2F0IHByb2plY3Rfc2NhbGUoZmxvYXQgbWV0ZXJzKSB7XG4gIGlmIChwcm9qZWN0aW9uTW9kZSA9PSBQUk9KRUNUX01FUkNBVE9SX09GRlNFVFMpIHtcbiAgICByZXR1cm4gbWV0ZXJzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBtZXRlcnMgKiBwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdC54O1xuICB9XG59XG5cbnZlYzIgcHJvamVjdF9zY2FsZSh2ZWMyIG1ldGVycykge1xuICBpZiAocHJvamVjdGlvbk1vZGUgPT0gUFJPSkVDVF9NRVJDQVRPUl9PRkZTRVRTKSB7XG4gICAgcmV0dXJuIG1ldGVycztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmVjMihcbiAgICAgIG1ldGVycy54ICogcHJvamVjdGlvblBpeGVsc1BlclVuaXQueCxcbiAgICAgIG1ldGVycy55ICogcHJvamVjdGlvblBpeGVsc1BlclVuaXQueFxuICAgICk7XG4gIH1cbn1cblxudmVjMyBwcm9qZWN0X3NjYWxlKHZlYzMgbWV0ZXJzKSB7XG4gIGlmIChwcm9qZWN0aW9uTW9kZSA9PSBQUk9KRUNUX01FUkNBVE9SX09GRlNFVFMpIHtcbiAgICByZXR1cm4gbWV0ZXJzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2ZWMzKFxuICAgICAgbWV0ZXJzLnggKiBwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdC54LFxuICAgICAgbWV0ZXJzLnkgKiBwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdC54LFxuICAgICAgbWV0ZXJzLnogKiBwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdC54XG4gICAgKTtcbiAgfVxufVxuXG52ZWM0IHByb2plY3Rfc2NhbGUodmVjNCBtZXRlcnMpIHtcbiAgaWYgKHByb2plY3Rpb25Nb2RlID09IFBST0pFQ1RfTUVSQ0FUT1JfT0ZGU0VUUykge1xuICAgIHJldHVybiBtZXRlcnM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZlYzQoXG4gICAgICBtZXRlcnMueCAqIHByb2plY3Rpb25QaXhlbHNQZXJVbml0LngsXG4gICAgICBtZXRlcnMueSAqIHByb2plY3Rpb25QaXhlbHNQZXJVbml0LngsXG4gICAgICBtZXRlcnMueiAqIHByb2plY3Rpb25QaXhlbHNQZXJVbml0LngsXG4gICAgICBtZXRlcnMud1xuICAgICk7XG4gIH1cbn1cblxuLy9cbi8vIFByb2plY3RpbmcgcG9zaXRpb25zXG4vL1xuXG4vLyBub24tbGluZWFyIHByb2plY3Rpb246IGxuZ2xhdHMgPT4gdW5pdCB0aWxlIFswLTEsIDAtMV1cbnZlYzIgcHJvamVjdF9tZXJjYXRvcl8odmVjMiBsbmdsYXQpIHtcbiAgcmV0dXJuIHZlYzIoXG4gICAgcmFkaWFucyhsbmdsYXQueCkgKyBQSSxcbiAgICBQSSAtIGxvZyh0YW5fZnAzMihQSSAqIDAuMjUgKyByYWRpYW5zKGxuZ2xhdC55KSAqIDAuNSkpXG4gICk7XG59XG5cbnZlYzIgcHJvamVjdF9wb3NpdGlvbih2ZWMyIHBvc2l0aW9uKSB7XG4gIGlmIChwcm9qZWN0aW9uTW9kZSA9PSBQUk9KRUNUX0lERU5USVRZKSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9XG4gIGlmIChwcm9qZWN0aW9uTW9kZSA9PSBQUk9KRUNUX01FUkNBVE9SX09GRlNFVFMpIHtcbiAgICByZXR1cm4gcG9zaXRpb247XG4gICAgcmV0dXJuIHByb2plY3Rfc2NhbGUocG9zaXRpb24pO1xuICB9XG4gIC8vIENvdmVycyBwcm9qZWN0aW9uTW9kZSA9PSBQUk9KRUNUX01FUkNBVE9SXG4gIHJldHVybiBwcm9qZWN0X21lcmNhdG9yXyhwb3NpdGlvbikgKiBXT1JMRF9TQ0FMRSAqIHByb2plY3Rpb25TY2FsZTtcbn1cblxudmVjMyBwcm9qZWN0X3Bvc2l0aW9uKHZlYzMgcG9zaXRpb24pIHtcbiAgcmV0dXJuIHZlYzMocHJvamVjdF9wb3NpdGlvbihwb3NpdGlvbi54eSksIHByb2plY3Rfc2NhbGUocG9zaXRpb24ueikpO1xufVxuXG52ZWM0IHByb2plY3RfcG9zaXRpb24odmVjNCBwb3NpdGlvbikge1xuICByZXR1cm4gdmVjNChwcm9qZWN0X3Bvc2l0aW9uKHBvc2l0aW9uLnh5eiksIHBvc2l0aW9uLncpO1xufVxuXG4vL1xuXG52ZWM0IHByb2plY3RfdG9fdmlld3NwYWNlKHZlYzQgcG9zaXRpb24pIHtcbiAgcmV0dXJuIG1vZGVsVmlld01hdHJpeCAqIHBvc2l0aW9uO1xufVxuXG52ZWM0IHByb2plY3RfdG9fY2xpcHNwYWNlKHZlYzQgcG9zaXRpb24pIHtcbiAgaWYgKHByb2plY3Rpb25Nb2RlID09IFBST0pFQ1RfTUVSQ0FUT1JfT0ZGU0VUUykge1xuICAgIHBvc2l0aW9uID0gcG9zaXRpb24gKiBwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdC54O1xuICB9XG4gIHJldHVybiBwcm9qZWN0aW9uTWF0cml4ICogcG9zaXRpb24gKyBwcm9qZWN0aW9uQ2VudGVyO1xufVxuXG4vLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXG5mbG9hdCBzY2FsZShmbG9hdCBwb3NpdGlvbikge1xuICByZXR1cm4gcHJvamVjdF9zY2FsZShwb3NpdGlvbik7XG59XG5cbnZlYzIgc2NhbGUodmVjMiBwb3NpdGlvbikge1xuICByZXR1cm4gcHJvamVjdF9zY2FsZShwb3NpdGlvbik7XG59XG5cbnZlYzMgc2NhbGUodmVjMyBwb3NpdGlvbikge1xuICByZXR1cm4gcHJvamVjdF9zY2FsZShwb3NpdGlvbik7XG59XG5cbnZlYzQgc2NhbGUodmVjNCBwb3NpdGlvbikge1xuICByZXR1cm4gcHJvamVjdF9zY2FsZShwb3NpdGlvbik7XG59XG5cbnZlYzIgcHJlcHJvamVjdCh2ZWMyIHBvc2l0aW9uKSB7XG4gIHJldHVybiBwcm9qZWN0X3Bvc2l0aW9uKHBvc2l0aW9uKTtcbn1cblxudmVjMyBwcmVwcm9qZWN0KHZlYzMgcG9zaXRpb24pIHtcbiAgcmV0dXJuIHByb2plY3RfcG9zaXRpb24ocG9zaXRpb24pO1xufVxuXG52ZWM0IHByZXByb2plY3QodmVjNCBwb3NpdGlvbikge1xuICByZXR1cm4gcHJvamVjdF9wb3NpdGlvbihwb3NpdGlvbik7XG59XG5cbnZlYzQgcHJvamVjdCh2ZWM0IHBvc2l0aW9uKSB7XG4gIHJldHVybiBwcm9qZWN0X3RvX2NsaXBzcGFjZShwb3NpdGlvbik7XG59XG5gO1xuIl19