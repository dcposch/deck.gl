'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pointToDensityGridData = pointToDensityGridData;
var R_EARTH = 6378000;

/**
 * Calculate density grid from an array of points
 * @param {array} points
 * @param {number} worldUnitSize - unit size in meters
 * @param {function} getPosition - position accessor
 * @returns {object} - grid data, cell dimension and count range
 */
function pointToDensityGridData(points, worldUnitSize, getPosition) {
  var _pointsToGridHashing2 = _pointsToGridHashing(points, worldUnitSize, getPosition),
      gridHash = _pointsToGridHashing2.gridHash,
      gridOffset = _pointsToGridHashing2.gridOffset;

  var layerData = _getGridLayerDataFromGridHash(gridHash, gridOffset);
  var countRange = _getCellCountExtent(layerData);

  return {
    gridOffset: gridOffset,
    layerData: layerData,
    countRange: countRange
  };
}

/**
 * Project points into each cell, return a hash table of cells
 * @param {array} points
 * @param {number} worldUnitSize - unit size in meters
 * @param {function} getPosition - position accessor
 * @returns {object} - grid hash and cell dimension
 */
function _pointsToGridHashing(points, worldUnitSize, getPosition) {

  // find the geometric center of sample points
  var allLat = points.map(function (p) {
    return getPosition(p)[1];
  });
  var latMin = Math.min.apply(null, allLat);
  var latMax = Math.max.apply(null, allLat);

  var centerLat = (latMin + latMax) / 2;

  var gridOffset = _calculateGridLatLonOffset(worldUnitSize, centerLat);

  if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {
    return { gridHash: {}, gridOffset: gridOffset };
  }
  // calculate count per cell
  var gridHash = points.reduce(function (accu, pt) {
    var latIdx = Math.floor((getPosition(pt)[1] + 90) / gridOffset.yOffset);
    var lonIdx = Math.floor((getPosition(pt)[0] + 180) / gridOffset.xOffset);
    var key = latIdx + '-' + lonIdx;

    accu[key] = accu[key] || { count: 0, points: [] };
    accu[key].count += 1;
    accu[key].points.push(pt);

    return accu;
  }, {});

  return { gridHash: gridHash, gridOffset: gridOffset };
}

function _getGridLayerDataFromGridHash(gridHash, gridOffset) {
  return Object.keys(gridHash).reduce(function (accu, key, i) {
    var idxs = key.split('-');
    var latIdx = parseInt(idxs[0], 10);
    var lonIdx = parseInt(idxs[1], 10);

    accu.push(Object.assign({
      index: i,
      position: [-180 + gridOffset.xOffset * lonIdx, -90 + gridOffset.yOffset * latIdx]
    }, gridHash[key]));

    return accu;
  }, []);
}

function _getCellCountExtent(data) {
  return data.length ? [Math.min.apply(null, data.map(function (d) {
    return d.count;
  })), Math.max.apply(null, data.map(function (d) {
    return d.count;
  }))] : [0, 1];
}

/**
 * calculate grid layer cell size in lat lon based on world unit size
 * and current latitude
 * @param {number} worldUnitSize
 * @param {number} latitude
 * @returns {object} - lat delta and lon delta
 */
function _calculateGridLatLonOffset(worldUnitSize, latitude) {
  var yOffset = _calculateLatOffset(worldUnitSize);
  var xOffset = _calculateLonOffset(latitude, worldUnitSize);
  return { yOffset: yOffset, xOffset: xOffset };
}

/**
 * with a given x-km change, calculate the increment of latitude
 * based on stackoverflow http://stackoverflow.com/questions/7477003
 * @param {number} dy - change in km
 * @return {number} - increment in latitude
 */
function _calculateLatOffset(dy) {
  return dy / R_EARTH * (180 / Math.PI);
}

/**
 * with a given x-km change, and current latitude
 * calculate the increment of longitude
 * based on stackoverflow http://stackoverflow.com/questions/7477003
 * @param {number} lat - latitude of current location (based on city)
 * @param {number} dx - change in km
 * @return {number} - increment in longitude
 */
function _calculateLonOffset(lat, dx) {
  return dx / R_EARTH * (180 / Math.PI) / Math.cos(lat * Math.PI / 180);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9ncmlkLWxheWVyL2dyaWQtYWdncmVnYXRvci5qcyJdLCJuYW1lcyI6WyJwb2ludFRvRGVuc2l0eUdyaWREYXRhIiwiUl9FQVJUSCIsInBvaW50cyIsIndvcmxkVW5pdFNpemUiLCJnZXRQb3NpdGlvbiIsIl9wb2ludHNUb0dyaWRIYXNoaW5nIiwiZ3JpZEhhc2giLCJncmlkT2Zmc2V0IiwibGF5ZXJEYXRhIiwiX2dldEdyaWRMYXllckRhdGFGcm9tR3JpZEhhc2giLCJjb3VudFJhbmdlIiwiX2dldENlbGxDb3VudEV4dGVudCIsImFsbExhdCIsIm1hcCIsInAiLCJsYXRNaW4iLCJNYXRoIiwibWluIiwiYXBwbHkiLCJsYXRNYXgiLCJtYXgiLCJjZW50ZXJMYXQiLCJfY2FsY3VsYXRlR3JpZExhdExvbk9mZnNldCIsInhPZmZzZXQiLCJ5T2Zmc2V0IiwicmVkdWNlIiwiYWNjdSIsInB0IiwibGF0SWR4IiwiZmxvb3IiLCJsb25JZHgiLCJrZXkiLCJjb3VudCIsInB1c2giLCJPYmplY3QiLCJrZXlzIiwiaSIsImlkeHMiLCJzcGxpdCIsInBhcnNlSW50IiwiYXNzaWduIiwiaW5kZXgiLCJwb3NpdGlvbiIsImRhdGEiLCJsZW5ndGgiLCJkIiwibGF0aXR1ZGUiLCJfY2FsY3VsYXRlTGF0T2Zmc2V0IiwiX2NhbGN1bGF0ZUxvbk9mZnNldCIsImR5IiwiUEkiLCJsYXQiLCJkeCIsImNvcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7UUFTZ0JBLHNCLEdBQUFBLHNCO0FBVGhCLElBQU1DLFVBQVUsT0FBaEI7O0FBRUE7Ozs7Ozs7QUFPTyxTQUFTRCxzQkFBVCxDQUFnQ0UsTUFBaEMsRUFBd0NDLGFBQXhDLEVBQXVEQyxXQUF2RCxFQUFvRTtBQUFBLDhCQUUxQ0MscUJBQXFCSCxNQUFyQixFQUE2QkMsYUFBN0IsRUFBNENDLFdBQTVDLENBRjBDO0FBQUEsTUFFbEVFLFFBRmtFLHlCQUVsRUEsUUFGa0U7QUFBQSxNQUV4REMs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LENBQVA7QUFlRDs7QUFFRCxTQUFTZixtQkFBVCxDQUE2QmdDLElBQTdCLEVBQW1DO0FBQ2pDLFNBQU9BLEtBQUtDLE1BQUwsR0FBYyxDQUNuQjVCLEtBQUtDLEdBQUwsQ0FBU0MsS0FBVCxDQUFlLElBQWYsRUFBcUJ5QixLQUFLOUIsR0FBTCxDQUFTO0FBQUEsV0FBS2dDLEVBQUViLEtBQVA7QUFBQSxHQUFULENBQXJCLENBRG1CLEVBRW5CaEIsS0FBS0ksR0FBTCxDQUFTRixLQUFULENBQWUsSUFBZixFQUFxQnlCLEtBQUs5QixHQUFMLENBQVM7QUFBQSxXQUFLZ0MsRUFBRWIsS0FBUDtBQUFBLEdBQVQsQ0FBckIsQ0FGbUIsQ0FBZCxHQUdILENBQUMsQ0FBRCxFQUFJLENBQUosQ0FISjtBQUlEOztBQUVEOzs7Ozs7O0FBT0EsU0FBU1YsMEJBQVQsQ0FBb0NuQixhQUFwQyxFQUFtRDJDLFFBQW5ELEVBQTZEO0FBQzNELE1BQU10QixVQUFVdUIsb0JBQW9CNUMsYUFBcEIsQ0FBaEI7QUFDQSxNQUFNb0IsVUFBVXlCLG9CQUFvQkYsUUFBcEIsRUFBOEIzQyxhQUE5QixDQUFoQjtBQUNBLFNBQU8sRUFBQ3FCLGdCQUFELEVBQVVELGdCQUFWLEVBQVA7QUFDRDs7QUFFRDs7Ozs7O0FBTUEsU0FBU3dCLG1CQUFULENBQTZCRSxFQUE3QixFQUFpQztBQUMvQixTQUFRQSxLQUFLaEQsT0FBTixJQUFrQixNQUFNZSxLQUFLa0MsRUFBN0IsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7OztBQVFBLFNBQVNGLG1CQUFULENBQTZCRyxHQUE3QixFQUFrQ0MsRUFBbEMsRUFBc0M7QUFDcEMsU0FBUUEsS0FBS25ELE9BQU4sSUFBa0IsTUFBTWUsS0FBS2tDLEVBQTdCLElBQW1DbEMsS0FBS3FDLEdBQUwsQ0FBU0YsTUFBTW5DLEtBQUtrQyxFQUFYLEdBQWdCLEdBQXpCLENBQTFDO0FBQ0QiLCJmaWxlIjoiZ3JpZC1hZ2dyZWdhdG9yLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgUl9FQVJUSCA9IDYzNzgwMDA7XG5cbi8qKlxuICogQ2FsY3VsYXRlIGRlbnNpdHkgZ3JpZCBmcm9tIGFuIGFycmF5IG9mIHBvaW50c1xuICogQHBhcmFtIHthcnJheX0gcG9pbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gd29ybGRVbml0U2l6ZSAtIHVuaXQgc2l6ZSBpbiBtZXRlcnNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGdldFBvc2l0aW9uIC0gcG9zaXRpb24gYWNjZXNzb3JcbiAqIEByZXR1cm5zIHtvYmplY3R9IC0gZ3JpZCBkYXRhLCBjZWxsIGRpbWVuc2lvbiBhbmQgY291bnQgcmFuZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvaW50VG9EZW5zaXR5R3JpZERhdGEocG9pbnRzLCB3b3JsZFVuaXRTaXplLCBnZXRQb3NpdGlvbikge1xuXG4gIGNvbnN0IHtncmlkSGFzaCwgZ3JpZE9mZnNldH0gPSBfcG9pbnRzVG9HcmlkSGFzaGluZyhwb2ludHMsIHdvcmxkVW5pdFNpemUsIGdldFBvc2l0aW9uKTtcbiAgY29uc3QgbGF5ZXJEYXRhID0gX2dldEdyaWRMYXllckRhdGFGcm9tR3JpZEhhc2goZ3JpZEhhc2gsIGdyaWRPZmZzZXQpO1xuICBjb25zdCBjb3VudFJhbmdlID0gX2dldENlbGxDb3VudEV4dGVudChsYXllckRhdGEpO1xuXG4gIHJldHVybiB7XG4gICAgZ3JpZE9mZnNldCxcbiAgICBsYXllckRhdGEsXG4gICAgY291bnRSYW5nZVxuICB9O1xufVxuXG4vKipcbiAqIFByb2plY3QgcG9pbnRzIGludG8gZWFjaCBjZWxsLCByZXR1cm4gYSBoYXNoIHRhYmxlIG9mIGNlbGxzXG4gKiBAcGFyYW0ge2FycmF5fSBwb2ludHNcbiAqIEBwYXJhbSB7bnVtYmVyfSB3b3JsZFVuaXRTaXplIC0gdW5pdCBzaXplIGluIG1ldGVyc1xuICogQHBhcmFtIHtmdW5jdGlvbn0gZ2V0UG9zaXRpb24gLSBwb3NpdGlvbiBhY2Nlc3NvclxuICogQHJldHVybnMge29iamVjdH0gLSBncmlkIGhhc2ggYW5kIGNlbGwgZGltZW5zaW9uXG4gKi9cbmZ1bmN0aW9uIF9wb2ludHNUb0dyaWRIYXNoaW5nKHBvaW50cywgd29ybGRVbml0U2l6ZSwgZ2V0UG9zaXRpb24pIHtcblxuICAvLyBmaW5kIHRoZSBnZW9tZXRyaWMgY2VudGVyIG9mIHNhbXBsZSBwb2ludHNcbiAgY29uc3QgYWxsTGF0ID0gcG9pbnRzLm1hcChwID0+IGdldFBvc2l0aW9uKHApWzFdKTtcbiAgY29uc3QgbGF0TWluID0gTWF0aC5taW4uYXBwbHkobnVsbCwgYWxsTGF0KTtcbiAgY29uc3QgbGF0TWF4ID0gTWF0aC5tYXguYXBwbHkobnVsbCwgYWxsTGF0KTtcblxuICBjb25zdCBjZW50ZXJMYXQgPSAobGF0TWluICsgbGF0TWF4KSAvIDI7XG5cbiAgY29uc3QgZ3JpZE9mZnNldCA9IF9jYWxjdWxhdGVHcmlkTGF0TG9uT2Zmc2V0KHdvcmxkVW5pdFNpemUsIGNlbnRlckxhdCk7XG5cbiAgaWYgKGdyaWRPZmZzZXQueE9mZnNldCA8PSAwIHx8IGdyaWRPZmZzZXQueU9mZnNldCA8PSAwKSB7XG4gICAgcmV0dXJuIHtncmlkSGFzaDoge30sIGdyaWRPZmZzZXR9O1xuICB9XG4gIC8vIGNhbGN1bGF0ZSBjb3VudCBwZXIgY2VsbFxuICBjb25zdCBncmlkSGFzaCA9IHBvaW50cy5yZWR1Y2UoKGFjY3UsIHB0KSA9PiB7XG4gICAgY29uc3QgbGF0SWR4ID0gTWF0aC5mbG9vcigoZ2V0UG9zaXRpb24ocHQpWzFdICsgOTApIC8gZ3JpZE9mZnNldC55T2Zmc2V0KTtcbiAgICBjb25zdCBsb25JZHggPSBNYXRoLmZsb29yKChnZXRQb3NpdGlvbihwdClbMF0gKyAxODApIC8gZ3JpZE9mZnNldC54T2Zmc2V0KTtcbiAgICBjb25zdCBrZXkgPSBgJHtsYXRJZHh9LSR7bG9uSWR4fWA7XG5cbiAgICBhY2N1W2tleV0gPSBhY2N1W2tleV0gfHwge2NvdW50OiAwLCBwb2ludHM6IFtdfTtcbiAgICBhY2N1W2tleV0uY291bnQgKz0gMTtcbiAgICBhY2N1W2tleV0ucG9pbnRzLnB1c2gocHQpO1xuXG4gICAgcmV0dXJuIGFjY3U7XG4gIH0sIHt9KTtcblxuICByZXR1cm4ge2dyaWRIYXNoLCBncmlkT2Zmc2V0fTtcbn1cblxuZnVuY3Rpb24gX2dldEdyaWRMYXllckRhdGFGcm9tR3JpZEhhc2goZ3JpZEhhc2gsIGdyaWRPZmZzZXQpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGdyaWRIYXNoKS5yZWR1Y2UoKGFjY3UsIGtleSwgaSkgPT4ge1xuICAgIGNvbnN0IGlkeHMgPSBrZXkuc3BsaXQoJy0nKTtcbiAgICBjb25zdCBsYXRJZHggPSBwYXJzZUludChpZHhzWzBdLCAxMCk7XG4gICAgY29uc3QgbG9uSWR4ID0gcGFyc2VJbnQoaWR4c1sxXSwgMTApO1xuXG4gICAgYWNjdS5wdXNoKE9iamVjdC5hc3NpZ24oe1xuICAgICAgaW5kZXg6IGksXG4gICAgICBwb3NpdGlvbjogW1xuICAgICAgICAtMTgwICsgZ3JpZE9mZnNldC54T2Zmc2V0ICogbG9uSWR4LFxuICAgICAgICAtOTAgKyBncmlkT2Zmc2V0LnlPZmZzZXQgKiBsYXRJZHhcbiAgICAgIF1cbiAgICB9LCBncmlkSGFzaFtrZXldKSk7XG5cbiAgICByZXR1cm4gYWNjdTtcbiAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiBfZ2V0Q2VsbENvdW50RXh0ZW50KGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEubGVuZ3RoID8gW1xuICAgIE1hdGgubWluLmFwcGx5KG51bGwsIGRhdGEubWFwKGQgPT4gZC5jb3VudCkpLFxuICAgIE1hdGgubWF4LmFwcGx5KG51bGwsIGRhdGEubWFwKGQgPT4gZC5jb3VudCkpXG4gIF0gOiBbMCwgMV07XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIGdyaWQgbGF5ZXIgY2VsbCBzaXplIGluIGxhdCBsb24gYmFzZWQgb24gd29ybGQgdW5pdCBzaXplXG4gKiBhbmQgY3VycmVudCBsYXRpdHVkZVxuICogQHBhcmFtIHtudW1iZXJ9IHdvcmxkVW5pdFNpemVcbiAqIEBwYXJhbSB7bnVtYmVyfSBsYXRpdHVkZVxuICogQHJldHVybnMge29iamVjdH0gLSBsYXQgZGVsdGEgYW5kIGxvbiBkZWx0YVxuICovXG5mdW5jdGlvbiBfY2FsY3VsYXRlR3JpZExhdExvbk9mZnNldCh3b3JsZFVuaXRTaXplLCBsYXRpdHVkZSkge1xuICBjb25zdCB5T2Zmc2V0ID0gX2NhbGN1bGF0ZUxhdE9mZnNldCh3b3JsZFVuaXRTaXplKTtcbiAgY29uc3QgeE9mZnNldCA9IF9jYWxjdWxhdGVMb25PZmZzZXQobGF0aXR1ZGUsIHdvcmxkVW5pdFNpemUpO1xuICByZXR1cm4ge3lPZmZzZXQsIHhPZmZzZXR9O1xufVxuXG4vKipcbiAqIHdpdGggYSBnaXZlbiB4LWttIGNoYW5nZSwgY2FsY3VsYXRlIHRoZSBpbmNyZW1lbnQgb2YgbGF0aXR1ZGVcbiAqIGJhc2VkIG9uIHN0YWNrb3ZlcmZsb3cgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83NDc3MDAzXG4gKiBAcGFyYW0ge251bWJlcn0gZHkgLSBjaGFuZ2UgaW4ga21cbiAqIEByZXR1cm4ge251bWJlcn0gLSBpbmNyZW1lbnQgaW4gbGF0aXR1ZGVcbiAqL1xuZnVuY3Rpb24gX2NhbGN1bGF0ZUxhdE9mZnNldChkeSkge1xuICByZXR1cm4gKGR5IC8gUl9FQVJUSCkgKiAoMTgwIC8gTWF0aC5QSSk7XG59XG5cbi8qKlxuICogd2l0aCBhIGdpdmVuIHgta20gY2hhbmdlLCBhbmQgY3VycmVudCBsYXRpdHVkZVxuICogY2FsY3VsYXRlIHRoZSBpbmNyZW1lbnQgb2YgbG9uZ2l0dWRlXG4gKiBiYXNlZCBvbiBzdGFja292ZXJmbG93IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzQ3NzAwM1xuICogQHBhcmFtIHtudW1iZXJ9IGxhdCAtIGxhdGl0dWRlIG9mIGN1cnJlbnQgbG9jYXRpb24gKGJhc2VkIG9uIGNpdHkpXG4gKiBAcGFyYW0ge251bWJlcn0gZHggLSBjaGFuZ2UgaW4ga21cbiAqIEByZXR1cm4ge251bWJlcn0gLSBpbmNyZW1lbnQgaW4gbG9uZ2l0dWRlXG4gKi9cbmZ1bmN0aW9uIF9jYWxjdWxhdGVMb25PZmZzZXQobGF0LCBkeCkge1xuICByZXR1cm4gKGR4IC8gUl9FQVJUSCkgKiAoMTgwIC8gTWF0aC5QSSkgLyBNYXRoLmNvcyhsYXQgKiBNYXRoLlBJIC8gMTgwKTtcbn1cbiJdfQ==