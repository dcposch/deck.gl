"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
// Copyright (c) 2016 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

exports.default = "\n#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec4 instanceStartEndPositions64xyLow;\nattribute vec3 instanceLeftDeltas;\nattribute vec3 instanceRightDeltas;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float miterLimit;\n\nuniform float opacity;\nuniform float renderPickingBuffer;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\n\nconst float EPSILON = 0.001;\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\nvec3 lineJoin(vec3 prevPoint, vec3 currPoint, vec3 nextPoint) {\n\n  float width = clamp(project_scale(instanceStrokeWidths * widthScale),\n    widthMinPixels, widthMaxPixels) / 2.0;\n\n  vec2 deltaA = currPoint.xy - prevPoint.xy;\n  vec2 deltaB = nextPoint.xy - currPoint.xy;\n\n  vec2 offsetVec;\n  float offsetScale;\n  float offsetDirection;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(1.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(1.0, 0.0);\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n\n  // tangent of the corner\n  vec2 tangent = vec2(dirA + dirB);\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  // direction of the corner\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  // width offset from current position\n  vec2 perp = mix(perpB, perpA, positions.x);\n  float L = mix(lenB, lenA, positions.x);\n\n  // cap super sharp angles\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n  bool turnsRight = dirA.x * dirB.y > dirA.y * dirB.x;\n\n  // relative position to the corner:\n  // -1: inside (smaller side of the angle)\n  // 0: center\n  // 1: outside (bigger side of the angle)\n  float cornerPosition = mix(\n    flipIfTrue(turnsRight == (positions.y > 0.0)),\n    0.0,\n    positions.z\n  );\n\n  offsetScale = 1.0 / max(sinHalfA, EPSILON);\n\n  // do not bevel if line segment is too short\n  cornerPosition *= float(cornerPosition <= 0.0 || sinHalfA < min(lenA, lenB) / width * cosHalfA);\n  // trim if inside corner extends further than the line segment\n  offsetScale = mix(\n    offsetScale,\n    min(offsetScale, L / width / max(cosHalfA, EPSILON)),\n    float(cornerPosition < 0.0)\n  );\n\n  vMiterLength = mix(\n    offsetScale * cornerPosition,\n    mix(offsetScale, 0.0, cornerPosition),\n    step(0.0, cornerPosition)\n  ) - sinHalfA * jointType;\n  offsetDirection = mix(\n    positions.y,\n    mix(\n      flipIfTrue(turnsRight),\n      positions.y * flipIfTrue(turnsRight == (positions.x == 1.)),\n      cornerPosition\n    ),\n    step(0.0, cornerPosition)\n  );\n  offsetVec = mix(miterVec, -tangent, step(0.5, cornerPosition));\n  offsetScale = mix(offsetScale, 1.0 / max(cosHalfA, 0.001), step(0.5, cornerPosition));\n\n  // special treatment for start cap and end cap\n  float isStartCap = step(0.0, -lenA);\n  float isEndCap = step(0.0, -lenB);\n  float isCap = max(isStartCap, isEndCap);\n\n  // 0: center, 1: side\n  cornerPosition = isCap * (1.0 - positions.z);\n\n  // start of path: use next - curr\n  offsetVec = mix(offsetVec, mix(dirB, perpB, cornerPosition), isStartCap);\n  // end of path: use curr - prev\n  offsetVec = mix(offsetVec, mix(dirA, perpA, cornerPosition), isEndCap);\n\n  // extend out a triangle to envelope the round cap\n  offsetScale = mix(\n    offsetScale,\n    mix(4.0 * jointType, 1.0, cornerPosition),\n    isCap\n  );\n  vMiterLength = mix(vMiterLength, 1.0 - cornerPosition, isCap);\n\n  offsetDirection = mix(\n    offsetDirection,\n    mix(flipIfTrue(isStartCap > 0.), positions.y, cornerPosition),\n    isCap\n  );\n\n  vCornerOffset = offsetVec * offsetDirection * offsetScale;\n\n  return vec3(vCornerOffset * width, 0.0);\n}\n\nvoid main() {\n  vec4 color = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  vec4 pickingColor = vec4(instancePickingColors, 255.) / 255.;\n  vColor = mix(color, pickingColor, renderPickingBuffer);\n\n  float isEnd = positions.x;\n\n  // Calculate previous position\n  vec3 prevPosition = mix(-instanceLeftDeltas, vec3(0.0), isEnd) + instanceStartPositions;\n  prevPosition = project_position(prevPosition);\n\n  // Calculate current position\n  // Only here we need to do the 64-bit calculations.\n\n  vec2 instanceStartPositions64[2];\n  instanceStartPositions64[0] = vec2(instanceStartPositions.x, instanceStartEndPositions64xyLow.x);\n  instanceStartPositions64[1] = vec2(instanceStartPositions.y, instanceStartEndPositions64xyLow.y);\n\n  vec2 instanceEndPositions64[2];\n  instanceEndPositions64[0] = vec2(instanceEndPositions.x, instanceStartEndPositions64xyLow.z);\n  instanceEndPositions64[1] = vec2(instanceEndPositions.y, instanceStartEndPositions64xyLow.w);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n\n  vec2 tempCurrPosition64[2];\n  vec2_mix_fp64(instanceStartPositions64, instanceEndPositions64, isEnd, tempCurrPosition64);\n\n  vec4 currPosition64 = vec4(tempCurrPosition64[0].xy, tempCurrPosition64[1].xy);\n\n  vec2 projected_curr_position[2];\n  project_position_fp64(currPosition64, projected_curr_position);\n  float projected_curr_position_z = project_scale(currPosition.z);\n\n  currPosition = project_position(currPosition);\n\n  // Calculate next positions\n  vec3 nextPosition = mix(vec3(0.0), instanceRightDeltas, isEnd) + instanceEndPositions;\n  nextPosition = project_position(nextPosition);\n\n  vec3 pos = lineJoin(prevPosition, currPosition, nextPosition);\n  vec2 vertex_pos_modelspace[4];\n  vertex_pos_modelspace[0] = sum_fp64(vec2(pos.x, 0.0), projected_curr_position[0]);\n  vertex_pos_modelspace[1] = sum_fp64(vec2(pos.y, 0.0), projected_curr_position[1]);\n  vertex_pos_modelspace[2] = vec2(pos.z + projected_curr_position_z, 0.0);\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\n\n  gl_Position = project_to_clipspace_fp64(vertex_pos_modelspace);\n}\n";
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9wYXRoLWxheWVyL3BhdGgtbGF5ZXItdmVydGV4LTY0Lmdsc2wuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJwYXRoLWxheWVyLXZlcnRleC02NC5nbHNsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE2IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuZXhwb3J0IGRlZmF1bHQgYFxcXG5cbiNkZWZpbmUgU0hBREVSX05BTUUgcGF0aC1sYXllci12ZXJ0ZXgtc2hhZGVyXG5cbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9ucztcblxuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VTdGFydFBvc2l0aW9ucztcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlRW5kUG9zaXRpb25zO1xuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VTdGFydEVuZFBvc2l0aW9uczY0eHlMb3c7XG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZUxlZnREZWx0YXM7XG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVJpZ2h0RGVsdGFzO1xuYXR0cmlidXRlIGZsb2F0IGluc3RhbmNlU3Ryb2tlV2lkdGhzO1xuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VDb2xvcnM7XG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBpY2tpbmdDb2xvcnM7XG5cbnVuaWZvcm0gZmxvYXQgd2lkdGhTY2FsZTtcbnVuaWZvcm0gZmxvYXQgd2lkdGhNaW5QaXhlbHM7XG51bmlmb3JtIGZsb2F0IHdpZHRoTWF4UGl4ZWxzO1xudW5pZm9ybSBmbG9hdCBqb2ludFR5cGU7XG51bmlmb3JtIGZsb2F0IG1pdGVyTGltaXQ7XG5cbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcbnVuaWZvcm0gZmxvYXQgcmVuZGVyUGlja2luZ0J1ZmZlcjtcblxudmFyeWluZyB2ZWM0IHZDb2xvcjtcbnZhcnlpbmcgdmVjMiB2Q29ybmVyT2Zmc2V0O1xudmFyeWluZyBmbG9hdCB2TWl0ZXJMZW5ndGg7XG5cbmNvbnN0IGZsb2F0IEVQU0lMT04gPSAwLjAwMTtcblxuZmxvYXQgZmxpcElmVHJ1ZShib29sIGZsYWcpIHtcbiAgcmV0dXJuIC0oZmxvYXQoZmxhZykgKiAyLiAtIDEuKTtcbn1cbnZlYzMgbGluZUpvaW4odmVjMyBwcmV2UG9pbnQsIHZlYzMgY3VyclBvaW50LCB2ZWMzIG5leHRQb2ludCkge1xuXG4gIGZsb2F0IHdpZHRoID0gY2xhbXAocHJvamVjdF9zY2FsZShpbnN0YW5jZVN0cm9rZVdpZHRocyAqIHdpZHRoU2NhbGUpLFxuICAgIHdpZHRoTWluUGl4ZWxzLCB3aWR0aE1heFBpeGVscykgLyAyLjA7XG5cbiAgdmVjMiBkZWx0YUEgPSBjdXJyUG9pbnQueHkgLSBwcmV2UG9pbnQueHk7XG4gIHZlYzIgZGVsdGFCID0gbmV4dFBvaW50Lnh5IC0gY3VyclBvaW50Lnh5O1xuXG4gIHZlYzIgb2Zmc2V0VmVjO1xuICBmbG9hdCBvZmZzZXRTY2FsZTtcbiAgZmxvYXQgb2Zmc2V0RGlyZWN0aW9uO1xuXG4gIGZsb2F0IGxlbkEgPSBsZW5ndGgoZGVsdGFBKTtcbiAgZmxvYXQgbGVuQiA9IGxlbmd0aChkZWx0YUIpO1xuICB2ZWMyIGRpckEgPSBsZW5BID4gMC4gPyBub3JtYWxpemUoZGVsdGFBKSA6IHZlYzIoMS4wLCAwLjApO1xuICB2ZWMyIGRpckIgPSBsZW5CID4gMC4gPyBub3JtYWxpemUoZGVsdGFCKSA6IHZlYzIoMS4wLCAwLjApO1xuICB2ZWMyIHBlcnBBID0gdmVjMigtZGlyQS55LCBkaXJBLngpO1xuICB2ZWMyIHBlcnBCID0gdmVjMigtZGlyQi55LCBkaXJCLngpO1xuXG4gIC8vIHRhbmdlbnQgb2YgdGhlIGNvcm5lclxuICB2ZWMyIHRhbmdlbnQgPSB2ZWMyKGRpckEgKyBkaXJCKTtcbiAgdGFuZ2VudCA9IGxlbmd0aCh0YW5nZW50KSA+IDAuID8gbm9ybWFsaXplKHRhbmdlbnQpIDogcGVycEE7XG4gIC8vIGRpcmVjdGlvbiBvZiB0aGUgY29ybmVyXG4gIHZlYzIgbWl0ZXJWZWMgPSB2ZWMyKC10YW5nZW50LnksIHRhbmdlbnQueCk7XG4gIC8vIHdpZHRoIG9mZnNldCBmcm9tIGN1cnJlbnQgcG9zaXRpb25cbiAgdmVjMiBwZXJwID0gbWl4KHBlcnBCLCBwZXJwQSwgcG9zaXRpb25zLngpO1xuICBmbG9hdCBMID0gbWl4KGxlbkIsIGxlbkEsIHBvc2l0aW9ucy54KTtcblxuICAvLyBjYXAgc3VwZXIgc2hhcnAgYW5nbGVzXG4gIGZsb2F0IHNpbkhhbGZBID0gYWJzKGRvdChtaXRlclZlYywgcGVycCkpO1xuICBmbG9hdCBjb3NIYWxmQSA9IGFicyhkb3QoZGlyQSwgbWl0ZXJWZWMpKTtcbiAgYm9vbCB0dXJuc1JpZ2h0ID0gZGlyQS54ICogZGlyQi55ID4gZGlyQS55ICogZGlyQi54O1xuXG4gIC8vIHJlbGF0aXZlIHBvc2l0aW9uIHRvIHRoZSBjb3JuZXI6XG4gIC8vIC0xOiBpbnNpZGUgKHNtYWxsZXIgc2lkZSBvZiB0aGUgYW5nbGUpXG4gIC8vIDA6IGNlbnRlclxuICAvLyAxOiBvdXRzaWRlIChiaWdnZXIgc2lkZSBvZiB0aGUgYW5nbGUpXG4gIGZsb2F0IGNvcm5lclBvc2l0aW9uID0gbWl4KFxuICAgIGZsaXBJZlRydWUodHVybnNSaWdodCA9PSAocG9zaXRpb25zLnkgPiAwLjApKSxcbiAgICAwLjAsXG4gICAgcG9zaXRpb25zLnpcbiAgKTtcblxuICBvZmZzZXRTY2FsZSA9IDEuMCAvIG1heChzaW5IYWxmQSwgRVBTSUxPTik7XG5cbiAgLy8gZG8gbm90IGJldmVsIGlmIGxpbmUgc2VnbWVudCBpcyB0b28gc2hvcnRcbiAgY29ybmVyUG9zaXRpb24gKj0gZmxvYXQoY29ybmVyUG9zaXRpb24gPD0gMC4wIHx8IHNpbkhhbGZBIDwgbWluKGxlbkEsIGxlbkIpIC8gd2lkdGggKiBjb3NIYWxmQSk7XG4gIC8vIHRyaW0gaWYgaW5zaWRlIGNvcm5lciBleHRlbmRzIGZ1cnRoZXIgdGhhbiB0aGUgbGluZSBzZWdtZW50XG4gIG9mZnNldFNjYWxlID0gbWl4KFxuICAgIG9mZnNldFNjYWxlLFxuICAgIG1pbihvZmZzZXRTY2FsZSwgTCAvIHdpZHRoIC8gbWF4KGNvc0hhbGZBLCBFUFNJTE9OKSksXG4gICAgZmxvYXQoY29ybmVyUG9zaXRpb24gPCAwLjApXG4gICk7XG5cbiAgdk1pdGVyTGVuZ3RoID0gbWl4KFxuICAgIG9mZnNldFNjYWxlICogY29ybmVyUG9zaXRpb24sXG4gICAgbWl4KG9mZnNldFNjYWxlLCAwLjAsIGNvcm5lclBvc2l0aW9uKSxcbiAgICBzdGVwKDAuMCwgY29ybmVyUG9zaXRpb24pXG4gICkgLSBzaW5IYWxmQSAqIGpvaW50VHlwZTtcbiAgb2Zmc2V0RGlyZWN0aW9uID0gbWl4KFxuICAgIHBvc2l0aW9ucy55LFxuICAgIG1peChcbiAgICAgIGZsaXBJZlRydWUodHVybnNSaWdodCksXG4gICAgICBwb3NpdGlvbnMueSAqIGZsaXBJZlRydWUodHVybnNSaWdodCA9PSAocG9zaXRpb25zLnggPT0gMS4pKSxcbiAgICAgIGNvcm5lclBvc2l0aW9uXG4gICAgKSxcbiAgICBzdGVwKDAuMCwgY29ybmVyUG9zaXRpb24pXG4gICk7XG4gIG9mZnNldFZlYyA9IG1peChtaXRlclZlYywgLXRhbmdlbnQsIHN0ZXAoMC41LCBjb3JuZXJQb3NpdGlvbikpO1xuICBvZmZzZXRTY2FsZSA9IG1peChvZmZzZXRTY2FsZSwgMS4wIC8gbWF4KGNvc0hhbGZBLCAwLjAwMSksIHN0ZXAoMC41LCBjb3JuZXJQb3NpdGlvbikpO1xuXG4gIC8vIHNwZWNpYWwgdHJlYXRtZW50IGZvciBzdGFydCBjYXAgYW5kIGVuZCBjYXBcbiAgZmxvYXQgaXNTdGFydENhcCA9IHN0ZXAoMC4wLCAtbGVuQSk7XG4gIGZsb2F0IGlzRW5kQ2FwID0gc3RlcCgwLjAsIC1sZW5CKTtcbiAgZmxvYXQgaXNDYXAgPSBtYXgoaXNTdGFydENhcCwgaXNFbmRDYXApO1xuXG4gIC8vIDA6IGNlbnRlciwgMTogc2lkZVxuICBjb3JuZXJQb3NpdGlvbiA9IGlzQ2FwICogKDEuMCAtIHBvc2l0aW9ucy56KTtcblxuICAvLyBzdGFydCBvZiBwYXRoOiB1c2UgbmV4dCAtIGN1cnJcbiAgb2Zmc2V0VmVjID0gbWl4KG9mZnNldFZlYywgbWl4KGRpckIsIHBlcnBCLCBjb3JuZXJQb3NpdGlvbiksIGlzU3RhcnRDYXApO1xuICAvLyBlbmQgb2YgcGF0aDogdXNlIGN1cnIgLSBwcmV2XG4gIG9mZnNldFZlYyA9IG1peChvZmZzZXRWZWMsIG1peChkaXJBLCBwZXJwQSwgY29ybmVyUG9zaXRpb24pLCBpc0VuZENhcCk7XG5cbiAgLy8gZXh0ZW5kIG91dCBhIHRyaWFuZ2xlIHRvIGVudmVsb3BlIHRoZSByb3VuZCBjYXBcbiAgb2Zmc2V0U2NhbGUgPSBtaXgoXG4gICAgb2Zmc2V0U2NhbGUsXG4gICAgbWl4KDQuMCAqIGpvaW50VHlwZSwgMS4wLCBjb3JuZXJQb3NpdGlvbiksXG4gICAgaXNDYXBcbiAgKTtcbiAgdk1pdGVyTGVuZ3RoID0gbWl4KHZNaXRlckxlbmd0aCwgMS4wIC0gY29ybmVyUG9zaXRpb24sIGlzQ2FwKTtcblxuICBvZmZzZXREaXJlY3Rpb24gPSBtaXgoXG4gICAgb2Zmc2V0RGlyZWN0aW9uLFxuICAgIG1peChmbGlwSWZUcnVlKGlzU3RhcnRDYXAgPiAwLiksIHBvc2l0aW9ucy55LCBjb3JuZXJQb3NpdGlvbiksXG4gICAgaXNDYXBcbiAgKTtcblxuICB2Q29ybmVyT2Zmc2V0ID0gb2Zmc2V0VmVjICogb2Zmc2V0RGlyZWN0aW9uICogb2Zmc2V0U2NhbGU7XG5cbiAgcmV0dXJuIHZlYzModkNvcm5lck9mZnNldCAqIHdpZHRoLCAwLjApO1xufVxuXG52b2lkIG1haW4oKSB7XG4gIHZlYzQgY29sb3IgPSB2ZWM0KGluc3RhbmNlQ29sb3JzLnJnYiwgaW5zdGFuY2VDb2xvcnMuYSAqIG9wYWNpdHkpIC8gMjU1LjtcbiAgdmVjNCBwaWNraW5nQ29sb3IgPSB2ZWM0KGluc3RhbmNlUGlja2luZ0NvbG9ycywgMjU1LikgLyAyNTUuO1xuICB2Q29sb3IgPSBtaXgoY29sb3IsIHBpY2tpbmdDb2xvciwgcmVuZGVyUGlja2luZ0J1ZmZlcik7XG5cbiAgZmxvYXQgaXNFbmQgPSBwb3NpdGlvbnMueDtcblxuICAvLyBDYWxjdWxhdGUgcHJldmlvdXMgcG9zaXRpb25cbiAgdmVjMyBwcmV2UG9zaXRpb24gPSBtaXgoLWluc3RhbmNlTGVmdERlbHRhcywgdmVjMygwLjApLCBpc0VuZCkgKyBpbnN0YW5jZVN0YXJ0UG9zaXRpb25zO1xuICBwcmV2UG9zaXRpb24gPSBwcm9qZWN0X3Bvc2l0aW9uKHByZXZQb3NpdGlvbik7XG5cbiAgLy8gQ2FsY3VsYXRlIGN1cnJlbnQgcG9zaXRpb25cbiAgLy8gT25seSBoZXJlIHdlIG5lZWQgdG8gZG8gdGhlIDY0LWJpdCBjYWxjdWxhdGlvbnMuXG5cbiAgdmVjMiBpbnN0YW5jZVN0YXJ0UG9zaXRpb25zNjRbMl07XG4gIGluc3RhbmNlU3RhcnRQb3NpdGlvbnM2NFswXSA9IHZlYzIoaW5zdGFuY2VTdGFydFBvc2l0aW9ucy54LCBpbnN0YW5jZVN0YXJ0RW5kUG9zaXRpb25zNjR4eUxvdy54KTtcbiAgaW5zdGFuY2VTdGFydFBvc2l0aW9uczY0WzFdID0gdmVjMihpbnN0YW5jZVN0YXJ0UG9zaXRpb25zLnksIGluc3RhbmNlU3RhcnRFbmRQb3NpdGlvbnM2NHh5TG93LnkpO1xuXG4gIHZlYzIgaW5zdGFuY2VFbmRQb3NpdGlvbnM2NFsyXTtcbiAgaW5zdGFuY2VFbmRQb3NpdGlvbnM2NFswXSA9IHZlYzIoaW5zdGFuY2VFbmRQb3NpdGlvbnMueCwgaW5zdGFuY2VTdGFydEVuZFBvc2l0aW9uczY0eHlMb3cueik7XG4gIGluc3RhbmNlRW5kUG9zaXRpb25zNjRbMV0gPSB2ZWMyKGluc3RhbmNlRW5kUG9zaXRpb25zLnksIGluc3RhbmNlU3RhcnRFbmRQb3NpdGlvbnM2NHh5TG93LncpO1xuXG4gIHZlYzMgY3VyclBvc2l0aW9uID0gbWl4KGluc3RhbmNlU3RhcnRQb3NpdGlvbnMsIGluc3RhbmNlRW5kUG9zaXRpb25zLCBpc0VuZCk7XG5cbiAgdmVjMiB0ZW1wQ3VyclBvc2l0aW9uNjRbMl07XG4gIHZlYzJfbWl4X2ZwNjQoaW5zdGFuY2VTdGFydFBvc2l0aW9uczY0LCBpbnN0YW5jZUVuZFBvc2l0aW9uczY0LCBpc0VuZCwgdGVtcEN1cnJQb3NpdGlvbjY0KTtcblxuICB2ZWM0IGN1cnJQb3NpdGlvbjY0ID0gdmVjNCh0ZW1wQ3VyclBvc2l0aW9uNjRbMF0ueHksIHRlbXBDdXJyUG9zaXRpb242NFsxXS54eSk7XG5cbiAgdmVjMiBwcm9qZWN0ZWRfY3Vycl9wb3NpdGlvblsyXTtcbiAgcHJvamVjdF9wb3NpdGlvbl9mcDY0KGN1cnJQb3NpdGlvbjY0LCBwcm9qZWN0ZWRfY3Vycl9wb3NpdGlvbik7XG4gIGZsb2F0IHByb2plY3RlZF9jdXJyX3Bvc2l0aW9uX3ogPSBwcm9qZWN0X3NjYWxlKGN1cnJQb3NpdGlvbi56KTtcblxuICBjdXJyUG9zaXRpb24gPSBwcm9qZWN0X3Bvc2l0aW9uKGN1cnJQb3NpdGlvbik7XG5cbiAgLy8gQ2FsY3VsYXRlIG5leHQgcG9zaXRpb25zXG4gIHZlYzMgbmV4dFBvc2l0aW9uID0gbWl4KHZlYzMoMC4wKSwgaW5zdGFuY2VSaWdodERlbHRhcywgaXNFbmQpICsgaW5zdGFuY2VFbmRQb3NpdGlvbnM7XG4gIG5leHRQb3NpdGlvbiA9IHByb2plY3RfcG9zaXRpb24obmV4dFBvc2l0aW9uKTtcblxuICB2ZWMzIHBvcyA9IGxpbmVKb2luKHByZXZQb3NpdGlvbiwgY3VyclBvc2l0aW9uLCBuZXh0UG9zaXRpb24pO1xuICB2ZWMyIHZlcnRleF9wb3NfbW9kZWxzcGFjZVs0XTtcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzBdID0gc3VtX2ZwNjQodmVjMihwb3MueCwgMC4wKSwgcHJvamVjdGVkX2N1cnJfcG9zaXRpb25bMF0pO1xuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMV0gPSBzdW1fZnA2NCh2ZWMyKHBvcy55LCAwLjApLCBwcm9qZWN0ZWRfY3Vycl9wb3NpdGlvblsxXSk7XG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVsyXSA9IHZlYzIocG9zLnogKyBwcm9qZWN0ZWRfY3Vycl9wb3NpdGlvbl96LCAwLjApO1xuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbM10gPSB2ZWMyKDEuMCwgMC4wKTtcblxuICBnbF9Qb3NpdGlvbiA9IHByb2plY3RfdG9fY2xpcHNwYWNlX2ZwNjQodmVydGV4X3Bvc19tb2RlbHNwYWNlKTtcbn1cbmA7XG4iXX0=