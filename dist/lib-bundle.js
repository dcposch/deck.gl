(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("luma.gl"), require("assert"), require("gl-matrix"), require("earcut"), require("lodash.flattendeep"), require("react"), require("."), require(".."), require("d3-hexbin"));
	else if(typeof define === 'function' && define.amd)
		define(["luma.gl", "assert", "gl-matrix", "earcut", "lodash.flattendeep", "react", ".", "..", "d3-hexbin"], factory);
	else if(typeof exports === 'object')
		exports["deck.gl"] = factory(require("luma.gl"), require("assert"), require("gl-matrix"), require("earcut"), require("lodash.flattendeep"), require("react"), require("."), require(".."), require("d3-hexbin"));
	else
		root["deck.gl"] = factory(root["luma.gl"], root["assert"], root["gl-matrix"], root["earcut"], root["lodash.flattendeep"], root["react"], root["."], root[".."], root["d3-hexbin"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_6__, __WEBPACK_EXTERNAL_MODULE_7__, __WEBPACK_EXTERNAL_MODULE_8__, __WEBPACK_EXTERNAL_MODULE_33__, __WEBPACK_EXTERNAL_MODULE_34__, __WEBPACK_EXTERNAL_MODULE_115__, __WEBPACK_EXTERNAL_MODULE_116__, __WEBPACK_EXTERNAL_MODULE_117__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 118);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/* exports provided: COORDINATE_SYSTEM, Layer, CompositeLayer, AttributeManager, LayerManager, get */
/* exports used: Layer, CompositeLayer, LayerManager, AttributeManager, COORDINATE_SYSTEM, get */
/*!**************************!*\
  !*** ./src/lib/index.js ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__init__ = __webpack_require__(/*! ./init */ 96);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constants__ = __webpack_require__(/*! ./constants */ 14);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return __WEBPACK_IMPORTED_MODULE_1__constants__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__layer__ = __webpack_require__(/*! ./layer */ 15);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_2__layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__composite_layer__ = __webpack_require__(/*! ./composite-layer */ 94);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return __WEBPACK_IMPORTED_MODULE_3__composite_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__attribute_manager__ = __webpack_require__(/*! ./attribute-manager */ 27);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return __WEBPACK_IMPORTED_MODULE_4__attribute_manager__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__layer_manager__ = __webpack_require__(/*! ./layer-manager */ 97);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return __WEBPACK_IMPORTED_MODULE_5__layer_manager__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_get__ = __webpack_require__(/*! ./utils/get */ 11);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return __WEBPACK_IMPORTED_MODULE_6__utils_get__[\"a\"]; });\n// Set up deck.gl global state\n\n\n\n\n// Export core objects\n\n\n\n\n\n// Ability to extract data from ES6 containers (Maps, Immutable.maps etc)\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9saWIvaW5kZXguanM/N2U1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTZXQgdXAgZGVjay5nbCBnbG9iYWwgc3RhdGVcbmltcG9ydCAnLi9pbml0JztcblxuZXhwb3J0IHtDT09SRElOQVRFX1NZU1RFTX0gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vLyBFeHBvcnQgY29yZSBvYmplY3RzXG5leHBvcnQge2RlZmF1bHQgYXMgTGF5ZXJ9IGZyb20gJy4vbGF5ZXInO1xuZXhwb3J0IHtkZWZhdWx0IGFzIENvbXBvc2l0ZUxheWVyfSBmcm9tICcuL2NvbXBvc2l0ZS1sYXllcic7XG5leHBvcnQge2RlZmF1bHQgYXMgQXR0cmlidXRlTWFuYWdlcn0gZnJvbSAnLi9hdHRyaWJ1dGUtbWFuYWdlcic7XG5leHBvcnQge2RlZmF1bHQgYXMgTGF5ZXJNYW5hZ2VyfSBmcm9tICcuL2xheWVyLW1hbmFnZXInO1xuXG4vLyBBYmlsaXR5IHRvIGV4dHJhY3QgZGF0YSBmcm9tIEVTNiBjb250YWluZXJzIChNYXBzLCBJbW11dGFibGUubWFwcyBldGMpXG5leHBvcnQge2dldH0gZnJvbSAnLi91dGlscy9nZXQnO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 1 */
/* unknown exports provided */
/* exports used: Model, Geometry, GL, Framebuffer, addEvents, createGLContext, FramebufferObject, glContextWithState, Matrix4, CylinderGeometry, CubeGeometry, Texture2D, loadTextures, glGetDebugInfo */
/*!**************************!*\
  !*** external "luma.gl" ***!
  \**************************/
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_1__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcImx1bWEuZ2xcIj9lNWFiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xX187XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJsdW1hLmdsXCJcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 2 */
/* exports provided: log, flatten, flattenVertices, fillArray, compareProps, areEqualShallow, compareArrays, checkArray, fp64ify, parseColor, getBlendMode, setBlendMode, get, count */
/* exports used: log, flatten, fp64ify, get, count, flattenVertices, fillArray, getBlendMode, setBlendMode, compareProps */
/*!********************************!*\
  !*** ./src/lib/utils/index.js ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__log__ = __webpack_require__(/*! ./log */ 28);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_0__log__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__flatten__ = __webpack_require__(/*! ./flatten */ 102);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return __WEBPACK_IMPORTED_MODULE_1__flatten__[\"a\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return __WEBPACK_IMPORTED_MODULE_1__flatten__[\"b\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return __WEBPACK_IMPORTED_MODULE_1__flatten__[\"c\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__compare_objects__ = __webpack_require__(/*! ./compare-objects */ 101);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"j\", function() { return __WEBPACK_IMPORTED_MODULE_2__compare_objects__[\"a\"]; });\n/* unused harmony reexport areEqualShallow */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__compare_arrays__ = __webpack_require__(/*! ./compare-arrays */ 100);\n/* unused harmony reexport compareArrays */\n/* unused harmony reexport checkArray */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__fp64__ = __webpack_require__(/*! ./fp64 */ 4);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return __WEBPACK_IMPORTED_MODULE_4__fp64__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__color__ = __webpack_require__(/*! ./color */ 99);\n/* unused harmony reexport parseColor */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__blend__ = __webpack_require__(/*! ./blend */ 98);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return __WEBPACK_IMPORTED_MODULE_6__blend__[\"a\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"i\", function() { return __WEBPACK_IMPORTED_MODULE_6__blend__[\"b\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__get__ = __webpack_require__(/*! ./get */ 11);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return __WEBPACK_IMPORTED_MODULE_7__get__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__count__ = __webpack_require__(/*! ./count */ 22);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return __WEBPACK_IMPORTED_MODULE_8__count__[\"a\"]; });\n// Log\n\n\n// Object and array support\n\n\n\n\n// FP64 and Color support\n\n\n\n\n// ES6 Container and Immutable support\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9saWIvdXRpbHMvaW5kZXguanM/ZTBhYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBMb2dcbmV4cG9ydCB7ZGVmYXVsdCBhcyBsb2d9IGZyb20gJy4vbG9nJztcblxuLy8gT2JqZWN0IGFuZCBhcnJheSBzdXBwb3J0XG5leHBvcnQge2ZsYXR0ZW4sIGZsYXR0ZW5WZXJ0aWNlcywgZmlsbEFycmF5fSBmcm9tICcuL2ZsYXR0ZW4nO1xuZXhwb3J0IHtjb21wYXJlUHJvcHMsIGFyZUVxdWFsU2hhbGxvd30gZnJvbSAnLi9jb21wYXJlLW9iamVjdHMnO1xuZXhwb3J0IHtjb21wYXJlQXJyYXlzLCBjaGVja0FycmF5fSBmcm9tICcuL2NvbXBhcmUtYXJyYXlzJztcblxuLy8gRlA2NCBhbmQgQ29sb3Igc3VwcG9ydFxuZXhwb3J0IHtmcDY0aWZ5fSBmcm9tICcuL2ZwNjQnO1xuZXhwb3J0IHtwYXJzZUNvbG9yfSBmcm9tICcuL2NvbG9yJztcbmV4cG9ydCB7Z2V0QmxlbmRNb2RlLCBzZXRCbGVuZE1vZGV9IGZyb20gJy4vYmxlbmQnO1xuXG4vLyBFUzYgQ29udGFpbmVyIGFuZCBJbW11dGFibGUgc3VwcG9ydFxuZXhwb3J0IHtnZXR9IGZyb20gJy4vZ2V0JztcbmV4cG9ydCB7Y291bnR9IGZyb20gJy4vY291bnQnO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGliL3V0aWxzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 3 */
/* exports provided: checkRendererVendor, getPlatformShaderDefines, assembleShaders, fp64, project, project64, lighting */
/* exports used: assembleShaders */
/*!***********************************!*\
  !*** ./src/shader-utils/index.js ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__assemble_shaders__ = __webpack_require__(/*! ./assemble-shaders */ 106);\n/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_0__assemble_shaders__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_chunks__ = __webpack_require__(/*! ./shader-chunks */ 30);\n/* unused harmony namespace reexport */\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9zaGFkZXItdXRpbHMvaW5kZXguanM/OGQ1MiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL2Fzc2VtYmxlLXNoYWRlcnMnO1xuZXhwb3J0ICogZnJvbSAnLi9zaGFkZXItY2h1bmtzJztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3NoYWRlci11dGlscy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 4 */
/* exports provided: fp64ify, enable64bitSupport */
/* exports used: fp64ify, enable64bitSupport */
/*!*******************************!*\
  !*** ./src/lib/utils/fp64.js ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0____ = __webpack_require__(/*! . */ 115);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_____default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0____);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1____ = __webpack_require__(/*! .. */ 116);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_____default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1____);\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = fp64ify;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = enable64bitSupport;\n// TODO - move to shaderlib utilities\n\n\n\nfunction fp64ify(a) {\n  const hiPart = Math.fround(a);\n  const loPart = a - Math.fround(a);\n  return [hiPart, loPart];\n}\n\nfunction enable64bitSupport(props) {\n  if (props.fp64) {\n    if (props.projectionMode === __WEBPACK_IMPORTED_MODULE_1____[\"COORDINATE_SYSTEM\"].LNG_LAT) {\n      return true;\n    }\n    __WEBPACK_IMPORTED_MODULE_0____[\"log\"].once(0, `64-bit mode only works with projectionMode set to\n      COORDINATE_SYSTEM.LNG_LAT. Rendering in 32-bit mode instead`);\n  }\n\n  return false;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9saWIvdXRpbHMvZnA2NC5qcz82Mjk3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRPRE8gLSBtb3ZlIHRvIHNoYWRlcmxpYiB1dGlsaXRpZXNcbmltcG9ydCB7bG9nfSBmcm9tICcuJztcbmltcG9ydCB7Q09PUkRJTkFURV9TWVNURU19IGZyb20gJy4uJztcblxuZXhwb3J0IGZ1bmN0aW9uIGZwNjRpZnkoYSkge1xuICBjb25zdCBoaVBhcnQgPSBNYXRoLmZyb3VuZChhKTtcbiAgY29uc3QgbG9QYXJ0ID0gYSAtIE1hdGguZnJvdW5kKGEpO1xuICByZXR1cm4gW2hpUGFydCwgbG9QYXJ0XTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZTY0Yml0U3VwcG9ydChwcm9wcykge1xuICBpZiAocHJvcHMuZnA2NCkge1xuICAgIGlmIChwcm9wcy5wcm9qZWN0aW9uTW9kZSA9PT0gQ09PUkRJTkFURV9TWVNURU0uTE5HX0xBVCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxvZy5vbmNlKDAsIGA2NC1iaXQgbW9kZSBvbmx5IHdvcmtzIHdpdGggcHJvamVjdGlvbk1vZGUgc2V0IHRvXG4gICAgICBDT09SRElOQVRFX1NZU1RFTS5MTkdfTEFULiBSZW5kZXJpbmcgaW4gMzItYml0IG1vZGUgaW5zdGVhZGApO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGliL3V0aWxzL2ZwNjQuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 5 */
/* exports provided: default, createMat4 */
/* exports used: default, createMat4 */
/*!***************************************!*\
  !*** ./src/lib/viewports/viewport.js ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_gl_matrix__ = __webpack_require__(/*! gl-matrix */ 7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_gl_matrix___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_gl_matrix__);\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = createMat4;\n// eslint-disable\n// View and Projection Matrix management\n\n// gl-matrix is a large dependency for a small module.\n// However since it is used by mapbox etc, it should already be present\n// in most target application bundles.\n\n\nconst IDENTITY = createMat4();\n\nclass Viewport {\n  /**\n   * @classdesc\n   * Manages coordinate system transformations for deck.gl.\n   *\n   * Note: The Viewport is immutable in the sense that it only has accessors.\n   * A new viewport instance should be created if any parameters have changed.\n   *\n   * @class\n   * @param {Object} opt - options\n   * @param {Boolean} mercator=true - Whether to use mercator projection\n   *\n   * @param {Number} opt.width=1 - Width of \"viewport\" or window\n   * @param {Number} opt.height=1 - Height of \"viewport\" or window\n   * @param {Array} opt.center=[0, 0] - Center of viewport\n   *   [longitude, latitude] or [x, y]\n   * @param {Number} opt.scale=1 - Either use scale or zoom\n   * @param {Number} opt.pitch=0 - Camera angle in degrees (0 is straight down)\n   * @param {Number} opt.bearing=0 - Map rotation in degrees (0 means north is up)\n   * @param {Number} opt.altitude= - Altitude of camera in screen units\n   *\n   * Web mercator projection short-hand parameters\n   * @param {Number} opt.latitude - Center of viewport on map (alternative to opt.center)\n   * @param {Number} opt.longitude - Center of viewport on map (alternative to opt.center)\n   * @param {Number} opt.zoom - Scale = Math.pow(2,zoom) on map (alternative to opt.scale)\n   */\n  /* eslint-disable complexity */\n  constructor({\n    // Window width/height in pixels (for pixel projection)\n    width = 1,\n    height = 1,\n    // Desc\n    viewMatrix = IDENTITY,\n    projectionMatrix = IDENTITY\n  } = {}) {\n    // Silently allow apps to send in 0,0\n    this.width = width || 1;\n    this.height = height || 1;\n    this.scale = 1;\n\n    this.viewMatrix = viewMatrix;\n    this.projectionMatrix = projectionMatrix;\n\n    // Note: As usual, matrix operations should be applied in \"reverse\" order\n    // since vectors will be multiplied in from the right during transformation\n    const vpm = createMat4();\n    __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].multiply(vpm, vpm, this.projectionMatrix);\n    __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].multiply(vpm, vpm, this.viewMatrix);\n    this.viewProjectionMatrix = vpm;\n\n    // Calculate matrices and scales needed for projection\n    /**\n     * Builds matrices that converts preprojected lngLats to screen pixels\n     * and vice versa.\n     * Note: Currently returns bottom-left coordinates!\n     * Note: Starts with the GL projection matrix and adds steps to the\n     *       scale and translate that matrix onto the window.\n     * Note: WebGL controls clip space to screen projection with gl.viewport\n     *       and does not need this step.\n     */\n    const m = createMat4();\n\n    // Scale with viewport window's width and height in pixels\n    __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].scale(m, m, [this.width, this.height, 1]);\n    // Convert to (0, 1)\n    __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].translate(m, m, [0.5, 0.5, 0]);\n    __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].scale(m, m, [0.5, 0.5, 1]);\n    // Project to clip space (-1, 1)\n    __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].multiply(m, m, this.viewProjectionMatrix);\n\n    const mInverse = __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].invert(createMat4(), m);\n    if (!mInverse) {\n      throw new Error('Pixel project matrix not invertible');\n    }\n\n    this.pixelProjectionMatrix = m;\n    this.pixelUnprojectionMatrix = mInverse;\n\n    this.project = this.project.bind(this);\n    this.unproject = this.unproject.bind(this);\n    this.projectFlat = this.projectFlat.bind(this);\n    this.unprojectFlat = this.unprojectFlat.bind(this);\n    this.getMatrices = this.getMatrices.bind(this);\n    this.getDistanceScales = this.getDistanceScales.bind(this);\n  }\n  /* eslint-enable complexity */\n\n  // Two viewports are equal if width and height are identical, and if\n  // their view and projection matrices are (approximately) equal.\n  equals(viewport) {\n    if (!(viewport instanceof Viewport)) {\n      return false;\n    }\n\n    return viewport.width === this.width &&\n      viewport.height === this.height &&\n      __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].equals(viewport.projectionMatrix, this.projectionMatrix) &&\n      __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].equals(viewport.viewMatrix, this.viewMatrix);\n  }\n\n  /**\n   * Projects xyz (possibly latitude and longitude) to pixel coordinates in window\n   * using viewport projection parameters\n   * - [longitude, latitude] to [x, y]\n   * - [longitude, latitude, Z] => [x, y, z]\n   * Note: By default, returns top-left coordinates for canvas/SVG type render\n   *\n   * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]\n   * @param {Object} opts - options\n   * @param {Object} opts.topLeft=true - Whether projected coords are top left\n   * @return {Array} - [x, y] or [x, y, z] in top left coords\n   */\n  project(xyz, {topLeft = true} = {}) {\n    const Z = xyz[2] || 0;\n    // console.error('projecting non-linear', xyz);\n    const [X, Y] = this.projectFlat(xyz);\n    const v = [X, Y, Z, 1];\n    // console.error('projecting linear', v);\n    // vec4.sub(v, v, [this.centerX, this.centerY, 0, 0]);\n    __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"vec4\"].transformMat4(v, v, this.pixelProjectionMatrix);\n    // Divide by w\n    const scale = 1 / v[3];\n    __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"vec4\"].multiply(v, v, [scale, scale, scale, scale]);\n    // console.error('projected', v);\n    const [x, , z] = v;\n    const y = topLeft ? this.height - v[1] : v[1];\n    return xyz.length === 2 ? [x, y] : [x, y, z];\n  }\n\n  /**\n   * Unproject pixel coordinates on screen onto world coordinates,\n   * (possibly [lon, lat]) on map.\n   * - [x, y] => [lng, lat]\n   * - [x, y, z] => [lng, lat, Z]\n   * @param {Array} xyz -\n   * @return {Array} - [lng, lat, Z] or [X, Y, Z]\n   */\n  unproject(xyz, {topLeft = true} = {}) {\n    // console.error('unprojecting linear', xyz);\n    const [x = 0, y = 0, z = 0] = xyz;\n    // const y2 = topLeft ? this.height - 1 - y : y;\n    const y2 = topLeft ? this.height - y : y;\n    const v = [x, y2, z, 1];\n    __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"vec4\"].transformMat4(v, v, this.pixelUnprojectionMatrix);\n    const scale = 1 / v[3];\n    __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"vec4\"].multiply(v, v, [scale, scale, scale, scale]);\n    // console.error('unprojecting non-linear', v);\n    const [x0, y0] = this.unprojectFlat(v);\n    // console.error('unprojected', [x0, y0]);\n    const [, , z0] = v;\n    return xyz.length === 2 ? [x0, y0] : [x0, y0, z0];\n  }\n\n  // NON_LINEAR PROJECTION HOOKS\n  // Used for web meractor projection\n\n  /**\n   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.\n   * Performs the nonlinear part of the web mercator projection.\n   * Remaining projection is done with 4x4 matrices which also handles\n   * perspective.\n   * @param {Array} lngLat - [lng, lat] coordinates\n   *   Specifies a point on the sphere to project onto the map.\n   * @return {Array} [x,y] coordinates.\n   */\n  projectFlat([x, y], scale = this.scale) {\n    return this._projectFlat(...arguments);\n  }\n\n  /**\n   * Unproject world point [x,y] on map onto {lat, lon} on sphere\n   * @param {object|Vector} xy - object with {x,y} members\n   *  representing point on projected map plane\n   * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.\n   *   Has toArray method if you need a GeoJSON Array.\n   *   Per cartographic tradition, lat and lon are specified as degrees.\n   */\n  unprojectFlat(xyz, scale = this.scale) {\n    return this._unprojectFlat(...arguments);\n  }\n\n  _projectFlat(xyz, scale = this.scale) {\n    return xyz;\n  }\n\n  _unprojectFlat(xyz, scale = this.scale) {\n    return xyz;\n  }\n\n  getMatrices({modelMatrix = null} = {}) {\n    let modelViewProjectionMatrix = this.viewProjectionMatrix;\n    let pixelProjectionMatrix = this.pixelProjectionMatrix;\n    let pixelUnprojectionMatrix = this.pixelUnprojectionMatrix;\n\n    if (modelMatrix) {\n      modelViewProjectionMatrix = __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].multiply([], this.viewProjectionMatrix, modelMatrix);\n      pixelProjectionMatrix = __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].multiply([], this.pixelProjectionMatrix, modelMatrix);\n      pixelUnprojectionMatrix = __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].invert([], pixelProjectionMatrix);\n    }\n\n    const matrices = Object.assign({\n      modelViewProjectionMatrix,\n      viewProjectionMatrix: this.viewProjectionMatrix,\n      viewMatrix: this.viewMatrix,\n      projectionMatrix: this.projectionMatrix,\n\n      // project/unproject between pixels and world\n      pixelProjectionMatrix,\n      pixelUnprojectionMatrix,\n\n      width: this.width,\n      height: this.height,\n      scale: this.scale\n    },\n\n      // Subclass can add additional params\n      // TODO - Fragile: better to make base Viewport class aware of all params\n      this._getParams()\n    );\n\n    return matrices;\n  }\n\n  getDistanceScales() {\n    return {\n      pixelsPerMeter: [1, 1, 1],\n      metersPerPixel: [1, 1, 1],\n      pixelsPerDegree: [1, 1, 1],\n      degreesPerPixel: [1, 1, 1]\n    };\n  }\n\n  // INTERNAL METHODS\n\n  // Can be subclassed to add additional fields to `getMatrices`\n  _getParams() {\n    return {};\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = Viewport;\n\n\n// Helper, avoids low-precision 32 bit matrices from gl-matrix mat4.create()\nfunction createMat4() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9saWIvdmlld3BvcnRzL3ZpZXdwb3J0LmpzPzRiYTgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXNsaW50LWRpc2FibGVcbi8vIFZpZXcgYW5kIFByb2plY3Rpb24gTWF0cml4IG1hbmFnZW1lbnRcblxuLy8gZ2wtbWF0cml4IGlzIGEgbGFyZ2UgZGVwZW5kZW5jeSBmb3IgYSBzbWFsbCBtb2R1bGUuXG4vLyBIb3dldmVyIHNpbmNlIGl0IGlzIHVzZWQgYnkgbWFwYm94IGV0YywgaXQgc2hvdWxkIGFscmVhZHkgYmUgcHJlc2VudFxuLy8gaW4gbW9zdCB0YXJnZXQgYXBwbGljYXRpb24gYnVuZGxlcy5cbmltcG9ydCB7bWF0NCwgdmVjNH0gZnJvbSAnZ2wtbWF0cml4JztcblxuY29uc3QgSURFTlRJVFkgPSBjcmVhdGVNYXQ0KCk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZpZXdwb3J0IHtcbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogTWFuYWdlcyBjb29yZGluYXRlIHN5c3RlbSB0cmFuc2Zvcm1hdGlvbnMgZm9yIGRlY2suZ2wuXG4gICAqXG4gICAqIE5vdGU6IFRoZSBWaWV3cG9ydCBpcyBpbW11dGFibGUgaW4gdGhlIHNlbnNlIHRoYXQgaXQgb25seSBoYXMgYWNjZXNzb3JzLlxuICAgKiBBIG5ldyB2aWV3cG9ydCBpbnN0YW5jZSBzaG91bGQgYmUgY3JlYXRlZCBpZiBhbnkgcGFyYW1ldGVycyBoYXZlIGNoYW5nZWQuXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0IC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1lcmNhdG9yPXRydWUgLSBXaGV0aGVyIHRvIHVzZSBtZXJjYXRvciBwcm9qZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQud2lkdGg9MSAtIFdpZHRoIG9mIFwidmlld3BvcnRcIiBvciB3aW5kb3dcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5oZWlnaHQ9MSAtIEhlaWdodCBvZiBcInZpZXdwb3J0XCIgb3Igd2luZG93XG4gICAqIEBwYXJhbSB7QXJyYXl9IG9wdC5jZW50ZXI9WzAsIDBdIC0gQ2VudGVyIG9mIHZpZXdwb3J0XG4gICAqICAgW2xvbmdpdHVkZSwgbGF0aXR1ZGVdIG9yIFt4LCB5XVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LnNjYWxlPTEgLSBFaXRoZXIgdXNlIHNjYWxlIG9yIHpvb21cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5waXRjaD0wIC0gQ2FtZXJhIGFuZ2xlIGluIGRlZ3JlZXMgKDAgaXMgc3RyYWlnaHQgZG93bilcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5iZWFyaW5nPTAgLSBNYXAgcm90YXRpb24gaW4gZGVncmVlcyAoMCBtZWFucyBub3J0aCBpcyB1cClcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5hbHRpdHVkZT0gLSBBbHRpdHVkZSBvZiBjYW1lcmEgaW4gc2NyZWVuIHVuaXRzXG4gICAqXG4gICAqIFdlYiBtZXJjYXRvciBwcm9qZWN0aW9uIHNob3J0LWhhbmQgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmxhdGl0dWRlIC0gQ2VudGVyIG9mIHZpZXdwb3J0IG9uIG1hcCAoYWx0ZXJuYXRpdmUgdG8gb3B0LmNlbnRlcilcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5sb25naXR1ZGUgLSBDZW50ZXIgb2Ygdmlld3BvcnQgb24gbWFwIChhbHRlcm5hdGl2ZSB0byBvcHQuY2VudGVyKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0Lnpvb20gLSBTY2FsZSA9IE1hdGgucG93KDIsem9vbSkgb24gbWFwIChhbHRlcm5hdGl2ZSB0byBvcHQuc2NhbGUpXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5ICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICAvLyBXaW5kb3cgd2lkdGgvaGVpZ2h0IGluIHBpeGVscyAoZm9yIHBpeGVsIHByb2plY3Rpb24pXG4gICAgd2lkdGggPSAxLFxuICAgIGhlaWdodCA9IDEsXG4gICAgLy8gRGVzY1xuICAgIHZpZXdNYXRyaXggPSBJREVOVElUWSxcbiAgICBwcm9qZWN0aW9uTWF0cml4ID0gSURFTlRJVFlcbiAgfSA9IHt9KSB7XG4gICAgLy8gU2lsZW50bHkgYWxsb3cgYXBwcyB0byBzZW5kIGluIDAsMFxuICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCAxO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IDE7XG4gICAgdGhpcy5zY2FsZSA9IDE7XG5cbiAgICB0aGlzLnZpZXdNYXRyaXggPSB2aWV3TWF0cml4O1xuICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IHByb2plY3Rpb25NYXRyaXg7XG5cbiAgICAvLyBOb3RlOiBBcyB1c3VhbCwgbWF0cml4IG9wZXJhdGlvbnMgc2hvdWxkIGJlIGFwcGxpZWQgaW4gXCJyZXZlcnNlXCIgb3JkZXJcbiAgICAvLyBzaW5jZSB2ZWN0b3JzIHdpbGwgYmUgbXVsdGlwbGllZCBpbiBmcm9tIHRoZSByaWdodCBkdXJpbmcgdHJhbnNmb3JtYXRpb25cbiAgICBjb25zdCB2cG0gPSBjcmVhdGVNYXQ0KCk7XG4gICAgbWF0NC5tdWx0aXBseSh2cG0sIHZwbSwgdGhpcy5wcm9qZWN0aW9uTWF0cml4KTtcbiAgICBtYXQ0Lm11bHRpcGx5KHZwbSwgdnBtLCB0aGlzLnZpZXdNYXRyaXgpO1xuICAgIHRoaXMudmlld1Byb2plY3Rpb25NYXRyaXggPSB2cG07XG5cbiAgICAvLyBDYWxjdWxhdGUgbWF0cmljZXMgYW5kIHNjYWxlcyBuZWVkZWQgZm9yIHByb2plY3Rpb25cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgbWF0cmljZXMgdGhhdCBjb252ZXJ0cyBwcmVwcm9qZWN0ZWQgbG5nTGF0cyB0byBzY3JlZW4gcGl4ZWxzXG4gICAgICogYW5kIHZpY2UgdmVyc2EuXG4gICAgICogTm90ZTogQ3VycmVudGx5IHJldHVybnMgYm90dG9tLWxlZnQgY29vcmRpbmF0ZXMhXG4gICAgICogTm90ZTogU3RhcnRzIHdpdGggdGhlIEdMIHByb2plY3Rpb24gbWF0cml4IGFuZCBhZGRzIHN0ZXBzIHRvIHRoZVxuICAgICAqICAgICAgIHNjYWxlIGFuZCB0cmFuc2xhdGUgdGhhdCBtYXRyaXggb250byB0aGUgd2luZG93LlxuICAgICAqIE5vdGU6IFdlYkdMIGNvbnRyb2xzIGNsaXAgc3BhY2UgdG8gc2NyZWVuIHByb2plY3Rpb24gd2l0aCBnbC52aWV3cG9ydFxuICAgICAqICAgICAgIGFuZCBkb2VzIG5vdCBuZWVkIHRoaXMgc3RlcC5cbiAgICAgKi9cbiAgICBjb25zdCBtID0gY3JlYXRlTWF0NCgpO1xuXG4gICAgLy8gU2NhbGUgd2l0aCB2aWV3cG9ydCB3aW5kb3cncyB3aWR0aCBhbmQgaGVpZ2h0IGluIHBpeGVsc1xuICAgIG1hdDQuc2NhbGUobSwgbSwgW3RoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAxXSk7XG4gICAgLy8gQ29udmVydCB0byAoMCwgMSlcbiAgICBtYXQ0LnRyYW5zbGF0ZShtLCBtLCBbMC41LCAwLjUsIDBdKTtcbiAgICBtYXQ0LnNjYWxlKG0sIG0sIFswLjUsIDAuNSwgMV0pO1xuICAgIC8vIFByb2plY3QgdG8gY2xpcCBzcGFjZSAoLTEsIDEpXG4gICAgbWF0NC5tdWx0aXBseShtLCBtLCB0aGlzLnZpZXdQcm9qZWN0aW9uTWF0cml4KTtcblxuICAgIGNvbnN0IG1JbnZlcnNlID0gbWF0NC5pbnZlcnQoY3JlYXRlTWF0NCgpLCBtKTtcbiAgICBpZiAoIW1JbnZlcnNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BpeGVsIHByb2plY3QgbWF0cml4IG5vdCBpbnZlcnRpYmxlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5waXhlbFByb2plY3Rpb25NYXRyaXggPSBtO1xuICAgIHRoaXMucGl4ZWxVbnByb2plY3Rpb25NYXRyaXggPSBtSW52ZXJzZTtcblxuICAgIHRoaXMucHJvamVjdCA9IHRoaXMucHJvamVjdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMudW5wcm9qZWN0ID0gdGhpcy51bnByb2plY3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLnByb2plY3RGbGF0ID0gdGhpcy5wcm9qZWN0RmxhdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMudW5wcm9qZWN0RmxhdCA9IHRoaXMudW5wcm9qZWN0RmxhdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZ2V0TWF0cmljZXMgPSB0aGlzLmdldE1hdHJpY2VzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5nZXREaXN0YW5jZVNjYWxlcyA9IHRoaXMuZ2V0RGlzdGFuY2VTY2FsZXMuYmluZCh0aGlzKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIGNvbXBsZXhpdHkgKi9cblxuICAvLyBUd28gdmlld3BvcnRzIGFyZSBlcXVhbCBpZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBpZGVudGljYWwsIGFuZCBpZlxuICAvLyB0aGVpciB2aWV3IGFuZCBwcm9qZWN0aW9uIG1hdHJpY2VzIGFyZSAoYXBwcm94aW1hdGVseSkgZXF1YWwuXG4gIGVxdWFscyh2aWV3cG9ydCkge1xuICAgIGlmICghKHZpZXdwb3J0IGluc3RhbmNlb2YgVmlld3BvcnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZpZXdwb3J0LndpZHRoID09PSB0aGlzLndpZHRoICYmXG4gICAgICB2aWV3cG9ydC5oZWlnaHQgPT09IHRoaXMuaGVpZ2h0ICYmXG4gICAgICBtYXQ0LmVxdWFscyh2aWV3cG9ydC5wcm9qZWN0aW9uTWF0cml4LCB0aGlzLnByb2plY3Rpb25NYXRyaXgpICYmXG4gICAgICBtYXQ0LmVxdWFscyh2aWV3cG9ydC52aWV3TWF0cml4LCB0aGlzLnZpZXdNYXRyaXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2plY3RzIHh5eiAocG9zc2libHkgbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSkgdG8gcGl4ZWwgY29vcmRpbmF0ZXMgaW4gd2luZG93XG4gICAqIHVzaW5nIHZpZXdwb3J0IHByb2plY3Rpb24gcGFyYW1ldGVyc1xuICAgKiAtIFtsb25naXR1ZGUsIGxhdGl0dWRlXSB0byBbeCwgeV1cbiAgICogLSBbbG9uZ2l0dWRlLCBsYXRpdHVkZSwgWl0gPT4gW3gsIHksIHpdXG4gICAqIE5vdGU6IEJ5IGRlZmF1bHQsIHJldHVybnMgdG9wLWxlZnQgY29vcmRpbmF0ZXMgZm9yIGNhbnZhcy9TVkcgdHlwZSByZW5kZXJcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gbG5nTGF0WiAtIFtsbmcsIGxhdF0gb3IgW2xuZywgbGF0LCBaXVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMudG9wTGVmdD10cnVlIC0gV2hldGhlciBwcm9qZWN0ZWQgY29vcmRzIGFyZSB0b3AgbGVmdFxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSBbeCwgeV0gb3IgW3gsIHksIHpdIGluIHRvcCBsZWZ0IGNvb3Jkc1xuICAgKi9cbiAgcHJvamVjdCh4eXosIHt0b3BMZWZ0ID0gdHJ1ZX0gPSB7fSkge1xuICAgIGNvbnN0IFogPSB4eXpbMl0gfHwgMDtcbiAgICAvLyBjb25zb2xlLmVycm9yKCdwcm9qZWN0aW5nIG5vbi1saW5lYXInLCB4eXopO1xuICAgIGNvbnN0IFtYLCBZXSA9IHRoaXMucHJvamVjdEZsYXQoeHl6KTtcbiAgICBjb25zdCB2ID0gW1gsIFksIFosIDFdO1xuICAgIC8vIGNvbnNvbGUuZXJyb3IoJ3Byb2plY3RpbmcgbGluZWFyJywgdik7XG4gICAgLy8gdmVjNC5zdWIodiwgdiwgW3RoaXMuY2VudGVyWCwgdGhpcy5jZW50ZXJZLCAwLCAwXSk7XG4gICAgdmVjNC50cmFuc2Zvcm1NYXQ0KHYsIHYsIHRoaXMucGl4ZWxQcm9qZWN0aW9uTWF0cml4KTtcbiAgICAvLyBEaXZpZGUgYnkgd1xuICAgIGNvbnN0IHNjYWxlID0gMSAvIHZbM107XG4gICAgdmVjNC5tdWx0aXBseSh2LCB2LCBbc2NhbGUsIHNjYWxlLCBzY2FsZSwgc2NhbGVdKTtcbiAgICAvLyBjb25zb2xlLmVycm9yKCdwcm9qZWN0ZWQnLCB2KTtcbiAgICBjb25zdCBbeCwgLCB6XSA9IHY7XG4gICAgY29uc3QgeSA9IHRvcExlZnQgPyB0aGlzLmhlaWdodCAtIHZbMV0gOiB2WzFdO1xuICAgIHJldHVybiB4eXoubGVuZ3RoID09PSAyID8gW3gsIHldIDogW3gsIHksIHpdO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucHJvamVjdCBwaXhlbCBjb29yZGluYXRlcyBvbiBzY3JlZW4gb250byB3b3JsZCBjb29yZGluYXRlcyxcbiAgICogKHBvc3NpYmx5IFtsb24sIGxhdF0pIG9uIG1hcC5cbiAgICogLSBbeCwgeV0gPT4gW2xuZywgbGF0XVxuICAgKiAtIFt4LCB5LCB6XSA9PiBbbG5nLCBsYXQsIFpdXG4gICAqIEBwYXJhbSB7QXJyYXl9IHh5eiAtXG4gICAqIEByZXR1cm4ge0FycmF5fSAtIFtsbmcsIGxhdCwgWl0gb3IgW1gsIFksIFpdXG4gICAqL1xuICB1bnByb2plY3QoeHl6LCB7dG9wTGVmdCA9IHRydWV9ID0ge30pIHtcbiAgICAvLyBjb25zb2xlLmVycm9yKCd1bnByb2plY3RpbmcgbGluZWFyJywgeHl6KTtcbiAgICBjb25zdCBbeCA9IDAsIHkgPSAwLCB6ID0gMF0gPSB4eXo7XG4gICAgLy8gY29uc3QgeTIgPSB0b3BMZWZ0ID8gdGhpcy5oZWlnaHQgLSAxIC0geSA6IHk7XG4gICAgY29uc3QgeTIgPSB0b3BMZWZ0ID8gdGhpcy5oZWlnaHQgLSB5IDogeTtcbiAgICBjb25zdCB2ID0gW3gsIHkyLCB6LCAxXTtcbiAgICB2ZWM0LnRyYW5zZm9ybU1hdDQodiwgdiwgdGhpcy5waXhlbFVucHJvamVjdGlvbk1hdHJpeCk7XG4gICAgY29uc3Qgc2NhbGUgPSAxIC8gdlszXTtcbiAgICB2ZWM0Lm11bHRpcGx5KHYsIHYsIFtzY2FsZSwgc2NhbGUsIHNjYWxlLCBzY2FsZV0pO1xuICAgIC8vIGNvbnNvbGUuZXJyb3IoJ3VucHJvamVjdGluZyBub24tbGluZWFyJywgdik7XG4gICAgY29uc3QgW3gwLCB5MF0gPSB0aGlzLnVucHJvamVjdEZsYXQodik7XG4gICAgLy8gY29uc29sZS5lcnJvcigndW5wcm9qZWN0ZWQnLCBbeDAsIHkwXSk7XG4gICAgY29uc3QgWywgLCB6MF0gPSB2O1xuICAgIHJldHVybiB4eXoubGVuZ3RoID09PSAyID8gW3gwLCB5MF0gOiBbeDAsIHkwLCB6MF07XG4gIH1cblxuICAvLyBOT05fTElORUFSIFBST0pFQ1RJT04gSE9PS1NcbiAgLy8gVXNlZCBmb3Igd2ViIG1lcmFjdG9yIHByb2plY3Rpb25cblxuICAvKipcbiAgICogUHJvamVjdCBbbG5nLGxhdF0gb24gc3BoZXJlIG9udG8gW3gseV0gb24gNTEyKjUxMiBNZXJjYXRvciBab29tIDAgdGlsZS5cbiAgICogUGVyZm9ybXMgdGhlIG5vbmxpbmVhciBwYXJ0IG9mIHRoZSB3ZWIgbWVyY2F0b3IgcHJvamVjdGlvbi5cbiAgICogUmVtYWluaW5nIHByb2plY3Rpb24gaXMgZG9uZSB3aXRoIDR4NCBtYXRyaWNlcyB3aGljaCBhbHNvIGhhbmRsZXNcbiAgICogcGVyc3BlY3RpdmUuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGxuZ0xhdCAtIFtsbmcsIGxhdF0gY29vcmRpbmF0ZXNcbiAgICogICBTcGVjaWZpZXMgYSBwb2ludCBvbiB0aGUgc3BoZXJlIHRvIHByb2plY3Qgb250byB0aGUgbWFwLlxuICAgKiBAcmV0dXJuIHtBcnJheX0gW3gseV0gY29vcmRpbmF0ZXMuXG4gICAqL1xuICBwcm9qZWN0RmxhdChbeCwgeV0sIHNjYWxlID0gdGhpcy5zY2FsZSkge1xuICAgIHJldHVybiB0aGlzLl9wcm9qZWN0RmxhdCguLi5hcmd1bWVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucHJvamVjdCB3b3JsZCBwb2ludCBbeCx5XSBvbiBtYXAgb250byB7bGF0LCBsb259IG9uIHNwaGVyZVxuICAgKiBAcGFyYW0ge29iamVjdHxWZWN0b3J9IHh5IC0gb2JqZWN0IHdpdGgge3gseX0gbWVtYmVyc1xuICAgKiAgcmVwcmVzZW50aW5nIHBvaW50IG9uIHByb2plY3RlZCBtYXAgcGxhbmVcbiAgICogQHJldHVybiB7R2VvQ29vcmRpbmF0ZXN9IC0gb2JqZWN0IHdpdGgge2xhdCxsb259IG9mIHBvaW50IG9uIHNwaGVyZS5cbiAgICogICBIYXMgdG9BcnJheSBtZXRob2QgaWYgeW91IG5lZWQgYSBHZW9KU09OIEFycmF5LlxuICAgKiAgIFBlciBjYXJ0b2dyYXBoaWMgdHJhZGl0aW9uLCBsYXQgYW5kIGxvbiBhcmUgc3BlY2lmaWVkIGFzIGRlZ3JlZXMuXG4gICAqL1xuICB1bnByb2plY3RGbGF0KHh5eiwgc2NhbGUgPSB0aGlzLnNjYWxlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VucHJvamVjdEZsYXQoLi4uYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9wcm9qZWN0RmxhdCh4eXosIHNjYWxlID0gdGhpcy5zY2FsZSkge1xuICAgIHJldHVybiB4eXo7XG4gIH1cblxuICBfdW5wcm9qZWN0RmxhdCh4eXosIHNjYWxlID0gdGhpcy5zY2FsZSkge1xuICAgIHJldHVybiB4eXo7XG4gIH1cblxuICBnZXRNYXRyaWNlcyh7bW9kZWxNYXRyaXggPSBudWxsfSA9IHt9KSB7XG4gICAgbGV0IG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggPSB0aGlzLnZpZXdQcm9qZWN0aW9uTWF0cml4O1xuICAgIGxldCBwaXhlbFByb2plY3Rpb25NYXRyaXggPSB0aGlzLnBpeGVsUHJvamVjdGlvbk1hdHJpeDtcbiAgICBsZXQgcGl4ZWxVbnByb2plY3Rpb25NYXRyaXggPSB0aGlzLnBpeGVsVW5wcm9qZWN0aW9uTWF0cml4O1xuXG4gICAgaWYgKG1vZGVsTWF0cml4KSB7XG4gICAgICBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4ID0gbWF0NC5tdWx0aXBseShbXSwgdGhpcy52aWV3UHJvamVjdGlvbk1hdHJpeCwgbW9kZWxNYXRyaXgpO1xuICAgICAgcGl4ZWxQcm9qZWN0aW9uTWF0cml4ID0gbWF0NC5tdWx0aXBseShbXSwgdGhpcy5waXhlbFByb2plY3Rpb25NYXRyaXgsIG1vZGVsTWF0cml4KTtcbiAgICAgIHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4ID0gbWF0NC5pbnZlcnQoW10sIHBpeGVsUHJvamVjdGlvbk1hdHJpeCk7XG4gICAgfVxuXG4gICAgY29uc3QgbWF0cmljZXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgsXG4gICAgICB2aWV3UHJvamVjdGlvbk1hdHJpeDogdGhpcy52aWV3UHJvamVjdGlvbk1hdHJpeCxcbiAgICAgIHZpZXdNYXRyaXg6IHRoaXMudmlld01hdHJpeCxcbiAgICAgIHByb2plY3Rpb25NYXRyaXg6IHRoaXMucHJvamVjdGlvbk1hdHJpeCxcblxuICAgICAgLy8gcHJvamVjdC91bnByb2plY3QgYmV0d2VlbiBwaXhlbHMgYW5kIHdvcmxkXG4gICAgICBwaXhlbFByb2plY3Rpb25NYXRyaXgsXG4gICAgICBwaXhlbFVucHJvamVjdGlvbk1hdHJpeCxcblxuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgc2NhbGU6IHRoaXMuc2NhbGVcbiAgICB9LFxuXG4gICAgICAvLyBTdWJjbGFzcyBjYW4gYWRkIGFkZGl0aW9uYWwgcGFyYW1zXG4gICAgICAvLyBUT0RPIC0gRnJhZ2lsZTogYmV0dGVyIHRvIG1ha2UgYmFzZSBWaWV3cG9ydCBjbGFzcyBhd2FyZSBvZiBhbGwgcGFyYW1zXG4gICAgICB0aGlzLl9nZXRQYXJhbXMoKVxuICAgICk7XG5cbiAgICByZXR1cm4gbWF0cmljZXM7XG4gIH1cblxuICBnZXREaXN0YW5jZVNjYWxlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGl4ZWxzUGVyTWV0ZXI6IFsxLCAxLCAxXSxcbiAgICAgIG1ldGVyc1BlclBpeGVsOiBbMSwgMSwgMV0sXG4gICAgICBwaXhlbHNQZXJEZWdyZWU6IFsxLCAxLCAxXSxcbiAgICAgIGRlZ3JlZXNQZXJQaXhlbDogWzEsIDEsIDFdXG4gICAgfTtcbiAgfVxuXG4gIC8vIElOVEVSTkFMIE1FVEhPRFNcblxuICAvLyBDYW4gYmUgc3ViY2xhc3NlZCB0byBhZGQgYWRkaXRpb25hbCBmaWVsZHMgdG8gYGdldE1hdHJpY2VzYFxuICBfZ2V0UGFyYW1zKCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxufVxuXG4vLyBIZWxwZXIsIGF2b2lkcyBsb3ctcHJlY2lzaW9uIDMyIGJpdCBtYXRyaWNlcyBmcm9tIGdsLW1hdHJpeCBtYXQ0LmNyZWF0ZSgpXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWF0NCgpIHtcbiAgcmV0dXJuIFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xpYi92aWV3cG9ydHMvdmlld3BvcnQuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 6 */
/* unknown exports provided */
/* exports used: default */
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_6__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcImFzc2VydFwiPzFlNDEiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzZfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImFzc2VydFwiXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 7 */
/* unknown exports provided */
/* exports used: vec3, vec2, mat4, vec4 */
/*!****************************!*\
  !*** external "gl-matrix" ***!
  \****************************/
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_7__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcImdsLW1hdHJpeFwiP2I5NWQiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzdfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImdsLW1hdHJpeFwiXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 8 */
/* unknown exports provided */
/* exports used: default */
/*!*************************!*\
  !*** external "earcut" ***!
  \*************************/
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_8__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcImVhcmN1dFwiPzVmZDciXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzhfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImVhcmN1dFwiXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 9 */
/* exports provided: Effect, EffectManager */
/* exports used: EffectManager, Effect */
/*!***************************************!*\
  !*** ./src/experimental/lib/index.js ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__effect__ = __webpack_require__(/*! ./effect */ 53);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return __WEBPACK_IMPORTED_MODULE_0__effect__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__effect_manager__ = __webpack_require__(/*! ./effect-manager */ 52);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_1__effect_manager__[\"a\"]; });\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9leHBlcmltZW50YWwvbGliL2luZGV4LmpzPzI4NzEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHtkZWZhdWx0IGFzIEVmZmVjdH0gZnJvbSAnLi9lZmZlY3QnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEVmZmVjdE1hbmFnZXJ9IGZyb20gJy4vZWZmZWN0LW1hbmFnZXInO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZXhwZXJpbWVudGFsL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 10 */
/* exports provided: default */
/* exports used: default */
/*!**************************************************!*\
  !*** ./src/layers/core/path-layer/path-layer.js ***!
  \**************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl__ = __webpack_require__(/*! luma.gl */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__ = __webpack_require__(/*! ../../../lib/utils/fp64 */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__path_layer_vertex_glsl__ = __webpack_require__(/*! ./path-layer-vertex.glsl */ 74);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__path_layer_vertex_64_glsl__ = __webpack_require__(/*! ./path-layer-vertex-64.glsl */ 73);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__path_layer_fragment_glsl__ = __webpack_require__(/*! ./path-layer-fragment.glsl */ 72);\n// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\n\n\n\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\n\nconst defaultProps = {\n  opacity: 1,\n  widthScale: 1, // stroke width in meters\n  widthMinPixels: 0, //  min stroke width in pixels\n  widthMaxPixels: Number.MAX_SAFE_INTEGER, // max stroke width in pixels\n  rounded: false,\n  miterLimit: 4,\n  fp64: false,\n\n  getPath: object => object.path,\n  getColor: object => object.color || DEFAULT_COLOR,\n  getWidth: object => object.width || 1\n};\n\nconst isClosed = path => {\n  const firstPoint = path[0];\n  const lastPoint = path[path.length - 1];\n  return firstPoint[0] === lastPoint[0] && firstPoint[1] === lastPoint[1] &&\n    firstPoint[2] === lastPoint[2];\n};\n\nclass PathLayer extends __WEBPACK_IMPORTED_MODULE_0__lib__[\"a\" /* Layer */] {\n  getShaders() {\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__[\"b\" /* enable64bitSupport */])(this.props) ? {\n      vs: __WEBPACK_IMPORTED_MODULE_5__path_layer_vertex_64_glsl__[\"a\" /* default */], fs: __WEBPACK_IMPORTED_MODULE_6__path_layer_fragment_glsl__[\"a\" /* default */], modules: ['fp64', 'project64']\n    } : {\n      vs: __WEBPACK_IMPORTED_MODULE_4__path_layer_vertex_glsl__[\"a\" /* default */], fs: __WEBPACK_IMPORTED_MODULE_6__path_layer_fragment_glsl__[\"a\" /* default */], modules: []\n    };\n  }\n\n  initializeState() {\n    const {gl} = this.context;\n    this.setState({model: this._getModel(gl)});\n\n    const {attributeManager} = this.state;\n    /* eslint-disable max-len */\n    attributeManager.addInstanced({\n      instanceStartPositions: {size: 3, update: this.calculateStartPositions},\n      instanceEndPositions: {size: 3, update: this.calculateEndPositions},\n      instanceLeftDeltas: {size: 3, update: this.calculateLeftDeltas},\n      instanceRightDeltas: {size: 3, update: this.calculateRightDeltas},\n      instanceStrokeWidths: {size: 1, accessor: 'getWidth', update: this.calculateStrokeWidths},\n      instanceColors: {size: 4, type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].UNSIGNED_BYTE, accessor: 'getColor', update: this.calculateColors},\n      instancePickingColors: {size: 3, type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].UNSIGNED_BYTE, update: this.calculatePickingColors}\n    });\n    /* eslint-enable max-len */\n  }\n\n  updateAttribute({props, oldProps, changeFlags}) {\n    if (props.fp64 !== oldProps.fp64) {\n      const {attributeManager} = this.state;\n      attributeManager.invalidateAll();\n\n      if (props.fp64 && props.projectionMode === __WEBPACK_IMPORTED_MODULE_0__lib__[\"e\" /* COORDINATE_SYSTEM */].LNG_LAT) {\n        attributeManager.addInstanced({\n          instanceStartEndPositions64xyLow: {\n            size: 4,\n            update: this.calculateInstanceStartEndPositions64xyLow\n          }\n        });\n      } else {\n        attributeManager.remove([\n          'instanceStartEndPositions64xyLow'\n        ]);\n      }\n    }\n  }\n\n  updateState({oldProps, props, changeFlags}) {\n    super.updateState({props, oldProps, changeFlags});\n\n    const {getPath} = this.props;\n    const {attributeManager} = this.state;\n    if (props.fp64 !== oldProps.fp64) {\n      const {gl} = this.context;\n      this.setState({model: this._getModel(gl)});\n    }\n    this.updateAttribute({props, oldProps, changeFlags});\n\n    if (changeFlags.dataChanged) {\n      // this.state.paths only stores point positions in each path\n      const paths = props.data.map(getPath);\n      const numInstances = paths.reduce((count, path) => count + path.length - 1, 0);\n\n      this.setState({paths, numInstances});\n      attributeManager.invalidateAll();\n    }\n  }\n\n  draw({uniforms}) {\n    const {\n      rounded, miterLimit, widthScale, widthMinPixels, widthMaxPixels\n    } = this.props;\n\n    this.state.model.render(Object.assign({}, uniforms, {\n      jointType: Number(rounded),\n      widthScale,\n      miterLimit,\n      widthMinPixels,\n      widthMaxPixels\n    }));\n  }\n\n  _getModel(gl) {\n    const shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"a\" /* assembleShaders */])(gl, this.getShaders());\n\n    /*\n     *       _\n     *        \"-_ 1                   3                       5\n     *     _     \"o---------------------o-------------------_-o\n     *       -   / \"\"--..__              '.             _.-' /\n     *   _     \"@- - - - - \"\"--..__- - - - x - - - -_.@'    /\n     *    \"-_  /                   \"\"--..__ '.  _,-` :     /\n     *       \"o----------------------------\"\"-o'    :     /\n     *      0,2                            4 / '.  :     /\n     *                                      /   '.:     /\n     *                                     /     :'.   /\n     *                                    /     :  ', /\n     *                                   /     :     o\n     */\n\n    const SEGMENT_INDICES = [\n      // start corner\n      0, 2, 1,\n      // body\n      1, 2, 4, 1, 4, 3,\n      // end corner\n      3, 4, 5\n    ];\n\n    // [0] position on segment - 0: start, 1: end\n    // [1] side of path - -1: left, 0: center, 1: right\n    // [2] role - 0: offset point 1: joint point\n    const SEGMENT_POSITIONS = [\n      // bevel start corner\n      0, 0, 1,\n      // start inner corner\n      0, -1, 0,\n      // start outer corner\n      0, 1, 0,\n      // end inner corner\n      1, -1, 0,\n      // end outer corner\n      1, 1, 0,\n      // bevel end corner\n      1, 0, 1\n    ];\n\n    return new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Model\"]({\n      gl,\n      id: this.props.id,\n      fs: shaders.fs,\n      vs: shaders.vs,\n      geometry: new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Geometry\"]({\n        drawMode: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].TRIANGLES,\n        attributes: {\n          indices: new Uint16Array(SEGMENT_INDICES),\n          positions: new Float32Array(SEGMENT_POSITIONS)\n        }\n      }),\n      isInstanced: true\n    });\n  }\n\n  calculateStartPositions(attribute) {\n    const {paths} = this.state;\n    const {value} = attribute;\n\n    let i = 0;\n    paths.forEach(path => {\n      const numSegments = path.length - 1;\n      for (let ptIndex = 0; ptIndex < numSegments; ptIndex++) {\n        const point = path[ptIndex];\n        value[i++] = point[0];\n        value[i++] = point[1];\n        value[i++] = point[2] || 0;\n      }\n    });\n  }\n\n  calculateEndPositions(attribute) {\n    const {paths} = this.state;\n    const {value} = attribute;\n\n    let i = 0;\n    paths.forEach(path => {\n      for (let ptIndex = 1; ptIndex < path.length; ptIndex++) {\n        const point = path[ptIndex];\n        value[i++] = point[0];\n        value[i++] = point[1];\n        value[i++] = point[2] || 0;\n      }\n    });\n  }\n\n  calculateInstanceStartEndPositions64xyLow(attribute) {\n    const {paths} = this.state;\n    const {value} = attribute;\n\n    let i = 0;\n    paths.forEach(path => {\n      const numSegments = path.length - 1;\n      for (let ptIndex = 0; ptIndex < numSegments; ptIndex++) {\n        const startPoint = path[ptIndex];\n        const endPoint = path[ptIndex + 1];\n        value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__[\"a\" /* fp64ify */])(startPoint[0])[1];\n        value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__[\"a\" /* fp64ify */])(startPoint[1])[1];\n        value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__[\"a\" /* fp64ify */])(endPoint[0])[1];\n        value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__[\"a\" /* fp64ify */])(endPoint[1])[1];\n      }\n    });\n  }\n\n  calculateLeftDeltas(attribute) {\n    const {paths} = this.state;\n    const {value} = attribute;\n\n    let i = 0;\n    paths.forEach(path => {\n      const numSegments = path.length - 1;\n      let prevPoint = isClosed(path) ? path[path.length - 2] : path[0];\n\n      for (let ptIndex = 0; ptIndex < numSegments; ptIndex++) {\n        const point = path[ptIndex];\n        value[i++] = point[0] - prevPoint[0];\n        value[i++] = point[1] - prevPoint[1];\n        value[i++] = (point[2] - prevPoint[2]) || 0;\n        prevPoint = point;\n      }\n    });\n  }\n\n  calculateRightDeltas(attribute) {\n    const {paths} = this.state;\n    const {value} = attribute;\n\n    let i = 0;\n    paths.forEach(path => {\n      for (let ptIndex = 1; ptIndex < path.length; ptIndex++) {\n        const point = path[ptIndex];\n        let nextPoint = path[ptIndex + 1];\n        if (!nextPoint) {\n          nextPoint = isClosed(path) ? path[1] : point;\n        }\n\n        value[i++] = nextPoint[0] - point[0];\n        value[i++] = nextPoint[1] - point[1];\n        value[i++] = (nextPoint[2] - point[2]) || 0;\n      }\n    });\n  }\n\n  calculateStrokeWidths(attribute) {\n    const {data, getWidth} = this.props;\n    const {paths} = this.state;\n    const {value} = attribute;\n\n    let i = 0;\n    paths.forEach((path, index) => {\n      const width = getWidth(data[index], index);\n      for (let ptIndex = 1; ptIndex < path.length; ptIndex++) {\n        value[i++] = width;\n      }\n    });\n  }\n\n  calculateColors(attribute) {\n    const {data, getColor} = this.props;\n    const {paths} = this.state;\n    const {value} = attribute;\n\n    let i = 0;\n    paths.forEach((path, index) => {\n      const color = getColor(data[index], index) || DEFAULT_COLOR;\n      if (Array.isArray(color[0])) {\n        if (color.length !== path.length) {\n          throw new Error('PathLayer getColor() returned a color array, but the number of ' +\n           `colors returned doesn't match the number of points in the path. Index ${index}`);\n        }\n        color.forEach((pointColor) => {\n          const alpha = isNaN(pointColor[3]) ? 255 : pointColor[3];\n          // two copies for outside edge and inside edge each\n          value[i++] = pointColor[0];\n          value[i++] = pointColor[1];\n          value[i++] = pointColor[2];\n          value[i++] = alpha;\n        });\n      } else {\n        const pointColor = color;\n        if (isNaN(pointColor[3])) {\n          pointColor[3] = 255;\n        }\n        for (let ptIndex = 0; ptIndex < path.length; ptIndex++) {\n          // two copies for outside edge and inside edge each\n          value[i++] = pointColor[0];\n          value[i++] = pointColor[1];\n          value[i++] = pointColor[2];\n          value[i++] = pointColor[3];\n        }\n      }\n    });\n  }\n\n  // Override the default picking colors calculation\n  calculatePickingColors(attribute) {\n    const {paths} = this.state;\n    const {value} = attribute;\n\n    let i = 0;\n    paths.forEach((path, index) => {\n      const pickingColor = this.encodePickingColor(index);\n      for (let ptIndex = 1; ptIndex < path.length; ptIndex++) {\n        value[i++] = pickingColor[0];\n        value[i++] = pickingColor[1];\n        value[i++] = pickingColor[2];\n      }\n    });\n  }\n\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = PathLayer;\n\n\nPathLayer.layerName = 'PathLayer';\nPathLayer.defaultProps = defaultProps;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvcGF0aC1sYXllci9wYXRoLWxheWVyLmpzPzA0ZmYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtMYXllcn0gZnJvbSAnLi4vLi4vLi4vbGliJztcbmltcG9ydCB7YXNzZW1ibGVTaGFkZXJzfSBmcm9tICcuLi8uLi8uLi9zaGFkZXItdXRpbHMnO1xuaW1wb3J0IHtHTCwgTW9kZWwsIEdlb21ldHJ5fSBmcm9tICdsdW1hLmdsJztcbmltcG9ydCB7ZnA2NGlmeSwgZW5hYmxlNjRiaXRTdXBwb3J0fSBmcm9tICcuLi8uLi8uLi9saWIvdXRpbHMvZnA2NCc7XG5pbXBvcnQge0NPT1JESU5BVEVfU1lTVEVNfSBmcm9tICcuLi8uLi8uLi9saWInO1xuXG5pbXBvcnQgcGF0aFZlcnRleCBmcm9tICcuL3BhdGgtbGF5ZXItdmVydGV4Lmdsc2wnO1xuaW1wb3J0IHBhdGhWZXJ0ZXg2NCBmcm9tICcuL3BhdGgtbGF5ZXItdmVydGV4LTY0Lmdsc2wnO1xuaW1wb3J0IHBhdGhGcmFnbWVudCBmcm9tICcuL3BhdGgtbGF5ZXItZnJhZ21lbnQuZ2xzbCc7XG5cbmNvbnN0IERFRkFVTFRfQ09MT1IgPSBbMCwgMCwgMCwgMjU1XTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBvcGFjaXR5OiAxLFxuICB3aWR0aFNjYWxlOiAxLCAvLyBzdHJva2Ugd2lkdGggaW4gbWV0ZXJzXG4gIHdpZHRoTWluUGl4ZWxzOiAwLCAvLyAgbWluIHN0cm9rZSB3aWR0aCBpbiBwaXhlbHNcbiAgd2lkdGhNYXhQaXhlbHM6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLCAvLyBtYXggc3Ryb2tlIHdpZHRoIGluIHBpeGVsc1xuICByb3VuZGVkOiBmYWxzZSxcbiAgbWl0ZXJMaW1pdDogNCxcbiAgZnA2NDogZmFsc2UsXG5cbiAgZ2V0UGF0aDogb2JqZWN0ID0+IG9iamVjdC5wYXRoLFxuICBnZXRDb2xvcjogb2JqZWN0ID0+IG9iamVjdC5jb2xvciB8fCBERUZBVUxUX0NPTE9SLFxuICBnZXRXaWR0aDogb2JqZWN0ID0+IG9iamVjdC53aWR0aCB8fCAxXG59O1xuXG5jb25zdCBpc0Nsb3NlZCA9IHBhdGggPT4ge1xuICBjb25zdCBmaXJzdFBvaW50ID0gcGF0aFswXTtcbiAgY29uc3QgbGFzdFBvaW50ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gZmlyc3RQb2ludFswXSA9PT0gbGFzdFBvaW50WzBdICYmIGZpcnN0UG9pbnRbMV0gPT09IGxhc3RQb2ludFsxXSAmJlxuICAgIGZpcnN0UG9pbnRbMl0gPT09IGxhc3RQb2ludFsyXTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhdGhMYXllciBleHRlbmRzIExheWVyIHtcbiAgZ2V0U2hhZGVycygpIHtcbiAgICByZXR1cm4gZW5hYmxlNjRiaXRTdXBwb3J0KHRoaXMucHJvcHMpID8ge1xuICAgICAgdnM6IHBhdGhWZXJ0ZXg2NCwgZnM6IHBhdGhGcmFnbWVudCwgbW9kdWxlczogWydmcDY0JywgJ3Byb2plY3Q2NCddXG4gICAgfSA6IHtcbiAgICAgIHZzOiBwYXRoVmVydGV4LCBmczogcGF0aEZyYWdtZW50LCBtb2R1bGVzOiBbXVxuICAgIH07XG4gIH1cblxuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgY29uc3Qge2dsfSA9IHRoaXMuY29udGV4dDtcbiAgICB0aGlzLnNldFN0YXRlKHttb2RlbDogdGhpcy5fZ2V0TW9kZWwoZ2wpfSk7XG5cbiAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICBpbnN0YW5jZVN0YXJ0UG9zaXRpb25zOiB7c2l6ZTogMywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZVN0YXJ0UG9zaXRpb25zfSxcbiAgICAgIGluc3RhbmNlRW5kUG9zaXRpb25zOiB7c2l6ZTogMywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUVuZFBvc2l0aW9uc30sXG4gICAgICBpbnN0YW5jZUxlZnREZWx0YXM6IHtzaXplOiAzLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlTGVmdERlbHRhc30sXG4gICAgICBpbnN0YW5jZVJpZ2h0RGVsdGFzOiB7c2l6ZTogMywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZVJpZ2h0RGVsdGFzfSxcbiAgICAgIGluc3RhbmNlU3Ryb2tlV2lkdGhzOiB7c2l6ZTogMSwgYWNjZXNzb3I6ICdnZXRXaWR0aCcsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVTdHJva2VXaWR0aHN9LFxuICAgICAgaW5zdGFuY2VDb2xvcnM6IHtzaXplOiA0LCB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLCBhY2Nlc3NvcjogJ2dldENvbG9yJywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUNvbG9yc30sXG4gICAgICBpbnN0YW5jZVBpY2tpbmdDb2xvcnM6IHtzaXplOiAzLCB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlUGlja2luZ0NvbG9yc31cbiAgICB9KTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cbiAgfVxuXG4gIHVwZGF0ZUF0dHJpYnV0ZSh7cHJvcHMsIG9sZFByb3BzLCBjaGFuZ2VGbGFnc30pIHtcbiAgICBpZiAocHJvcHMuZnA2NCAhPT0gb2xkUHJvcHMuZnA2NCkge1xuICAgICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZUFsbCgpO1xuXG4gICAgICBpZiAocHJvcHMuZnA2NCAmJiBwcm9wcy5wcm9qZWN0aW9uTW9kZSA9PT0gQ09PUkRJTkFURV9TWVNURU0uTE5HX0xBVCkge1xuICAgICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICAgICAgaW5zdGFuY2VTdGFydEVuZFBvc2l0aW9uczY0eHlMb3c6IHtcbiAgICAgICAgICAgIHNpemU6IDQsXG4gICAgICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VTdGFydEVuZFBvc2l0aW9uczY0eHlMb3dcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cmlidXRlTWFuYWdlci5yZW1vdmUoW1xuICAgICAgICAgICdpbnN0YW5jZVN0YXJ0RW5kUG9zaXRpb25zNjR4eUxvdydcbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlU3RhdGUoe29sZFByb3BzLCBwcm9wcywgY2hhbmdlRmxhZ3N9KSB7XG4gICAgc3VwZXIudXBkYXRlU3RhdGUoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KTtcblxuICAgIGNvbnN0IHtnZXRQYXRofSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAocHJvcHMuZnA2NCAhPT0gb2xkUHJvcHMuZnA2NCkge1xuICAgICAgY29uc3Qge2dsfSA9IHRoaXMuY29udGV4dDtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe21vZGVsOiB0aGlzLl9nZXRNb2RlbChnbCl9KTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVBdHRyaWJ1dGUoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KTtcblxuICAgIGlmIChjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCkge1xuICAgICAgLy8gdGhpcy5zdGF0ZS5wYXRocyBvbmx5IHN0b3JlcyBwb2ludCBwb3NpdGlvbnMgaW4gZWFjaCBwYXRoXG4gICAgICBjb25zdCBwYXRocyA9IHByb3BzLmRhdGEubWFwKGdldFBhdGgpO1xuICAgICAgY29uc3QgbnVtSW5zdGFuY2VzID0gcGF0aHMucmVkdWNlKChjb3VudCwgcGF0aCkgPT4gY291bnQgKyBwYXRoLmxlbmd0aCAtIDEsIDApO1xuXG4gICAgICB0aGlzLnNldFN0YXRlKHtwYXRocywgbnVtSW5zdGFuY2VzfSk7XG4gICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGVBbGwoKTtcbiAgICB9XG4gIH1cblxuICBkcmF3KHt1bmlmb3Jtc30pIHtcbiAgICBjb25zdCB7XG4gICAgICByb3VuZGVkLCBtaXRlckxpbWl0LCB3aWR0aFNjYWxlLCB3aWR0aE1pblBpeGVscywgd2lkdGhNYXhQaXhlbHNcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIHRoaXMuc3RhdGUubW9kZWwucmVuZGVyKE9iamVjdC5hc3NpZ24oe30sIHVuaWZvcm1zLCB7XG4gICAgICBqb2ludFR5cGU6IE51bWJlcihyb3VuZGVkKSxcbiAgICAgIHdpZHRoU2NhbGUsXG4gICAgICBtaXRlckxpbWl0LFxuICAgICAgd2lkdGhNaW5QaXhlbHMsXG4gICAgICB3aWR0aE1heFBpeGVsc1xuICAgIH0pKTtcbiAgfVxuXG4gIF9nZXRNb2RlbChnbCkge1xuICAgIGNvbnN0IHNoYWRlcnMgPSBhc3NlbWJsZVNoYWRlcnMoZ2wsIHRoaXMuZ2V0U2hhZGVycygpKTtcblxuICAgIC8qXG4gICAgICogICAgICAgX1xuICAgICAqICAgICAgICBcIi1fIDEgICAgICAgICAgICAgICAgICAgMyAgICAgICAgICAgICAgICAgICAgICAgNVxuICAgICAqICAgICBfICAgICBcIm8tLS0tLS0tLS0tLS0tLS0tLS0tLS1vLS0tLS0tLS0tLS0tLS0tLS0tLV8tb1xuICAgICAqICAgICAgIC0gICAvIFwiXCItLS4uX18gICAgICAgICAgICAgICcuICAgICAgICAgICAgIF8uLScgL1xuICAgICAqICAgXyAgICAgXCJALSAtIC0gLSAtIFwiXCItLS4uX18tIC0gLSAtIHggLSAtIC0gLV8uQCcgICAgL1xuICAgICAqICAgIFwiLV8gIC8gICAgICAgICAgICAgICAgICAgXCJcIi0tLi5fXyAnLiAgXywtYCA6ICAgICAvXG4gICAgICogICAgICAgXCJvLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiXCItbycgICAgOiAgICAgL1xuICAgICAqICAgICAgMCwyICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQgLyAnLiAgOiAgICAgL1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvICAgJy46ICAgICAvXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyAgICAgOicuICAgL1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyAgICAgOiAgJywgL1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvICAgICA6ICAgICBvXG4gICAgICovXG5cbiAgICBjb25zdCBTRUdNRU5UX0lORElDRVMgPSBbXG4gICAgICAvLyBzdGFydCBjb3JuZXJcbiAgICAgIDAsIDIsIDEsXG4gICAgICAvLyBib2R5XG4gICAgICAxLCAyLCA0LCAxLCA0LCAzLFxuICAgICAgLy8gZW5kIGNvcm5lclxuICAgICAgMywgNCwgNVxuICAgIF07XG5cbiAgICAvLyBbMF0gcG9zaXRpb24gb24gc2VnbWVudCAtIDA6IHN0YXJ0LCAxOiBlbmRcbiAgICAvLyBbMV0gc2lkZSBvZiBwYXRoIC0gLTE6IGxlZnQsIDA6IGNlbnRlciwgMTogcmlnaHRcbiAgICAvLyBbMl0gcm9sZSAtIDA6IG9mZnNldCBwb2ludCAxOiBqb2ludCBwb2ludFxuICAgIGNvbnN0IFNFR01FTlRfUE9TSVRJT05TID0gW1xuICAgICAgLy8gYmV2ZWwgc3RhcnQgY29ybmVyXG4gICAgICAwLCAwLCAxLFxuICAgICAgLy8gc3RhcnQgaW5uZXIgY29ybmVyXG4gICAgICAwLCAtMSwgMCxcbiAgICAgIC8vIHN0YXJ0IG91dGVyIGNvcm5lclxuICAgICAgMCwgMSwgMCxcbiAgICAgIC8vIGVuZCBpbm5lciBjb3JuZXJcbiAgICAgIDEsIC0xLCAwLFxuICAgICAgLy8gZW5kIG91dGVyIGNvcm5lclxuICAgICAgMSwgMSwgMCxcbiAgICAgIC8vIGJldmVsIGVuZCBjb3JuZXJcbiAgICAgIDEsIDAsIDFcbiAgICBdO1xuXG4gICAgcmV0dXJuIG5ldyBNb2RlbCh7XG4gICAgICBnbCxcbiAgICAgIGlkOiB0aGlzLnByb3BzLmlkLFxuICAgICAgZnM6IHNoYWRlcnMuZnMsXG4gICAgICB2czogc2hhZGVycy52cyxcbiAgICAgIGdlb21ldHJ5OiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICBkcmF3TW9kZTogR0wuVFJJQU5HTEVTLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgaW5kaWNlczogbmV3IFVpbnQxNkFycmF5KFNFR01FTlRfSU5ESUNFUyksXG4gICAgICAgICAgcG9zaXRpb25zOiBuZXcgRmxvYXQzMkFycmF5KFNFR01FTlRfUE9TSVRJT05TKVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIGlzSW5zdGFuY2VkOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICBjYWxjdWxhdGVTdGFydFBvc2l0aW9ucyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7cGF0aHN9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7dmFsdWV9ID0gYXR0cmlidXRlO1xuXG4gICAgbGV0IGkgPSAwO1xuICAgIHBhdGhzLmZvckVhY2gocGF0aCA9PiB7XG4gICAgICBjb25zdCBudW1TZWdtZW50cyA9IHBhdGgubGVuZ3RoIC0gMTtcbiAgICAgIGZvciAobGV0IHB0SW5kZXggPSAwOyBwdEluZGV4IDwgbnVtU2VnbWVudHM7IHB0SW5kZXgrKykge1xuICAgICAgICBjb25zdCBwb2ludCA9IHBhdGhbcHRJbmRleF07XG4gICAgICAgIHZhbHVlW2krK10gPSBwb2ludFswXTtcbiAgICAgICAgdmFsdWVbaSsrXSA9IHBvaW50WzFdO1xuICAgICAgICB2YWx1ZVtpKytdID0gcG9pbnRbMl0gfHwgMDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUVuZFBvc2l0aW9ucyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7cGF0aHN9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7dmFsdWV9ID0gYXR0cmlidXRlO1xuXG4gICAgbGV0IGkgPSAwO1xuICAgIHBhdGhzLmZvckVhY2gocGF0aCA9PiB7XG4gICAgICBmb3IgKGxldCBwdEluZGV4ID0gMTsgcHRJbmRleCA8IHBhdGgubGVuZ3RoOyBwdEluZGV4KyspIHtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBwYXRoW3B0SW5kZXhdO1xuICAgICAgICB2YWx1ZVtpKytdID0gcG9pbnRbMF07XG4gICAgICAgIHZhbHVlW2krK10gPSBwb2ludFsxXTtcbiAgICAgICAgdmFsdWVbaSsrXSA9IHBvaW50WzJdIHx8IDA7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZVN0YXJ0RW5kUG9zaXRpb25zNjR4eUxvdyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7cGF0aHN9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7dmFsdWV9ID0gYXR0cmlidXRlO1xuXG4gICAgbGV0IGkgPSAwO1xuICAgIHBhdGhzLmZvckVhY2gocGF0aCA9PiB7XG4gICAgICBjb25zdCBudW1TZWdtZW50cyA9IHBhdGgubGVuZ3RoIC0gMTtcbiAgICAgIGZvciAobGV0IHB0SW5kZXggPSAwOyBwdEluZGV4IDwgbnVtU2VnbWVudHM7IHB0SW5kZXgrKykge1xuICAgICAgICBjb25zdCBzdGFydFBvaW50ID0gcGF0aFtwdEluZGV4XTtcbiAgICAgICAgY29uc3QgZW5kUG9pbnQgPSBwYXRoW3B0SW5kZXggKyAxXTtcbiAgICAgICAgdmFsdWVbaSsrXSA9IGZwNjRpZnkoc3RhcnRQb2ludFswXSlbMV07XG4gICAgICAgIHZhbHVlW2krK10gPSBmcDY0aWZ5KHN0YXJ0UG9pbnRbMV0pWzFdO1xuICAgICAgICB2YWx1ZVtpKytdID0gZnA2NGlmeShlbmRQb2ludFswXSlbMV07XG4gICAgICAgIHZhbHVlW2krK10gPSBmcDY0aWZ5KGVuZFBvaW50WzFdKVsxXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUxlZnREZWx0YXMoYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge3BhdGhzfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qge3ZhbHVlfSA9IGF0dHJpYnV0ZTtcblxuICAgIGxldCBpID0gMDtcbiAgICBwYXRocy5mb3JFYWNoKHBhdGggPT4ge1xuICAgICAgY29uc3QgbnVtU2VnbWVudHMgPSBwYXRoLmxlbmd0aCAtIDE7XG4gICAgICBsZXQgcHJldlBvaW50ID0gaXNDbG9zZWQocGF0aCkgPyBwYXRoW3BhdGgubGVuZ3RoIC0gMl0gOiBwYXRoWzBdO1xuXG4gICAgICBmb3IgKGxldCBwdEluZGV4ID0gMDsgcHRJbmRleCA8IG51bVNlZ21lbnRzOyBwdEluZGV4KyspIHtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBwYXRoW3B0SW5kZXhdO1xuICAgICAgICB2YWx1ZVtpKytdID0gcG9pbnRbMF0gLSBwcmV2UG9pbnRbMF07XG4gICAgICAgIHZhbHVlW2krK10gPSBwb2ludFsxXSAtIHByZXZQb2ludFsxXTtcbiAgICAgICAgdmFsdWVbaSsrXSA9IChwb2ludFsyXSAtIHByZXZQb2ludFsyXSkgfHwgMDtcbiAgICAgICAgcHJldlBvaW50ID0gcG9pbnQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjYWxjdWxhdGVSaWdodERlbHRhcyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7cGF0aHN9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7dmFsdWV9ID0gYXR0cmlidXRlO1xuXG4gICAgbGV0IGkgPSAwO1xuICAgIHBhdGhzLmZvckVhY2gocGF0aCA9PiB7XG4gICAgICBmb3IgKGxldCBwdEluZGV4ID0gMTsgcHRJbmRleCA8IHBhdGgubGVuZ3RoOyBwdEluZGV4KyspIHtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBwYXRoW3B0SW5kZXhdO1xuICAgICAgICBsZXQgbmV4dFBvaW50ID0gcGF0aFtwdEluZGV4ICsgMV07XG4gICAgICAgIGlmICghbmV4dFBvaW50KSB7XG4gICAgICAgICAgbmV4dFBvaW50ID0gaXNDbG9zZWQocGF0aCkgPyBwYXRoWzFdIDogcG9pbnQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZVtpKytdID0gbmV4dFBvaW50WzBdIC0gcG9pbnRbMF07XG4gICAgICAgIHZhbHVlW2krK10gPSBuZXh0UG9pbnRbMV0gLSBwb2ludFsxXTtcbiAgICAgICAgdmFsdWVbaSsrXSA9IChuZXh0UG9pbnRbMl0gLSBwb2ludFsyXSkgfHwgMDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNhbGN1bGF0ZVN0cm9rZVdpZHRocyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7ZGF0YSwgZ2V0V2lkdGh9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7cGF0aHN9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7dmFsdWV9ID0gYXR0cmlidXRlO1xuXG4gICAgbGV0IGkgPSAwO1xuICAgIHBhdGhzLmZvckVhY2goKHBhdGgsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCB3aWR0aCA9IGdldFdpZHRoKGRhdGFbaW5kZXhdLCBpbmRleCk7XG4gICAgICBmb3IgKGxldCBwdEluZGV4ID0gMTsgcHRJbmRleCA8IHBhdGgubGVuZ3RoOyBwdEluZGV4KyspIHtcbiAgICAgICAgdmFsdWVbaSsrXSA9IHdpZHRoO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY2FsY3VsYXRlQ29sb3JzKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtkYXRhLCBnZXRDb2xvcn0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHtwYXRoc30gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHt2YWx1ZX0gPSBhdHRyaWJ1dGU7XG5cbiAgICBsZXQgaSA9IDA7XG4gICAgcGF0aHMuZm9yRWFjaCgocGF0aCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGNvbG9yID0gZ2V0Q29sb3IoZGF0YVtpbmRleF0sIGluZGV4KSB8fCBERUZBVUxUX0NPTE9SO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29sb3JbMF0pKSB7XG4gICAgICAgIGlmIChjb2xvci5sZW5ndGggIT09IHBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXRoTGF5ZXIgZ2V0Q29sb3IoKSByZXR1cm5lZCBhIGNvbG9yIGFycmF5LCBidXQgdGhlIG51bWJlciBvZiAnICtcbiAgICAgICAgICAgYGNvbG9ycyByZXR1cm5lZCBkb2Vzbid0IG1hdGNoIHRoZSBudW1iZXIgb2YgcG9pbnRzIGluIHRoZSBwYXRoLiBJbmRleCAke2luZGV4fWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbG9yLmZvckVhY2goKHBvaW50Q29sb3IpID0+IHtcbiAgICAgICAgICBjb25zdCBhbHBoYSA9IGlzTmFOKHBvaW50Q29sb3JbM10pID8gMjU1IDogcG9pbnRDb2xvclszXTtcbiAgICAgICAgICAvLyB0d28gY29waWVzIGZvciBvdXRzaWRlIGVkZ2UgYW5kIGluc2lkZSBlZGdlIGVhY2hcbiAgICAgICAgICB2YWx1ZVtpKytdID0gcG9pbnRDb2xvclswXTtcbiAgICAgICAgICB2YWx1ZVtpKytdID0gcG9pbnRDb2xvclsxXTtcbiAgICAgICAgICB2YWx1ZVtpKytdID0gcG9pbnRDb2xvclsyXTtcbiAgICAgICAgICB2YWx1ZVtpKytdID0gYWxwaGE7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcG9pbnRDb2xvciA9IGNvbG9yO1xuICAgICAgICBpZiAoaXNOYU4ocG9pbnRDb2xvclszXSkpIHtcbiAgICAgICAgICBwb2ludENvbG9yWzNdID0gMjU1O1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHB0SW5kZXggPSAwOyBwdEluZGV4IDwgcGF0aC5sZW5ndGg7IHB0SW5kZXgrKykge1xuICAgICAgICAgIC8vIHR3byBjb3BpZXMgZm9yIG91dHNpZGUgZWRnZSBhbmQgaW5zaWRlIGVkZ2UgZWFjaFxuICAgICAgICAgIHZhbHVlW2krK10gPSBwb2ludENvbG9yWzBdO1xuICAgICAgICAgIHZhbHVlW2krK10gPSBwb2ludENvbG9yWzFdO1xuICAgICAgICAgIHZhbHVlW2krK10gPSBwb2ludENvbG9yWzJdO1xuICAgICAgICAgIHZhbHVlW2krK10gPSBwb2ludENvbG9yWzNdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBPdmVycmlkZSB0aGUgZGVmYXVsdCBwaWNraW5nIGNvbG9ycyBjYWxjdWxhdGlvblxuICBjYWxjdWxhdGVQaWNraW5nQ29sb3JzKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtwYXRoc30gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHt2YWx1ZX0gPSBhdHRyaWJ1dGU7XG5cbiAgICBsZXQgaSA9IDA7XG4gICAgcGF0aHMuZm9yRWFjaCgocGF0aCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHBpY2tpbmdDb2xvciA9IHRoaXMuZW5jb2RlUGlja2luZ0NvbG9yKGluZGV4KTtcbiAgICAgIGZvciAobGV0IHB0SW5kZXggPSAxOyBwdEluZGV4IDwgcGF0aC5sZW5ndGg7IHB0SW5kZXgrKykge1xuICAgICAgICB2YWx1ZVtpKytdID0gcGlja2luZ0NvbG9yWzBdO1xuICAgICAgICB2YWx1ZVtpKytdID0gcGlja2luZ0NvbG9yWzFdO1xuICAgICAgICB2YWx1ZVtpKytdID0gcGlja2luZ0NvbG9yWzJdO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbn1cblxuUGF0aExheWVyLmxheWVyTmFtZSA9ICdQYXRoTGF5ZXInO1xuUGF0aExheWVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xheWVycy9jb3JlL3BhdGgtbGF5ZXIvcGF0aC1sYXllci5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 11 */
/* exports provided: get */
/* exports used: get */
/*!******************************!*\
  !*** ./src/lib/utils/get.js ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (immutable) */ __webpack_exports__[\"a\"] = get;\n/**\n * Access properties of nested containers using dot-path notation\n * - Supports plain objects and arrays, as well as classes with `get` methods\n *   such as ES6 Maps, Immutable.js objects etc\n * - Returns undefined if any container is not valid, instead of throwing\n *\n * @param {Object} container - container that supports get\n * @param {String|*} compositeKey - key to access, can be '.'-separated string\n * @return {*} - value in the final key of the nested container\n */\nfunction get(container, compositeKey) {\n  // Split the key into subkeys\n  const keyList = getKeys(compositeKey);\n  // Recursively get the value of each key;\n  let value = container;\n  for (const key of keyList) {\n    // If any intermediate subfield is not a container, return undefined\n    if (!isObject(value)) {\n      return undefined;\n    }\n    // Get the `getter` for this container\n    const getter = getGetter(value);\n    // Use the getter to get the value for the key\n    value = getter(value, key);\n  }\n  return value;\n}\n\n/**\n * Checks if argument is an indexable object (not a primitive value, nor null)\n * @param {*} value - JavaScript value to be tested\n * @return {Boolean} - true if argument is a JavaScript object\n */\nfunction isObject(value) {\n  return value !== null && typeof value === 'object';\n}\n\n// Default getter is container indexing\nconst squareBracketGetter = (container, key) => container[key];\nconst getMethodGetter = (obj, key) => obj.get(key);\n// Cache key to key arrays for speed\nconst keyMap = {};\n\n// Looks for a `get` function on the prototype\n// TODO - follow prototype chain?\n// @private\n// @return {Function} - get function: (container, key) => value\nfunction getGetter(container) {\n  // Check if container has a special get method\n  const prototype = Object.getPrototypeOf(container);\n  return prototype.get ? getMethodGetter : squareBracketGetter;\n}\n\n// Takes a string of '.' separated keys and returns an array of keys\n// E.g. 'feature.geometry.type' => 'feature', 'geometry', 'type'\n// @private\nfunction getKeys(compositeKey) {\n  if (typeof compositeKey === 'string') {\n    // else assume string and split around dots\n    let keyList = keyMap[compositeKey];\n    if (!keyList) {\n      keyList = compositeKey.split('.');\n      keyMap[compositeKey] = keyList;\n    }\n    return keyList;\n  }\n  // Wrap in array if needed\n  return Array.isArray(compositeKey) ? compositeKey : [compositeKey];\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL3V0aWxzL2dldC5qcz9mZmUyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQWNjZXNzIHByb3BlcnRpZXMgb2YgbmVzdGVkIGNvbnRhaW5lcnMgdXNpbmcgZG90LXBhdGggbm90YXRpb25cbiAqIC0gU3VwcG9ydHMgcGxhaW4gb2JqZWN0cyBhbmQgYXJyYXlzLCBhcyB3ZWxsIGFzIGNsYXNzZXMgd2l0aCBgZ2V0YCBtZXRob2RzXG4gKiAgIHN1Y2ggYXMgRVM2IE1hcHMsIEltbXV0YWJsZS5qcyBvYmplY3RzIGV0Y1xuICogLSBSZXR1cm5zIHVuZGVmaW5lZCBpZiBhbnkgY29udGFpbmVyIGlzIG5vdCB2YWxpZCwgaW5zdGVhZCBvZiB0aHJvd2luZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250YWluZXIgLSBjb250YWluZXIgdGhhdCBzdXBwb3J0cyBnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfCp9IGNvbXBvc2l0ZUtleSAtIGtleSB0byBhY2Nlc3MsIGNhbiBiZSAnLictc2VwYXJhdGVkIHN0cmluZ1xuICogQHJldHVybiB7Kn0gLSB2YWx1ZSBpbiB0aGUgZmluYWwga2V5IG9mIHRoZSBuZXN0ZWQgY29udGFpbmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXQoY29udGFpbmVyLCBjb21wb3NpdGVLZXkpIHtcbiAgLy8gU3BsaXQgdGhlIGtleSBpbnRvIHN1YmtleXNcbiAgY29uc3Qga2V5TGlzdCA9IGdldEtleXMoY29tcG9zaXRlS2V5KTtcbiAgLy8gUmVjdXJzaXZlbHkgZ2V0IHRoZSB2YWx1ZSBvZiBlYWNoIGtleTtcbiAgbGV0IHZhbHVlID0gY29udGFpbmVyO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlMaXN0KSB7XG4gICAgLy8gSWYgYW55IGludGVybWVkaWF0ZSBzdWJmaWVsZCBpcyBub3QgYSBjb250YWluZXIsIHJldHVybiB1bmRlZmluZWRcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gR2V0IHRoZSBgZ2V0dGVyYCBmb3IgdGhpcyBjb250YWluZXJcbiAgICBjb25zdCBnZXR0ZXIgPSBnZXRHZXR0ZXIodmFsdWUpO1xuICAgIC8vIFVzZSB0aGUgZ2V0dGVyIHRvIGdldCB0aGUgdmFsdWUgZm9yIHRoZSBrZXlcbiAgICB2YWx1ZSA9IGdldHRlcih2YWx1ZSwga2V5KTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFyZ3VtZW50IGlzIGFuIGluZGV4YWJsZSBvYmplY3QgKG5vdCBhIHByaW1pdGl2ZSB2YWx1ZSwgbm9yIG51bGwpXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gSmF2YVNjcmlwdCB2YWx1ZSB0byBiZSB0ZXN0ZWRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IC0gdHJ1ZSBpZiBhcmd1bWVudCBpcyBhIEphdmFTY3JpcHQgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xufVxuXG4vLyBEZWZhdWx0IGdldHRlciBpcyBjb250YWluZXIgaW5kZXhpbmdcbmNvbnN0IHNxdWFyZUJyYWNrZXRHZXR0ZXIgPSAoY29udGFpbmVyLCBrZXkpID0+IGNvbnRhaW5lcltrZXldO1xuY29uc3QgZ2V0TWV0aG9kR2V0dGVyID0gKG9iaiwga2V5KSA9PiBvYmouZ2V0KGtleSk7XG4vLyBDYWNoZSBrZXkgdG8ga2V5IGFycmF5cyBmb3Igc3BlZWRcbmNvbnN0IGtleU1hcCA9IHt9O1xuXG4vLyBMb29rcyBmb3IgYSBgZ2V0YCBmdW5jdGlvbiBvbiB0aGUgcHJvdG90eXBlXG4vLyBUT0RPIC0gZm9sbG93IHByb3RvdHlwZSBjaGFpbj9cbi8vIEBwcml2YXRlXG4vLyBAcmV0dXJuIHtGdW5jdGlvbn0gLSBnZXQgZnVuY3Rpb246IChjb250YWluZXIsIGtleSkgPT4gdmFsdWVcbmZ1bmN0aW9uIGdldEdldHRlcihjb250YWluZXIpIHtcbiAgLy8gQ2hlY2sgaWYgY29udGFpbmVyIGhhcyBhIHNwZWNpYWwgZ2V0IG1ldGhvZFxuICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY29udGFpbmVyKTtcbiAgcmV0dXJuIHByb3RvdHlwZS5nZXQgPyBnZXRNZXRob2RHZXR0ZXIgOiBzcXVhcmVCcmFja2V0R2V0dGVyO1xufVxuXG4vLyBUYWtlcyBhIHN0cmluZyBvZiAnLicgc2VwYXJhdGVkIGtleXMgYW5kIHJldHVybnMgYW4gYXJyYXkgb2Yga2V5c1xuLy8gRS5nLiAnZmVhdHVyZS5nZW9tZXRyeS50eXBlJyA9PiAnZmVhdHVyZScsICdnZW9tZXRyeScsICd0eXBlJ1xuLy8gQHByaXZhdGVcbmZ1bmN0aW9uIGdldEtleXMoY29tcG9zaXRlS2V5KSB7XG4gIGlmICh0eXBlb2YgY29tcG9zaXRlS2V5ID09PSAnc3RyaW5nJykge1xuICAgIC8vIGVsc2UgYXNzdW1lIHN0cmluZyBhbmQgc3BsaXQgYXJvdW5kIGRvdHNcbiAgICBsZXQga2V5TGlzdCA9IGtleU1hcFtjb21wb3NpdGVLZXldO1xuICAgIGlmICgha2V5TGlzdCkge1xuICAgICAga2V5TGlzdCA9IGNvbXBvc2l0ZUtleS5zcGxpdCgnLicpO1xuICAgICAga2V5TWFwW2NvbXBvc2l0ZUtleV0gPSBrZXlMaXN0O1xuICAgIH1cbiAgICByZXR1cm4ga2V5TGlzdDtcbiAgfVxuICAvLyBXcmFwIGluIGFycmF5IGlmIG5lZWRlZFxuICByZXR1cm4gQXJyYXkuaXNBcnJheShjb21wb3NpdGVLZXkpID8gY29tcG9zaXRlS2V5IDogW2NvbXBvc2l0ZUtleV07XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9saWIvdXRpbHMvZ2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 12 */
/* exports provided: default */
/* exports used: default */
/*!*****************************!*\
  !*** ./src/react/deckgl.js ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(/*! react */ 34);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__autobind__ = __webpack_require__(/*! ./autobind */ 29);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__webgl_renderer__ = __webpack_require__(/*! ./webgl-renderer */ 105);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib__ = __webpack_require__(/*! ../lib */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__experimental__ = __webpack_require__(/*! ../experimental */ 51);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_luma_gl__ = __webpack_require__(/*! luma.gl */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__lib_viewports__ = __webpack_require__(/*! ../lib/viewports */ 16);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__lib_utils__ = __webpack_require__(/*! ../lib/utils */ 2);\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\n\n\nfunction noop() {}\n\nconst propTypes = {\n  id: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].string,\n  width: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].number.isRequired,\n  height: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].number.isRequired,\n  layers: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].arrayOf(__WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].instanceOf(__WEBPACK_IMPORTED_MODULE_3__lib__[\"a\" /* Layer */])).isRequired,\n  effects: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].arrayOf(__WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].instanceOf(__WEBPACK_IMPORTED_MODULE_4__experimental__[\"a\" /* Effect */])),\n  gl: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].object,\n  debug: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].bool,\n  viewport: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].instanceOf(__WEBPACK_IMPORTED_MODULE_6__lib_viewports__[\"b\" /* Viewport */]),\n  onWebGLInitialized: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func,\n  onLayerClick: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func,\n  onLayerHover: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func,\n  onAfterRender: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func\n};\n\nconst defaultProps = {\n  id: 'deckgl-overlay',\n  debug: false,\n  gl: null,\n  effects: [],\n  onWebGLInitialized: noop,\n  onLayerClick: noop,\n  onLayerHover: noop,\n  onAfterRender: noop\n};\n\nclass DeckGL extends __WEBPACK_IMPORTED_MODULE_0_react___default.a.Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n    this.needsRedraw = true;\n    this.layerManager = null;\n    this.effectManager = null;\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__autobind__[\"a\" /* default */])(this);\n  }\n\n  componentWillReceiveProps(nextProps) {\n    this._updateLayers(nextProps);\n  }\n\n  _updateLayers(nextProps) {\n    const {width, height, latitude, longitude, zoom, pitch, bearing, altitude} = nextProps;\n    let {viewport} = nextProps;\n\n    // If Viewport is not supplied, create one from mercator props\n    viewport = viewport || new __WEBPACK_IMPORTED_MODULE_6__lib_viewports__[\"a\" /* WebMercatorViewport */]({\n      width, height, latitude, longitude, zoom, pitch, bearing, altitude\n    });\n\n    if (this.layerManager) {\n      this.layerManager\n        .setViewport(viewport)\n        .updateLayers({newLayers: nextProps.layers});\n    }\n  }\n\n  _onRendererInitialized({gl, canvas}) {\n    gl.enable(__WEBPACK_IMPORTED_MODULE_5_luma_gl__[\"GL\"].BLEND);\n    gl.blendFunc(__WEBPACK_IMPORTED_MODULE_5_luma_gl__[\"GL\"].SRC_ALPHA, __WEBPACK_IMPORTED_MODULE_5_luma_gl__[\"GL\"].ONE_MINUS_SRC_ALPHA);\n\n    this.props.onWebGLInitialized(gl);\n\n    // Note: avoid React setState due GL animation loop / setState timing issue\n    this.layerManager = new __WEBPACK_IMPORTED_MODULE_3__lib__[\"c\" /* LayerManager */]({gl});\n    this.effectManager = new __WEBPACK_IMPORTED_MODULE_4__experimental__[\"b\" /* EffectManager */]({gl, layerManager: this.layerManager});\n    for (const effect of this.props.effects) {\n      this.effectManager.addEffect(effect);\n    }\n    this._updateLayers(this.props);\n\n    // Check if a mouse event has been specified and that at least one of the layers is pickable\n    const hasEvent = this.props.onLayerClick !== noop || this.props.onLayerHover !== noop;\n    const hasPickableLayer = this.layerManager.layers.map(l => l.props.pickable).includes(true);\n    if (this.layerManager.layers.length && hasEvent && !hasPickableLayer) {\n      __WEBPACK_IMPORTED_MODULE_7__lib_utils__[\"a\" /* log */].once(\n        0,\n        'You have supplied a mouse event handler but none of your layers got the `pickable` flag.'\n      );\n    }\n\n    this.events = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5_luma_gl__[\"addEvents\"])(canvas, {\n      cacheSize: false,\n      cachePosition: false,\n      centerOrigin: false,\n      onClick: this._onClick,\n      onMouseMove: this._onMouseMove\n    });\n  }\n\n  // Route events to layers\n  _onClick(event) {\n    const {x, y} = event;\n    const selectedInfos = this.layerManager.pickLayer({x, y, mode: 'click'});\n    if (selectedInfos.length) {\n      const firstInfo = selectedInfos.find(info => info.index >= 0);\n      // Event.event holds the original MouseEvent object\n      this.props.onLayerClick(firstInfo, selectedInfos, event.event);\n    }\n  }\n\n  // Route events to layers\n  _onMouseMove(event) {\n    const {x, y} = event;\n    const selectedInfos = this.layerManager.pickLayer({x, y, mode: 'hover'});\n    if (selectedInfos.length) {\n      const firstInfo = selectedInfos.find(info => info.index >= 0);\n      // Event.event holds the original MouseEvent object\n      this.props.onLayerHover(firstInfo, selectedInfos, event.event);\n    }\n  }\n\n  _onRenderFrame({gl}) {\n    const redraw = this.layerManager.needsRedraw({clearRedrawFlags: true});\n    if (!redraw) {\n      return;\n    }\n\n    // clear depth and color buffers\n    gl.clear(__WEBPACK_IMPORTED_MODULE_5_luma_gl__[\"GL\"].COLOR_BUFFER_BIT | __WEBPACK_IMPORTED_MODULE_5_luma_gl__[\"GL\"].DEPTH_BUFFER_BIT);\n\n    this.effectManager.preDraw();\n    this.layerManager.drawLayers({pass: 'primary'});\n    this.effectManager.draw();\n  }\n\n  render() {\n    const {width, height, gl, debug} = this.props;\n\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_react__[\"createElement\"])(__WEBPACK_IMPORTED_MODULE_2__webgl_renderer__[\"a\" /* default */], Object.assign({}, this.props, {\n      width,\n      height,\n      gl,\n      debug,\n      viewport: {x: 0, y: 0, width, height},\n      onRendererInitialized: this._onRendererInitialized,\n      onNeedRedraw: this._onNeedRedraw,\n      onRenderFrame: this._onRenderFrame,\n      onMouseMove: this._onMouseMove,\n      onClick: this._onClick\n    }));\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = DeckGL;\n\n\nDeckGL.propTypes = propTypes;\nDeckGL.defaultProps = defaultProps;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcmVhY3QvZGVja2dsLmpzP2FmOTQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cbmltcG9ydCBSZWFjdCwge1Byb3BUeXBlcywgY3JlYXRlRWxlbWVudH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGF1dG9iaW5kIGZyb20gJy4vYXV0b2JpbmQnO1xuaW1wb3J0IFdlYkdMUmVuZGVyZXIgZnJvbSAnLi93ZWJnbC1yZW5kZXJlcic7XG5pbXBvcnQge0xheWVyTWFuYWdlciwgTGF5ZXJ9IGZyb20gJy4uL2xpYic7XG5pbXBvcnQge0VmZmVjdE1hbmFnZXIsIEVmZmVjdH0gZnJvbSAnLi4vZXhwZXJpbWVudGFsJztcbmltcG9ydCB7R0wsIGFkZEV2ZW50c30gZnJvbSAnbHVtYS5nbCc7XG5pbXBvcnQge1ZpZXdwb3J0LCBXZWJNZXJjYXRvclZpZXdwb3J0fSBmcm9tICcuLi9saWIvdmlld3BvcnRzJztcbmltcG9ydCB7bG9nfSBmcm9tICcuLi9saWIvdXRpbHMnO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuY29uc3QgcHJvcFR5cGVzID0ge1xuICBpZDogUHJvcFR5cGVzLnN0cmluZyxcbiAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGxheWVyczogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLmluc3RhbmNlT2YoTGF5ZXIpKS5pc1JlcXVpcmVkLFxuICBlZmZlY3RzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuaW5zdGFuY2VPZihFZmZlY3QpKSxcbiAgZ2w6IFByb3BUeXBlcy5vYmplY3QsXG4gIGRlYnVnOiBQcm9wVHlwZXMuYm9vbCxcbiAgdmlld3BvcnQ6IFByb3BUeXBlcy5pbnN0YW5jZU9mKFZpZXdwb3J0KSxcbiAgb25XZWJHTEluaXRpYWxpemVkOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25MYXllckNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25MYXllckhvdmVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25BZnRlclJlbmRlcjogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgaWQ6ICdkZWNrZ2wtb3ZlcmxheScsXG4gIGRlYnVnOiBmYWxzZSxcbiAgZ2w6IG51bGwsXG4gIGVmZmVjdHM6IFtdLFxuICBvbldlYkdMSW5pdGlhbGl6ZWQ6IG5vb3AsXG4gIG9uTGF5ZXJDbGljazogbm9vcCxcbiAgb25MYXllckhvdmVyOiBub29wLFxuICBvbkFmdGVyUmVuZGVyOiBub29wXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWNrR0wgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge307XG4gICAgdGhpcy5uZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgdGhpcy5sYXllck1hbmFnZXIgPSBudWxsO1xuICAgIHRoaXMuZWZmZWN0TWFuYWdlciA9IG51bGw7XG4gICAgYXV0b2JpbmQodGhpcyk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIHRoaXMuX3VwZGF0ZUxheWVycyhuZXh0UHJvcHMpO1xuICB9XG5cbiAgX3VwZGF0ZUxheWVycyhuZXh0UHJvcHMpIHtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodCwgbGF0aXR1ZGUsIGxvbmdpdHVkZSwgem9vbSwgcGl0Y2gsIGJlYXJpbmcsIGFsdGl0dWRlfSA9IG5leHRQcm9wcztcbiAgICBsZXQge3ZpZXdwb3J0fSA9IG5leHRQcm9wcztcblxuICAgIC8vIElmIFZpZXdwb3J0IGlzIG5vdCBzdXBwbGllZCwgY3JlYXRlIG9uZSBmcm9tIG1lcmNhdG9yIHByb3BzXG4gICAgdmlld3BvcnQgPSB2aWV3cG9ydCB8fCBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydCh7XG4gICAgICB3aWR0aCwgaGVpZ2h0LCBsYXRpdHVkZSwgbG9uZ2l0dWRlLCB6b29tLCBwaXRjaCwgYmVhcmluZywgYWx0aXR1ZGVcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmxheWVyTWFuYWdlcikge1xuICAgICAgdGhpcy5sYXllck1hbmFnZXJcbiAgICAgICAgLnNldFZpZXdwb3J0KHZpZXdwb3J0KVxuICAgICAgICAudXBkYXRlTGF5ZXJzKHtuZXdMYXllcnM6IG5leHRQcm9wcy5sYXllcnN9KTtcbiAgICB9XG4gIH1cblxuICBfb25SZW5kZXJlckluaXRpYWxpemVkKHtnbCwgY2FudmFzfSkge1xuICAgIGdsLmVuYWJsZShHTC5CTEVORCk7XG4gICAgZ2wuYmxlbmRGdW5jKEdMLlNSQ19BTFBIQSwgR0wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG5cbiAgICB0aGlzLnByb3BzLm9uV2ViR0xJbml0aWFsaXplZChnbCk7XG5cbiAgICAvLyBOb3RlOiBhdm9pZCBSZWFjdCBzZXRTdGF0ZSBkdWUgR0wgYW5pbWF0aW9uIGxvb3AgLyBzZXRTdGF0ZSB0aW1pbmcgaXNzdWVcbiAgICB0aGlzLmxheWVyTWFuYWdlciA9IG5ldyBMYXllck1hbmFnZXIoe2dsfSk7XG4gICAgdGhpcy5lZmZlY3RNYW5hZ2VyID0gbmV3IEVmZmVjdE1hbmFnZXIoe2dsLCBsYXllck1hbmFnZXI6IHRoaXMubGF5ZXJNYW5hZ2VyfSk7XG4gICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgdGhpcy5wcm9wcy5lZmZlY3RzKSB7XG4gICAgICB0aGlzLmVmZmVjdE1hbmFnZXIuYWRkRWZmZWN0KGVmZmVjdCk7XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZUxheWVycyh0aGlzLnByb3BzKTtcblxuICAgIC8vIENoZWNrIGlmIGEgbW91c2UgZXZlbnQgaGFzIGJlZW4gc3BlY2lmaWVkIGFuZCB0aGF0IGF0IGxlYXN0IG9uZSBvZiB0aGUgbGF5ZXJzIGlzIHBpY2thYmxlXG4gICAgY29uc3QgaGFzRXZlbnQgPSB0aGlzLnByb3BzLm9uTGF5ZXJDbGljayAhPT0gbm9vcCB8fCB0aGlzLnByb3BzLm9uTGF5ZXJIb3ZlciAhPT0gbm9vcDtcbiAgICBjb25zdCBoYXNQaWNrYWJsZUxheWVyID0gdGhpcy5sYXllck1hbmFnZXIubGF5ZXJzLm1hcChsID0+IGwucHJvcHMucGlja2FibGUpLmluY2x1ZGVzKHRydWUpO1xuICAgIGlmICh0aGlzLmxheWVyTWFuYWdlci5sYXllcnMubGVuZ3RoICYmIGhhc0V2ZW50ICYmICFoYXNQaWNrYWJsZUxheWVyKSB7XG4gICAgICBsb2cub25jZShcbiAgICAgICAgMCxcbiAgICAgICAgJ1lvdSBoYXZlIHN1cHBsaWVkIGEgbW91c2UgZXZlbnQgaGFuZGxlciBidXQgbm9uZSBvZiB5b3VyIGxheWVycyBnb3QgdGhlIGBwaWNrYWJsZWAgZmxhZy4nXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuZXZlbnRzID0gYWRkRXZlbnRzKGNhbnZhcywge1xuICAgICAgY2FjaGVTaXplOiBmYWxzZSxcbiAgICAgIGNhY2hlUG9zaXRpb246IGZhbHNlLFxuICAgICAgY2VudGVyT3JpZ2luOiBmYWxzZSxcbiAgICAgIG9uQ2xpY2s6IHRoaXMuX29uQ2xpY2ssXG4gICAgICBvbk1vdXNlTW92ZTogdGhpcy5fb25Nb3VzZU1vdmVcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFJvdXRlIGV2ZW50cyB0byBsYXllcnNcbiAgX29uQ2xpY2soZXZlbnQpIHtcbiAgICBjb25zdCB7eCwgeX0gPSBldmVudDtcbiAgICBjb25zdCBzZWxlY3RlZEluZm9zID0gdGhpcy5sYXllck1hbmFnZXIucGlja0xheWVyKHt4LCB5LCBtb2RlOiAnY2xpY2snfSk7XG4gICAgaWYgKHNlbGVjdGVkSW5mb3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCBmaXJzdEluZm8gPSBzZWxlY3RlZEluZm9zLmZpbmQoaW5mbyA9PiBpbmZvLmluZGV4ID49IDApO1xuICAgICAgLy8gRXZlbnQuZXZlbnQgaG9sZHMgdGhlIG9yaWdpbmFsIE1vdXNlRXZlbnQgb2JqZWN0XG4gICAgICB0aGlzLnByb3BzLm9uTGF5ZXJDbGljayhmaXJzdEluZm8sIHNlbGVjdGVkSW5mb3MsIGV2ZW50LmV2ZW50KTtcbiAgICB9XG4gIH1cblxuICAvLyBSb3V0ZSBldmVudHMgdG8gbGF5ZXJzXG4gIF9vbk1vdXNlTW92ZShldmVudCkge1xuICAgIGNvbnN0IHt4LCB5fSA9IGV2ZW50O1xuICAgIGNvbnN0IHNlbGVjdGVkSW5mb3MgPSB0aGlzLmxheWVyTWFuYWdlci5waWNrTGF5ZXIoe3gsIHksIG1vZGU6ICdob3Zlcid9KTtcbiAgICBpZiAoc2VsZWN0ZWRJbmZvcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGZpcnN0SW5mbyA9IHNlbGVjdGVkSW5mb3MuZmluZChpbmZvID0+IGluZm8uaW5kZXggPj0gMCk7XG4gICAgICAvLyBFdmVudC5ldmVudCBob2xkcyB0aGUgb3JpZ2luYWwgTW91c2VFdmVudCBvYmplY3RcbiAgICAgIHRoaXMucHJvcHMub25MYXllckhvdmVyKGZpcnN0SW5mbywgc2VsZWN0ZWRJbmZvcywgZXZlbnQuZXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIF9vblJlbmRlckZyYW1lKHtnbH0pIHtcbiAgICBjb25zdCByZWRyYXcgPSB0aGlzLmxheWVyTWFuYWdlci5uZWVkc1JlZHJhdyh7Y2xlYXJSZWRyYXdGbGFnczogdHJ1ZX0pO1xuICAgIGlmICghcmVkcmF3KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY2xlYXIgZGVwdGggYW5kIGNvbG9yIGJ1ZmZlcnNcbiAgICBnbC5jbGVhcihHTC5DT0xPUl9CVUZGRVJfQklUIHwgR0wuREVQVEhfQlVGRkVSX0JJVCk7XG5cbiAgICB0aGlzLmVmZmVjdE1hbmFnZXIucHJlRHJhdygpO1xuICAgIHRoaXMubGF5ZXJNYW5hZ2VyLmRyYXdMYXllcnMoe3Bhc3M6ICdwcmltYXJ5J30pO1xuICAgIHRoaXMuZWZmZWN0TWFuYWdlci5kcmF3KCk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHQsIGdsLCBkZWJ1Z30gPSB0aGlzLnByb3BzO1xuXG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoV2ViR0xSZW5kZXJlciwgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcywge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBnbCxcbiAgICAgIGRlYnVnLFxuICAgICAgdmlld3BvcnQ6IHt4OiAwLCB5OiAwLCB3aWR0aCwgaGVpZ2h0fSxcbiAgICAgIG9uUmVuZGVyZXJJbml0aWFsaXplZDogdGhpcy5fb25SZW5kZXJlckluaXRpYWxpemVkLFxuICAgICAgb25OZWVkUmVkcmF3OiB0aGlzLl9vbk5lZWRSZWRyYXcsXG4gICAgICBvblJlbmRlckZyYW1lOiB0aGlzLl9vblJlbmRlckZyYW1lLFxuICAgICAgb25Nb3VzZU1vdmU6IHRoaXMuX29uTW91c2VNb3ZlLFxuICAgICAgb25DbGljazogdGhpcy5fb25DbGlja1xuICAgIH0pKTtcbiAgfVxufVxuXG5EZWNrR0wucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuRGVja0dMLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3JlYWN0L2RlY2tnbC5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 13 */
/* exports provided: isSimple, normalize, getVertexCount, getTriangleCount, forEachVertex */
/* exports used: normalize, getVertexCount, getTriangleCount, forEachVertex */
/*!********************************************************!*\
  !*** ./src/layers/core/solid-polygon-layer/polygon.js ***!
  \********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib_utils__ = __webpack_require__(/*! ../../../lib/utils */ 2);\n/* unused harmony export isSimple */\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = normalize;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = getVertexCount;\n/* harmony export (immutable) */ __webpack_exports__[\"c\"] = getTriangleCount;\n/* harmony export (immutable) */ __webpack_exports__[\"d\"] = forEachVertex;\n\n\n// Basic polygon support\n//\n// Handles simple and complex polygons\n// Simple polygons are arrays of vertices, implicitly \"closed\"\n// Complex polygons are arrays of simple polygons, with the first polygon\n// representing the outer hull and other polygons representing holes\n\n/**\n * Check if this is a non-nested polygon (i.e. the first element of the first element is a number)\n * @param {Array} polygon - either a complex or simple polygon\n * @return {Boolean} - true if the polygon is a simple polygon (i.e. not an array of polygons)\n */\nfunction isSimple(polygon) {\n  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"e\" /* count */])(polygon) >= 1 &&\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"e\" /* count */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"d\" /* get */])(polygon, 0)) >= 2 &&\n    Number.isFinite(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"d\" /* get */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"d\" /* get */])(polygon, 0), 0));\n}\n\n/**\n * Normalize to ensure that all polygons in a list are complex - simplifies processing\n * @param {Array} polygon - either a complex or a simple polygon\n * @param {Object} opts\n * @param {Object} opts.dimensions - if 3, the coords will be padded with 0's if needed\n * @return {Array} - returns a complex polygons\n */\nfunction normalize(polygon, {dimensions = 3} = {}) {\n  return isSimple(polygon) ? [polygon] : polygon;\n}\n\n/**\n * Check if this is a non-nested polygon (i.e. the first element of the first element is a number)\n * @param {Array} polygon - either a complex or simple polygon\n * @return {Boolean} - true if the polygon is a simple polygon (i.e. not an array of polygons)\n */\nfunction getVertexCount(polygon) {\n  return isSimple(polygon) ?\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"e\" /* count */])(polygon) :\n    polygon.reduce((length, simplePolygon) => length + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"e\" /* count */])(simplePolygon), 0);\n}\n\n// Return number of triangles needed to tesselate the polygon\nfunction getTriangleCount(polygon) {\n  let triangleCount = 0;\n  let first = true;\n  for (const simplePolygon of normalize(polygon)) {\n    const size = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"e\" /* count */])(simplePolygon);\n    if (first) {\n      triangleCount += size >= 3 ? size - 2 : 0;\n    } else {\n      triangleCount += size + 1;\n    }\n    first = false;\n  }\n  return triangleCount;\n}\n\nfunction forEachVertex(polygon, visitor) {\n  if (isSimple(polygon)) {\n    polygon.forEach(visitor);\n    return;\n  }\n\n  let vertexIndex = 0;\n  polygon.forEach(simplePolygon => {\n    simplePolygon.forEach((v, i, p) => visitor(v, vertexIndex, polygon));\n    vertexIndex++;\n  });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvc29saWQtcG9seWdvbi1sYXllci9wb2x5Z29uLmpzP2QwMmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtnZXQsIGNvdW50fSBmcm9tICcuLi8uLi8uLi9saWIvdXRpbHMnO1xuXG4vLyBCYXNpYyBwb2x5Z29uIHN1cHBvcnRcbi8vXG4vLyBIYW5kbGVzIHNpbXBsZSBhbmQgY29tcGxleCBwb2x5Z29uc1xuLy8gU2ltcGxlIHBvbHlnb25zIGFyZSBhcnJheXMgb2YgdmVydGljZXMsIGltcGxpY2l0bHkgXCJjbG9zZWRcIlxuLy8gQ29tcGxleCBwb2x5Z29ucyBhcmUgYXJyYXlzIG9mIHNpbXBsZSBwb2x5Z29ucywgd2l0aCB0aGUgZmlyc3QgcG9seWdvblxuLy8gcmVwcmVzZW50aW5nIHRoZSBvdXRlciBodWxsIGFuZCBvdGhlciBwb2x5Z29ucyByZXByZXNlbnRpbmcgaG9sZXNcblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIGlzIGEgbm9uLW5lc3RlZCBwb2x5Z29uIChpLmUuIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBmaXJzdCBlbGVtZW50IGlzIGEgbnVtYmVyKVxuICogQHBhcmFtIHtBcnJheX0gcG9seWdvbiAtIGVpdGhlciBhIGNvbXBsZXggb3Igc2ltcGxlIHBvbHlnb25cbiAqIEByZXR1cm4ge0Jvb2xlYW59IC0gdHJ1ZSBpZiB0aGUgcG9seWdvbiBpcyBhIHNpbXBsZSBwb2x5Z29uIChpLmUuIG5vdCBhbiBhcnJheSBvZiBwb2x5Z29ucylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU2ltcGxlKHBvbHlnb24pIHtcbiAgcmV0dXJuIGNvdW50KHBvbHlnb24pID49IDEgJiZcbiAgICBjb3VudChnZXQocG9seWdvbiwgMCkpID49IDIgJiZcbiAgICBOdW1iZXIuaXNGaW5pdGUoZ2V0KGdldChwb2x5Z29uLCAwKSwgMCkpO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSB0byBlbnN1cmUgdGhhdCBhbGwgcG9seWdvbnMgaW4gYSBsaXN0IGFyZSBjb21wbGV4IC0gc2ltcGxpZmllcyBwcm9jZXNzaW5nXG4gKiBAcGFyYW0ge0FycmF5fSBwb2x5Z29uIC0gZWl0aGVyIGEgY29tcGxleCBvciBhIHNpbXBsZSBwb2x5Z29uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtPYmplY3R9IG9wdHMuZGltZW5zaW9ucyAtIGlmIDMsIHRoZSBjb29yZHMgd2lsbCBiZSBwYWRkZWQgd2l0aCAwJ3MgaWYgbmVlZGVkXG4gKiBAcmV0dXJuIHtBcnJheX0gLSByZXR1cm5zIGEgY29tcGxleCBwb2x5Z29uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKHBvbHlnb24sIHtkaW1lbnNpb25zID0gM30gPSB7fSkge1xuICByZXR1cm4gaXNTaW1wbGUocG9seWdvbikgPyBbcG9seWdvbl0gOiBwb2x5Z29uO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoaXMgaXMgYSBub24tbmVzdGVkIHBvbHlnb24gKGkuZS4gdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaXMgYSBudW1iZXIpXG4gKiBAcGFyYW0ge0FycmF5fSBwb2x5Z29uIC0gZWl0aGVyIGEgY29tcGxleCBvciBzaW1wbGUgcG9seWdvblxuICogQHJldHVybiB7Qm9vbGVhbn0gLSB0cnVlIGlmIHRoZSBwb2x5Z29uIGlzIGEgc2ltcGxlIHBvbHlnb24gKGkuZS4gbm90IGFuIGFycmF5IG9mIHBvbHlnb25zKVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmVydGV4Q291bnQocG9seWdvbikge1xuICByZXR1cm4gaXNTaW1wbGUocG9seWdvbikgP1xuICAgIGNvdW50KHBvbHlnb24pIDpcbiAgICBwb2x5Z29uLnJlZHVjZSgobGVuZ3RoLCBzaW1wbGVQb2x5Z29uKSA9PiBsZW5ndGggKyBjb3VudChzaW1wbGVQb2x5Z29uKSwgMCk7XG59XG5cbi8vIFJldHVybiBudW1iZXIgb2YgdHJpYW5nbGVzIG5lZWRlZCB0byB0ZXNzZWxhdGUgdGhlIHBvbHlnb25cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmlhbmdsZUNvdW50KHBvbHlnb24pIHtcbiAgbGV0IHRyaWFuZ2xlQ291bnQgPSAwO1xuICBsZXQgZmlyc3QgPSB0cnVlO1xuICBmb3IgKGNvbnN0IHNpbXBsZVBvbHlnb24gb2Ygbm9ybWFsaXplKHBvbHlnb24pKSB7XG4gICAgY29uc3Qgc2l6ZSA9IGNvdW50KHNpbXBsZVBvbHlnb24pO1xuICAgIGlmIChmaXJzdCkge1xuICAgICAgdHJpYW5nbGVDb3VudCArPSBzaXplID49IDMgPyBzaXplIC0gMiA6IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaWFuZ2xlQ291bnQgKz0gc2l6ZSArIDE7XG4gICAgfVxuICAgIGZpcnN0ID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRyaWFuZ2xlQ291bnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JFYWNoVmVydGV4KHBvbHlnb24sIHZpc2l0b3IpIHtcbiAgaWYgKGlzU2ltcGxlKHBvbHlnb24pKSB7XG4gICAgcG9seWdvbi5mb3JFYWNoKHZpc2l0b3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCB2ZXJ0ZXhJbmRleCA9IDA7XG4gIHBvbHlnb24uZm9yRWFjaChzaW1wbGVQb2x5Z29uID0+IHtcbiAgICBzaW1wbGVQb2x5Z29uLmZvckVhY2goKHYsIGksIHApID0+IHZpc2l0b3IodiwgdmVydGV4SW5kZXgsIHBvbHlnb24pKTtcbiAgICB2ZXJ0ZXhJbmRleCsrO1xuICB9KTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xheWVycy9jb3JlL3NvbGlkLXBvbHlnb24tbGF5ZXIvcG9seWdvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 14 */
/* exports provided: COORDINATE_SYSTEM */
/* exports used: COORDINATE_SYSTEM */
/*!******************************!*\
  !*** ./src/lib/constants.js ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Note: The numeric values here are matched by shader code in the\n// \"project\" and \"project64\" shader modules. Both places need to be\n// updated.\n\n// TODO: Maybe \"POSITIONS\" would be a better name?\nconst COORDINATE_SYSTEM = {\n  // Positions are interpreted as [lng, lat, elevation]\n  // lng lat are degrees, elevation is meters. distances as meters.\n  LNGLAT: 1.0,\n\n  // Positions are interpreted as lng lat offsets: [deltaLng, deltaLat, elevation]\n  // deltaLng, deltaLat are delta degrees, elevation is meters.\n  // distances as meters.\n  LNGLAT_OFFSETS: 3.0,\n\n  // Positions are interpreted as meter offsets, distances as meters\n  METER_OFFSETS: 2.0,\n  METERS: 2.0,\n\n  // Positions and distances are not transformed: [x, y, z] in unit coordinates\n  IDENTITY: 0.0\n};\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = COORDINATE_SYSTEM;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL2NvbnN0YW50cy5qcz82OTNjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIE5vdGU6IFRoZSBudW1lcmljIHZhbHVlcyBoZXJlIGFyZSBtYXRjaGVkIGJ5IHNoYWRlciBjb2RlIGluIHRoZVxuLy8gXCJwcm9qZWN0XCIgYW5kIFwicHJvamVjdDY0XCIgc2hhZGVyIG1vZHVsZXMuIEJvdGggcGxhY2VzIG5lZWQgdG8gYmVcbi8vIHVwZGF0ZWQuXG5cbi8vIFRPRE86IE1heWJlIFwiUE9TSVRJT05TXCIgd291bGQgYmUgYSBiZXR0ZXIgbmFtZT9cbmV4cG9ydCBjb25zdCBDT09SRElOQVRFX1NZU1RFTSA9IHtcbiAgLy8gUG9zaXRpb25zIGFyZSBpbnRlcnByZXRlZCBhcyBbbG5nLCBsYXQsIGVsZXZhdGlvbl1cbiAgLy8gbG5nIGxhdCBhcmUgZGVncmVlcywgZWxldmF0aW9uIGlzIG1ldGVycy4gZGlzdGFuY2VzIGFzIG1ldGVycy5cbiAgTE5HTEFUOiAxLjAsXG5cbiAgLy8gUG9zaXRpb25zIGFyZSBpbnRlcnByZXRlZCBhcyBsbmcgbGF0IG9mZnNldHM6IFtkZWx0YUxuZywgZGVsdGFMYXQsIGVsZXZhdGlvbl1cbiAgLy8gZGVsdGFMbmcsIGRlbHRhTGF0IGFyZSBkZWx0YSBkZWdyZWVzLCBlbGV2YXRpb24gaXMgbWV0ZXJzLlxuICAvLyBkaXN0YW5jZXMgYXMgbWV0ZXJzLlxuICBMTkdMQVRfT0ZGU0VUUzogMy4wLFxuXG4gIC8vIFBvc2l0aW9ucyBhcmUgaW50ZXJwcmV0ZWQgYXMgbWV0ZXIgb2Zmc2V0cywgZGlzdGFuY2VzIGFzIG1ldGVyc1xuICBNRVRFUl9PRkZTRVRTOiAyLjAsXG4gIE1FVEVSUzogMi4wLFxuXG4gIC8vIFBvc2l0aW9ucyBhbmQgZGlzdGFuY2VzIGFyZSBub3QgdHJhbnNmb3JtZWQ6IFt4LCB5LCB6XSBpbiB1bml0IGNvb3JkaW5hdGVzXG4gIElERU5USVRZOiAwLjBcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9saWIvY29uc3RhbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 15 */
/* exports provided: default, TEST_EXPORTS */
/* exports used: default */
/*!**************************!*\
  !*** ./src/lib/layer.js ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants__ = __webpack_require__(/*! ./constants */ 14);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__attribute_manager__ = __webpack_require__(/*! ./attribute-manager */ 27);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils__ = __webpack_require__(/*! ./utils */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_luma_gl__ = __webpack_require__(/*! luma.gl */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_assert__ = __webpack_require__(/*! assert */ 6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_assert__);\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n/* global window */\n\n\n\n\n\n\n/*\n * @param {string} props.id - layer name\n * @param {array}  props.data - array of data instances\n * @param {bool} props.opacity - opacity of the layer\n */\nconst defaultProps = {\n  dataComparator: null,\n  numInstances: undefined,\n  visible: true,\n  pickable: false,\n  opacity: 0.8,\n  onHover: () => {},\n  onClick: () => {},\n  // Update triggers: a key change detection mechanism in deck.gl\n  // See layer documentation\n  updateTriggers: {},\n  projectionMode: __WEBPACK_IMPORTED_MODULE_0__constants__[\"a\" /* COORDINATE_SYSTEM */].LNG_LAT\n};\n\nlet counter = 0;\n\nclass Layer {\n  /**\n   * @class\n   * @param {object} props - See docs and defaults above\n   */\n  constructor(props) {\n    // If sublayer has static defaultProps member, getDefaultProps will return it\n    const mergedDefaultProps = getDefaultProps(this);\n    // Merge supplied props with pre-merged default props\n    props = Object.assign({}, mergedDefaultProps, props);\n    // Accept null as data - otherwise apps and layers need to add ugly checks\n    props.data = props.data || [];\n    // Props are immutable\n    Object.freeze(props);\n\n    // Define all members and freeze layer\n    this.id = props.id;\n    this.props = props;\n    this.oldProps = null;\n    this.state = null;\n    this.context = null;\n    this.count = counter++;\n    Object.seal(this);\n  }\n\n  toString() {\n    const className = this.constructor.layerName || this.constructor.name;\n    return className !== this.props.id ? `<${className}:'${this.props.id}'>` : `<${className}>`;\n  }\n\n  // //////////////////////////////////////////////////\n  // LIFECYCLE METHODS, overridden by the layer subclasses\n\n  // Called once to set up the initial state\n  // App can create WebGL resources\n  initializeState() {\n    throw new Error(`Layer ${this} has not defined initializeState`);\n  }\n\n  // Let's layer control if updateState should be called\n  shouldUpdateState({oldProps, props, oldContext, context, changeFlags}) {\n    return changeFlags.somethingChanged;\n  }\n\n  // Default implementation, all attributes will be invalidated and updated\n  // when data changes\n  updateState({oldProps, props, oldContext, context, changeFlags}) {\n    if (changeFlags.dataChanged) {\n      this.invalidateAttribute('all');\n    }\n  }\n\n  // Called once when layer is no longer matched and state will be discarded\n  // App can destroy WebGL resources here\n  finalizeState() {\n  }\n\n  // Implement to generate sublayers\n  renderLayers() {\n    return null;\n  }\n\n  // If state has a model, draw it with supplied uniforms\n  draw({uniforms = {}}) {\n    if (this.state.model) {\n      this.state.model.render(uniforms);\n    }\n  }\n\n  // called to populate the info object that is passed to the event handler\n  // @return null to cancel event\n  getPickingInfo({info, mode}) {\n    const {color, index} = info;\n\n    if (index >= 0) {\n      // If props.data is an indexable array, get the object\n      if (Array.isArray(this.props.data)) {\n        info.object = this.props.data[index];\n      }\n    }\n\n    // TODO - move to the JS part of a shader picking shader package\n    if (mode === 'hover') {\n      const selectedPickingColor = new Float32Array(3);\n      selectedPickingColor[0] = color[0];\n      selectedPickingColor[1] = color[1];\n      selectedPickingColor[2] = color[2];\n      this.setUniforms({selectedPickingColor});\n    }\n\n    return info;\n  }\n\n  // END LIFECYCLE METHODS\n  // //////////////////////////////////////////////////\n\n  // Default implementation of attribute invalidation, can be redefine\n  invalidateAttribute(name = 'all') {\n    if (name === 'all') {\n      this.state.attributeManager.invalidateAll();\n    } else {\n      this.state.attributeManager.invalidate(name);\n    }\n  }\n\n  // Calls attribute manager to update any WebGL attributes, can be redefined\n  updateAttributes(props) {\n    const {attributeManager, model} = this.state;\n    if (!attributeManager) {\n      return;\n    }\n\n    const numInstances = this.getNumInstances(props);\n    // Figure out data length\n    attributeManager.update({\n      data: props.data,\n      numInstances,\n      props,\n      buffers: props,\n      context: this,\n      // Don't worry about non-attribute props\n      ignoreUnknownAttributes: true\n    });\n    if (model) {\n      const changedAttributes = attributeManager.getChangedAttributes({clearChangedFlags: true});\n      model.setAttributes(changedAttributes);\n    }\n  }\n\n  // Public API\n\n  // Updates selected state members and marks the object for redraw\n  setState(updateObject) {\n    Object.assign(this.state, updateObject);\n    this.state.needsRedraw = true;\n  }\n\n  setNeedsRedraw(redraw = true) {\n    if (this.state) {\n      this.state.needsRedraw = redraw;\n    }\n  }\n\n  // PROJECTION METHODS\n\n  /**\n   * Projects a point with current map state (lat, lon, zoom, pitch, bearing)\n   *\n   * Note: Position conversion is done in shader, so in many cases there is no need\n   * for this function\n   * @param {Array|TypedArray} lngLat - long and lat values\n   * @return {Array|TypedArray} - x, y coordinates\n   */\n  project(lngLat) {\n    const {viewport} = this.context;\n    __WEBPACK_IMPORTED_MODULE_4_assert___default()(Array.isArray(lngLat), 'Layer.project needs [lng,lat]');\n    return viewport.project(lngLat);\n  }\n\n  unproject(xy) {\n    const {viewport} = this.context;\n    __WEBPACK_IMPORTED_MODULE_4_assert___default()(Array.isArray(xy), 'Layer.unproject needs [x,y]');\n    return viewport.unproject(xy);\n  }\n\n  projectFlat(lngLat) {\n    const {viewport} = this.context;\n    __WEBPACK_IMPORTED_MODULE_4_assert___default()(Array.isArray(lngLat), 'Layer.project needs [lng,lat]');\n    return viewport.projectFlat(lngLat);\n  }\n\n  unprojectFlat(xy) {\n    const {viewport} = this.context;\n    __WEBPACK_IMPORTED_MODULE_4_assert___default()(Array.isArray(xy), 'Layer.unproject needs [x,y]');\n    return viewport.unprojectFlat(xy);\n  }\n\n  screenToDevicePixels(screenPixels) {\n    const devicePixelRatio = typeof window !== 'undefined' ?\n      window.devicePixelRatio : 1;\n    return screenPixels * devicePixelRatio;\n  }\n\n  /**\n   * Returns the picking color that doesn't match any subfeature\n   * Use if some graphics do not belong to any pickable subfeature\n   * @return {Array} - a black color\n   */\n  nullPickingColor() {\n    return [0, 0, 0];\n  }\n\n  /**\n   * Returns the picking color that doesn't match any subfeature\n   * Use if some graphics do not belong to any pickable subfeature\n   * @param {int} i - index to be decoded\n   * @return {Array} - the decoded color\n   */\n  encodePickingColor(i) {\n    return [\n      (i + 1) % 256,\n      Math.floor((i + 1) / 256) % 256,\n      Math.floor((i + 1) / 256 / 256) % 256\n    ];\n  }\n\n  /**\n   * Returns the picking color that doesn't match any subfeature\n   * Use if some graphics do not belong to any pickable subfeature\n   * @param {Uint8Array} color - color array to be decoded\n   * @return {Array} - the decoded picking color\n   */\n  decodePickingColor(color) {\n    __WEBPACK_IMPORTED_MODULE_4_assert___default()(color instanceof Uint8Array);\n    const [i1, i2, i3] = color;\n    // 1 was added to seperate from no selection\n    const index = i1 + i2 * 256 + i3 * 65536 - 1;\n    return index;\n  }\n\n  calculateInstancePickingColors(attribute, {numInstances}) {\n    const {value, size} = attribute;\n    // add 1 to index to seperate from no selection\n    for (let i = 0; i < numInstances; i++) {\n      const pickingColor = this.encodePickingColor(i);\n      value[i * size + 0] = pickingColor[0];\n      value[i * size + 1] = pickingColor[1];\n      value[i * size + 2] = pickingColor[2];\n    }\n  }\n\n  // DATA ACCESS API\n  // Data can use iterators and may not be random access\n\n  // Use iteration (the only required capability on data) to get first element\n  getFirstObject() {\n    const {data} = this.props;\n    for (const object of data) {\n      return object;\n    }\n    return null;\n  }\n\n  // INTERNAL METHODS\n\n  // Deduces numer of instances. Intention is to support:\n  // - Explicit setting of numInstances\n  // - Auto-deduction for ES6 containers that define a size member\n  // - Auto-deduction for Classic Arrays via the built-in length attribute\n  // - Auto-deduction via arrays\n  getNumInstances(props) {\n    props = props || this.props;\n\n    // First check if the layer has set its own value\n    if (this.state && this.state.numInstances !== undefined) {\n      return this.state.numInstances;\n    }\n\n    // Check if app has provided an explicit value\n    if (props.numInstances !== undefined) {\n      return props.numInstances;\n    }\n\n    // Use container library to get a count for any ES6 container or object\n    const {data} = props;\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"e\" /* count */])(data);\n  }\n\n  // LAYER MANAGER API\n  // Should only be called by the deck.gl LayerManager class\n\n  // Called by layer manager when a new layer is found\n  /* eslint-disable max-statements */\n  initializeLayer(updateParams) {\n    __WEBPACK_IMPORTED_MODULE_4_assert___default()(this.context.gl, 'Layer context missing gl');\n    __WEBPACK_IMPORTED_MODULE_4_assert___default()(!this.state, 'Layer missing state');\n\n    this.state = {};\n\n    // Initialize state only once\n    this.setState({\n      attributeManager: new __WEBPACK_IMPORTED_MODULE_1__attribute_manager__[\"a\" /* default */]({id: this.props.id}),\n      model: null,\n      needsRedraw: true,\n      dataChanged: true\n    });\n\n    // Add attribute manager loggers if provided\n    this.state.attributeManager.setLogFunctions(this.props);\n\n    const {attributeManager} = this.state;\n    // All instanced layers get instancePickingColors attribute by default\n    // Their shaders can use it to render a picking scene\n    // TODO - this slows down non instanced layers\n    attributeManager.addInstanced({\n      instancePickingColors: {\n        type: __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].UNSIGNED_BYTE,\n        size: 3,\n        update: this.calculateInstancePickingColors\n      }\n    });\n\n    // Call subclass lifecycle methods\n    this.initializeState();\n    this.updateState(updateParams);\n    // End subclass lifecycle methods\n\n    // Add any subclass attributes\n    this.updateAttributes(this.props);\n    this._updateBaseUniforms();\n\n    const {model} = this.state;\n    if (model) {\n      model.setInstanceCount(this.getNumInstances());\n      model.id = this.props.id;\n      model.program.id = `${this.props.id}-program`;\n      model.geometry.id = `${this.props.id}-geometry`;\n      model.setAttributes(attributeManager.getAttributes());\n    }\n  }\n\n  // Called by layer manager when existing layer is getting new props\n  updateLayer(updateParams) {\n    // Check for deprecated method\n    if (this.shouldUpdate) {\n      __WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* log */].once(0, `deck.gl v3 ${this}: \"shouldUpdate\" deprecated, renamed to \"shouldUpdateState\"`);\n    }\n\n    // Call subclass lifecycle method\n    const stateNeedsUpdate = this.shouldUpdateState(updateParams);\n    // End lifecycle method\n\n    if (stateNeedsUpdate) {\n\n      // Call deprecated lifecycle method if defined\n      const hasRedefinedMethod = this.willReceiveProps &&\n        this.willReceiveProps !== Layer.prototype.willReceiveProps;\n      if (hasRedefinedMethod) {\n        __WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* log */].once(0, `deck.gl v3 willReceiveProps deprecated. Use updateState in ${this}`);\n        const {oldProps, props, changeFlags} = updateParams;\n        this.setState(changeFlags);\n        this.willReceiveProps(oldProps, props, changeFlags);\n        this.setState({\n          dataChanged: false,\n          viewportChanged: false\n        });\n      }\n      // End lifecycle method\n\n      // Call subclass lifecycle method\n      this.updateState(updateParams);\n      // End lifecycle method\n\n      // Run the attribute updaters\n      this.updateAttributes(updateParams.props);\n      this._updateBaseUniforms();\n\n      if (this.state.model) {\n        this.state.model.setInstanceCount(this.getNumInstances());\n      }\n    }\n  }\n  /* eslint-enable max-statements */\n\n  // Called by manager when layer is about to be disposed\n  // Note: not guaranteed to be called on application shutdown\n  finalizeLayer() {\n    // Call subclass lifecycle method\n    this.finalizeState();\n    // End lifecycle method\n  }\n\n  // Calculates uniforms\n  drawLayer({uniforms = {}}) {\n    // Call subclass lifecycle method\n    this.draw({uniforms});\n    // End lifecycle method\n  }\n\n  // {uniforms = {}, ...opts}\n  pickLayer(opts) {\n    // Call subclass lifecycle method\n    return this.getPickingInfo(opts);\n    // End lifecycle method\n  }\n\n  diffProps(oldProps, newProps, context) {\n    // First check if any props have changed (ignore props that will be examined separately)\n    const propsChangedReason = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"j\" /* compareProps */])({\n      newProps,\n      oldProps,\n      ignoreProps: {data: null, updateTriggers: null}\n    });\n\n    // Now check if any data related props have changed\n    const dataChangedReason = this._diffDataProps(oldProps, newProps);\n\n    const propsChanged = Boolean(propsChangedReason);\n    const dataChanged = Boolean(dataChangedReason);\n    const viewportChanged = context.viewportChanged;\n    const somethingChanged = propsChanged || dataChanged || viewportChanged;\n\n    // Check update triggers to determine if any attributes need regeneration\n    // Note - if data has changed, all attributes will need regeneration, so skip this step\n    if (!dataChanged) {\n      this._diffUpdateTriggers(oldProps, newProps);\n    } else {\n      __WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* log */].log(1, `dataChanged: ${dataChanged}`);\n    }\n\n    return {\n      propsChanged,\n      dataChanged,\n      viewportChanged,\n      somethingChanged,\n      reason: dataChangedReason || propsChangedReason\n    };\n  }\n\n  // Checks state of attributes and model\n  // TODO - is attribute manager needed? - Model should be enough.\n  getNeedsRedraw({clearRedrawFlags = false} = {}) {\n    // this method may be called by the render loop as soon a the layer\n    // has been created, so guard against uninitialized state\n    if (!this.state) {\n      return false;\n    }\n\n    let redraw = false;\n    redraw = redraw || this.state.needsRedraw;\n    this.state.needsRedraw = this.state.needsRedraw && !clearRedrawFlags;\n\n    const {attributeManager, model} = this.state;\n    redraw = redraw || (attributeManager && attributeManager.getNeedsRedraw({clearRedrawFlags}));\n    redraw = redraw || (model && model.getNeedsRedraw({clearRedrawFlags}));\n\n    return redraw;\n  }\n\n  // PRIVATE METHODS\n\n  // The comparison of the data prop requires special handling\n  // the dataComparator should be used if supplied\n  _diffDataProps(oldProps, newProps) {\n    // Support optional app defined comparison of data\n    const {dataComparator} = newProps;\n    if (dataComparator) {\n      if (!dataComparator(newProps.data, oldProps.data)) {\n        return 'Data comparator detected a change';\n      }\n    // Otherwise, do a shallow equal on props\n    } else if (newProps.data !== oldProps.data) {\n      return 'A new data container was supplied';\n    }\n\n    return null;\n  }\n\n  // Checks if any update triggers have changed, and invalidate\n  // attributes accordingly.\n  /* eslint-disable max-statements */\n  _diffUpdateTriggers(oldProps, newProps) {\n    // const {attributeManager} = this.state;\n    // const updateTriggerMap = attributeManager.getUpdateTriggerMap();\n\n    let change = false;\n\n    for (const propName in newProps.updateTriggers) {\n      const oldTriggers = oldProps.updateTriggers[propName] || {};\n      const newTriggers = newProps.updateTriggers[propName] || {};\n      const diffReason = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"j\" /* compareProps */])({\n        oldProps: oldTriggers,\n        newProps: newTriggers\n      });\n      if (diffReason) {\n        if (propName === 'all') {\n          __WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* log */].log(1, `updateTriggers invalidating all attributes: ${diffReason}`);\n          this.invalidateAttribute('all');\n          change = true;\n        } else {\n          __WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* log */].log(1, `updateTriggers invalidating attribute ${propName}: ${diffReason}`);\n          this.invalidateAttribute(propName);\n          change = true;\n        }\n      }\n    }\n\n    return change;\n  }\n  /* eslint-enable max-statements */\n\n  _checkRequiredProp(propertyName, condition) {\n    const value = this.props[propertyName];\n    if (value === undefined) {\n      throw new Error(`Property ${propertyName} undefined in layer ${this}`);\n    }\n    if (condition && !condition(value)) {\n      throw new Error(`Bad property ${propertyName} in layer ${this}`);\n    }\n  }\n\n  // Emits a warning if an old prop is used, optionally suggesting a replacement\n  _checkRemovedProp(oldProp, newProp = null) {\n    if (this.props[oldProp] !== undefined) {\n      const layerName = this.constructor;\n      let message = `${layerName} no longer accepts props.${oldProp} in this version of deck.gl.`;\n      if (newProp) {\n        message += `\\nPlease use props.${newProp} instead.`;\n      }\n      __WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* log */].once(0, message);\n    }\n  }\n\n  _updateBaseUniforms() {\n    this.setUniforms({\n      // apply gamma to opacity to make it visually \"linear\"\n      opacity: Math.pow(this.props.opacity, 1 / 2.2),\n      ONE: 1.0\n    });\n  }\n\n  // DEPRECATED METHODS\n  // shouldUpdate() {}\n\n  willReceiveProps() {\n  }\n\n  // Updates selected state members and marks the object for redraw\n  setUniforms(uniformMap) {\n    if (this.state.model) {\n      this.state.model.setUniforms(uniformMap);\n    }\n    // TODO - set needsRedraw on the model?\n    this.state.needsRedraw = true;\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* log */])(3, 'layer.setUniforms', uniformMap);\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = Layer;\n\n\nLayer.layerName = 'Layer';\nLayer.defaultProps = defaultProps;\n\n// HELPERS\n\n// Constructors have their super class constructors as prototypes\nfunction getOwnProperty(object, prop) {\n  return object.hasOwnProperty(prop) && object[prop];\n}\n/*\n * Return merged default props stored on layers constructor, create them if needed\n */\nfunction getDefaultProps(layer) {\n  const mergedDefaultProps = getOwnProperty(layer.constructor, 'mergedDefaultProps');\n  if (mergedDefaultProps) {\n    return mergedDefaultProps;\n  }\n  return mergeDefaultProps(layer);\n}\n\n/*\n * Walk the prototype chain and merge all default props\n */\nfunction mergeDefaultProps(layer) {\n  const subClassConstructor = layer.constructor;\n  const layerName = getOwnProperty(subClassConstructor, 'layerName');\n  if (!layerName) {\n    __WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* log */].once(0, `layer ${layer.constructor.name} does not specify a \"layerName\"`);\n  }\n  let mergedDefaultProps = {\n    id: layerName || layer.constructor.name\n  };\n\n  while (layer) {\n    const layerDefaultProps = getOwnProperty(layer.constructor, 'defaultProps');\n    Object.freeze(layerDefaultProps);\n    if (layerDefaultProps) {\n      mergedDefaultProps = Object.assign({}, layerDefaultProps, mergedDefaultProps);\n    }\n    layer = Object.getPrototypeOf(layer);\n  }\n  // Store for quick lookup\n  subClassConstructor.mergedDefaultProps = mergedDefaultProps;\n  return mergedDefaultProps;\n}\n\nconst TEST_EXPORTS = {\n  mergeDefaultProps\n};\n/* unused harmony export TEST_EXPORTS */\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL2xheWVyLmpzPzdjZTMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cbi8qIGdsb2JhbCB3aW5kb3cgKi9cbmltcG9ydCB7Q09PUkRJTkFURV9TWVNURU19IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCBBdHRyaWJ1dGVNYW5hZ2VyIGZyb20gJy4vYXR0cmlidXRlLW1hbmFnZXInO1xuaW1wb3J0IHtsb2csIGNvbXBhcmVQcm9wcywgY291bnR9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHtHTH0gZnJvbSAnbHVtYS5nbCc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbi8qXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcHMuaWQgLSBsYXllciBuYW1lXG4gKiBAcGFyYW0ge2FycmF5fSAgcHJvcHMuZGF0YSAtIGFycmF5IG9mIGRhdGEgaW5zdGFuY2VzXG4gKiBAcGFyYW0ge2Jvb2x9IHByb3BzLm9wYWNpdHkgLSBvcGFjaXR5IG9mIHRoZSBsYXllclxuICovXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIGRhdGFDb21wYXJhdG9yOiBudWxsLFxuICBudW1JbnN0YW5jZXM6IHVuZGVmaW5lZCxcbiAgdmlzaWJsZTogdHJ1ZSxcbiAgcGlja2FibGU6IGZhbHNlLFxuICBvcGFjaXR5OiAwLjgsXG4gIG9uSG92ZXI6ICgpID0+IHt9LFxuICBvbkNsaWNrOiAoKSA9PiB7fSxcbiAgLy8gVXBkYXRlIHRyaWdnZXJzOiBhIGtleSBjaGFuZ2UgZGV0ZWN0aW9uIG1lY2hhbmlzbSBpbiBkZWNrLmdsXG4gIC8vIFNlZSBsYXllciBkb2N1bWVudGF0aW9uXG4gIHVwZGF0ZVRyaWdnZXJzOiB7fSxcbiAgcHJvamVjdGlvbk1vZGU6IENPT1JESU5BVEVfU1lTVEVNLkxOR19MQVRcbn07XG5cbmxldCBjb3VudGVyID0gMDtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGF5ZXIge1xuICAvKipcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyAtIFNlZSBkb2NzIGFuZCBkZWZhdWx0cyBhYm92ZVxuICAgKi9cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAvLyBJZiBzdWJsYXllciBoYXMgc3RhdGljIGRlZmF1bHRQcm9wcyBtZW1iZXIsIGdldERlZmF1bHRQcm9wcyB3aWxsIHJldHVybiBpdFxuICAgIGNvbnN0IG1lcmdlZERlZmF1bHRQcm9wcyA9IGdldERlZmF1bHRQcm9wcyh0aGlzKTtcbiAgICAvLyBNZXJnZSBzdXBwbGllZCBwcm9wcyB3aXRoIHByZS1tZXJnZWQgZGVmYXVsdCBwcm9wc1xuICAgIHByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgbWVyZ2VkRGVmYXVsdFByb3BzLCBwcm9wcyk7XG4gICAgLy8gQWNjZXB0IG51bGwgYXMgZGF0YSAtIG90aGVyd2lzZSBhcHBzIGFuZCBsYXllcnMgbmVlZCB0byBhZGQgdWdseSBjaGVja3NcbiAgICBwcm9wcy5kYXRhID0gcHJvcHMuZGF0YSB8fCBbXTtcbiAgICAvLyBQcm9wcyBhcmUgaW1tdXRhYmxlXG4gICAgT2JqZWN0LmZyZWV6ZShwcm9wcyk7XG5cbiAgICAvLyBEZWZpbmUgYWxsIG1lbWJlcnMgYW5kIGZyZWV6ZSBsYXllclxuICAgIHRoaXMuaWQgPSBwcm9wcy5pZDtcbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgdGhpcy5vbGRQcm9wcyA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLmNvdW50ID0gY291bnRlcisrO1xuICAgIE9iamVjdC5zZWFsKHRoaXMpO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5sYXllck5hbWUgfHwgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIHJldHVybiBjbGFzc05hbWUgIT09IHRoaXMucHJvcHMuaWQgPyBgPCR7Y2xhc3NOYW1lfTonJHt0aGlzLnByb3BzLmlkfSc+YCA6IGA8JHtjbGFzc05hbWV9PmA7XG4gIH1cblxuICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBMSUZFQ1lDTEUgTUVUSE9EUywgb3ZlcnJpZGRlbiBieSB0aGUgbGF5ZXIgc3ViY2xhc3Nlc1xuXG4gIC8vIENhbGxlZCBvbmNlIHRvIHNldCB1cCB0aGUgaW5pdGlhbCBzdGF0ZVxuICAvLyBBcHAgY2FuIGNyZWF0ZSBXZWJHTCByZXNvdXJjZXNcbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTGF5ZXIgJHt0aGlzfSBoYXMgbm90IGRlZmluZWQgaW5pdGlhbGl6ZVN0YXRlYCk7XG4gIH1cblxuICAvLyBMZXQncyBsYXllciBjb250cm9sIGlmIHVwZGF0ZVN0YXRlIHNob3VsZCBiZSBjYWxsZWRcbiAgc2hvdWxkVXBkYXRlU3RhdGUoe29sZFByb3BzLCBwcm9wcywgb2xkQ29udGV4dCwgY29udGV4dCwgY2hhbmdlRmxhZ3N9KSB7XG4gICAgcmV0dXJuIGNoYW5nZUZsYWdzLnNvbWV0aGluZ0NoYW5nZWQ7XG4gIH1cblxuICAvLyBEZWZhdWx0IGltcGxlbWVudGF0aW9uLCBhbGwgYXR0cmlidXRlcyB3aWxsIGJlIGludmFsaWRhdGVkIGFuZCB1cGRhdGVkXG4gIC8vIHdoZW4gZGF0YSBjaGFuZ2VzXG4gIHVwZGF0ZVN0YXRlKHtvbGRQcm9wcywgcHJvcHMsIG9sZENvbnRleHQsIGNvbnRleHQsIGNoYW5nZUZsYWdzfSkge1xuICAgIGlmIChjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCkge1xuICAgICAgdGhpcy5pbnZhbGlkYXRlQXR0cmlidXRlKCdhbGwnKTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsZWQgb25jZSB3aGVuIGxheWVyIGlzIG5vIGxvbmdlciBtYXRjaGVkIGFuZCBzdGF0ZSB3aWxsIGJlIGRpc2NhcmRlZFxuICAvLyBBcHAgY2FuIGRlc3Ryb3kgV2ViR0wgcmVzb3VyY2VzIGhlcmVcbiAgZmluYWxpemVTdGF0ZSgpIHtcbiAgfVxuXG4gIC8vIEltcGxlbWVudCB0byBnZW5lcmF0ZSBzdWJsYXllcnNcbiAgcmVuZGVyTGF5ZXJzKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gSWYgc3RhdGUgaGFzIGEgbW9kZWwsIGRyYXcgaXQgd2l0aCBzdXBwbGllZCB1bmlmb3Jtc1xuICBkcmF3KHt1bmlmb3JtcyA9IHt9fSkge1xuICAgIGlmICh0aGlzLnN0YXRlLm1vZGVsKSB7XG4gICAgICB0aGlzLnN0YXRlLm1vZGVsLnJlbmRlcih1bmlmb3Jtcyk7XG4gICAgfVxuICB9XG5cbiAgLy8gY2FsbGVkIHRvIHBvcHVsYXRlIHRoZSBpbmZvIG9iamVjdCB0aGF0IGlzIHBhc3NlZCB0byB0aGUgZXZlbnQgaGFuZGxlclxuICAvLyBAcmV0dXJuIG51bGwgdG8gY2FuY2VsIGV2ZW50XG4gIGdldFBpY2tpbmdJbmZvKHtpbmZvLCBtb2RlfSkge1xuICAgIGNvbnN0IHtjb2xvciwgaW5kZXh9ID0gaW5mbztcblxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAvLyBJZiBwcm9wcy5kYXRhIGlzIGFuIGluZGV4YWJsZSBhcnJheSwgZ2V0IHRoZSBvYmplY3RcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMucHJvcHMuZGF0YSkpIHtcbiAgICAgICAgaW5mby5vYmplY3QgPSB0aGlzLnByb3BzLmRhdGFbaW5kZXhdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE8gLSBtb3ZlIHRvIHRoZSBKUyBwYXJ0IG9mIGEgc2hhZGVyIHBpY2tpbmcgc2hhZGVyIHBhY2thZ2VcbiAgICBpZiAobW9kZSA9PT0gJ2hvdmVyJykge1xuICAgICAgY29uc3Qgc2VsZWN0ZWRQaWNraW5nQ29sb3IgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICAgICAgc2VsZWN0ZWRQaWNraW5nQ29sb3JbMF0gPSBjb2xvclswXTtcbiAgICAgIHNlbGVjdGVkUGlja2luZ0NvbG9yWzFdID0gY29sb3JbMV07XG4gICAgICBzZWxlY3RlZFBpY2tpbmdDb2xvclsyXSA9IGNvbG9yWzJdO1xuICAgICAgdGhpcy5zZXRVbmlmb3Jtcyh7c2VsZWN0ZWRQaWNraW5nQ29sb3J9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxuXG4gIC8vIEVORCBMSUZFQ1lDTEUgTUVUSE9EU1xuICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIC8vIERlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgYXR0cmlidXRlIGludmFsaWRhdGlvbiwgY2FuIGJlIHJlZGVmaW5lXG4gIGludmFsaWRhdGVBdHRyaWJ1dGUobmFtZSA9ICdhbGwnKSB7XG4gICAgaWYgKG5hbWUgPT09ICdhbGwnKSB7XG4gICAgICB0aGlzLnN0YXRlLmF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZUFsbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlLmF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZShuYW1lKTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxscyBhdHRyaWJ1dGUgbWFuYWdlciB0byB1cGRhdGUgYW55IFdlYkdMIGF0dHJpYnV0ZXMsIGNhbiBiZSByZWRlZmluZWRcbiAgdXBkYXRlQXR0cmlidXRlcyhwcm9wcykge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVNYW5hZ2VyLCBtb2RlbH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICghYXR0cmlidXRlTWFuYWdlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG51bUluc3RhbmNlcyA9IHRoaXMuZ2V0TnVtSW5zdGFuY2VzKHByb3BzKTtcbiAgICAvLyBGaWd1cmUgb3V0IGRhdGEgbGVuZ3RoXG4gICAgYXR0cmlidXRlTWFuYWdlci51cGRhdGUoe1xuICAgICAgZGF0YTogcHJvcHMuZGF0YSxcbiAgICAgIG51bUluc3RhbmNlcyxcbiAgICAgIHByb3BzLFxuICAgICAgYnVmZmVyczogcHJvcHMsXG4gICAgICBjb250ZXh0OiB0aGlzLFxuICAgICAgLy8gRG9uJ3Qgd29ycnkgYWJvdXQgbm9uLWF0dHJpYnV0ZSBwcm9wc1xuICAgICAgaWdub3JlVW5rbm93bkF0dHJpYnV0ZXM6IHRydWVcbiAgICB9KTtcbiAgICBpZiAobW9kZWwpIHtcbiAgICAgIGNvbnN0IGNoYW5nZWRBdHRyaWJ1dGVzID0gYXR0cmlidXRlTWFuYWdlci5nZXRDaGFuZ2VkQXR0cmlidXRlcyh7Y2xlYXJDaGFuZ2VkRmxhZ3M6IHRydWV9KTtcbiAgICAgIG1vZGVsLnNldEF0dHJpYnV0ZXMoY2hhbmdlZEF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFB1YmxpYyBBUElcblxuICAvLyBVcGRhdGVzIHNlbGVjdGVkIHN0YXRlIG1lbWJlcnMgYW5kIG1hcmtzIHRoZSBvYmplY3QgZm9yIHJlZHJhd1xuICBzZXRTdGF0ZSh1cGRhdGVPYmplY3QpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuc3RhdGUsIHVwZGF0ZU9iamVjdCk7XG4gICAgdGhpcy5zdGF0ZS5uZWVkc1JlZHJhdyA9IHRydWU7XG4gIH1cblxuICBzZXROZWVkc1JlZHJhdyhyZWRyYXcgPSB0cnVlKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUpIHtcbiAgICAgIHRoaXMuc3RhdGUubmVlZHNSZWRyYXcgPSByZWRyYXc7XG4gICAgfVxuICB9XG5cbiAgLy8gUFJPSkVDVElPTiBNRVRIT0RTXG5cbiAgLyoqXG4gICAqIFByb2plY3RzIGEgcG9pbnQgd2l0aCBjdXJyZW50IG1hcCBzdGF0ZSAobGF0LCBsb24sIHpvb20sIHBpdGNoLCBiZWFyaW5nKVxuICAgKlxuICAgKiBOb3RlOiBQb3NpdGlvbiBjb252ZXJzaW9uIGlzIGRvbmUgaW4gc2hhZGVyLCBzbyBpbiBtYW55IGNhc2VzIHRoZXJlIGlzIG5vIG5lZWRcbiAgICogZm9yIHRoaXMgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheXxUeXBlZEFycmF5fSBsbmdMYXQgLSBsb25nIGFuZCBsYXQgdmFsdWVzXG4gICAqIEByZXR1cm4ge0FycmF5fFR5cGVkQXJyYXl9IC0geCwgeSBjb29yZGluYXRlc1xuICAgKi9cbiAgcHJvamVjdChsbmdMYXQpIHtcbiAgICBjb25zdCB7dmlld3BvcnR9ID0gdGhpcy5jb250ZXh0O1xuICAgIGFzc2VydChBcnJheS5pc0FycmF5KGxuZ0xhdCksICdMYXllci5wcm9qZWN0IG5lZWRzIFtsbmcsbGF0XScpO1xuICAgIHJldHVybiB2aWV3cG9ydC5wcm9qZWN0KGxuZ0xhdCk7XG4gIH1cblxuICB1bnByb2plY3QoeHkpIHtcbiAgICBjb25zdCB7dmlld3BvcnR9ID0gdGhpcy5jb250ZXh0O1xuICAgIGFzc2VydChBcnJheS5pc0FycmF5KHh5KSwgJ0xheWVyLnVucHJvamVjdCBuZWVkcyBbeCx5XScpO1xuICAgIHJldHVybiB2aWV3cG9ydC51bnByb2plY3QoeHkpO1xuICB9XG5cbiAgcHJvamVjdEZsYXQobG5nTGF0KSB7XG4gICAgY29uc3Qge3ZpZXdwb3J0fSA9IHRoaXMuY29udGV4dDtcbiAgICBhc3NlcnQoQXJyYXkuaXNBcnJheShsbmdMYXQpLCAnTGF5ZXIucHJvamVjdCBuZWVkcyBbbG5nLGxhdF0nKTtcbiAgICByZXR1cm4gdmlld3BvcnQucHJvamVjdEZsYXQobG5nTGF0KTtcbiAgfVxuXG4gIHVucHJvamVjdEZsYXQoeHkpIHtcbiAgICBjb25zdCB7dmlld3BvcnR9ID0gdGhpcy5jb250ZXh0O1xuICAgIGFzc2VydChBcnJheS5pc0FycmF5KHh5KSwgJ0xheWVyLnVucHJvamVjdCBuZWVkcyBbeCx5XScpO1xuICAgIHJldHVybiB2aWV3cG9ydC51bnByb2plY3RGbGF0KHh5KTtcbiAgfVxuXG4gIHNjcmVlblRvRGV2aWNlUGl4ZWxzKHNjcmVlblBpeGVscykge1xuICAgIGNvbnN0IGRldmljZVBpeGVsUmF0aW8gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/XG4gICAgICB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6IDE7XG4gICAgcmV0dXJuIHNjcmVlblBpeGVscyAqIGRldmljZVBpeGVsUmF0aW87XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGlja2luZyBjb2xvciB0aGF0IGRvZXNuJ3QgbWF0Y2ggYW55IHN1YmZlYXR1cmVcbiAgICogVXNlIGlmIHNvbWUgZ3JhcGhpY3MgZG8gbm90IGJlbG9uZyB0byBhbnkgcGlja2FibGUgc3ViZmVhdHVyZVxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSBhIGJsYWNrIGNvbG9yXG4gICAqL1xuICBudWxsUGlja2luZ0NvbG9yKCkge1xuICAgIHJldHVybiBbMCwgMCwgMF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGlja2luZyBjb2xvciB0aGF0IGRvZXNuJ3QgbWF0Y2ggYW55IHN1YmZlYXR1cmVcbiAgICogVXNlIGlmIHNvbWUgZ3JhcGhpY3MgZG8gbm90IGJlbG9uZyB0byBhbnkgcGlja2FibGUgc3ViZmVhdHVyZVxuICAgKiBAcGFyYW0ge2ludH0gaSAtIGluZGV4IHRvIGJlIGRlY29kZWRcbiAgICogQHJldHVybiB7QXJyYXl9IC0gdGhlIGRlY29kZWQgY29sb3JcbiAgICovXG4gIGVuY29kZVBpY2tpbmdDb2xvcihpKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIChpICsgMSkgJSAyNTYsXG4gICAgICBNYXRoLmZsb29yKChpICsgMSkgLyAyNTYpICUgMjU2LFxuICAgICAgTWF0aC5mbG9vcigoaSArIDEpIC8gMjU2IC8gMjU2KSAlIDI1NlxuICAgIF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGlja2luZyBjb2xvciB0aGF0IGRvZXNuJ3QgbWF0Y2ggYW55IHN1YmZlYXR1cmVcbiAgICogVXNlIGlmIHNvbWUgZ3JhcGhpY3MgZG8gbm90IGJlbG9uZyB0byBhbnkgcGlja2FibGUgc3ViZmVhdHVyZVxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGNvbG9yIC0gY29sb3IgYXJyYXkgdG8gYmUgZGVjb2RlZFxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSB0aGUgZGVjb2RlZCBwaWNraW5nIGNvbG9yXG4gICAqL1xuICBkZWNvZGVQaWNraW5nQ29sb3IoY29sb3IpIHtcbiAgICBhc3NlcnQoY29sb3IgaW5zdGFuY2VvZiBVaW50OEFycmF5KTtcbiAgICBjb25zdCBbaTEsIGkyLCBpM10gPSBjb2xvcjtcbiAgICAvLyAxIHdhcyBhZGRlZCB0byBzZXBlcmF0ZSBmcm9tIG5vIHNlbGVjdGlvblxuICAgIGNvbnN0IGluZGV4ID0gaTEgKyBpMiAqIDI1NiArIGkzICogNjU1MzYgLSAxO1xuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlUGlja2luZ0NvbG9ycyhhdHRyaWJ1dGUsIHtudW1JbnN0YW5jZXN9KSB7XG4gICAgY29uc3Qge3ZhbHVlLCBzaXplfSA9IGF0dHJpYnV0ZTtcbiAgICAvLyBhZGQgMSB0byBpbmRleCB0byBzZXBlcmF0ZSBmcm9tIG5vIHNlbGVjdGlvblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtSW5zdGFuY2VzOyBpKyspIHtcbiAgICAgIGNvbnN0IHBpY2tpbmdDb2xvciA9IHRoaXMuZW5jb2RlUGlja2luZ0NvbG9yKGkpO1xuICAgICAgdmFsdWVbaSAqIHNpemUgKyAwXSA9IHBpY2tpbmdDb2xvclswXTtcbiAgICAgIHZhbHVlW2kgKiBzaXplICsgMV0gPSBwaWNraW5nQ29sb3JbMV07XG4gICAgICB2YWx1ZVtpICogc2l6ZSArIDJdID0gcGlja2luZ0NvbG9yWzJdO1xuICAgIH1cbiAgfVxuXG4gIC8vIERBVEEgQUNDRVNTIEFQSVxuICAvLyBEYXRhIGNhbiB1c2UgaXRlcmF0b3JzIGFuZCBtYXkgbm90IGJlIHJhbmRvbSBhY2Nlc3NcblxuICAvLyBVc2UgaXRlcmF0aW9uICh0aGUgb25seSByZXF1aXJlZCBjYXBhYmlsaXR5IG9uIGRhdGEpIHRvIGdldCBmaXJzdCBlbGVtZW50XG4gIGdldEZpcnN0T2JqZWN0KCkge1xuICAgIGNvbnN0IHtkYXRhfSA9IHRoaXMucHJvcHM7XG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgZGF0YSkge1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBJTlRFUk5BTCBNRVRIT0RTXG5cbiAgLy8gRGVkdWNlcyBudW1lciBvZiBpbnN0YW5jZXMuIEludGVudGlvbiBpcyB0byBzdXBwb3J0OlxuICAvLyAtIEV4cGxpY2l0IHNldHRpbmcgb2YgbnVtSW5zdGFuY2VzXG4gIC8vIC0gQXV0by1kZWR1Y3Rpb24gZm9yIEVTNiBjb250YWluZXJzIHRoYXQgZGVmaW5lIGEgc2l6ZSBtZW1iZXJcbiAgLy8gLSBBdXRvLWRlZHVjdGlvbiBmb3IgQ2xhc3NpYyBBcnJheXMgdmlhIHRoZSBidWlsdC1pbiBsZW5ndGggYXR0cmlidXRlXG4gIC8vIC0gQXV0by1kZWR1Y3Rpb24gdmlhIGFycmF5c1xuICBnZXROdW1JbnN0YW5jZXMocHJvcHMpIHtcbiAgICBwcm9wcyA9IHByb3BzIHx8IHRoaXMucHJvcHM7XG5cbiAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGUgbGF5ZXIgaGFzIHNldCBpdHMgb3duIHZhbHVlXG4gICAgaWYgKHRoaXMuc3RhdGUgJiYgdGhpcy5zdGF0ZS5udW1JbnN0YW5jZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUubnVtSW5zdGFuY2VzO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGFwcCBoYXMgcHJvdmlkZWQgYW4gZXhwbGljaXQgdmFsdWVcbiAgICBpZiAocHJvcHMubnVtSW5zdGFuY2VzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBwcm9wcy5udW1JbnN0YW5jZXM7XG4gICAgfVxuXG4gICAgLy8gVXNlIGNvbnRhaW5lciBsaWJyYXJ5IHRvIGdldCBhIGNvdW50IGZvciBhbnkgRVM2IGNvbnRhaW5lciBvciBvYmplY3RcbiAgICBjb25zdCB7ZGF0YX0gPSBwcm9wcztcbiAgICByZXR1cm4gY291bnQoZGF0YSk7XG4gIH1cblxuICAvLyBMQVlFUiBNQU5BR0VSIEFQSVxuICAvLyBTaG91bGQgb25seSBiZSBjYWxsZWQgYnkgdGhlIGRlY2suZ2wgTGF5ZXJNYW5hZ2VyIGNsYXNzXG5cbiAgLy8gQ2FsbGVkIGJ5IGxheWVyIG1hbmFnZXIgd2hlbiBhIG5ldyBsYXllciBpcyBmb3VuZFxuICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuICBpbml0aWFsaXplTGF5ZXIodXBkYXRlUGFyYW1zKSB7XG4gICAgYXNzZXJ0KHRoaXMuY29udGV4dC5nbCwgJ0xheWVyIGNvbnRleHQgbWlzc2luZyBnbCcpO1xuICAgIGFzc2VydCghdGhpcy5zdGF0ZSwgJ0xheWVyIG1pc3Npbmcgc3RhdGUnKTtcblxuICAgIHRoaXMuc3RhdGUgPSB7fTtcblxuICAgIC8vIEluaXRpYWxpemUgc3RhdGUgb25seSBvbmNlXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBhdHRyaWJ1dGVNYW5hZ2VyOiBuZXcgQXR0cmlidXRlTWFuYWdlcih7aWQ6IHRoaXMucHJvcHMuaWR9KSxcbiAgICAgIG1vZGVsOiBudWxsLFxuICAgICAgbmVlZHNSZWRyYXc6IHRydWUsXG4gICAgICBkYXRhQ2hhbmdlZDogdHJ1ZVxuICAgIH0pO1xuXG4gICAgLy8gQWRkIGF0dHJpYnV0ZSBtYW5hZ2VyIGxvZ2dlcnMgaWYgcHJvdmlkZWRcbiAgICB0aGlzLnN0YXRlLmF0dHJpYnV0ZU1hbmFnZXIuc2V0TG9nRnVuY3Rpb25zKHRoaXMucHJvcHMpO1xuXG4gICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcbiAgICAvLyBBbGwgaW5zdGFuY2VkIGxheWVycyBnZXQgaW5zdGFuY2VQaWNraW5nQ29sb3JzIGF0dHJpYnV0ZSBieSBkZWZhdWx0XG4gICAgLy8gVGhlaXIgc2hhZGVycyBjYW4gdXNlIGl0IHRvIHJlbmRlciBhIHBpY2tpbmcgc2NlbmVcbiAgICAvLyBUT0RPIC0gdGhpcyBzbG93cyBkb3duIG5vbiBpbnN0YW5jZWQgbGF5ZXJzXG4gICAgYXR0cmlidXRlTWFuYWdlci5hZGRJbnN0YW5jZWQoe1xuICAgICAgaW5zdGFuY2VQaWNraW5nQ29sb3JzOiB7XG4gICAgICAgIHR5cGU6IEdMLlVOU0lHTkVEX0JZVEUsXG4gICAgICAgIHNpemU6IDMsXG4gICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVBpY2tpbmdDb2xvcnNcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENhbGwgc3ViY2xhc3MgbGlmZWN5Y2xlIG1ldGhvZHNcbiAgICB0aGlzLmluaXRpYWxpemVTdGF0ZSgpO1xuICAgIHRoaXMudXBkYXRlU3RhdGUodXBkYXRlUGFyYW1zKTtcbiAgICAvLyBFbmQgc3ViY2xhc3MgbGlmZWN5Y2xlIG1ldGhvZHNcblxuICAgIC8vIEFkZCBhbnkgc3ViY2xhc3MgYXR0cmlidXRlc1xuICAgIHRoaXMudXBkYXRlQXR0cmlidXRlcyh0aGlzLnByb3BzKTtcbiAgICB0aGlzLl91cGRhdGVCYXNlVW5pZm9ybXMoKTtcblxuICAgIGNvbnN0IHttb2RlbH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmIChtb2RlbCkge1xuICAgICAgbW9kZWwuc2V0SW5zdGFuY2VDb3VudCh0aGlzLmdldE51bUluc3RhbmNlcygpKTtcbiAgICAgIG1vZGVsLmlkID0gdGhpcy5wcm9wcy5pZDtcbiAgICAgIG1vZGVsLnByb2dyYW0uaWQgPSBgJHt0aGlzLnByb3BzLmlkfS1wcm9ncmFtYDtcbiAgICAgIG1vZGVsLmdlb21ldHJ5LmlkID0gYCR7dGhpcy5wcm9wcy5pZH0tZ2VvbWV0cnlgO1xuICAgICAgbW9kZWwuc2V0QXR0cmlidXRlcyhhdHRyaWJ1dGVNYW5hZ2VyLmdldEF0dHJpYnV0ZXMoKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbGVkIGJ5IGxheWVyIG1hbmFnZXIgd2hlbiBleGlzdGluZyBsYXllciBpcyBnZXR0aW5nIG5ldyBwcm9wc1xuICB1cGRhdGVMYXllcih1cGRhdGVQYXJhbXMpIHtcbiAgICAvLyBDaGVjayBmb3IgZGVwcmVjYXRlZCBtZXRob2RcbiAgICBpZiAodGhpcy5zaG91bGRVcGRhdGUpIHtcbiAgICAgIGxvZy5vbmNlKDAsIGBkZWNrLmdsIHYzICR7dGhpc306IFwic2hvdWxkVXBkYXRlXCIgZGVwcmVjYXRlZCwgcmVuYW1lZCB0byBcInNob3VsZFVwZGF0ZVN0YXRlXCJgKTtcbiAgICB9XG5cbiAgICAvLyBDYWxsIHN1YmNsYXNzIGxpZmVjeWNsZSBtZXRob2RcbiAgICBjb25zdCBzdGF0ZU5lZWRzVXBkYXRlID0gdGhpcy5zaG91bGRVcGRhdGVTdGF0ZSh1cGRhdGVQYXJhbXMpO1xuICAgIC8vIEVuZCBsaWZlY3ljbGUgbWV0aG9kXG5cbiAgICBpZiAoc3RhdGVOZWVkc1VwZGF0ZSkge1xuXG4gICAgICAvLyBDYWxsIGRlcHJlY2F0ZWQgbGlmZWN5Y2xlIG1ldGhvZCBpZiBkZWZpbmVkXG4gICAgICBjb25zdCBoYXNSZWRlZmluZWRNZXRob2QgPSB0aGlzLndpbGxSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgdGhpcy53aWxsUmVjZWl2ZVByb3BzICE9PSBMYXllci5wcm90b3R5cGUud2lsbFJlY2VpdmVQcm9wcztcbiAgICAgIGlmIChoYXNSZWRlZmluZWRNZXRob2QpIHtcbiAgICAgICAgbG9nLm9uY2UoMCwgYGRlY2suZ2wgdjMgd2lsbFJlY2VpdmVQcm9wcyBkZXByZWNhdGVkLiBVc2UgdXBkYXRlU3RhdGUgaW4gJHt0aGlzfWApO1xuICAgICAgICBjb25zdCB7b2xkUHJvcHMsIHByb3BzLCBjaGFuZ2VGbGFnc30gPSB1cGRhdGVQYXJhbXM7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoY2hhbmdlRmxhZ3MpO1xuICAgICAgICB0aGlzLndpbGxSZWNlaXZlUHJvcHMob2xkUHJvcHMsIHByb3BzLCBjaGFuZ2VGbGFncyk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGRhdGFDaGFuZ2VkOiBmYWxzZSxcbiAgICAgICAgICB2aWV3cG9ydENoYW5nZWQ6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gRW5kIGxpZmVjeWNsZSBtZXRob2RcblxuICAgICAgLy8gQ2FsbCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kXG4gICAgICB0aGlzLnVwZGF0ZVN0YXRlKHVwZGF0ZVBhcmFtcyk7XG4gICAgICAvLyBFbmQgbGlmZWN5Y2xlIG1ldGhvZFxuXG4gICAgICAvLyBSdW4gdGhlIGF0dHJpYnV0ZSB1cGRhdGVyc1xuICAgICAgdGhpcy51cGRhdGVBdHRyaWJ1dGVzKHVwZGF0ZVBhcmFtcy5wcm9wcyk7XG4gICAgICB0aGlzLl91cGRhdGVCYXNlVW5pZm9ybXMoKTtcblxuICAgICAgaWYgKHRoaXMuc3RhdGUubW9kZWwpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5tb2RlbC5zZXRJbnN0YW5jZUNvdW50KHRoaXMuZ2V0TnVtSW5zdGFuY2VzKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG1heC1zdGF0ZW1lbnRzICovXG5cbiAgLy8gQ2FsbGVkIGJ5IG1hbmFnZXIgd2hlbiBsYXllciBpcyBhYm91dCB0byBiZSBkaXNwb3NlZFxuICAvLyBOb3RlOiBub3QgZ3VhcmFudGVlZCB0byBiZSBjYWxsZWQgb24gYXBwbGljYXRpb24gc2h1dGRvd25cbiAgZmluYWxpemVMYXllcigpIHtcbiAgICAvLyBDYWxsIHN1YmNsYXNzIGxpZmVjeWNsZSBtZXRob2RcbiAgICB0aGlzLmZpbmFsaXplU3RhdGUoKTtcbiAgICAvLyBFbmQgbGlmZWN5Y2xlIG1ldGhvZFxuICB9XG5cbiAgLy8gQ2FsY3VsYXRlcyB1bmlmb3Jtc1xuICBkcmF3TGF5ZXIoe3VuaWZvcm1zID0ge319KSB7XG4gICAgLy8gQ2FsbCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kXG4gICAgdGhpcy5kcmF3KHt1bmlmb3Jtc30pO1xuICAgIC8vIEVuZCBsaWZlY3ljbGUgbWV0aG9kXG4gIH1cblxuICAvLyB7dW5pZm9ybXMgPSB7fSwgLi4ub3B0c31cbiAgcGlja0xheWVyKG9wdHMpIHtcbiAgICAvLyBDYWxsIHN1YmNsYXNzIGxpZmVjeWNsZSBtZXRob2RcbiAgICByZXR1cm4gdGhpcy5nZXRQaWNraW5nSW5mbyhvcHRzKTtcbiAgICAvLyBFbmQgbGlmZWN5Y2xlIG1ldGhvZFxuICB9XG5cbiAgZGlmZlByb3BzKG9sZFByb3BzLCBuZXdQcm9wcywgY29udGV4dCkge1xuICAgIC8vIEZpcnN0IGNoZWNrIGlmIGFueSBwcm9wcyBoYXZlIGNoYW5nZWQgKGlnbm9yZSBwcm9wcyB0aGF0IHdpbGwgYmUgZXhhbWluZWQgc2VwYXJhdGVseSlcbiAgICBjb25zdCBwcm9wc0NoYW5nZWRSZWFzb24gPSBjb21wYXJlUHJvcHMoe1xuICAgICAgbmV3UHJvcHMsXG4gICAgICBvbGRQcm9wcyxcbiAgICAgIGlnbm9yZVByb3BzOiB7ZGF0YTogbnVsbCwgdXBkYXRlVHJpZ2dlcnM6IG51bGx9XG4gICAgfSk7XG5cbiAgICAvLyBOb3cgY2hlY2sgaWYgYW55IGRhdGEgcmVsYXRlZCBwcm9wcyBoYXZlIGNoYW5nZWRcbiAgICBjb25zdCBkYXRhQ2hhbmdlZFJlYXNvbiA9IHRoaXMuX2RpZmZEYXRhUHJvcHMob2xkUHJvcHMsIG5ld1Byb3BzKTtcblxuICAgIGNvbnN0IHByb3BzQ2hhbmdlZCA9IEJvb2xlYW4ocHJvcHNDaGFuZ2VkUmVhc29uKTtcbiAgICBjb25zdCBkYXRhQ2hhbmdlZCA9IEJvb2xlYW4oZGF0YUNoYW5nZWRSZWFzb24pO1xuICAgIGNvbnN0IHZpZXdwb3J0Q2hhbmdlZCA9IGNvbnRleHQudmlld3BvcnRDaGFuZ2VkO1xuICAgIGNvbnN0IHNvbWV0aGluZ0NoYW5nZWQgPSBwcm9wc0NoYW5nZWQgfHwgZGF0YUNoYW5nZWQgfHwgdmlld3BvcnRDaGFuZ2VkO1xuXG4gICAgLy8gQ2hlY2sgdXBkYXRlIHRyaWdnZXJzIHRvIGRldGVybWluZSBpZiBhbnkgYXR0cmlidXRlcyBuZWVkIHJlZ2VuZXJhdGlvblxuICAgIC8vIE5vdGUgLSBpZiBkYXRhIGhhcyBjaGFuZ2VkLCBhbGwgYXR0cmlidXRlcyB3aWxsIG5lZWQgcmVnZW5lcmF0aW9uLCBzbyBza2lwIHRoaXMgc3RlcFxuICAgIGlmICghZGF0YUNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2RpZmZVcGRhdGVUcmlnZ2VycyhvbGRQcm9wcywgbmV3UHJvcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2cubG9nKDEsIGBkYXRhQ2hhbmdlZDogJHtkYXRhQ2hhbmdlZH1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcHJvcHNDaGFuZ2VkLFxuICAgICAgZGF0YUNoYW5nZWQsXG4gICAgICB2aWV3cG9ydENoYW5nZWQsXG4gICAgICBzb21ldGhpbmdDaGFuZ2VkLFxuICAgICAgcmVhc29uOiBkYXRhQ2hhbmdlZFJlYXNvbiB8fCBwcm9wc0NoYW5nZWRSZWFzb25cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2hlY2tzIHN0YXRlIG9mIGF0dHJpYnV0ZXMgYW5kIG1vZGVsXG4gIC8vIFRPRE8gLSBpcyBhdHRyaWJ1dGUgbWFuYWdlciBuZWVkZWQ/IC0gTW9kZWwgc2hvdWxkIGJlIGVub3VnaC5cbiAgZ2V0TmVlZHNSZWRyYXcoe2NsZWFyUmVkcmF3RmxhZ3MgPSBmYWxzZX0gPSB7fSkge1xuICAgIC8vIHRoaXMgbWV0aG9kIG1heSBiZSBjYWxsZWQgYnkgdGhlIHJlbmRlciBsb29wIGFzIHNvb24gYSB0aGUgbGF5ZXJcbiAgICAvLyBoYXMgYmVlbiBjcmVhdGVkLCBzbyBndWFyZCBhZ2FpbnN0IHVuaW5pdGlhbGl6ZWQgc3RhdGVcbiAgICBpZiAoIXRoaXMuc3RhdGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgcmVkcmF3ID0gZmFsc2U7XG4gICAgcmVkcmF3ID0gcmVkcmF3IHx8IHRoaXMuc3RhdGUubmVlZHNSZWRyYXc7XG4gICAgdGhpcy5zdGF0ZS5uZWVkc1JlZHJhdyA9IHRoaXMuc3RhdGUubmVlZHNSZWRyYXcgJiYgIWNsZWFyUmVkcmF3RmxhZ3M7XG5cbiAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlciwgbW9kZWx9ID0gdGhpcy5zdGF0ZTtcbiAgICByZWRyYXcgPSByZWRyYXcgfHwgKGF0dHJpYnV0ZU1hbmFnZXIgJiYgYXR0cmlidXRlTWFuYWdlci5nZXROZWVkc1JlZHJhdyh7Y2xlYXJSZWRyYXdGbGFnc30pKTtcbiAgICByZWRyYXcgPSByZWRyYXcgfHwgKG1vZGVsICYmIG1vZGVsLmdldE5lZWRzUmVkcmF3KHtjbGVhclJlZHJhd0ZsYWdzfSkpO1xuXG4gICAgcmV0dXJuIHJlZHJhdztcbiAgfVxuXG4gIC8vIFBSSVZBVEUgTUVUSE9EU1xuXG4gIC8vIFRoZSBjb21wYXJpc29uIG9mIHRoZSBkYXRhIHByb3AgcmVxdWlyZXMgc3BlY2lhbCBoYW5kbGluZ1xuICAvLyB0aGUgZGF0YUNvbXBhcmF0b3Igc2hvdWxkIGJlIHVzZWQgaWYgc3VwcGxpZWRcbiAgX2RpZmZEYXRhUHJvcHMob2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgLy8gU3VwcG9ydCBvcHRpb25hbCBhcHAgZGVmaW5lZCBjb21wYXJpc29uIG9mIGRhdGFcbiAgICBjb25zdCB7ZGF0YUNvbXBhcmF0b3J9ID0gbmV3UHJvcHM7XG4gICAgaWYgKGRhdGFDb21wYXJhdG9yKSB7XG4gICAgICBpZiAoIWRhdGFDb21wYXJhdG9yKG5ld1Byb3BzLmRhdGEsIG9sZFByb3BzLmRhdGEpKSB7XG4gICAgICAgIHJldHVybiAnRGF0YSBjb21wYXJhdG9yIGRldGVjdGVkIGEgY2hhbmdlJztcbiAgICAgIH1cbiAgICAvLyBPdGhlcndpc2UsIGRvIGEgc2hhbGxvdyBlcXVhbCBvbiBwcm9wc1xuICAgIH0gZWxzZSBpZiAobmV3UHJvcHMuZGF0YSAhPT0gb2xkUHJvcHMuZGF0YSkge1xuICAgICAgcmV0dXJuICdBIG5ldyBkYXRhIGNvbnRhaW5lciB3YXMgc3VwcGxpZWQnO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQ2hlY2tzIGlmIGFueSB1cGRhdGUgdHJpZ2dlcnMgaGF2ZSBjaGFuZ2VkLCBhbmQgaW52YWxpZGF0ZVxuICAvLyBhdHRyaWJ1dGVzIGFjY29yZGluZ2x5LlxuICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuICBfZGlmZlVwZGF0ZVRyaWdnZXJzKG9sZFByb3BzLCBuZXdQcm9wcykge1xuICAgIC8vIGNvbnN0IHthdHRyaWJ1dGVNYW5hZ2VyfSA9IHRoaXMuc3RhdGU7XG4gICAgLy8gY29uc3QgdXBkYXRlVHJpZ2dlck1hcCA9IGF0dHJpYnV0ZU1hbmFnZXIuZ2V0VXBkYXRlVHJpZ2dlck1hcCgpO1xuXG4gICAgbGV0IGNoYW5nZSA9IGZhbHNlO1xuXG4gICAgZm9yIChjb25zdCBwcm9wTmFtZSBpbiBuZXdQcm9wcy51cGRhdGVUcmlnZ2Vycykge1xuICAgICAgY29uc3Qgb2xkVHJpZ2dlcnMgPSBvbGRQcm9wcy51cGRhdGVUcmlnZ2Vyc1twcm9wTmFtZV0gfHwge307XG4gICAgICBjb25zdCBuZXdUcmlnZ2VycyA9IG5ld1Byb3BzLnVwZGF0ZVRyaWdnZXJzW3Byb3BOYW1lXSB8fCB7fTtcbiAgICAgIGNvbnN0IGRpZmZSZWFzb24gPSBjb21wYXJlUHJvcHMoe1xuICAgICAgICBvbGRQcm9wczogb2xkVHJpZ2dlcnMsXG4gICAgICAgIG5ld1Byb3BzOiBuZXdUcmlnZ2Vyc1xuICAgICAgfSk7XG4gICAgICBpZiAoZGlmZlJlYXNvbikge1xuICAgICAgICBpZiAocHJvcE5hbWUgPT09ICdhbGwnKSB7XG4gICAgICAgICAgbG9nLmxvZygxLCBgdXBkYXRlVHJpZ2dlcnMgaW52YWxpZGF0aW5nIGFsbCBhdHRyaWJ1dGVzOiAke2RpZmZSZWFzb259YCk7XG4gICAgICAgICAgdGhpcy5pbnZhbGlkYXRlQXR0cmlidXRlKCdhbGwnKTtcbiAgICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZy5sb2coMSwgYHVwZGF0ZVRyaWdnZXJzIGludmFsaWRhdGluZyBhdHRyaWJ1dGUgJHtwcm9wTmFtZX06ICR7ZGlmZlJlYXNvbn1gKTtcbiAgICAgICAgICB0aGlzLmludmFsaWRhdGVBdHRyaWJ1dGUocHJvcE5hbWUpO1xuICAgICAgICAgIGNoYW5nZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbmdlO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMgKi9cblxuICBfY2hlY2tSZXF1aXJlZFByb3AocHJvcGVydHlOYW1lLCBjb25kaXRpb24pIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMucHJvcHNbcHJvcGVydHlOYW1lXTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9wZXJ0eSAke3Byb3BlcnR5TmFtZX0gdW5kZWZpbmVkIGluIGxheWVyICR7dGhpc31gKTtcbiAgICB9XG4gICAgaWYgKGNvbmRpdGlvbiAmJiAhY29uZGl0aW9uKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBCYWQgcHJvcGVydHkgJHtwcm9wZXJ0eU5hbWV9IGluIGxheWVyICR7dGhpc31gKTtcbiAgICB9XG4gIH1cblxuICAvLyBFbWl0cyBhIHdhcm5pbmcgaWYgYW4gb2xkIHByb3AgaXMgdXNlZCwgb3B0aW9uYWxseSBzdWdnZXN0aW5nIGEgcmVwbGFjZW1lbnRcbiAgX2NoZWNrUmVtb3ZlZFByb3Aob2xkUHJvcCwgbmV3UHJvcCA9IG51bGwpIHtcbiAgICBpZiAodGhpcy5wcm9wc1tvbGRQcm9wXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBsYXllck5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgbGV0IG1lc3NhZ2UgPSBgJHtsYXllck5hbWV9IG5vIGxvbmdlciBhY2NlcHRzIHByb3BzLiR7b2xkUHJvcH0gaW4gdGhpcyB2ZXJzaW9uIG9mIGRlY2suZ2wuYDtcbiAgICAgIGlmIChuZXdQcm9wKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gYFxcblBsZWFzZSB1c2UgcHJvcHMuJHtuZXdQcm9wfSBpbnN0ZWFkLmA7XG4gICAgICB9XG4gICAgICBsb2cub25jZSgwLCBtZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlQmFzZVVuaWZvcm1zKCkge1xuICAgIHRoaXMuc2V0VW5pZm9ybXMoe1xuICAgICAgLy8gYXBwbHkgZ2FtbWEgdG8gb3BhY2l0eSB0byBtYWtlIGl0IHZpc3VhbGx5IFwibGluZWFyXCJcbiAgICAgIG9wYWNpdHk6IE1hdGgucG93KHRoaXMucHJvcHMub3BhY2l0eSwgMSAvIDIuMiksXG4gICAgICBPTkU6IDEuMFxuICAgIH0pO1xuICB9XG5cbiAgLy8gREVQUkVDQVRFRCBNRVRIT0RTXG4gIC8vIHNob3VsZFVwZGF0ZSgpIHt9XG5cbiAgd2lsbFJlY2VpdmVQcm9wcygpIHtcbiAgfVxuXG4gIC8vIFVwZGF0ZXMgc2VsZWN0ZWQgc3RhdGUgbWVtYmVycyBhbmQgbWFya3MgdGhlIG9iamVjdCBmb3IgcmVkcmF3XG4gIHNldFVuaWZvcm1zKHVuaWZvcm1NYXApIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5tb2RlbCkge1xuICAgICAgdGhpcy5zdGF0ZS5tb2RlbC5zZXRVbmlmb3Jtcyh1bmlmb3JtTWFwKTtcbiAgICB9XG4gICAgLy8gVE9ETyAtIHNldCBuZWVkc1JlZHJhdyBvbiB0aGUgbW9kZWw/XG4gICAgdGhpcy5zdGF0ZS5uZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgbG9nKDMsICdsYXllci5zZXRVbmlmb3JtcycsIHVuaWZvcm1NYXApO1xuICB9XG59XG5cbkxheWVyLmxheWVyTmFtZSA9ICdMYXllcic7XG5MYXllci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5cbi8vIEhFTFBFUlNcblxuLy8gQ29uc3RydWN0b3JzIGhhdmUgdGhlaXIgc3VwZXIgY2xhc3MgY29uc3RydWN0b3JzIGFzIHByb3RvdHlwZXNcbmZ1bmN0aW9uIGdldE93blByb3BlcnR5KG9iamVjdCwgcHJvcCkge1xuICByZXR1cm4gb2JqZWN0Lmhhc093blByb3BlcnR5KHByb3ApICYmIG9iamVjdFtwcm9wXTtcbn1cbi8qXG4gKiBSZXR1cm4gbWVyZ2VkIGRlZmF1bHQgcHJvcHMgc3RvcmVkIG9uIGxheWVycyBjb25zdHJ1Y3RvciwgY3JlYXRlIHRoZW0gaWYgbmVlZGVkXG4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcyhsYXllcikge1xuICBjb25zdCBtZXJnZWREZWZhdWx0UHJvcHMgPSBnZXRPd25Qcm9wZXJ0eShsYXllci5jb25zdHJ1Y3RvciwgJ21lcmdlZERlZmF1bHRQcm9wcycpO1xuICBpZiAobWVyZ2VkRGVmYXVsdFByb3BzKSB7XG4gICAgcmV0dXJuIG1lcmdlZERlZmF1bHRQcm9wcztcbiAgfVxuICByZXR1cm4gbWVyZ2VEZWZhdWx0UHJvcHMobGF5ZXIpO1xufVxuXG4vKlxuICogV2FsayB0aGUgcHJvdG90eXBlIGNoYWluIGFuZCBtZXJnZSBhbGwgZGVmYXVsdCBwcm9wc1xuICovXG5mdW5jdGlvbiBtZXJnZURlZmF1bHRQcm9wcyhsYXllcikge1xuICBjb25zdCBzdWJDbGFzc0NvbnN0cnVjdG9yID0gbGF5ZXIuY29uc3RydWN0b3I7XG4gIGNvbnN0IGxheWVyTmFtZSA9IGdldE93blByb3BlcnR5KHN1YkNsYXNzQ29uc3RydWN0b3IsICdsYXllck5hbWUnKTtcbiAgaWYgKCFsYXllck5hbWUpIHtcbiAgICBsb2cub25jZSgwLCBgbGF5ZXIgJHtsYXllci5jb25zdHJ1Y3Rvci5uYW1lfSBkb2VzIG5vdCBzcGVjaWZ5IGEgXCJsYXllck5hbWVcImApO1xuICB9XG4gIGxldCBtZXJnZWREZWZhdWx0UHJvcHMgPSB7XG4gICAgaWQ6IGxheWVyTmFtZSB8fCBsYXllci5jb25zdHJ1Y3Rvci5uYW1lXG4gIH07XG5cbiAgd2hpbGUgKGxheWVyKSB7XG4gICAgY29uc3QgbGF5ZXJEZWZhdWx0UHJvcHMgPSBnZXRPd25Qcm9wZXJ0eShsYXllci5jb25zdHJ1Y3RvciwgJ2RlZmF1bHRQcm9wcycpO1xuICAgIE9iamVjdC5mcmVlemUobGF5ZXJEZWZhdWx0UHJvcHMpO1xuICAgIGlmIChsYXllckRlZmF1bHRQcm9wcykge1xuICAgICAgbWVyZ2VkRGVmYXVsdFByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgbGF5ZXJEZWZhdWx0UHJvcHMsIG1lcmdlZERlZmF1bHRQcm9wcyk7XG4gICAgfVxuICAgIGxheWVyID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGxheWVyKTtcbiAgfVxuICAvLyBTdG9yZSBmb3IgcXVpY2sgbG9va3VwXG4gIHN1YkNsYXNzQ29uc3RydWN0b3IubWVyZ2VkRGVmYXVsdFByb3BzID0gbWVyZ2VkRGVmYXVsdFByb3BzO1xuICByZXR1cm4gbWVyZ2VkRGVmYXVsdFByb3BzO1xufVxuXG5leHBvcnQgY29uc3QgVEVTVF9FWFBPUlRTID0ge1xuICBtZXJnZURlZmF1bHRQcm9wc1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xpYi9sYXllci5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 16 */
/* exports provided: default, Viewport, PerspectiveViewport, OrthographicViewport, WebMercatorViewport */
/* exports used: WebMercatorViewport, Viewport */
/*!************************************!*\
  !*** ./src/lib/viewports/index.js ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__viewport__ = __webpack_require__(/*! ./viewport */ 5);\n/* unused harmony reexport default */\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return __WEBPACK_IMPORTED_MODULE_0__viewport__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__perspective_viewport__ = __webpack_require__(/*! ./perspective-viewport */ 24);\n/* unused harmony reexport PerspectiveViewport */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__orthographic_viewport__ = __webpack_require__(/*! ./orthographic-viewport */ 23);\n/* unused harmony reexport OrthographicViewport */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__web_mercator_viewport__ = __webpack_require__(/*! ./web-mercator-viewport */ 25);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_3__web_mercator_viewport__[\"a\"]; });\n\n\n\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL3ZpZXdwb3J0cy9pbmRleC5qcz85OTBiIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7ZGVmYXVsdCBhcyBkZWZhdWx0fSBmcm9tICcuL3ZpZXdwb3J0JztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBWaWV3cG9ydH0gZnJvbSAnLi92aWV3cG9ydCc7XG5leHBvcnQge2RlZmF1bHQgYXMgUGVyc3BlY3RpdmVWaWV3cG9ydH0gZnJvbSAnLi9wZXJzcGVjdGl2ZS12aWV3cG9ydCc7XG5leHBvcnQge2RlZmF1bHQgYXMgT3J0aG9ncmFwaGljVmlld3BvcnR9IGZyb20gJy4vb3J0aG9ncmFwaGljLXZpZXdwb3J0JztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBXZWJNZXJjYXRvclZpZXdwb3J0fSBmcm9tICcuL3dlYi1tZXJjYXRvci12aWV3cG9ydCc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9saWIvdmlld3BvcnRzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 17 */
/* exports provided: default */
/* exports used: default */
/*!*************************************************************!*\
  !*** ./src/experimental/effects/reflection-effect/index.js ***!
  \*************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__reflection_effect__ = __webpack_require__(/*! ./reflection-effect */ 50);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_0__reflection_effect__[\"a\"]; });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZXhwZXJpbWVudGFsL2VmZmVjdHMvcmVmbGVjdGlvbi1lZmZlY3QvaW5kZXguanM/ZDg4OSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge2RlZmF1bHQgYXMgZGVmYXVsdH0gZnJvbSAnLi9yZWZsZWN0aW9uLWVmZmVjdCc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9leHBlcmltZW50YWwvZWZmZWN0cy9yZWZsZWN0aW9uLWVmZmVjdC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 18 */
/* exports provided: default */
/* exports used: default */
/*!************************************************************!*\
  !*** ./src/layers/core/grid-cell-layer/grid-cell-layer.js ***!
  \************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl__ = __webpack_require__(/*! luma.gl */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__ = __webpack_require__(/*! ../../../lib/utils/fp64 */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__grid_cell_layer_vertex_glsl__ = __webpack_require__(/*! ./grid-cell-layer-vertex.glsl */ 60);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__grid_cell_layer_vertex_64_glsl__ = __webpack_require__(/*! ./grid-cell-layer-vertex-64.glsl */ 59);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__grid_cell_layer_fragment_glsl__ = __webpack_require__(/*! ./grid-cell-layer-fragment.glsl */ 58);\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\n\n\n\n\nconst DEFAULT_COLOR = [255, 0, 255, 255];\n\nconst defaultProps = {\n  cellSize: 1000,\n  // AUDIT - replace with cellsize\n  lonOffset: 0.0113,\n  latOffset: 0.0089,\n\n  elevationScale: 1,\n  extruded: true,\n  fp64: false,\n\n  getPosition: x => x.position,\n  getElevation: x => x.elevation,\n  getColor: x => x.color,\n\n  lightSettings: {\n    lightsPosition: [-122.45, 37.65, 8000, -122.45, 37.20, 1000],\n    ambientRatio: 0.4,\n    diffuseRatio: 0.6,\n    specularRatio: 0.8,\n    lightsStrength: [1.0, 0.0, 0.8, 0.0],\n    numberOfLights: 2\n  }\n};\n\nclass GridCellLayer extends __WEBPACK_IMPORTED_MODULE_0__lib__[\"a\" /* Layer */] {\n  /**\n   * A generic GridLayer that takes latitude longitude delta of cells as a uniform\n   * and the min lat lng of cells. grid can be 3d when pass in a height\n   * and set enable3d to true\n   *\n   * @param {array} props.data -\n   * @param {boolean} props.extruded - enable grid elevation\n   * @param {number} props.latOffset - grid cell size in lat delta\n   * @param {number} props.lonOffset - grid cell size in lng delta\n   * @param {function} props.getPosition - position accessor, returned as [minLng, minLat]\n   * @param {function} props.getElevation - elevation accessor\n   * @param {function} props.getColor - color accessor, returned as [r, g, b, a]\n   */\n\n  getShaders() {\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__[\"b\" /* enable64bitSupport */])(this.props) ? {\n      vs: __WEBPACK_IMPORTED_MODULE_5__grid_cell_layer_vertex_64_glsl__[\"a\" /* default */], fs: __WEBPACK_IMPORTED_MODULE_6__grid_cell_layer_fragment_glsl__[\"a\" /* default */], modules: ['fp64', 'project64', 'lighting']\n    } : {\n      vs: __WEBPACK_IMPORTED_MODULE_4__grid_cell_layer_vertex_glsl__[\"a\" /* default */], fs: __WEBPACK_IMPORTED_MODULE_6__grid_cell_layer_fragment_glsl__[\"a\" /* default */], modules: ['lighting']\n    };\n  }\n\n  initializeState() {\n    const {gl} = this.context;\n    this.setState({model: this._getModel(gl)});\n\n    const {attributeManager} = this.state;\n    /* eslint-disable max-len */\n    attributeManager.addInstanced({\n      instancePositions: {size: 4, accessor: ['getPosition', 'getElevation'], update: this.calculateInstancePositions},\n      instanceColors: {size: 4, type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].UNSIGNED_BYTE, accessor: 'getColor', update: this.calculateInstanceColors}\n    });\n    /* eslint-enable max-len */\n  }\n\n  updateAttribute({props, oldProps, changeFlags}) {\n    if (props.fp64 !== oldProps.fp64) {\n      const {attributeManager} = this.state;\n      attributeManager.invalidateAll();\n\n      if (props.fp64 && props.projectionMode === __WEBPACK_IMPORTED_MODULE_0__lib__[\"e\" /* COORDINATE_SYSTEM */].LNG_LAT) {\n        attributeManager.addInstanced({\n          instancePositions64xyLow: {\n            size: 2,\n            accessor: 'getPosition',\n            update: this.calculateInstancePositions64xyLow\n          }\n        });\n      } else {\n        attributeManager.remove([\n          'instancePositions64xyLow'\n        ]);\n      }\n\n    }\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    super.updateState({props, oldProps, changeFlags});\n    // Re-generate model if geometry changed\n    if (props.fp64 !== oldProps.fp64) {\n      const {gl} = this.context;\n      this.setState({model: this._getModel(gl)});\n    }\n    this.updateAttribute({props, oldProps, changeFlags});\n    this.updateUniforms();\n  }\n\n  _getModel(gl) {\n    const geometry = new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"CubeGeometry\"]({});\n    const shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"a\" /* assembleShaders */])(gl, this.getShaders());\n\n    return new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Model\"]({\n      gl,\n      id: this.props.id,\n      vs: shaders.vs,\n      fs: shaders.fs,\n      geometry,\n      isInstanced: true\n    });\n  }\n\n  updateUniforms() {\n    const {opacity, extruded, elevationScale, latOffset, lonOffset, lightSettings} = this.props;\n\n    this.setUniforms(Object.assign({}, {\n      extruded,\n      elevationScale,\n      opacity,\n      latOffset,\n      lonOffset\n    },\n    lightSettings));\n  }\n\n  draw({uniforms}) {\n    super.draw({uniforms: Object.assign({}, uniforms)});\n  }\n\n  calculateInstancePositions(attribute) {\n    const {data, getPosition, getElevation} = this.props;\n    const {value, size} = attribute;\n    let i = 0;\n    for (const object of data) {\n      const position = getPosition(object);\n      const elevation = getElevation(object) || 0;\n      value[i + 0] = position[0];\n      value[i + 1] = position[1];\n      value[i + 2] = 0;\n      value[i + 3] = elevation;\n      i += size;\n    }\n  }\n\n  calculateInstancePositions64xyLow(attribute) {\n    const {data, getPosition} = this.props;\n    const {value} = attribute;\n    let i = 0;\n    for (const point of data) {\n      const position = getPosition(point);\n      value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__[\"a\" /* fp64ify */])(position[0])[1];\n      value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__[\"a\" /* fp64ify */])(position[1])[1];\n    }\n  }\n\n  calculateInstanceColors(attribute) {\n    const {data, getColor} = this.props;\n    const {value, size} = attribute;\n    let i = 0;\n    for (const object of data) {\n      const color = getColor(object) || DEFAULT_COLOR;\n      value[i + 0] = color[0];\n      value[i + 1] = color[1];\n      value[i + 2] = color[2];\n      value[i + 3] = Number.isFinite(color[3]) ? color[3] : DEFAULT_COLOR[3];\n      i += size;\n    }\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = GridCellLayer;\n\n\nGridCellLayer.layerName = 'GridCellLayer';\nGridCellLayer.defaultProps = defaultProps;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvZ3JpZC1jZWxsLWxheWVyL2dyaWQtY2VsbC1sYXllci5qcz82ZTQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNiBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uLy4uLy4uL2xpYic7XG5pbXBvcnQge2Fzc2VtYmxlU2hhZGVyc30gZnJvbSAnLi4vLi4vLi4vc2hhZGVyLXV0aWxzJztcbmltcG9ydCB7R0wsIE1vZGVsLCBDdWJlR2VvbWV0cnl9IGZyb20gJ2x1bWEuZ2wnO1xuaW1wb3J0IHtmcDY0aWZ5LCBlbmFibGU2NGJpdFN1cHBvcnR9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscy9mcDY0JztcbmltcG9ydCB7Q09PUkRJTkFURV9TWVNURU19IGZyb20gJy4uLy4uLy4uL2xpYic7XG5cbmltcG9ydCBncmlkQ2VsbFZlcnRleCBmcm9tICcuL2dyaWQtY2VsbC1sYXllci12ZXJ0ZXguZ2xzbCc7XG5pbXBvcnQgZ3JpZENlbGxWZXJ0ZXg2NCBmcm9tICcuL2dyaWQtY2VsbC1sYXllci12ZXJ0ZXgtNjQuZ2xzbCc7XG5pbXBvcnQgZ3JpZENlbGxGcmFnbWVudCBmcm9tICcuL2dyaWQtY2VsbC1sYXllci1mcmFnbWVudC5nbHNsJztcblxuY29uc3QgREVGQVVMVF9DT0xPUiA9IFsyNTUsIDAsIDI1NSwgMjU1XTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBjZWxsU2l6ZTogMTAwMCxcbiAgLy8gQVVESVQgLSByZXBsYWNlIHdpdGggY2VsbHNpemVcbiAgbG9uT2Zmc2V0OiAwLjAxMTMsXG4gIGxhdE9mZnNldDogMC4wMDg5LFxuXG4gIGVsZXZhdGlvblNjYWxlOiAxLFxuICBleHRydWRlZDogdHJ1ZSxcbiAgZnA2NDogZmFsc2UsXG5cbiAgZ2V0UG9zaXRpb246IHggPT4geC5wb3NpdGlvbixcbiAgZ2V0RWxldmF0aW9uOiB4ID0+IHguZWxldmF0aW9uLFxuICBnZXRDb2xvcjogeCA9PiB4LmNvbG9yLFxuXG4gIGxpZ2h0U2V0dGluZ3M6IHtcbiAgICBsaWdodHNQb3NpdGlvbjogWy0xMjIuNDUsIDM3LjY1LCA4MDAwLCAtMTIyLjQ1LCAzNy4yMCwgMTAwMF0sXG4gICAgYW1iaWVudFJhdGlvOiAwLjQsXG4gICAgZGlmZnVzZVJhdGlvOiAwLjYsXG4gICAgc3BlY3VsYXJSYXRpbzogMC44LFxuICAgIGxpZ2h0c1N0cmVuZ3RoOiBbMS4wLCAwLjAsIDAuOCwgMC4wXSxcbiAgICBudW1iZXJPZkxpZ2h0czogMlxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcmlkQ2VsbExheWVyIGV4dGVuZHMgTGF5ZXIge1xuICAvKipcbiAgICogQSBnZW5lcmljIEdyaWRMYXllciB0aGF0IHRha2VzIGxhdGl0dWRlIGxvbmdpdHVkZSBkZWx0YSBvZiBjZWxscyBhcyBhIHVuaWZvcm1cbiAgICogYW5kIHRoZSBtaW4gbGF0IGxuZyBvZiBjZWxscy4gZ3JpZCBjYW4gYmUgM2Qgd2hlbiBwYXNzIGluIGEgaGVpZ2h0XG4gICAqIGFuZCBzZXQgZW5hYmxlM2QgdG8gdHJ1ZVxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5fSBwcm9wcy5kYXRhIC1cbiAgICogQHBhcmFtIHtib29sZWFufSBwcm9wcy5leHRydWRlZCAtIGVuYWJsZSBncmlkIGVsZXZhdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gcHJvcHMubGF0T2Zmc2V0IC0gZ3JpZCBjZWxsIHNpemUgaW4gbGF0IGRlbHRhXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwcm9wcy5sb25PZmZzZXQgLSBncmlkIGNlbGwgc2l6ZSBpbiBsbmcgZGVsdGFcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gcHJvcHMuZ2V0UG9zaXRpb24gLSBwb3NpdGlvbiBhY2Nlc3NvciwgcmV0dXJuZWQgYXMgW21pbkxuZywgbWluTGF0XVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBwcm9wcy5nZXRFbGV2YXRpb24gLSBlbGV2YXRpb24gYWNjZXNzb3JcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gcHJvcHMuZ2V0Q29sb3IgLSBjb2xvciBhY2Nlc3NvciwgcmV0dXJuZWQgYXMgW3IsIGcsIGIsIGFdXG4gICAqL1xuXG4gIGdldFNoYWRlcnMoKSB7XG4gICAgcmV0dXJuIGVuYWJsZTY0Yml0U3VwcG9ydCh0aGlzLnByb3BzKSA/IHtcbiAgICAgIHZzOiBncmlkQ2VsbFZlcnRleDY0LCBmczogZ3JpZENlbGxGcmFnbWVudCwgbW9kdWxlczogWydmcDY0JywgJ3Byb2plY3Q2NCcsICdsaWdodGluZyddXG4gICAgfSA6IHtcbiAgICAgIHZzOiBncmlkQ2VsbFZlcnRleCwgZnM6IGdyaWRDZWxsRnJhZ21lbnQsIG1vZHVsZXM6IFsnbGlnaHRpbmcnXVxuICAgIH07XG4gIH1cblxuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgY29uc3Qge2dsfSA9IHRoaXMuY29udGV4dDtcbiAgICB0aGlzLnNldFN0YXRlKHttb2RlbDogdGhpcy5fZ2V0TW9kZWwoZ2wpfSk7XG5cbiAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICBpbnN0YW5jZVBvc2l0aW9uczoge3NpemU6IDQsIGFjY2Vzc29yOiBbJ2dldFBvc2l0aW9uJywgJ2dldEVsZXZhdGlvbiddLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnN9LFxuICAgICAgaW5zdGFuY2VDb2xvcnM6IHtzaXplOiA0LCB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLCBhY2Nlc3NvcjogJ2dldENvbG9yJywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlQ29sb3JzfVxuICAgIH0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuICB9XG5cbiAgdXBkYXRlQXR0cmlidXRlKHtwcm9wcywgb2xkUHJvcHMsIGNoYW5nZUZsYWdzfSkge1xuICAgIGlmIChwcm9wcy5mcDY0ICE9PSBvbGRQcm9wcy5mcDY0KSB7XG4gICAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgICAgYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlQWxsKCk7XG5cbiAgICAgIGlmIChwcm9wcy5mcDY0ICYmIHByb3BzLnByb2plY3Rpb25Nb2RlID09PSBDT09SRElOQVRFX1NZU1RFTS5MTkdfTEFUKSB7XG4gICAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkSW5zdGFuY2VkKHtcbiAgICAgICAgICBpbnN0YW5jZVBvc2l0aW9uczY0eHlMb3c6IHtcbiAgICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgICBhY2Nlc3NvcjogJ2dldFBvc2l0aW9uJyxcbiAgICAgICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9uczY0eHlMb3dcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cmlidXRlTWFuYWdlci5yZW1vdmUoW1xuICAgICAgICAgICdpbnN0YW5jZVBvc2l0aW9uczY0eHlMb3cnXG4gICAgICAgIF0pO1xuICAgICAgfVxuXG4gICAgfVxuICB9XG5cbiAgdXBkYXRlU3RhdGUoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KSB7XG4gICAgc3VwZXIudXBkYXRlU3RhdGUoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KTtcbiAgICAvLyBSZS1nZW5lcmF0ZSBtb2RlbCBpZiBnZW9tZXRyeSBjaGFuZ2VkXG4gICAgaWYgKHByb3BzLmZwNjQgIT09IG9sZFByb3BzLmZwNjQpIHtcbiAgICAgIGNvbnN0IHtnbH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICB0aGlzLnNldFN0YXRlKHttb2RlbDogdGhpcy5fZ2V0TW9kZWwoZ2wpfSk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlQXR0cmlidXRlKHtwcm9wcywgb2xkUHJvcHMsIGNoYW5nZUZsYWdzfSk7XG4gICAgdGhpcy51cGRhdGVVbmlmb3JtcygpO1xuICB9XG5cbiAgX2dldE1vZGVsKGdsKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgQ3ViZUdlb21ldHJ5KHt9KTtcbiAgICBjb25zdCBzaGFkZXJzID0gYXNzZW1ibGVTaGFkZXJzKGdsLCB0aGlzLmdldFNoYWRlcnMoKSk7XG5cbiAgICByZXR1cm4gbmV3IE1vZGVsKHtcbiAgICAgIGdsLFxuICAgICAgaWQ6IHRoaXMucHJvcHMuaWQsXG4gICAgICB2czogc2hhZGVycy52cyxcbiAgICAgIGZzOiBzaGFkZXJzLmZzLFxuICAgICAgZ2VvbWV0cnksXG4gICAgICBpc0luc3RhbmNlZDogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgdXBkYXRlVW5pZm9ybXMoKSB7XG4gICAgY29uc3Qge29wYWNpdHksIGV4dHJ1ZGVkLCBlbGV2YXRpb25TY2FsZSwgbGF0T2Zmc2V0LCBsb25PZmZzZXQsIGxpZ2h0U2V0dGluZ3N9ID0gdGhpcy5wcm9wcztcblxuICAgIHRoaXMuc2V0VW5pZm9ybXMoT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgZXh0cnVkZWQsXG4gICAgICBlbGV2YXRpb25TY2FsZSxcbiAgICAgIG9wYWNpdHksXG4gICAgICBsYXRPZmZzZXQsXG4gICAgICBsb25PZmZzZXRcbiAgICB9LFxuICAgIGxpZ2h0U2V0dGluZ3MpKTtcbiAgfVxuXG4gIGRyYXcoe3VuaWZvcm1zfSkge1xuICAgIHN1cGVyLmRyYXcoe3VuaWZvcm1zOiBPYmplY3QuYXNzaWduKHt9LCB1bmlmb3Jtcyl9KTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtkYXRhLCBnZXRQb3NpdGlvbiwgZ2V0RWxldmF0aW9ufSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3ZhbHVlLCBzaXplfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgZGF0YSkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRQb3NpdGlvbihvYmplY3QpO1xuICAgICAgY29uc3QgZWxldmF0aW9uID0gZ2V0RWxldmF0aW9uKG9iamVjdCkgfHwgMDtcbiAgICAgIHZhbHVlW2kgKyAwXSA9IHBvc2l0aW9uWzBdO1xuICAgICAgdmFsdWVbaSArIDFdID0gcG9zaXRpb25bMV07XG4gICAgICB2YWx1ZVtpICsgMl0gPSAwO1xuICAgICAgdmFsdWVbaSArIDNdID0gZWxldmF0aW9uO1xuICAgICAgaSArPSBzaXplO1xuICAgIH1cbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zNjR4eUxvdyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7ZGF0YSwgZ2V0UG9zaXRpb259ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7dmFsdWV9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IHBvaW50IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UG9zaXRpb24ocG9pbnQpO1xuICAgICAgdmFsdWVbaSsrXSA9IGZwNjRpZnkocG9zaXRpb25bMF0pWzFdO1xuICAgICAgdmFsdWVbaSsrXSA9IGZwNjRpZnkocG9zaXRpb25bMV0pWzFdO1xuICAgIH1cbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlQ29sb3JzKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtkYXRhLCBnZXRDb2xvcn0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHt2YWx1ZSwgc2l6ZX0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gZ2V0Q29sb3Iob2JqZWN0KSB8fCBERUZBVUxUX0NPTE9SO1xuICAgICAgdmFsdWVbaSArIDBdID0gY29sb3JbMF07XG4gICAgICB2YWx1ZVtpICsgMV0gPSBjb2xvclsxXTtcbiAgICAgIHZhbHVlW2kgKyAyXSA9IGNvbG9yWzJdO1xuICAgICAgdmFsdWVbaSArIDNdID0gTnVtYmVyLmlzRmluaXRlKGNvbG9yWzNdKSA/IGNvbG9yWzNdIDogREVGQVVMVF9DT0xPUlszXTtcbiAgICAgIGkgKz0gc2l6ZTtcbiAgICB9XG4gIH1cbn1cblxuR3JpZENlbGxMYXllci5sYXllck5hbWUgPSAnR3JpZENlbGxMYXllcic7XG5HcmlkQ2VsbExheWVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xheWVycy9jb3JlL2dyaWQtY2VsbC1sYXllci9ncmlkLWNlbGwtbGF5ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 19 */
/* exports provided: default */
/* exports used: default */
/*!******************************************************************!*\
  !*** ./src/layers/core/hexagon-cell-layer/hexagon-cell-layer.js ***!
  \******************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl__ = __webpack_require__(/*! luma.gl */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_utils__ = __webpack_require__(/*! ../../../lib/utils */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__lib_utils_fp64__ = __webpack_require__(/*! ../../../lib/utils/fp64 */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__hexagon_cell_layer_vertex_glsl__ = __webpack_require__(/*! ./hexagon-cell-layer-vertex.glsl */ 64);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__hexagon_cell_layer_vertex_64_glsl__ = __webpack_require__(/*! ./hexagon-cell-layer-vertex-64.glsl */ 63);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__hexagon_cell_layer_fragment_glsl__ = __webpack_require__(/*! ./hexagon-cell-layer-fragment.glsl */ 62);\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\n\n\n\n\n\nfunction positionsAreEqual(v1, v2) {\n  // Hex positions are expected to change entirely, not to maintain some\n  // positions and change others. Right now we only check a single vertex,\n  // because H3 guarantees order, but even if that wasn't true, this would only\n  // return a false positive for adjacent hexagons, which is close enough for\n  // our purposes.\n  return v1 === v2 || (\n    v1 && v2 && v1[0][0] === v2[0][0] && v1[0][1] === v2[0][1]\n  );\n}\n\nconst DEFAULT_COLOR = [255, 0, 255, 255];\n\nconst defaultProps = {\n  hexagonVertices: null,\n  radius: null,\n  angle: null,\n  coverage: 1,\n  elevationScale: 1,\n  extruded: true,\n  fp64: false,\n\n  getCentroid: x => x.centroid,\n  getColor: x => x.color,\n  getElevation: x => x.elevation,\n\n  lightSettings: {\n    lightsPosition: [-122.45, 37.75, 8000, -122.0, 38.00, 5000],\n    ambientRatio: 0.4,\n    diffuseRatio: 0.6,\n    specularRatio: 0.8,\n    lightsStrength: [1.2, 0.0, 0.8, 0.0],\n    numberOfLights: 2\n  }\n};\n\nclass HexagonCellLayer extends __WEBPACK_IMPORTED_MODULE_0__lib__[\"a\" /* Layer */] {\n\n  constructor(props) {\n    let missingProps = false;\n    if (!props.hexagonVertices && (!props.radius || !Number.isFinite(props.angle))) {\n      __WEBPACK_IMPORTED_MODULE_3__lib_utils__[\"a\" /* log */].once(0, 'HexagonLayer: Either hexagonVertices or radius and angel are ' +\n        'needed to calculate primitive hexagon.');\n      missingProps = true;\n\n    } else if (props.hexagonVertices && (!Array.isArray(props.hexagonVertices) ||\n      props.hexagonVertices.length < 6)) {\n      __WEBPACK_IMPORTED_MODULE_3__lib_utils__[\"a\" /* log */].once(0, 'HexagonLayer: HexagonVertices needs to be an array of 6 points');\n\n      missingProps = true;\n    }\n\n    if (missingProps) {\n      __WEBPACK_IMPORTED_MODULE_3__lib_utils__[\"a\" /* log */].once(0, 'Now using 1000 meter as default radius, 0 as default angel');\n      props.radius = 1000;\n      props.angle = 0;\n    }\n\n    super(props);\n  }\n\n  getShaders() {\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__lib_utils_fp64__[\"b\" /* enable64bitSupport */])(this.props) ? {\n      vs: __WEBPACK_IMPORTED_MODULE_6__hexagon_cell_layer_vertex_64_glsl__[\"a\" /* default */], fs: __WEBPACK_IMPORTED_MODULE_7__hexagon_cell_layer_fragment_glsl__[\"a\" /* default */], modules: ['fp64', 'project64', 'lighting']\n    } : {\n      vs: __WEBPACK_IMPORTED_MODULE_5__hexagon_cell_layer_vertex_glsl__[\"a\" /* default */], fs: __WEBPACK_IMPORTED_MODULE_7__hexagon_cell_layer_fragment_glsl__[\"a\" /* default */], modules: ['lighting']\n    };\n  }\n\n  /**\n   * DeckGL calls initializeState when GL context is available\n   * Essentially a deferred constructor\n   */\n  initializeState() {\n    const {gl} = this.context;\n    this.setState({model: this._getModel(gl)});\n\n    const {attributeManager} = this.state;\n    /* eslint-disable max-len */\n    attributeManager.addInstanced({\n      instancePositions: {size: 3, accessor: ['getCentroid', 'getElevation'],\n        update: this.calculateInstancePositions},\n      instanceColors: {size: 4, type: gl.UNSIGNED_BYTE, accessor: 'getColor',\n        update: this.calculateInstanceColors}\n    });\n    /* eslint-enable max-len */\n\n    this.updateRadiusAngle();\n  }\n\n  updateAttribute({props, oldProps, changeFlags}) {\n    if (props.fp64 !== oldProps.fp64) {\n      const {attributeManager} = this.state;\n      attributeManager.invalidateAll();\n\n      if (props.fp64 && props.projectionMode === __WEBPACK_IMPORTED_MODULE_0__lib__[\"e\" /* COORDINATE_SYSTEM */].LNG_LAT) {\n        attributeManager.addInstanced({\n          instancePositions64xyLow: {\n            size: 2,\n            accessor: 'getCentroid',\n            update: this.calculateInstancePositions64xyLow\n          }\n        });\n      } else {\n        attributeManager.remove([\n          'instancePositions64xyLow'\n        ]);\n      }\n\n    }\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    super.updateState({props, oldProps, changeFlags});\n    if (props.fp64 !== oldProps.fp64) {\n      const {gl} = this.context;\n      this.setState({model: this._getModel(gl)});\n    }\n    this.updateAttribute({props, oldProps, changeFlags});\n\n    const viewportChanged = changeFlags.viewportChanged;\n    const {model} = this.state;\n\n    // Update the positions in the model if they've changes\n    const verticesChanged =\n      !positionsAreEqual(oldProps.hexagonVertices, props.hexagonVertices);\n\n    if (model && (verticesChanged || viewportChanged)) {\n      this.updateRadiusAngle();\n    }\n    this.updateUniforms();\n  }\n\n  updateRadiusAngle() {\n    let angle;\n    let radius;\n    const {hexagonVertices} = this.props;\n\n    if (Array.isArray(hexagonVertices) && hexagonVertices.length >= 6) {\n\n      // calculate angle and vertices from hexagonVertices if provided\n      const vertices = this.props.hexagonVertices;\n\n      const vertex0 = vertices[0];\n      const vertex3 = vertices[3];\n\n      // transform to space coordinates\n      const spaceCoord0 = this.projectFlat(vertex0);\n      const spaceCoord3 = this.projectFlat(vertex3);\n\n      // distance between two close centroids\n      const dx = spaceCoord0[0] - spaceCoord3[0];\n      const dy = spaceCoord0[1] - spaceCoord3[1];\n      const dxy = Math.sqrt(dx * dx + dy * dy);\n\n      // Calculate angle that the perpendicular hexagon vertex axis is tilted\n      angle = Math.acos(dx / dxy) * -Math.sign(dy) + Math.PI / 2;\n      radius = dxy / 2;\n\n    } else if (this.props.radius && Number.isFinite(this.props.angle)) {\n\n      // if no hexagonVertices provided, try use radius & angle\n      const {viewport} = this.context;\n      const {pixelsPerMeter} = viewport.getDistanceScales();\n\n      angle = this.props.angle;\n      radius = this.props.radius * pixelsPerMeter[0];\n\n    }\n\n    this.setUniforms({\n      angle,\n      radius\n    });\n  }\n\n  getCylinderGeometry(radius) {\n    return new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"CylinderGeometry\"]({\n      radius,\n      topRadius: radius,\n      bottomRadius: radius,\n      topCap: true,\n      bottomCap: true,\n      height: 1,\n      nradial: 6,\n      nvertical: 1\n    });\n  }\n\n  updateUniforms() {\n    const {opacity, elevationScale, extruded, coverage, lightSettings} = this.props;\n\n    this.setUniforms(Object.assign({}, {\n      extruded,\n      opacity,\n      coverage,\n      elevationScale\n    },\n    lightSettings));\n  }\n\n  _getModel(gl) {\n    const shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"a\" /* assembleShaders */])(gl, this.getShaders());\n\n    return new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Model\"]({\n      gl,\n      id: this.props.id,\n      vs: shaders.vs,\n      fs: shaders.fs,\n      geometry: this.getCylinderGeometry(1),\n      isInstanced: true\n    });\n  }\n\n  draw({uniforms}) {\n    super.draw({uniforms: Object.assign({}, uniforms)});\n  }\n\n  calculateInstancePositions(attribute) {\n    const {data, getCentroid, getElevation} = this.props;\n    const {value, size} = attribute;\n    let i = 0;\n    for (const object of data) {\n      const [lon, lat] = getCentroid(object);\n      const elevation = getElevation(object);\n      value[i + 0] = lon;\n      value[i + 1] = lat;\n      value[i + 2] = elevation || this.props.elevation;\n      i += size;\n    }\n  }\n\n  calculateInstancePositions64xyLow(attribute) {\n    const {data, getCentroid} = this.props;\n    const {value} = attribute;\n    let i = 0;\n    for (const object of data) {\n      const position = getCentroid(object);\n      value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__lib_utils_fp64__[\"a\" /* fp64ify */])(position[0])[1];\n      value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__lib_utils_fp64__[\"a\" /* fp64ify */])(position[1])[1];\n    }\n  }\n\n  calculateInstanceColors(attribute) {\n    const {data, getColor} = this.props;\n    const {value, size} = attribute;\n    let i = 0;\n    for (const object of data) {\n      const color = getColor(object) || DEFAULT_COLOR;\n\n      value[i + 0] = color[0];\n      value[i + 1] = color[1];\n      value[i + 2] = color[2];\n      value[i + 3] = Number.isFinite(color[3]) ? color[3] : DEFAULT_COLOR[3];\n      i += size;\n    }\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = HexagonCellLayer;\n\n\nHexagonCellLayer.layerName = 'HexagonCellLayer';\nHexagonCellLayer.defaultProps = defaultProps;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvaGV4YWdvbi1jZWxsLWxheWVyL2hleGFnb24tY2VsbC1sYXllci5qcz8zMTVlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNiBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uLy4uLy4uL2xpYic7XG5pbXBvcnQge2Fzc2VtYmxlU2hhZGVyc30gZnJvbSAnLi4vLi4vLi4vc2hhZGVyLXV0aWxzJztcbmltcG9ydCB7TW9kZWwsIEN5bGluZGVyR2VvbWV0cnl9IGZyb20gJ2x1bWEuZ2wnO1xuaW1wb3J0IHtsb2d9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscyc7XG5pbXBvcnQge2ZwNjRpZnksIGVuYWJsZTY0Yml0U3VwcG9ydH0gZnJvbSAnLi4vLi4vLi4vbGliL3V0aWxzL2ZwNjQnO1xuaW1wb3J0IHtDT09SRElOQVRFX1NZU1RFTX0gZnJvbSAnLi4vLi4vLi4vbGliJztcblxuaW1wb3J0IGhleENlbGxWZXJ0ZXggZnJvbSAnLi9oZXhhZ29uLWNlbGwtbGF5ZXItdmVydGV4Lmdsc2wnO1xuaW1wb3J0IGhleENlbGxWZXJ0ZXg2NCBmcm9tICcuL2hleGFnb24tY2VsbC1sYXllci12ZXJ0ZXgtNjQuZ2xzbCc7XG5pbXBvcnQgaGV4Q2VsbEZyYWdtZW50IGZyb20gJy4vaGV4YWdvbi1jZWxsLWxheWVyLWZyYWdtZW50Lmdsc2wnO1xuXG5mdW5jdGlvbiBwb3NpdGlvbnNBcmVFcXVhbCh2MSwgdjIpIHtcbiAgLy8gSGV4IHBvc2l0aW9ucyBhcmUgZXhwZWN0ZWQgdG8gY2hhbmdlIGVudGlyZWx5LCBub3QgdG8gbWFpbnRhaW4gc29tZVxuICAvLyBwb3NpdGlvbnMgYW5kIGNoYW5nZSBvdGhlcnMuIFJpZ2h0IG5vdyB3ZSBvbmx5IGNoZWNrIGEgc2luZ2xlIHZlcnRleCxcbiAgLy8gYmVjYXVzZSBIMyBndWFyYW50ZWVzIG9yZGVyLCBidXQgZXZlbiBpZiB0aGF0IHdhc24ndCB0cnVlLCB0aGlzIHdvdWxkIG9ubHlcbiAgLy8gcmV0dXJuIGEgZmFsc2UgcG9zaXRpdmUgZm9yIGFkamFjZW50IGhleGFnb25zLCB3aGljaCBpcyBjbG9zZSBlbm91Z2ggZm9yXG4gIC8vIG91ciBwdXJwb3Nlcy5cbiAgcmV0dXJuIHYxID09PSB2MiB8fCAoXG4gICAgdjEgJiYgdjIgJiYgdjFbMF1bMF0gPT09IHYyWzBdWzBdICYmIHYxWzBdWzFdID09PSB2MlswXVsxXVxuICApO1xufVxuXG5jb25zdCBERUZBVUxUX0NPTE9SID0gWzI1NSwgMCwgMjU1LCAyNTVdO1xuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIGhleGFnb25WZXJ0aWNlczogbnVsbCxcbiAgcmFkaXVzOiBudWxsLFxuICBhbmdsZTogbnVsbCxcbiAgY292ZXJhZ2U6IDEsXG4gIGVsZXZhdGlvblNjYWxlOiAxLFxuICBleHRydWRlZDogdHJ1ZSxcbiAgZnA2NDogZmFsc2UsXG5cbiAgZ2V0Q2VudHJvaWQ6IHggPT4geC5jZW50cm9pZCxcbiAgZ2V0Q29sb3I6IHggPT4geC5jb2xvcixcbiAgZ2V0RWxldmF0aW9uOiB4ID0+IHguZWxldmF0aW9uLFxuXG4gIGxpZ2h0U2V0dGluZ3M6IHtcbiAgICBsaWdodHNQb3NpdGlvbjogWy0xMjIuNDUsIDM3Ljc1LCA4MDAwLCAtMTIyLjAsIDM4LjAwLCA1MDAwXSxcbiAgICBhbWJpZW50UmF0aW86IDAuNCxcbiAgICBkaWZmdXNlUmF0aW86IDAuNixcbiAgICBzcGVjdWxhclJhdGlvOiAwLjgsXG4gICAgbGlnaHRzU3RyZW5ndGg6IFsxLjIsIDAuMCwgMC44LCAwLjBdLFxuICAgIG51bWJlck9mTGlnaHRzOiAyXG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhleGFnb25DZWxsTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG5cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBsZXQgbWlzc2luZ1Byb3BzID0gZmFsc2U7XG4gICAgaWYgKCFwcm9wcy5oZXhhZ29uVmVydGljZXMgJiYgKCFwcm9wcy5yYWRpdXMgfHwgIU51bWJlci5pc0Zpbml0ZShwcm9wcy5hbmdsZSkpKSB7XG4gICAgICBsb2cub25jZSgwLCAnSGV4YWdvbkxheWVyOiBFaXRoZXIgaGV4YWdvblZlcnRpY2VzIG9yIHJhZGl1cyBhbmQgYW5nZWwgYXJlICcgK1xuICAgICAgICAnbmVlZGVkIHRvIGNhbGN1bGF0ZSBwcmltaXRpdmUgaGV4YWdvbi4nKTtcbiAgICAgIG1pc3NpbmdQcm9wcyA9IHRydWU7XG5cbiAgICB9IGVsc2UgaWYgKHByb3BzLmhleGFnb25WZXJ0aWNlcyAmJiAoIUFycmF5LmlzQXJyYXkocHJvcHMuaGV4YWdvblZlcnRpY2VzKSB8fFxuICAgICAgcHJvcHMuaGV4YWdvblZlcnRpY2VzLmxlbmd0aCA8IDYpKSB7XG4gICAgICBsb2cub25jZSgwLCAnSGV4YWdvbkxheWVyOiBIZXhhZ29uVmVydGljZXMgbmVlZHMgdG8gYmUgYW4gYXJyYXkgb2YgNiBwb2ludHMnKTtcblxuICAgICAgbWlzc2luZ1Byb3BzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobWlzc2luZ1Byb3BzKSB7XG4gICAgICBsb2cub25jZSgwLCAnTm93IHVzaW5nIDEwMDAgbWV0ZXIgYXMgZGVmYXVsdCByYWRpdXMsIDAgYXMgZGVmYXVsdCBhbmdlbCcpO1xuICAgICAgcHJvcHMucmFkaXVzID0gMTAwMDtcbiAgICAgIHByb3BzLmFuZ2xlID0gMDtcbiAgICB9XG5cbiAgICBzdXBlcihwcm9wcyk7XG4gIH1cblxuICBnZXRTaGFkZXJzKCkge1xuICAgIHJldHVybiBlbmFibGU2NGJpdFN1cHBvcnQodGhpcy5wcm9wcykgPyB7XG4gICAgICB2czogaGV4Q2VsbFZlcnRleDY0LCBmczogaGV4Q2VsbEZyYWdtZW50LCBtb2R1bGVzOiBbJ2ZwNjQnLCAncHJvamVjdDY0JywgJ2xpZ2h0aW5nJ11cbiAgICB9IDoge1xuICAgICAgdnM6IGhleENlbGxWZXJ0ZXgsIGZzOiBoZXhDZWxsRnJhZ21lbnQsIG1vZHVsZXM6IFsnbGlnaHRpbmcnXVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVja0dMIGNhbGxzIGluaXRpYWxpemVTdGF0ZSB3aGVuIEdMIGNvbnRleHQgaXMgYXZhaWxhYmxlXG4gICAqIEVzc2VudGlhbGx5IGEgZGVmZXJyZWQgY29uc3RydWN0b3JcbiAgICovXG4gIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuICAgIHRoaXMuc2V0U3RhdGUoe21vZGVsOiB0aGlzLl9nZXRNb2RlbChnbCl9KTtcblxuICAgIGNvbnN0IHthdHRyaWJ1dGVNYW5hZ2VyfSA9IHRoaXMuc3RhdGU7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkSW5zdGFuY2VkKHtcbiAgICAgIGluc3RhbmNlUG9zaXRpb25zOiB7c2l6ZTogMywgYWNjZXNzb3I6IFsnZ2V0Q2VudHJvaWQnLCAnZ2V0RWxldmF0aW9uJ10sXG4gICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9uc30sXG4gICAgICBpbnN0YW5jZUNvbG9yczoge3NpemU6IDQsIHR5cGU6IGdsLlVOU0lHTkVEX0JZVEUsIGFjY2Vzc29yOiAnZ2V0Q29sb3InLFxuICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VDb2xvcnN9XG4gICAgfSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbiAgICB0aGlzLnVwZGF0ZVJhZGl1c0FuZ2xlKCk7XG4gIH1cblxuICB1cGRhdGVBdHRyaWJ1dGUoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KSB7XG4gICAgaWYgKHByb3BzLmZwNjQgIT09IG9sZFByb3BzLmZwNjQpIHtcbiAgICAgIGNvbnN0IHthdHRyaWJ1dGVNYW5hZ2VyfSA9IHRoaXMuc3RhdGU7XG4gICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGVBbGwoKTtcblxuICAgICAgaWYgKHByb3BzLmZwNjQgJiYgcHJvcHMucHJvamVjdGlvbk1vZGUgPT09IENPT1JESU5BVEVfU1lTVEVNLkxOR19MQVQpIHtcbiAgICAgICAgYXR0cmlidXRlTWFuYWdlci5hZGRJbnN0YW5jZWQoe1xuICAgICAgICAgIGluc3RhbmNlUG9zaXRpb25zNjR4eUxvdzoge1xuICAgICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICAgIGFjY2Vzc29yOiAnZ2V0Q2VudHJvaWQnLFxuICAgICAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zNjR4eUxvd1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyaWJ1dGVNYW5hZ2VyLnJlbW92ZShbXG4gICAgICAgICAgJ2luc3RhbmNlUG9zaXRpb25zNjR4eUxvdydcbiAgICAgICAgXSk7XG4gICAgICB9XG5cbiAgICB9XG4gIH1cblxuICB1cGRhdGVTdGF0ZSh7cHJvcHMsIG9sZFByb3BzLCBjaGFuZ2VGbGFnc30pIHtcbiAgICBzdXBlci51cGRhdGVTdGF0ZSh7cHJvcHMsIG9sZFByb3BzLCBjaGFuZ2VGbGFnc30pO1xuICAgIGlmIChwcm9wcy5mcDY0ICE9PSBvbGRQcm9wcy5mcDY0KSB7XG4gICAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7bW9kZWw6IHRoaXMuX2dldE1vZGVsKGdsKX0pO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUF0dHJpYnV0ZSh7cHJvcHMsIG9sZFByb3BzLCBjaGFuZ2VGbGFnc30pO1xuXG4gICAgY29uc3Qgdmlld3BvcnRDaGFuZ2VkID0gY2hhbmdlRmxhZ3Mudmlld3BvcnRDaGFuZ2VkO1xuICAgIGNvbnN0IHttb2RlbH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgLy8gVXBkYXRlIHRoZSBwb3NpdGlvbnMgaW4gdGhlIG1vZGVsIGlmIHRoZXkndmUgY2hhbmdlc1xuICAgIGNvbnN0IHZlcnRpY2VzQ2hhbmdlZCA9XG4gICAgICAhcG9zaXRpb25zQXJlRXF1YWwob2xkUHJvcHMuaGV4YWdvblZlcnRpY2VzLCBwcm9wcy5oZXhhZ29uVmVydGljZXMpO1xuXG4gICAgaWYgKG1vZGVsICYmICh2ZXJ0aWNlc0NoYW5nZWQgfHwgdmlld3BvcnRDaGFuZ2VkKSkge1xuICAgICAgdGhpcy51cGRhdGVSYWRpdXNBbmdsZSgpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVVuaWZvcm1zKCk7XG4gIH1cblxuICB1cGRhdGVSYWRpdXNBbmdsZSgpIHtcbiAgICBsZXQgYW5nbGU7XG4gICAgbGV0IHJhZGl1cztcbiAgICBjb25zdCB7aGV4YWdvblZlcnRpY2VzfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShoZXhhZ29uVmVydGljZXMpICYmIGhleGFnb25WZXJ0aWNlcy5sZW5ndGggPj0gNikge1xuXG4gICAgICAvLyBjYWxjdWxhdGUgYW5nbGUgYW5kIHZlcnRpY2VzIGZyb20gaGV4YWdvblZlcnRpY2VzIGlmIHByb3ZpZGVkXG4gICAgICBjb25zdCB2ZXJ0aWNlcyA9IHRoaXMucHJvcHMuaGV4YWdvblZlcnRpY2VzO1xuXG4gICAgICBjb25zdCB2ZXJ0ZXgwID0gdmVydGljZXNbMF07XG4gICAgICBjb25zdCB2ZXJ0ZXgzID0gdmVydGljZXNbM107XG5cbiAgICAgIC8vIHRyYW5zZm9ybSB0byBzcGFjZSBjb29yZGluYXRlc1xuICAgICAgY29uc3Qgc3BhY2VDb29yZDAgPSB0aGlzLnByb2plY3RGbGF0KHZlcnRleDApO1xuICAgICAgY29uc3Qgc3BhY2VDb29yZDMgPSB0aGlzLnByb2plY3RGbGF0KHZlcnRleDMpO1xuXG4gICAgICAvLyBkaXN0YW5jZSBiZXR3ZWVuIHR3byBjbG9zZSBjZW50cm9pZHNcbiAgICAgIGNvbnN0IGR4ID0gc3BhY2VDb29yZDBbMF0gLSBzcGFjZUNvb3JkM1swXTtcbiAgICAgIGNvbnN0IGR5ID0gc3BhY2VDb29yZDBbMV0gLSBzcGFjZUNvb3JkM1sxXTtcbiAgICAgIGNvbnN0IGR4eSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBhbmdsZSB0aGF0IHRoZSBwZXJwZW5kaWN1bGFyIGhleGFnb24gdmVydGV4IGF4aXMgaXMgdGlsdGVkXG4gICAgICBhbmdsZSA9IE1hdGguYWNvcyhkeCAvIGR4eSkgKiAtTWF0aC5zaWduKGR5KSArIE1hdGguUEkgLyAyO1xuICAgICAgcmFkaXVzID0gZHh5IC8gMjtcblxuICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wcy5yYWRpdXMgJiYgTnVtYmVyLmlzRmluaXRlKHRoaXMucHJvcHMuYW5nbGUpKSB7XG5cbiAgICAgIC8vIGlmIG5vIGhleGFnb25WZXJ0aWNlcyBwcm92aWRlZCwgdHJ5IHVzZSByYWRpdXMgJiBhbmdsZVxuICAgICAgY29uc3Qge3ZpZXdwb3J0fSA9IHRoaXMuY29udGV4dDtcbiAgICAgIGNvbnN0IHtwaXhlbHNQZXJNZXRlcn0gPSB2aWV3cG9ydC5nZXREaXN0YW5jZVNjYWxlcygpO1xuXG4gICAgICBhbmdsZSA9IHRoaXMucHJvcHMuYW5nbGU7XG4gICAgICByYWRpdXMgPSB0aGlzLnByb3BzLnJhZGl1cyAqIHBpeGVsc1Blck1ldGVyWzBdO1xuXG4gICAgfVxuXG4gICAgdGhpcy5zZXRVbmlmb3Jtcyh7XG4gICAgICBhbmdsZSxcbiAgICAgIHJhZGl1c1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0Q3lsaW5kZXJHZW9tZXRyeShyYWRpdXMpIHtcbiAgICByZXR1cm4gbmV3IEN5bGluZGVyR2VvbWV0cnkoe1xuICAgICAgcmFkaXVzLFxuICAgICAgdG9wUmFkaXVzOiByYWRpdXMsXG4gICAgICBib3R0b21SYWRpdXM6IHJhZGl1cyxcbiAgICAgIHRvcENhcDogdHJ1ZSxcbiAgICAgIGJvdHRvbUNhcDogdHJ1ZSxcbiAgICAgIGhlaWdodDogMSxcbiAgICAgIG5yYWRpYWw6IDYsXG4gICAgICBudmVydGljYWw6IDFcbiAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZVVuaWZvcm1zKCkge1xuICAgIGNvbnN0IHtvcGFjaXR5LCBlbGV2YXRpb25TY2FsZSwgZXh0cnVkZWQsIGNvdmVyYWdlLCBsaWdodFNldHRpbmdzfSA9IHRoaXMucHJvcHM7XG5cbiAgICB0aGlzLnNldFVuaWZvcm1zKE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgIGV4dHJ1ZGVkLFxuICAgICAgb3BhY2l0eSxcbiAgICAgIGNvdmVyYWdlLFxuICAgICAgZWxldmF0aW9uU2NhbGVcbiAgICB9LFxuICAgIGxpZ2h0U2V0dGluZ3MpKTtcbiAgfVxuXG4gIF9nZXRNb2RlbChnbCkge1xuICAgIGNvbnN0IHNoYWRlcnMgPSBhc3NlbWJsZVNoYWRlcnMoZ2wsIHRoaXMuZ2V0U2hhZGVycygpKTtcblxuICAgIHJldHVybiBuZXcgTW9kZWwoe1xuICAgICAgZ2wsXG4gICAgICBpZDogdGhpcy5wcm9wcy5pZCxcbiAgICAgIHZzOiBzaGFkZXJzLnZzLFxuICAgICAgZnM6IHNoYWRlcnMuZnMsXG4gICAgICBnZW9tZXRyeTogdGhpcy5nZXRDeWxpbmRlckdlb21ldHJ5KDEpLFxuICAgICAgaXNJbnN0YW5jZWQ6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGRyYXcoe3VuaWZvcm1zfSkge1xuICAgIHN1cGVyLmRyYXcoe3VuaWZvcm1zOiBPYmplY3QuYXNzaWduKHt9LCB1bmlmb3Jtcyl9KTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtkYXRhLCBnZXRDZW50cm9pZCwgZ2V0RWxldmF0aW9ufSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3ZhbHVlLCBzaXplfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgZGF0YSkge1xuICAgICAgY29uc3QgW2xvbiwgbGF0XSA9IGdldENlbnRyb2lkKG9iamVjdCk7XG4gICAgICBjb25zdCBlbGV2YXRpb24gPSBnZXRFbGV2YXRpb24ob2JqZWN0KTtcbiAgICAgIHZhbHVlW2kgKyAwXSA9IGxvbjtcbiAgICAgIHZhbHVlW2kgKyAxXSA9IGxhdDtcbiAgICAgIHZhbHVlW2kgKyAyXSA9IGVsZXZhdGlvbiB8fCB0aGlzLnByb3BzLmVsZXZhdGlvbjtcbiAgICAgIGkgKz0gc2l6ZTtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9uczY0eHlMb3coYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2RhdGEsIGdldENlbnRyb2lkfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3ZhbHVlfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgZGF0YSkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRDZW50cm9pZChvYmplY3QpO1xuICAgICAgdmFsdWVbaSsrXSA9IGZwNjRpZnkocG9zaXRpb25bMF0pWzFdO1xuICAgICAgdmFsdWVbaSsrXSA9IGZwNjRpZnkocG9zaXRpb25bMV0pWzFdO1xuICAgIH1cbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlQ29sb3JzKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtkYXRhLCBnZXRDb2xvcn0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHt2YWx1ZSwgc2l6ZX0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gZ2V0Q29sb3Iob2JqZWN0KSB8fCBERUZBVUxUX0NPTE9SO1xuXG4gICAgICB2YWx1ZVtpICsgMF0gPSBjb2xvclswXTtcbiAgICAgIHZhbHVlW2kgKyAxXSA9IGNvbG9yWzFdO1xuICAgICAgdmFsdWVbaSArIDJdID0gY29sb3JbMl07XG4gICAgICB2YWx1ZVtpICsgM10gPSBOdW1iZXIuaXNGaW5pdGUoY29sb3JbM10pID8gY29sb3JbM10gOiBERUZBVUxUX0NPTE9SWzNdO1xuICAgICAgaSArPSBzaXplO1xuICAgIH1cbiAgfVxufVxuXG5IZXhhZ29uQ2VsbExheWVyLmxheWVyTmFtZSA9ICdIZXhhZ29uQ2VsbExheWVyJztcbkhleGFnb25DZWxsTGF5ZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGF5ZXJzL2NvcmUvaGV4YWdvbi1jZWxsLWxheWVyL2hleGFnb24tY2VsbC1sYXllci5qc1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 20 */
/* exports provided: default */
/* exports used: default */
/*!****************************************************************!*\
  !*** ./src/layers/core/scatterplot-layer/scatterplot-layer.js ***!
  \****************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_utils__ = __webpack_require__(/*! ../../../lib/utils */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__ = __webpack_require__(/*! ../../../lib/utils/fp64 */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_luma_gl__ = __webpack_require__(/*! luma.gl */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__scatterplot_layer_vertex_glsl__ = __webpack_require__(/*! ./scatterplot-layer-vertex.glsl */ 80);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__scatterplot_layer_vertex_64_glsl__ = __webpack_require__(/*! ./scatterplot-layer-vertex-64.glsl */ 79);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__scatterplot_layer_fragment_glsl__ = __webpack_require__(/*! ./scatterplot-layer-fragment.glsl */ 78);\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\n\n\n\n\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\n\nconst defaultProps = {\n  radiusScale: 1,  //  point radius in meters\n  radiusMinPixels: 0, //  min point radius in pixels\n  radiusMaxPixels: Number.MAX_SAFE_INTEGER, // max point radius in pixels\n  strokeWidth: 1,\n  outline: false,\n  fp64: false,\n\n  getPosition: x => x.position,\n  getRadius: x => x.radius || 1,\n  getColor: x => x.color || DEFAULT_COLOR\n};\n\nclass ScatterplotLayer extends __WEBPACK_IMPORTED_MODULE_0__lib__[\"a\" /* Layer */] {\n  getShaders(id) {\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__[\"b\" /* enable64bitSupport */])(this.props) ? {\n      vs: __WEBPACK_IMPORTED_MODULE_6__scatterplot_layer_vertex_64_glsl__[\"a\" /* default */], fs: __WEBPACK_IMPORTED_MODULE_7__scatterplot_layer_fragment_glsl__[\"a\" /* default */], modules: ['fp64', 'project64']\n    } : {\n      vs: __WEBPACK_IMPORTED_MODULE_5__scatterplot_layer_vertex_glsl__[\"a\" /* default */], fs: __WEBPACK_IMPORTED_MODULE_7__scatterplot_layer_fragment_glsl__[\"a\" /* default */], modules: []\n    };\n  }\n\n  initializeState() {\n    const {gl} = this.context;\n    this.setState({model: this._getModel(gl)});\n\n    /* eslint-disable max-len */\n    /* deprecated props check */\n    this._checkRemovedProp('radius', 'radiusScale');\n    this._checkRemovedProp('drawOutline', 'outline');\n\n    this.state.attributeManager.addInstanced({\n      instancePositions: {size: 3, accessor: 'getPosition', update: this.calculateInstancePositions},\n      instanceRadius: {size: 1, accessor: 'getRadius', defaultValue: 1, update: this.calculateInstanceRadius},\n      instanceColors: {size: 4, type: __WEBPACK_IMPORTED_MODULE_4_luma_gl__[\"GL\"].UNSIGNED_BYTE, accessor: 'getColor', update: this.calculateInstanceColors}\n    });\n    /* eslint-enable max-len */\n  }\n\n  updateAttribute({props, oldProps, changeFlags}) {\n    if (props.fp64 !== oldProps.fp64) {\n      const {attributeManager} = this.state;\n      attributeManager.invalidateAll();\n\n      if (props.fp64 && props.projectionMode === __WEBPACK_IMPORTED_MODULE_0__lib__[\"e\" /* COORDINATE_SYSTEM */].LNG_LAT) {\n        attributeManager.addInstanced({\n          instancePositions64xyLow: {\n            size: 2,\n            accessor: 'getPosition',\n            update: this.calculateInstancePositions64xyLow\n          }\n        });\n      } else {\n        attributeManager.remove([\n          'instancePositions64xyLow'\n        ]);\n      }\n\n    }\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    super.updateState({props, oldProps, changeFlags});\n    if (props.fp64 !== oldProps.fp64) {\n      const {gl} = this.context;\n      this.setState({model: this._getModel(gl)});\n    }\n    this.updateAttribute({props, oldProps, changeFlags});\n  }\n\n  draw({uniforms}) {\n    const {radiusScale, radiusMinPixels, radiusMaxPixels, outline, strokeWidth} = this.props;\n    this.state.model.render(Object.assign({}, uniforms, {\n      outline: outline ? 1 : 0,\n      strokeWidth,\n      radiusScale,\n      radiusMinPixels,\n      radiusMaxPixels\n    }));\n  }\n\n  _getModel(gl) {\n    // a square that minimally cover the unit circle\n    const positions = [-1, -1, 0, -1, 1, 0, 1, 1, 0, 1, -1, 0];\n    const shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"a\" /* assembleShaders */])(gl, this.getShaders());\n\n    return new __WEBPACK_IMPORTED_MODULE_4_luma_gl__[\"Model\"]({\n      gl,\n      id: this.props.id,\n      vs: shaders.vs,\n      fs: shaders.fs,\n      geometry: new __WEBPACK_IMPORTED_MODULE_4_luma_gl__[\"Geometry\"]({\n        drawMode: __WEBPACK_IMPORTED_MODULE_4_luma_gl__[\"GL\"].TRIANGLE_FAN,\n        positions: new Float32Array(positions)\n      }),\n      isInstanced: true\n    });\n  }\n\n  calculateInstancePositions(attribute) {\n    const {data, getPosition} = this.props;\n    const {value} = attribute;\n    let i = 0;\n    for (const point of data) {\n      const position = getPosition(point);\n      value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"d\" /* get */])(position, 0);\n      value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"d\" /* get */])(position, 1);\n      value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"d\" /* get */])(position, 2) || 0;\n    }\n  }\n\n  calculateInstancePositions64xyLow(attribute) {\n    const {data, getPosition} = this.props;\n    const {value} = attribute;\n    let i = 0;\n    for (const point of data) {\n      const position = getPosition(point);\n      value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__[\"a\" /* fp64ify */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"d\" /* get */])(position, 0))[1];\n      value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__[\"a\" /* fp64ify */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"d\" /* get */])(position, 1))[1];\n    }\n  }\n\n  calculateInstanceRadius(attribute) {\n    const {data, getRadius} = this.props;\n    const {value} = attribute;\n    let i = 0;\n    for (const point of data) {\n      const radius = getRadius(point);\n      value[i++] = isNaN(radius) ? 1 : radius;\n    }\n  }\n\n  calculateInstanceColors(attribute) {\n    const {data, getColor} = this.props;\n    const {value} = attribute;\n    let i = 0;\n    for (const point of data) {\n      const color = getColor(point) || DEFAULT_COLOR;\n      value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"d\" /* get */])(color, 0);\n      value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"d\" /* get */])(color, 1);\n      value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"d\" /* get */])(color, 2);\n      value[i++] = isNaN(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"d\" /* get */])(color, 3)) ? 255 : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"d\" /* get */])(color, 3);\n    }\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = ScatterplotLayer;\n\n\nScatterplotLayer.layerName = 'ScatterplotLayer';\nScatterplotLayer.defaultProps = defaultProps;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvc2NhdHRlcnBsb3QtbGF5ZXIvc2NhdHRlcnBsb3QtbGF5ZXIuanM/Y2I0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge0xheWVyfSBmcm9tICcuLi8uLi8uLi9saWInO1xuaW1wb3J0IHthc3NlbWJsZVNoYWRlcnN9IGZyb20gJy4uLy4uLy4uL3NoYWRlci11dGlscyc7XG5pbXBvcnQge0NPT1JESU5BVEVfU1lTVEVNfSBmcm9tICcuLi8uLi8uLi9saWInO1xuaW1wb3J0IHtnZXR9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscyc7XG5pbXBvcnQge2ZwNjRpZnksIGVuYWJsZTY0Yml0U3VwcG9ydH0gZnJvbSAnLi4vLi4vLi4vbGliL3V0aWxzL2ZwNjQnO1xuaW1wb3J0IHtHTCwgTW9kZWwsIEdlb21ldHJ5fSBmcm9tICdsdW1hLmdsJztcblxuaW1wb3J0IHNjYXR0ZXJwbG90VmVydGV4IGZyb20gJy4vc2NhdHRlcnBsb3QtbGF5ZXItdmVydGV4Lmdsc2wnO1xuaW1wb3J0IHNjYXR0ZXJwbG90VmVydGV4NjQgZnJvbSAnLi9zY2F0dGVycGxvdC1sYXllci12ZXJ0ZXgtNjQuZ2xzbCc7XG5pbXBvcnQgc2NhdHRlcnBsb3RGcmFnbWVudCBmcm9tICcuL3NjYXR0ZXJwbG90LWxheWVyLWZyYWdtZW50Lmdsc2wnO1xuXG5jb25zdCBERUZBVUxUX0NPTE9SID0gWzAsIDAsIDAsIDI1NV07XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgcmFkaXVzU2NhbGU6IDEsICAvLyAgcG9pbnQgcmFkaXVzIGluIG1ldGVyc1xuICByYWRpdXNNaW5QaXhlbHM6IDAsIC8vICBtaW4gcG9pbnQgcmFkaXVzIGluIHBpeGVsc1xuICByYWRpdXNNYXhQaXhlbHM6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLCAvLyBtYXggcG9pbnQgcmFkaXVzIGluIHBpeGVsc1xuICBzdHJva2VXaWR0aDogMSxcbiAgb3V0bGluZTogZmFsc2UsXG4gIGZwNjQ6IGZhbHNlLFxuXG4gIGdldFBvc2l0aW9uOiB4ID0+IHgucG9zaXRpb24sXG4gIGdldFJhZGl1czogeCA9PiB4LnJhZGl1cyB8fCAxLFxuICBnZXRDb2xvcjogeCA9PiB4LmNvbG9yIHx8IERFRkFVTFRfQ09MT1Jcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjYXR0ZXJwbG90TGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIGdldFNoYWRlcnMoaWQpIHtcbiAgICByZXR1cm4gZW5hYmxlNjRiaXRTdXBwb3J0KHRoaXMucHJvcHMpID8ge1xuICAgICAgdnM6IHNjYXR0ZXJwbG90VmVydGV4NjQsIGZzOiBzY2F0dGVycGxvdEZyYWdtZW50LCBtb2R1bGVzOiBbJ2ZwNjQnLCAncHJvamVjdDY0J11cbiAgICB9IDoge1xuICAgICAgdnM6IHNjYXR0ZXJwbG90VmVydGV4LCBmczogc2NhdHRlcnBsb3RGcmFnbWVudCwgbW9kdWxlczogW11cbiAgICB9O1xuICB9XG5cbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIGNvbnN0IHtnbH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgdGhpcy5zZXRTdGF0ZSh7bW9kZWw6IHRoaXMuX2dldE1vZGVsKGdsKX0pO1xuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgIC8qIGRlcHJlY2F0ZWQgcHJvcHMgY2hlY2sgKi9cbiAgICB0aGlzLl9jaGVja1JlbW92ZWRQcm9wKCdyYWRpdXMnLCAncmFkaXVzU2NhbGUnKTtcbiAgICB0aGlzLl9jaGVja1JlbW92ZWRQcm9wKCdkcmF3T3V0bGluZScsICdvdXRsaW5lJyk7XG5cbiAgICB0aGlzLnN0YXRlLmF0dHJpYnV0ZU1hbmFnZXIuYWRkSW5zdGFuY2VkKHtcbiAgICAgIGluc3RhbmNlUG9zaXRpb25zOiB7c2l6ZTogMywgYWNjZXNzb3I6ICdnZXRQb3NpdGlvbicsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9uc30sXG4gICAgICBpbnN0YW5jZVJhZGl1czoge3NpemU6IDEsIGFjY2Vzc29yOiAnZ2V0UmFkaXVzJywgZGVmYXVsdFZhbHVlOiAxLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VSYWRpdXN9LFxuICAgICAgaW5zdGFuY2VDb2xvcnM6IHtzaXplOiA0LCB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLCBhY2Nlc3NvcjogJ2dldENvbG9yJywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlQ29sb3JzfVxuICAgIH0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuICB9XG5cbiAgdXBkYXRlQXR0cmlidXRlKHtwcm9wcywgb2xkUHJvcHMsIGNoYW5nZUZsYWdzfSkge1xuICAgIGlmIChwcm9wcy5mcDY0ICE9PSBvbGRQcm9wcy5mcDY0KSB7XG4gICAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgICAgYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlQWxsKCk7XG5cbiAgICAgIGlmIChwcm9wcy5mcDY0ICYmIHByb3BzLnByb2plY3Rpb25Nb2RlID09PSBDT09SRElOQVRFX1NZU1RFTS5MTkdfTEFUKSB7XG4gICAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkSW5zdGFuY2VkKHtcbiAgICAgICAgICBpbnN0YW5jZVBvc2l0aW9uczY0eHlMb3c6IHtcbiAgICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgICBhY2Nlc3NvcjogJ2dldFBvc2l0aW9uJyxcbiAgICAgICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9uczY0eHlMb3dcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cmlidXRlTWFuYWdlci5yZW1vdmUoW1xuICAgICAgICAgICdpbnN0YW5jZVBvc2l0aW9uczY0eHlMb3cnXG4gICAgICAgIF0pO1xuICAgICAgfVxuXG4gICAgfVxuICB9XG5cbiAgdXBkYXRlU3RhdGUoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KSB7XG4gICAgc3VwZXIudXBkYXRlU3RhdGUoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KTtcbiAgICBpZiAocHJvcHMuZnA2NCAhPT0gb2xkUHJvcHMuZnA2NCkge1xuICAgICAgY29uc3Qge2dsfSA9IHRoaXMuY29udGV4dDtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe21vZGVsOiB0aGlzLl9nZXRNb2RlbChnbCl9KTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVBdHRyaWJ1dGUoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KTtcbiAgfVxuXG4gIGRyYXcoe3VuaWZvcm1zfSkge1xuICAgIGNvbnN0IHtyYWRpdXNTY2FsZSwgcmFkaXVzTWluUGl4ZWxzLCByYWRpdXNNYXhQaXhlbHMsIG91dGxpbmUsIHN0cm9rZVdpZHRofSA9IHRoaXMucHJvcHM7XG4gICAgdGhpcy5zdGF0ZS5tb2RlbC5yZW5kZXIoT2JqZWN0LmFzc2lnbih7fSwgdW5pZm9ybXMsIHtcbiAgICAgIG91dGxpbmU6IG91dGxpbmUgPyAxIDogMCxcbiAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgcmFkaXVzU2NhbGUsXG4gICAgICByYWRpdXNNaW5QaXhlbHMsXG4gICAgICByYWRpdXNNYXhQaXhlbHNcbiAgICB9KSk7XG4gIH1cblxuICBfZ2V0TW9kZWwoZ2wpIHtcbiAgICAvLyBhIHNxdWFyZSB0aGF0IG1pbmltYWxseSBjb3ZlciB0aGUgdW5pdCBjaXJjbGVcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBbLTEsIC0xLCAwLCAtMSwgMSwgMCwgMSwgMSwgMCwgMSwgLTEsIDBdO1xuICAgIGNvbnN0IHNoYWRlcnMgPSBhc3NlbWJsZVNoYWRlcnMoZ2wsIHRoaXMuZ2V0U2hhZGVycygpKTtcblxuICAgIHJldHVybiBuZXcgTW9kZWwoe1xuICAgICAgZ2wsXG4gICAgICBpZDogdGhpcy5wcm9wcy5pZCxcbiAgICAgIHZzOiBzaGFkZXJzLnZzLFxuICAgICAgZnM6IHNoYWRlcnMuZnMsXG4gICAgICBnZW9tZXRyeTogbmV3IEdlb21ldHJ5KHtcbiAgICAgICAgZHJhd01vZGU6IEdMLlRSSUFOR0xFX0ZBTixcbiAgICAgICAgcG9zaXRpb25zOiBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9ucylcbiAgICAgIH0pLFxuICAgICAgaXNJbnN0YW5jZWQ6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtkYXRhLCBnZXRQb3NpdGlvbn0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHt2YWx1ZX0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3QgcG9pbnQgb2YgZGF0YSkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRQb3NpdGlvbihwb2ludCk7XG4gICAgICB2YWx1ZVtpKytdID0gZ2V0KHBvc2l0aW9uLCAwKTtcbiAgICAgIHZhbHVlW2krK10gPSBnZXQocG9zaXRpb24sIDEpO1xuICAgICAgdmFsdWVbaSsrXSA9IGdldChwb3NpdGlvbiwgMikgfHwgMDtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9uczY0eHlMb3coYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2RhdGEsIGdldFBvc2l0aW9ufSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3ZhbHVlfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBwb2ludCBvZiBkYXRhKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFBvc2l0aW9uKHBvaW50KTtcbiAgICAgIHZhbHVlW2krK10gPSBmcDY0aWZ5KGdldChwb3NpdGlvbiwgMCkpWzFdO1xuICAgICAgdmFsdWVbaSsrXSA9IGZwNjRpZnkoZ2V0KHBvc2l0aW9uLCAxKSlbMV07XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VSYWRpdXMoYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2RhdGEsIGdldFJhZGl1c30gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHt2YWx1ZX0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3QgcG9pbnQgb2YgZGF0YSkge1xuICAgICAgY29uc3QgcmFkaXVzID0gZ2V0UmFkaXVzKHBvaW50KTtcbiAgICAgIHZhbHVlW2krK10gPSBpc05hTihyYWRpdXMpID8gMSA6IHJhZGl1cztcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZUNvbG9ycyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7ZGF0YSwgZ2V0Q29sb3J9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7dmFsdWV9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IHBvaW50IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gZ2V0Q29sb3IocG9pbnQpIHx8IERFRkFVTFRfQ09MT1I7XG4gICAgICB2YWx1ZVtpKytdID0gZ2V0KGNvbG9yLCAwKTtcbiAgICAgIHZhbHVlW2krK10gPSBnZXQoY29sb3IsIDEpO1xuICAgICAgdmFsdWVbaSsrXSA9IGdldChjb2xvciwgMik7XG4gICAgICB2YWx1ZVtpKytdID0gaXNOYU4oZ2V0KGNvbG9yLCAzKSkgPyAyNTUgOiBnZXQoY29sb3IsIDMpO1xuICAgIH1cbiAgfVxufVxuXG5TY2F0dGVycGxvdExheWVyLmxheWVyTmFtZSA9ICdTY2F0dGVycGxvdExheWVyJztcblNjYXR0ZXJwbG90TGF5ZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGF5ZXJzL2NvcmUvc2NhdHRlcnBsb3QtbGF5ZXIvc2NhdHRlcnBsb3QtbGF5ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 21 */
/* exports provided: default */
/* exports used: default */
/*!********************************************************************!*\
  !*** ./src/layers/deprecated/choropleth-layer/choropleth-layer.js ***!
  \********************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_utils__ = __webpack_require__(/*! ../../../lib/utils */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geojson__ = __webpack_require__(/*! ./geojson */ 91);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_luma_gl__ = __webpack_require__(/*! luma.gl */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_earcut__ = __webpack_require__(/*! earcut */ 8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_earcut___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_earcut__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__choropleth_layer_vertex_glsl__ = __webpack_require__(/*! ./choropleth-layer-vertex.glsl */ 90);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__choropleth_layer_fragment_glsl__ = __webpack_require__(/*! ./choropleth-layer-fragment.glsl */ 89);\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\n\n\n\n\nconst DEFAULT_COLOR = [0, 0, 255, 255];\n\nconst defaultProps = {\n  getColor: feature => __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"d\" /* get */])(feature, 'properties.color'),\n  drawContour: false,\n  strokeWidth: 1\n};\n\nclass ChoroplethLayer extends __WEBPACK_IMPORTED_MODULE_0__lib__[\"a\" /* Layer */] {\n\n  constructor(props) {\n    super(props);\n    __WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"a\" /* log */].once('ChoroplethLayer is deprecated. Consider using GeoJsonLayer instead');\n  }\n\n  getShaders() {\n    return {\n      vs: __WEBPACK_IMPORTED_MODULE_6__choropleth_layer_vertex_glsl__[\"a\" /* default */],\n      fs: __WEBPACK_IMPORTED_MODULE_7__choropleth_layer_fragment_glsl__[\"a\" /* default */]\n    };\n  }\n\n  initializeState() {\n    const {gl} = this.context;\n\n    const {attributeManager} = this.state;\n    attributeManager.addDynamic({\n      // Primtive attributes\n      indices: {size: 1, update: this.calculateIndices, isIndexed: true},\n      positions: {size: 3, update: this.calculatePositions},\n      colors: {size: 4, type: __WEBPACK_IMPORTED_MODULE_4_luma_gl__[\"GL\"].UNSIGNED_BYTE, update: this.calculateColors},\n      // Instanced attributes\n      pickingColors: {\n        size: 3,\n        type: __WEBPACK_IMPORTED_MODULE_4_luma_gl__[\"GL\"].UNSIGNED_BYTE,\n        update: this.calculatePickingColors,\n        noAlloc: true\n      }\n    });\n\n    const IndexType = gl.getExtension('OES_element_index_uint') ? Uint32Array : Uint16Array;\n\n    this.setState({\n      model: this.getModel(gl),\n      numInstances: 0,\n      IndexType\n    });\n  }\n\n  updateState({oldProps, props, changeFlags}) {\n    const {attributeManager} = this.state;\n    if (changeFlags.dataChanged) {\n      this.state.choropleths = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__geojson__[\"a\" /* extractPolygons */])(props.data);\n      attributeManager.invalidateAll();\n    }\n\n    if (props.drawContour !== oldProps.drawContour) {\n      this.state.model.geometry.drawMode = props.drawContour ? __WEBPACK_IMPORTED_MODULE_4_luma_gl__[\"GL\"].LINES : __WEBPACK_IMPORTED_MODULE_4_luma_gl__[\"GL\"].TRIANGLES;\n      attributeManager.invalidateAll();\n    }\n\n  }\n\n  draw({uniforms}) {\n    const {gl} = this.context;\n    const lineWidth = this.screenToDevicePixels(this.props.strokeWidth);\n    gl.lineWidth(lineWidth);\n    this.state.model.render(uniforms);\n    // Setting line width back to 1 is here to workaround a Google Chrome bug\n    // gl.clear() and gl.isEnabled() will return GL_INVALID_VALUE even with\n    // correct parameter\n    // This is not happening on Safari and Firefox\n    gl.lineWidth(1.0);\n  }\n\n  getPickingInfo(opts) {\n    const info = super.getPickingInfo(opts);\n    const index = this.decodePickingColor(info.color);\n    const feature = index >= 0 ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"d\" /* get */])(this.props.data, ['features', index]) : null;\n    info.feature = feature;\n    info.object = feature;\n    return info;\n  }\n\n  getModel(gl) {\n    const shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"a\" /* assembleShaders */])(gl, this.getShaders());\n\n    return new __WEBPACK_IMPORTED_MODULE_4_luma_gl__[\"Model\"]({\n      gl,\n      id: this.props.id,\n      vs: shaders.vs,\n      fs: shaders.fs,\n      geometry: new __WEBPACK_IMPORTED_MODULE_4_luma_gl__[\"Geometry\"]({\n        drawMode: this.props.drawContour ? __WEBPACK_IMPORTED_MODULE_4_luma_gl__[\"GL\"].LINES : __WEBPACK_IMPORTED_MODULE_4_luma_gl__[\"GL\"].TRIANGLES\n      }),\n      vertexCount: 0,\n      isIndexed: true\n    });\n  }\n\n  calculateIndices(attribute) {\n    // adjust index offset for multiple choropleths\n    const offsets = this.state.choropleths.reduce(\n      (acc, choropleth) => [...acc, acc[acc.length - 1] +\n        choropleth.reduce((count, polygon) => count + polygon.length, 0)],\n      [0]\n    );\n    const {IndexType} = this.state;\n    if (IndexType === Uint16Array && offsets[offsets.length - 1] > 65535) {\n      throw new Error('Vertex count exceeds browser\\'s limit');\n    }\n\n    const indices = this.state.choropleths.map(\n      (choropleth, choroplethIndex) => this.props.drawContour ?\n        // 1. get sequentially ordered indices of each choropleth contour\n        // 2. offset them by the number of indices in previous choropleths\n        calculateContourIndices(choropleth).map(index => index + offsets[choroplethIndex]) :\n        // 1. get triangulated indices for the internal areas\n        // 2. offset them by the number of indices in previous choropleths\n        calculateSurfaceIndices(choropleth).map(index => index + offsets[choroplethIndex])\n    );\n\n    attribute.value = new IndexType(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"b\" /* flatten */])(indices));\n    attribute.target = __WEBPACK_IMPORTED_MODULE_4_luma_gl__[\"GL\"].ELEMENT_ARRAY_BUFFER;\n    this.state.model.setVertexCount(attribute.value.length / attribute.size);\n  }\n\n  calculatePositions(attribute) {\n    const vertices = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"b\" /* flatten */])(this.state.choropleths);\n    attribute.value = new Float32Array(vertices);\n  }\n\n  calculateColors(attribute) {\n    const {data, getColor} = this.props;\n    const features = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"d\" /* get */])(data, 'features');\n    const colors = this.state.choropleths.map(\n      (choropleth, choroplethIndex) => {\n        const feature = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"d\" /* get */])(features, choropleth.featureIndex);\n        const color = getColor(feature) || DEFAULT_COLOR;\n        // Ensure alpha is set\n        if (isNaN(color[3])) {\n          color[3] = DEFAULT_COLOR[3];\n        }\n        return choropleth.map(polygon => polygon.map(vertex => color));\n      }\n    );\n\n    attribute.value = new Uint8Array(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"b\" /* flatten */])(colors));\n  }\n\n  // Override the default picking colors calculation\n  calculatePickingColors(attribute) {\n    const colors = this.state.choropleths.map(\n      (choropleth, choroplethIndex) => {\n        const {featureIndex} = choropleth;\n        const color = this.props.drawContour ? [0, 0, 0] : [\n          (featureIndex + 1) % 256,\n          Math.floor((featureIndex + 1) / 256) % 256,\n          Math.floor((featureIndex + 1) / 256 / 256) % 256\n        ];\n        return choropleth.map(polygon => polygon.map(vertex => color));\n      }\n    );\n\n    attribute.value = new Uint8Array(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"b\" /* flatten */])(colors));\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = ChoroplethLayer;\n\n\nChoroplethLayer.layerName = 'ChoroplethLayer';\nChoroplethLayer.defaultProps = defaultProps;\n\n/*\n * get vertex indices for drawing choropleth contour\n * @param {[Number,Number,Number][][]} choropleth\n * @returns {[Number]} indices\n */\nfunction calculateContourIndices(choropleth) {\n  let offset = 0;\n\n  return choropleth.reduce((acc, polygon) => {\n    const numVertices = polygon.length;\n\n    // use vertex pairs for gl.LINES => [0, 1, 1, 2, 2, ..., n-2, n-2, n-1]\n    const indices = [...acc, offset];\n    for (let i = 1; i < numVertices - 1; i++) {\n      indices.push(i + offset, i + offset);\n    }\n    indices.push(offset + numVertices - 1);\n\n    offset += numVertices;\n    return indices;\n  }, []);\n}\n\n/*\n * get vertex indices for drawing choropleth mesh\n * @param {[Number,Number,Number][][]} choropleth\n * @returns {[Number]} indices\n */\nfunction calculateSurfaceIndices(choropleth) {\n  let holes = null;\n\n  if (choropleth.length > 1) {\n    holes = choropleth.reduce(\n      (acc, polygon) => [...acc, acc[acc.length - 1] + polygon.length],\n      [0]\n    ).slice(1, choropleth.length);\n  }\n\n  return __WEBPACK_IMPORTED_MODULE_5_earcut___default()(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"b\" /* flatten */])(choropleth), holes, 3);\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2RlcHJlY2F0ZWQvY2hvcm9wbGV0aC1sYXllci9jaG9yb3BsZXRoLWxheWVyLmpzP2NjOWMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtMYXllcn0gZnJvbSAnLi4vLi4vLi4vbGliJztcbmltcG9ydCB7YXNzZW1ibGVTaGFkZXJzfSBmcm9tICcuLi8uLi8uLi9zaGFkZXItdXRpbHMnO1xuaW1wb3J0IHtnZXQsIGZsYXR0ZW4sIGxvZ30gZnJvbSAnLi4vLi4vLi4vbGliL3V0aWxzJztcbmltcG9ydCB7ZXh0cmFjdFBvbHlnb25zfSBmcm9tICcuL2dlb2pzb24nO1xuaW1wb3J0IHtHTCwgTW9kZWwsIEdlb21ldHJ5fSBmcm9tICdsdW1hLmdsJztcbmltcG9ydCBlYXJjdXQgZnJvbSAnZWFyY3V0JztcblxuaW1wb3J0IGNob3JvcGxldGhWZXJ0ZXggZnJvbSAnLi9jaG9yb3BsZXRoLWxheWVyLXZlcnRleC5nbHNsJztcbmltcG9ydCBjaG9yb3BsZXRoRnJhZ21lbnQgZnJvbSAnLi9jaG9yb3BsZXRoLWxheWVyLWZyYWdtZW50Lmdsc2wnO1xuXG5jb25zdCBERUZBVUxUX0NPTE9SID0gWzAsIDAsIDI1NSwgMjU1XTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBnZXRDb2xvcjogZmVhdHVyZSA9PiBnZXQoZmVhdHVyZSwgJ3Byb3BlcnRpZXMuY29sb3InKSxcbiAgZHJhd0NvbnRvdXI6IGZhbHNlLFxuICBzdHJva2VXaWR0aDogMVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hvcm9wbGV0aExheWVyIGV4dGVuZHMgTGF5ZXIge1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIGxvZy5vbmNlKCdDaG9yb3BsZXRoTGF5ZXIgaXMgZGVwcmVjYXRlZC4gQ29uc2lkZXIgdXNpbmcgR2VvSnNvbkxheWVyIGluc3RlYWQnKTtcbiAgfVxuXG4gIGdldFNoYWRlcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZzOiBjaG9yb3BsZXRoVmVydGV4LFxuICAgICAgZnM6IGNob3JvcGxldGhGcmFnbWVudFxuICAgIH07XG4gIH1cblxuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgY29uc3Qge2dsfSA9IHRoaXMuY29udGV4dDtcblxuICAgIGNvbnN0IHthdHRyaWJ1dGVNYW5hZ2VyfSA9IHRoaXMuc3RhdGU7XG4gICAgYXR0cmlidXRlTWFuYWdlci5hZGREeW5hbWljKHtcbiAgICAgIC8vIFByaW10aXZlIGF0dHJpYnV0ZXNcbiAgICAgIGluZGljZXM6IHtzaXplOiAxLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5kaWNlcywgaXNJbmRleGVkOiB0cnVlfSxcbiAgICAgIHBvc2l0aW9uczoge3NpemU6IDMsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVQb3NpdGlvbnN9LFxuICAgICAgY29sb3JzOiB7c2l6ZTogNCwgdHlwZTogR0wuVU5TSUdORURfQllURSwgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUNvbG9yc30sXG4gICAgICAvLyBJbnN0YW5jZWQgYXR0cmlidXRlc1xuICAgICAgcGlja2luZ0NvbG9yczoge1xuICAgICAgICBzaXplOiAzLFxuICAgICAgICB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLFxuICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlUGlja2luZ0NvbG9ycyxcbiAgICAgICAgbm9BbGxvYzogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgSW5kZXhUeXBlID0gZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfZWxlbWVudF9pbmRleF91aW50JykgPyBVaW50MzJBcnJheSA6IFVpbnQxNkFycmF5O1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBtb2RlbDogdGhpcy5nZXRNb2RlbChnbCksXG4gICAgICBudW1JbnN0YW5jZXM6IDAsXG4gICAgICBJbmRleFR5cGVcbiAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZVN0YXRlKHtvbGRQcm9wcywgcHJvcHMsIGNoYW5nZUZsYWdzfSkge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVNYW5hZ2VyfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKGNoYW5nZUZsYWdzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICB0aGlzLnN0YXRlLmNob3JvcGxldGhzID0gZXh0cmFjdFBvbHlnb25zKHByb3BzLmRhdGEpO1xuICAgICAgYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlQWxsKCk7XG4gICAgfVxuXG4gICAgaWYgKHByb3BzLmRyYXdDb250b3VyICE9PSBvbGRQcm9wcy5kcmF3Q29udG91cikge1xuICAgICAgdGhpcy5zdGF0ZS5tb2RlbC5nZW9tZXRyeS5kcmF3TW9kZSA9IHByb3BzLmRyYXdDb250b3VyID8gR0wuTElORVMgOiBHTC5UUklBTkdMRVM7XG4gICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGVBbGwoKTtcbiAgICB9XG5cbiAgfVxuXG4gIGRyYXcoe3VuaWZvcm1zfSkge1xuICAgIGNvbnN0IHtnbH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgY29uc3QgbGluZVdpZHRoID0gdGhpcy5zY3JlZW5Ub0RldmljZVBpeGVscyh0aGlzLnByb3BzLnN0cm9rZVdpZHRoKTtcbiAgICBnbC5saW5lV2lkdGgobGluZVdpZHRoKTtcbiAgICB0aGlzLnN0YXRlLm1vZGVsLnJlbmRlcih1bmlmb3Jtcyk7XG4gICAgLy8gU2V0dGluZyBsaW5lIHdpZHRoIGJhY2sgdG8gMSBpcyBoZXJlIHRvIHdvcmthcm91bmQgYSBHb29nbGUgQ2hyb21lIGJ1Z1xuICAgIC8vIGdsLmNsZWFyKCkgYW5kIGdsLmlzRW5hYmxlZCgpIHdpbGwgcmV0dXJuIEdMX0lOVkFMSURfVkFMVUUgZXZlbiB3aXRoXG4gICAgLy8gY29ycmVjdCBwYXJhbWV0ZXJcbiAgICAvLyBUaGlzIGlzIG5vdCBoYXBwZW5pbmcgb24gU2FmYXJpIGFuZCBGaXJlZm94XG4gICAgZ2wubGluZVdpZHRoKDEuMCk7XG4gIH1cblxuICBnZXRQaWNraW5nSW5mbyhvcHRzKSB7XG4gICAgY29uc3QgaW5mbyA9IHN1cGVyLmdldFBpY2tpbmdJbmZvKG9wdHMpO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5kZWNvZGVQaWNraW5nQ29sb3IoaW5mby5jb2xvcik7XG4gICAgY29uc3QgZmVhdHVyZSA9IGluZGV4ID49IDAgPyBnZXQodGhpcy5wcm9wcy5kYXRhLCBbJ2ZlYXR1cmVzJywgaW5kZXhdKSA6IG51bGw7XG4gICAgaW5mby5mZWF0dXJlID0gZmVhdHVyZTtcbiAgICBpbmZvLm9iamVjdCA9IGZlYXR1cmU7XG4gICAgcmV0dXJuIGluZm87XG4gIH1cblxuICBnZXRNb2RlbChnbCkge1xuICAgIGNvbnN0IHNoYWRlcnMgPSBhc3NlbWJsZVNoYWRlcnMoZ2wsIHRoaXMuZ2V0U2hhZGVycygpKTtcblxuICAgIHJldHVybiBuZXcgTW9kZWwoe1xuICAgICAgZ2wsXG4gICAgICBpZDogdGhpcy5wcm9wcy5pZCxcbiAgICAgIHZzOiBzaGFkZXJzLnZzLFxuICAgICAgZnM6IHNoYWRlcnMuZnMsXG4gICAgICBnZW9tZXRyeTogbmV3IEdlb21ldHJ5KHtcbiAgICAgICAgZHJhd01vZGU6IHRoaXMucHJvcHMuZHJhd0NvbnRvdXIgPyBHTC5MSU5FUyA6IEdMLlRSSUFOR0xFU1xuICAgICAgfSksXG4gICAgICB2ZXJ0ZXhDb3VudDogMCxcbiAgICAgIGlzSW5kZXhlZDogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgY2FsY3VsYXRlSW5kaWNlcyhhdHRyaWJ1dGUpIHtcbiAgICAvLyBhZGp1c3QgaW5kZXggb2Zmc2V0IGZvciBtdWx0aXBsZSBjaG9yb3BsZXRoc1xuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLnN0YXRlLmNob3JvcGxldGhzLnJlZHVjZShcbiAgICAgIChhY2MsIGNob3JvcGxldGgpID0+IFsuLi5hY2MsIGFjY1thY2MubGVuZ3RoIC0gMV0gK1xuICAgICAgICBjaG9yb3BsZXRoLnJlZHVjZSgoY291bnQsIHBvbHlnb24pID0+IGNvdW50ICsgcG9seWdvbi5sZW5ndGgsIDApXSxcbiAgICAgIFswXVxuICAgICk7XG4gICAgY29uc3Qge0luZGV4VHlwZX0gPSB0aGlzLnN0YXRlO1xuICAgIGlmIChJbmRleFR5cGUgPT09IFVpbnQxNkFycmF5ICYmIG9mZnNldHNbb2Zmc2V0cy5sZW5ndGggLSAxXSA+IDY1NTM1KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZlcnRleCBjb3VudCBleGNlZWRzIGJyb3dzZXJcXCdzIGxpbWl0Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5kaWNlcyA9IHRoaXMuc3RhdGUuY2hvcm9wbGV0aHMubWFwKFxuICAgICAgKGNob3JvcGxldGgsIGNob3JvcGxldGhJbmRleCkgPT4gdGhpcy5wcm9wcy5kcmF3Q29udG91ciA/XG4gICAgICAgIC8vIDEuIGdldCBzZXF1ZW50aWFsbHkgb3JkZXJlZCBpbmRpY2VzIG9mIGVhY2ggY2hvcm9wbGV0aCBjb250b3VyXG4gICAgICAgIC8vIDIuIG9mZnNldCB0aGVtIGJ5IHRoZSBudW1iZXIgb2YgaW5kaWNlcyBpbiBwcmV2aW91cyBjaG9yb3BsZXRoc1xuICAgICAgICBjYWxjdWxhdGVDb250b3VySW5kaWNlcyhjaG9yb3BsZXRoKS5tYXAoaW5kZXggPT4gaW5kZXggKyBvZmZzZXRzW2Nob3JvcGxldGhJbmRleF0pIDpcbiAgICAgICAgLy8gMS4gZ2V0IHRyaWFuZ3VsYXRlZCBpbmRpY2VzIGZvciB0aGUgaW50ZXJuYWwgYXJlYXNcbiAgICAgICAgLy8gMi4gb2Zmc2V0IHRoZW0gYnkgdGhlIG51bWJlciBvZiBpbmRpY2VzIGluIHByZXZpb3VzIGNob3JvcGxldGhzXG4gICAgICAgIGNhbGN1bGF0ZVN1cmZhY2VJbmRpY2VzKGNob3JvcGxldGgpLm1hcChpbmRleCA9PiBpbmRleCArIG9mZnNldHNbY2hvcm9wbGV0aEluZGV4XSlcbiAgICApO1xuXG4gICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IEluZGV4VHlwZShmbGF0dGVuKGluZGljZXMpKTtcbiAgICBhdHRyaWJ1dGUudGFyZ2V0ID0gR0wuRUxFTUVOVF9BUlJBWV9CVUZGRVI7XG4gICAgdGhpcy5zdGF0ZS5tb2RlbC5zZXRWZXJ0ZXhDb3VudChhdHRyaWJ1dGUudmFsdWUubGVuZ3RoIC8gYXR0cmlidXRlLnNpemUpO1xuICB9XG5cbiAgY2FsY3VsYXRlUG9zaXRpb25zKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHZlcnRpY2VzID0gZmxhdHRlbih0aGlzLnN0YXRlLmNob3JvcGxldGhzKTtcbiAgICBhdHRyaWJ1dGUudmFsdWUgPSBuZXcgRmxvYXQzMkFycmF5KHZlcnRpY2VzKTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUNvbG9ycyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7ZGF0YSwgZ2V0Q29sb3J9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBmZWF0dXJlcyA9IGdldChkYXRhLCAnZmVhdHVyZXMnKTtcbiAgICBjb25zdCBjb2xvcnMgPSB0aGlzLnN0YXRlLmNob3JvcGxldGhzLm1hcChcbiAgICAgIChjaG9yb3BsZXRoLCBjaG9yb3BsZXRoSW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgZmVhdHVyZSA9IGdldChmZWF0dXJlcywgY2hvcm9wbGV0aC5mZWF0dXJlSW5kZXgpO1xuICAgICAgICBjb25zdCBjb2xvciA9IGdldENvbG9yKGZlYXR1cmUpIHx8IERFRkFVTFRfQ09MT1I7XG4gICAgICAgIC8vIEVuc3VyZSBhbHBoYSBpcyBzZXRcbiAgICAgICAgaWYgKGlzTmFOKGNvbG9yWzNdKSkge1xuICAgICAgICAgIGNvbG9yWzNdID0gREVGQVVMVF9DT0xPUlszXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hvcm9wbGV0aC5tYXAocG9seWdvbiA9PiBwb2x5Z29uLm1hcCh2ZXJ0ZXggPT4gY29sb3IpKTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IFVpbnQ4QXJyYXkoZmxhdHRlbihjb2xvcnMpKTtcbiAgfVxuXG4gIC8vIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHBpY2tpbmcgY29sb3JzIGNhbGN1bGF0aW9uXG4gIGNhbGN1bGF0ZVBpY2tpbmdDb2xvcnMoYXR0cmlidXRlKSB7XG4gICAgY29uc3QgY29sb3JzID0gdGhpcy5zdGF0ZS5jaG9yb3BsZXRocy5tYXAoXG4gICAgICAoY2hvcm9wbGV0aCwgY2hvcm9wbGV0aEluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHtmZWF0dXJlSW5kZXh9ID0gY2hvcm9wbGV0aDtcbiAgICAgICAgY29uc3QgY29sb3IgPSB0aGlzLnByb3BzLmRyYXdDb250b3VyID8gWzAsIDAsIDBdIDogW1xuICAgICAgICAgIChmZWF0dXJlSW5kZXggKyAxKSAlIDI1NixcbiAgICAgICAgICBNYXRoLmZsb29yKChmZWF0dXJlSW5kZXggKyAxKSAvIDI1NikgJSAyNTYsXG4gICAgICAgICAgTWF0aC5mbG9vcigoZmVhdHVyZUluZGV4ICsgMSkgLyAyNTYgLyAyNTYpICUgMjU2XG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBjaG9yb3BsZXRoLm1hcChwb2x5Z29uID0+IHBvbHlnb24ubWFwKHZlcnRleCA9PiBjb2xvcikpO1xuICAgICAgfVxuICAgICk7XG5cbiAgICBhdHRyaWJ1dGUudmFsdWUgPSBuZXcgVWludDhBcnJheShmbGF0dGVuKGNvbG9ycykpO1xuICB9XG59XG5cbkNob3JvcGxldGhMYXllci5sYXllck5hbWUgPSAnQ2hvcm9wbGV0aExheWVyJztcbkNob3JvcGxldGhMYXllci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5cbi8qXG4gKiBnZXQgdmVydGV4IGluZGljZXMgZm9yIGRyYXdpbmcgY2hvcm9wbGV0aCBjb250b3VyXG4gKiBAcGFyYW0ge1tOdW1iZXIsTnVtYmVyLE51bWJlcl1bXVtdfSBjaG9yb3BsZXRoXG4gKiBAcmV0dXJucyB7W051bWJlcl19IGluZGljZXNcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlQ29udG91ckluZGljZXMoY2hvcm9wbGV0aCkge1xuICBsZXQgb2Zmc2V0ID0gMDtcblxuICByZXR1cm4gY2hvcm9wbGV0aC5yZWR1Y2UoKGFjYywgcG9seWdvbikgPT4ge1xuICAgIGNvbnN0IG51bVZlcnRpY2VzID0gcG9seWdvbi5sZW5ndGg7XG5cbiAgICAvLyB1c2UgdmVydGV4IHBhaXJzIGZvciBnbC5MSU5FUyA9PiBbMCwgMSwgMSwgMiwgMiwgLi4uLCBuLTIsIG4tMiwgbi0xXVxuICAgIGNvbnN0IGluZGljZXMgPSBbLi4uYWNjLCBvZmZzZXRdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbnVtVmVydGljZXMgLSAxOyBpKyspIHtcbiAgICAgIGluZGljZXMucHVzaChpICsgb2Zmc2V0LCBpICsgb2Zmc2V0KTtcbiAgICB9XG4gICAgaW5kaWNlcy5wdXNoKG9mZnNldCArIG51bVZlcnRpY2VzIC0gMSk7XG5cbiAgICBvZmZzZXQgKz0gbnVtVmVydGljZXM7XG4gICAgcmV0dXJuIGluZGljZXM7XG4gIH0sIFtdKTtcbn1cblxuLypcbiAqIGdldCB2ZXJ0ZXggaW5kaWNlcyBmb3IgZHJhd2luZyBjaG9yb3BsZXRoIG1lc2hcbiAqIEBwYXJhbSB7W051bWJlcixOdW1iZXIsTnVtYmVyXVtdW119IGNob3JvcGxldGhcbiAqIEByZXR1cm5zIHtbTnVtYmVyXX0gaW5kaWNlc1xuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVTdXJmYWNlSW5kaWNlcyhjaG9yb3BsZXRoKSB7XG4gIGxldCBob2xlcyA9IG51bGw7XG5cbiAgaWYgKGNob3JvcGxldGgubGVuZ3RoID4gMSkge1xuICAgIGhvbGVzID0gY2hvcm9wbGV0aC5yZWR1Y2UoXG4gICAgICAoYWNjLCBwb2x5Z29uKSA9PiBbLi4uYWNjLCBhY2NbYWNjLmxlbmd0aCAtIDFdICsgcG9seWdvbi5sZW5ndGhdLFxuICAgICAgWzBdXG4gICAgKS5zbGljZSgxLCBjaG9yb3BsZXRoLmxlbmd0aCk7XG4gIH1cblxuICByZXR1cm4gZWFyY3V0KGZsYXR0ZW4oY2hvcm9wbGV0aCksIGhvbGVzLCAzKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xheWVycy9kZXByZWNhdGVkL2Nob3JvcGxldGgtbGF5ZXIvY2hvcm9wbGV0aC1sYXllci5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 22 */
/* exports provided: count */
/* exports used: count */
/*!********************************!*\
  !*** ./src/lib/utils/count.js ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (immutable) */ __webpack_exports__[\"a\"] = count;\nconst ERR_NOT_OBJECT = 'count(): argument not an object';\nconst ERR_NOT_CONTAINER = 'count(): argument not a container';\n\n/**\n * Deduces numer of elements in a JavaScript container.\n * - Auto-deduction for ES6 containers that define a count() method\n * - Auto-deduction for ES6 containers that define a size member\n * - Auto-deduction for Classic Arrays via the built-in length attribute\n * - Also handles objects, although note that this an O(N) operation\n */\nfunction count(container) {\n  if (!isObject(container)) {\n    throw new Error(ERR_NOT_OBJECT);\n  }\n\n  // Check if ES6 collection \"count\" function is available\n  if (typeof container.count === 'function') {\n    return container.count();\n  }\n\n  // Check if ES6 collection \"size\" attribute is set\n  if (Number.isFinite(container.size)) {\n    return container.size;\n  }\n\n  // Check if array length attribute is set\n  // Note: checking this last since some ES6 collections (Immutable.js)\n  // emit profuse warnings when trying to access `length` attribute\n  if (Number.isFinite(container.length)) {\n    return container.length;\n  }\n\n  // Note that getting the count of an object is O(N)\n  if (isPlainObject(container)) {\n    let counter = 0;\n    for (const key in container) { // eslint-disable-line\n      counter++;\n    }\n    return counter;\n  }\n\n  throw new Error(ERR_NOT_CONTAINER);\n}\n\n/**\n * Checks if argument is a plain object (not a class or array etc)\n * @param {*} value - JavaScript value to be tested\n * @return {Boolean} - true if argument is a plain JavaScript object\n */\nfunction isPlainObject(value) {\n  return value !== null && typeof value === 'object' && value.constructor === Object;\n}\n\n/**\n * Checks if argument is an indexable object (not a primitive value, nor null)\n * @param {*} value - JavaScript value to be tested\n * @return {Boolean} - true if argument is a JavaScript object\n */\nfunction isObject(value) {\n  return value !== null && typeof value === 'object';\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL3V0aWxzL2NvdW50LmpzPzgwNGMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgRVJSX05PVF9PQkpFQ1QgPSAnY291bnQoKTogYXJndW1lbnQgbm90IGFuIG9iamVjdCc7XG5jb25zdCBFUlJfTk9UX0NPTlRBSU5FUiA9ICdjb3VudCgpOiBhcmd1bWVudCBub3QgYSBjb250YWluZXInO1xuXG4vKipcbiAqIERlZHVjZXMgbnVtZXIgb2YgZWxlbWVudHMgaW4gYSBKYXZhU2NyaXB0IGNvbnRhaW5lci5cbiAqIC0gQXV0by1kZWR1Y3Rpb24gZm9yIEVTNiBjb250YWluZXJzIHRoYXQgZGVmaW5lIGEgY291bnQoKSBtZXRob2RcbiAqIC0gQXV0by1kZWR1Y3Rpb24gZm9yIEVTNiBjb250YWluZXJzIHRoYXQgZGVmaW5lIGEgc2l6ZSBtZW1iZXJcbiAqIC0gQXV0by1kZWR1Y3Rpb24gZm9yIENsYXNzaWMgQXJyYXlzIHZpYSB0aGUgYnVpbHQtaW4gbGVuZ3RoIGF0dHJpYnV0ZVxuICogLSBBbHNvIGhhbmRsZXMgb2JqZWN0cywgYWx0aG91Z2ggbm90ZSB0aGF0IHRoaXMgYW4gTyhOKSBvcGVyYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvdW50KGNvbnRhaW5lcikge1xuICBpZiAoIWlzT2JqZWN0KGNvbnRhaW5lcikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoRVJSX05PVF9PQkpFQ1QpO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgRVM2IGNvbGxlY3Rpb24gXCJjb3VudFwiIGZ1bmN0aW9uIGlzIGF2YWlsYWJsZVxuICBpZiAodHlwZW9mIGNvbnRhaW5lci5jb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBjb250YWluZXIuY291bnQoKTtcbiAgfVxuXG4gIC8vIENoZWNrIGlmIEVTNiBjb2xsZWN0aW9uIFwic2l6ZVwiIGF0dHJpYnV0ZSBpcyBzZXRcbiAgaWYgKE51bWJlci5pc0Zpbml0ZShjb250YWluZXIuc2l6ZSkpIHtcbiAgICByZXR1cm4gY29udGFpbmVyLnNpemU7XG4gIH1cblxuICAvLyBDaGVjayBpZiBhcnJheSBsZW5ndGggYXR0cmlidXRlIGlzIHNldFxuICAvLyBOb3RlOiBjaGVja2luZyB0aGlzIGxhc3Qgc2luY2Ugc29tZSBFUzYgY29sbGVjdGlvbnMgKEltbXV0YWJsZS5qcylcbiAgLy8gZW1pdCBwcm9mdXNlIHdhcm5pbmdzIHdoZW4gdHJ5aW5nIHRvIGFjY2VzcyBgbGVuZ3RoYCBhdHRyaWJ1dGVcbiAgaWYgKE51bWJlci5pc0Zpbml0ZShjb250YWluZXIubGVuZ3RoKSkge1xuICAgIHJldHVybiBjb250YWluZXIubGVuZ3RoO1xuICB9XG5cbiAgLy8gTm90ZSB0aGF0IGdldHRpbmcgdGhlIGNvdW50IG9mIGFuIG9iamVjdCBpcyBPKE4pXG4gIGlmIChpc1BsYWluT2JqZWN0KGNvbnRhaW5lcikpIHtcbiAgICBsZXQgY291bnRlciA9IDA7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY29udGFpbmVyKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIGNvdW50ZXIrKztcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoRVJSX05PVF9DT05UQUlORVIpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhcmd1bWVudCBpcyBhIHBsYWluIG9iamVjdCAobm90IGEgY2xhc3Mgb3IgYXJyYXkgZXRjKVxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIEphdmFTY3JpcHQgdmFsdWUgdG8gYmUgdGVzdGVkXG4gKiBAcmV0dXJuIHtCb29sZWFufSAtIHRydWUgaWYgYXJndW1lbnQgaXMgYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdFxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFyZ3VtZW50IGlzIGFuIGluZGV4YWJsZSBvYmplY3QgKG5vdCBhIHByaW1pdGl2ZSB2YWx1ZSwgbm9yIG51bGwpXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gSmF2YVNjcmlwdCB2YWx1ZSB0byBiZSB0ZXN0ZWRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IC0gdHJ1ZSBpZiBhcmd1bWVudCBpcyBhIEphdmFTY3JpcHQgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xufVxuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9saWIvdXRpbHMvY291bnQuanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 23 */
/* exports provided: default */
/* exports used: default */
/*!****************************************************!*\
  !*** ./src/lib/viewports/orthographic-viewport.js ***!
  \****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__viewport__ = __webpack_require__(/*! ./viewport */ 5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_gl_matrix__ = __webpack_require__(/*! gl-matrix */ 7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_gl_matrix___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_gl_matrix__);\n\n\n\nclass OrthographicViewport extends __WEBPACK_IMPORTED_MODULE_0__viewport__[\"a\" /* default */] {\n  constructor({\n    // viewport arguments\n    width, // Width of viewport\n    height, // Height of viewport\n    // view matrix arguments\n    eye = [0, 0, 1], // Defines eye position, default unit distance along z axis\n    lookAt = [0, 0, 0], // Which point is camera looking at, default origin\n    up = [0, 1, 0], // Defines up direction, default positive y axis\n    // projection matrix arguments\n    near = 1, // Distance of near clipping plane\n    far = 100, // Distance of far clipping plane\n    left, // Left bound of the frustum\n    top, // Top bound of the frustum\n    // automatically calculated\n    right = null, // Right bound of the frustum\n    bottom = null // Bottom bound of the frustum\n  }) {\n    right = Number.isFinite(right) ? right : left + width;\n    bottom = Number.isFinite(bottom) ? bottom : top + height;\n    super({\n      viewMatrix: __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"mat4\"].lookAt([], eye, lookAt, up),\n      projectionMatrix: __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"mat4\"].ortho([], left, right, bottom, top, near, far),\n      width,\n      height\n    });\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = OrthographicViewport;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL3ZpZXdwb3J0cy9vcnRob2dyYXBoaWMtdmlld3BvcnQuanM/NmZlMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVmlld3BvcnQgZnJvbSAnLi92aWV3cG9ydCc7XG5pbXBvcnQge21hdDR9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9ydGhvZ3JhcGhpY1ZpZXdwb3J0IGV4dGVuZHMgVmlld3BvcnQge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgLy8gdmlld3BvcnQgYXJndW1lbnRzXG4gICAgd2lkdGgsIC8vIFdpZHRoIG9mIHZpZXdwb3J0XG4gICAgaGVpZ2h0LCAvLyBIZWlnaHQgb2Ygdmlld3BvcnRcbiAgICAvLyB2aWV3IG1hdHJpeCBhcmd1bWVudHNcbiAgICBleWUgPSBbMCwgMCwgMV0sIC8vIERlZmluZXMgZXllIHBvc2l0aW9uLCBkZWZhdWx0IHVuaXQgZGlzdGFuY2UgYWxvbmcgeiBheGlzXG4gICAgbG9va0F0ID0gWzAsIDAsIDBdLCAvLyBXaGljaCBwb2ludCBpcyBjYW1lcmEgbG9va2luZyBhdCwgZGVmYXVsdCBvcmlnaW5cbiAgICB1cCA9IFswLCAxLCAwXSwgLy8gRGVmaW5lcyB1cCBkaXJlY3Rpb24sIGRlZmF1bHQgcG9zaXRpdmUgeSBheGlzXG4gICAgLy8gcHJvamVjdGlvbiBtYXRyaXggYXJndW1lbnRzXG4gICAgbmVhciA9IDEsIC8vIERpc3RhbmNlIG9mIG5lYXIgY2xpcHBpbmcgcGxhbmVcbiAgICBmYXIgPSAxMDAsIC8vIERpc3RhbmNlIG9mIGZhciBjbGlwcGluZyBwbGFuZVxuICAgIGxlZnQsIC8vIExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAgICB0b3AsIC8vIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICAgIC8vIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZFxuICAgIHJpZ2h0ID0gbnVsbCwgLy8gUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAgICBib3R0b20gPSBudWxsIC8vIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICB9KSB7XG4gICAgcmlnaHQgPSBOdW1iZXIuaXNGaW5pdGUocmlnaHQpID8gcmlnaHQgOiBsZWZ0ICsgd2lkdGg7XG4gICAgYm90dG9tID0gTnVtYmVyLmlzRmluaXRlKGJvdHRvbSkgPyBib3R0b20gOiB0b3AgKyBoZWlnaHQ7XG4gICAgc3VwZXIoe1xuICAgICAgdmlld01hdHJpeDogbWF0NC5sb29rQXQoW10sIGV5ZSwgbG9va0F0LCB1cCksXG4gICAgICBwcm9qZWN0aW9uTWF0cml4OiBtYXQ0Lm9ydGhvKFtdLCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhciksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0pO1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9saWIvdmlld3BvcnRzL29ydGhvZ3JhcGhpYy12aWV3cG9ydC5qc1xuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 24 */
/* exports provided: default */
/* exports used: default */
/*!***************************************************!*\
  !*** ./src/lib/viewports/perspective-viewport.js ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__viewport__ = __webpack_require__(/*! ./viewport */ 5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_gl_matrix__ = __webpack_require__(/*! gl-matrix */ 7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_gl_matrix___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_gl_matrix__);\n\n\n\nconst DEGREES_TO_RADIANS = Math.PI / 180;\n\nclass PerspectiveViewport extends __WEBPACK_IMPORTED_MODULE_0__viewport__[\"a\" /* default */] {\n  constructor({\n    // viewport arguments\n    width, // Width of viewport\n    height, // Height of viewport\n    // view matrix arguments\n    eye, // Defines eye position\n    lookAt = [0, 0, 0], // Which point is camera looking at, default origin\n    up = [0, 1, 0], // Defines up direction, default positive y axis\n    // projection matrix arguments\n    fovy = 75, // Field of view covered by camera\n    near = 1, // Distance of near clipping plane\n    far = 100, // Distance of far clipping plane\n    // automatically calculated\n    aspect = null // Aspect ratio (set to viewport widht/height)\n  }) {\n    const fovyRadians = fovy * DEGREES_TO_RADIANS;\n    aspect = Number.isFinite(aspect) ? aspect : width / height;\n    super({\n      viewMatrix: __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"mat4\"].lookAt([], eye, lookAt, up),\n      projectionMatrix: __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"mat4\"].perspective([], fovyRadians, aspect, near, far),\n      width,\n      height\n    });\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = PerspectiveViewport;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL3ZpZXdwb3J0cy9wZXJzcGVjdGl2ZS12aWV3cG9ydC5qcz9kM2ZhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBWaWV3cG9ydCBmcm9tICcuL3ZpZXdwb3J0JztcbmltcG9ydCB7bWF0NH0gZnJvbSAnZ2wtbWF0cml4JztcblxuY29uc3QgREVHUkVFU19UT19SQURJQU5TID0gTWF0aC5QSSAvIDE4MDtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGVyc3BlY3RpdmVWaWV3cG9ydCBleHRlbmRzIFZpZXdwb3J0IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIC8vIHZpZXdwb3J0IGFyZ3VtZW50c1xuICAgIHdpZHRoLCAvLyBXaWR0aCBvZiB2aWV3cG9ydFxuICAgIGhlaWdodCwgLy8gSGVpZ2h0IG9mIHZpZXdwb3J0XG4gICAgLy8gdmlldyBtYXRyaXggYXJndW1lbnRzXG4gICAgZXllLCAvLyBEZWZpbmVzIGV5ZSBwb3NpdGlvblxuICAgIGxvb2tBdCA9IFswLCAwLCAwXSwgLy8gV2hpY2ggcG9pbnQgaXMgY2FtZXJhIGxvb2tpbmcgYXQsIGRlZmF1bHQgb3JpZ2luXG4gICAgdXAgPSBbMCwgMSwgMF0sIC8vIERlZmluZXMgdXAgZGlyZWN0aW9uLCBkZWZhdWx0IHBvc2l0aXZlIHkgYXhpc1xuICAgIC8vIHByb2plY3Rpb24gbWF0cml4IGFyZ3VtZW50c1xuICAgIGZvdnkgPSA3NSwgLy8gRmllbGQgb2YgdmlldyBjb3ZlcmVkIGJ5IGNhbWVyYVxuICAgIG5lYXIgPSAxLCAvLyBEaXN0YW5jZSBvZiBuZWFyIGNsaXBwaW5nIHBsYW5lXG4gICAgZmFyID0gMTAwLCAvLyBEaXN0YW5jZSBvZiBmYXIgY2xpcHBpbmcgcGxhbmVcbiAgICAvLyBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWRcbiAgICBhc3BlY3QgPSBudWxsIC8vIEFzcGVjdCByYXRpbyAoc2V0IHRvIHZpZXdwb3J0IHdpZGh0L2hlaWdodClcbiAgfSkge1xuICAgIGNvbnN0IGZvdnlSYWRpYW5zID0gZm92eSAqIERFR1JFRVNfVE9fUkFESUFOUztcbiAgICBhc3BlY3QgPSBOdW1iZXIuaXNGaW5pdGUoYXNwZWN0KSA/IGFzcGVjdCA6IHdpZHRoIC8gaGVpZ2h0O1xuICAgIHN1cGVyKHtcbiAgICAgIHZpZXdNYXRyaXg6IG1hdDQubG9va0F0KFtdLCBleWUsIGxvb2tBdCwgdXApLFxuICAgICAgcHJvamVjdGlvbk1hdHJpeDogbWF0NC5wZXJzcGVjdGl2ZShbXSwgZm92eVJhZGlhbnMsIGFzcGVjdCwgbmVhciwgZmFyKSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSk7XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xpYi92aWV3cG9ydHMvcGVyc3BlY3RpdmUtdmlld3BvcnQuanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 25 */
/* exports provided: default */
/* exports used: default */
/*!****************************************************!*\
  !*** ./src/lib/viewports/web-mercator-viewport.js ***!
  \****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__viewport__ = __webpack_require__(/*! ./viewport */ 5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_gl_matrix__ = __webpack_require__(/*! gl-matrix */ 7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_gl_matrix___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_gl_matrix__);\n// View and Projection Matrix calculations for mapbox-js style\n// map view properties\n\n\n\n// CONSTANTS\nconst PI = Math.PI;\nconst PI_4 = PI / 4;\nconst DEGREES_TO_RADIANS = PI / 180;\nconst RADIANS_TO_DEGREES = 180 / PI;\nconst TILE_SIZE = 512;\nconst WORLD_SCALE = TILE_SIZE / (2 * PI);\n\nconst DEFAULT_MAP_STATE = {\n  latitude: 37,\n  longitude: -122,\n  zoom: 11,\n  pitch: 0,\n  bearing: 0,\n  altitude: 1.5\n};\n\nclass WebMercatorViewport extends __WEBPACK_IMPORTED_MODULE_0__viewport__[\"a\" /* default */] {\n  /**\n   * @classdesc\n   * Creates view/projection matrices from mercator params\n   * Note: The Viewport is immutable in the sense that it only has accessors.\n   * A new viewport instance should be created if any parameters have changed.\n   *\n   * @class\n   * @param {Object} opt - options\n   * @param {Boolean} mercator=true - Whether to use mercator projection\n   *\n   * @param {Number} opt.width=1 - Width of \"viewport\" or window\n   * @param {Number} opt.height=1 - Height of \"viewport\" or window\n   * @param {Array} opt.center=[0, 0] - Center of viewport\n   *   [longitude, latitude] or [x, y]\n   * @param {Number} opt.scale=1 - Either use scale or zoom\n   * @param {Number} opt.pitch=0 - Camera angle in degrees (0 is straight down)\n   * @param {Number} opt.bearing=0 - Map rotation in degrees (0 means north is up)\n   * @param {Number} opt.altitude= - Altitude of camera in screen units\n   *\n   * Web mercator projection short-hand parameters\n   * @param {Number} opt.latitude - Center of viewport on map (alternative to opt.center)\n   * @param {Number} opt.longitude - Center of viewport on map (alternative to opt.center)\n   * @param {Number} opt.zoom - Scale = Math.pow(2,zoom) on map (alternative to opt.scale)\n\n   * Notes:\n   *  - Only one of center or [latitude, longitude] can be specified\n   *  - [latitude, longitude] can only be specified when \"mercator\" is true\n   *  - Altitude has a default value that matches assumptions in mapbox-gl\n   *  - width and height are forced to 1 if supplied as 0, to avoid\n   *    division by zero. This is intended to reduce the burden of apps to\n   *    to check values before instantiating a Viewport.\n   */\n  /* eslint-disable complexity, max-statements */\n  constructor({\n    // Map state\n    width,\n    height,\n    latitude,\n    longitude,\n    zoom,\n    pitch,\n    bearing,\n    altitude,\n    mercatorEnabled\n  } = {}) {\n    // Viewport - support undefined arguments\n    width = width !== undefined ? width : DEFAULT_MAP_STATE.width;\n    height = height !== undefined ? height : DEFAULT_MAP_STATE.height;\n    zoom = zoom !== undefined ? zoom : DEFAULT_MAP_STATE.zoom;\n    latitude = latitude !== undefined ? latitude : DEFAULT_MAP_STATE.latitude;\n    longitude = longitude !== undefined ? longitude : DEFAULT_MAP_STATE.longitude;\n    bearing = bearing !== undefined ? bearing : DEFAULT_MAP_STATE.bearing;\n    pitch = pitch !== undefined ? pitch : DEFAULT_MAP_STATE.pitch;\n    altitude = altitude !== undefined ? altitude : DEFAULT_MAP_STATE.altitude;\n\n    // Silently allow apps to send in 0,0 to facilitate isomorphic render etc\n    width = width || 1;\n    height = height || 1;\n\n    const scale = Math.pow(2, zoom);\n    // Altitude - prevent division by 0\n    // TODO - just throw an Error instead?\n    altitude = Math.max(0.75, altitude);\n\n    const distanceScales = calculateDistanceScales({latitude, longitude, scale});\n\n    const projectionMatrix = makeProjectionMatrixFromMercatorParams({\n      width,\n      height,\n      pitch,\n      bearing,\n      altitude\n    });\n\n    const {viewMatrix, viewMatrixUncentered, viewCenter} =\n      makeViewMatrixFromMercatorParams({\n        width,\n        height,\n        longitude,\n        latitude,\n        zoom,\n        pitch,\n        bearing,\n        altitude,\n        distanceScales\n      });\n\n    super({width, height, viewMatrix, projectionMatrix});\n\n    // Add additional matrices\n    this.viewMatrixUncentered = viewMatrixUncentered;\n    this.viewCenter = viewCenter;\n\n    // Save parameters\n    this.latitude = latitude;\n    this.longitude = longitude;\n    this.zoom = zoom;\n    this.pitch = pitch;\n    this.bearing = bearing;\n    this.altitude = altitude;\n\n    this.scale = scale;\n\n    this._distanceScales = distanceScales;\n\n    this.getDistanceScales = this.getDistanceScales.bind(this);\n    this.metersToLngLatDelta = this.metersToLngLatDelta.bind(this);\n    this.lngLatDeltaToMeters = this.lngLatDeltaToMeters.bind(this);\n    this.addMetersToLngLat = this.addMetersToLngLat.bind(this);\n  }\n  /* eslint-enable complexity, max-statements */\n\n  /**\n   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.\n   * Performs the nonlinear part of the web mercator projection.\n   * Remaining projection is done with 4x4 matrices which also handles\n   * perspective.\n   *\n   * @param {Array} lngLat - [lng, lat] coordinates\n   *   Specifies a point on the sphere to project onto the map.\n   * @return {Array} [x,y] coordinates.\n   */\n  _projectFlat(lngLat, scale = this.scale) {\n    return projectFlat(lngLat, scale);\n  }\n\n  /**\n   * Unproject world point [x,y] on map onto {lat, lon} on sphere\n   *\n   * @param {object|Vector} xy - object with {x,y} members\n   *  representing point on projected map plane\n   * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.\n   *   Has toArray method if you need a GeoJSON Array.\n   *   Per cartographic tradition, lat and lon are specified as degrees.\n   */\n  _unprojectFlat(xy, scale = this.scale) {\n    return unprojectFlat(xy, scale);\n  }\n\n  getDistanceScales() {\n    return this._distanceScales;\n  }\n\n  /**\n   * Converts a meter offset to a lnglat offset\n   *\n   * Note: Uses simple linear approximation around the viewport center\n   * Error increases with size of offset (roughly 1% per 100km)\n   *\n   * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas\n   * @return {[Number,Number]|[Number,Number,Number]) - array of [lng,lat,z] deltas\n   */\n  metersToLngLatDelta(xyz) {\n    const [x, y, z = 0] = xyz;\n    const {pixelsPerMeter, degreesPerPixel} = this._distanceScales;\n    const deltaLng = x * pixelsPerMeter[0] * degreesPerPixel[0];\n    const deltaLat = y * pixelsPerMeter[1] * degreesPerPixel[1];\n    return xyz.length === 2 ? [deltaLng, deltaLat] : [deltaLng, deltaLat, z];\n  }\n\n  /**\n   * Converts a lnglat offset to a meter offset\n   *\n   * Note: Uses simple linear approximation around the viewport center\n   * Error increases with size of offset (roughly 1% per 100km)\n   *\n   * @param {[Number,Number]|[Number,Number,Number]) deltaLngLatZ - array of [lng,lat,z] deltas\n   * @return {[Number,Number]|[Number,Number,Number]) - array of meter deltas\n   */\n  lngLatDeltaToMeters(deltaLngLatZ) {\n    const [deltaLng, deltaLat, deltaZ = 0] = deltaLngLatZ;\n    const {pixelsPerDegree, metersPerPixel} = this._distanceScales;\n    const deltaX = deltaLng * pixelsPerDegree[0] * metersPerPixel[0];\n    const deltaY = deltaLat * pixelsPerDegree[1] * metersPerPixel[1];\n    return deltaLngLatZ.length === 2 ? [deltaX, deltaY] : [deltaX, deltaY, deltaZ];\n  }\n\n  /**\n   * Add a meter delta to a base lnglat coordinate, returning a new lnglat array\n   *\n   * Note: Uses simple linear approximation around the viewport center\n   * Error increases with size of offset (roughly 1% per 100km)\n   *\n   * @param {[Number,Number]|[Number,Number,Number]) lngLatZ - base coordinate\n   * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas\n   * @return {[Number,Number]|[Number,Number,Number]) array of [lng,lat,z] deltas\n   */\n  addMetersToLngLat(lngLatZ, xyz) {\n    const [lng, lat, Z = 0] = lngLatZ;\n    const [deltaLng, deltaLat, deltaZ = 0] = this.metersToLngLatDelta(xyz);\n    return lngLatZ.length === 2 ?\n      [lng + deltaLng, lat + deltaLat] :\n      [lng + deltaLng, lat + deltaLat, Z + deltaZ];\n  }\n\n  // INTERNAL METHODS\n\n  _getParams() {\n    return this._distanceScales;\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = WebMercatorViewport;\n\n\n/**\n * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.\n * Performs the nonlinear part of the web mercator projection.\n * Remaining projection is done with 4x4 matrices which also handles\n * perspective.\n *\n * @param {Array} lngLat - [lng, lat] coordinates\n *   Specifies a point on the sphere to project onto the map.\n * @return {Array} [x,y] coordinates.\n */\nfunction projectFlat([lng, lat], scale) {\n  scale = scale * WORLD_SCALE;\n  const lambda2 = lng * DEGREES_TO_RADIANS;\n  const phi2 = lat * DEGREES_TO_RADIANS;\n  const x = scale * (lambda2 + PI);\n  const y = scale * (PI - Math.log(Math.tan(PI_4 + phi2 * 0.5)));\n  return [x, y];\n}\n\n/**\n * Unproject world point [x,y] on map onto {lat, lon} on sphere\n *\n * @param {object|Vector} xy - object with {x,y} members\n *  representing point on projected map plane\n * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.\n *   Has toArray method if you need a GeoJSON Array.\n *   Per cartographic tradition, lat and lon are specified as degrees.\n */\nfunction unprojectFlat([x, y], scale) {\n  scale = scale * WORLD_SCALE;\n  const lambda2 = x / scale - PI;\n  const phi2 = 2 * (Math.atan(Math.exp(PI - y / scale)) - PI_4);\n  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];\n}\n\n/**\n * Calculate distance scales in meters around current lat/lon, both for\n * degrees and pixels.\n * In mercator projection mode, the distance scales vary significantly\n * with latitude.\n */\nfunction calculateDistanceScales({latitude, longitude, scale}) {\n  // Approximately 111km per degree at equator\n  const METERS_PER_DEGREE = 111000;\n\n  const latCosine = Math.cos(latitude * Math.PI / 180);\n\n  const metersPerDegree = METERS_PER_DEGREE * latCosine;\n\n  // Calculate number of pixels occupied by one degree longitude\n  // around current lat/lon\n  const pixelsPerDegreeX = __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"vec2\"].distance(\n    projectFlat([longitude + 0.5, latitude]),\n    projectFlat([longitude - 0.5, latitude])\n  );\n  // Calculate number of pixels occupied by one degree latitude\n  // around current lat/lon\n  const pixelsPerDegreeY = __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"vec2\"].distance(\n    projectFlat([longitude, latitude + 0.5]),\n    projectFlat([longitude, latitude - 0.5])\n  );\n\n  const pixelsPerMeterX = pixelsPerDegreeX / metersPerDegree;\n  const pixelsPerMeterY = pixelsPerDegreeY / metersPerDegree;\n  const pixelsPerMeterZ = (pixelsPerMeterX + pixelsPerMeterY) / 2;\n  // const pixelsPerMeter = [pixelsPerMeterX, pixelsPerMeterY, pixelsPerMeterZ];\n\n  const worldSize = TILE_SIZE * scale;\n  const altPixelsPerMeter = worldSize / (4e7 * latCosine);\n  const pixelsPerMeter = [altPixelsPerMeter, altPixelsPerMeter, altPixelsPerMeter];\n  const metersPerPixel = [1 / altPixelsPerMeter, 1 / altPixelsPerMeter, 1 / pixelsPerMeterZ];\n\n  const pixelsPerDegree = [pixelsPerDegreeX, pixelsPerDegreeY, pixelsPerMeterZ];\n  const degreesPerPixel = [1 / pixelsPerDegreeX, 1 / pixelsPerDegreeY, 1 / pixelsPerMeterZ];\n\n  // Main results, used for converting meters to latlng deltas and scaling offsets\n  return {\n    pixelsPerMeter,\n    metersPerPixel,\n    pixelsPerDegree,\n    degreesPerPixel\n  };\n}\n\n// ATTRIBUTION:\n// view and projection matrix creation is intentionally kept compatible with\n// mapbox-gl's implementation to ensure that seamless interoperation\n// with mapbox and react-map-gl. See: https://github.com/mapbox/mapbox-gl-js\nfunction makeProjectionMatrixFromMercatorParams({\n  width,\n  height,\n  pitch,\n  altitude\n}) {\n  const pitchRadians = pitch * DEGREES_TO_RADIANS;\n\n  // PROJECTION MATRIX: PROJECTS FROM CAMERA SPACE TO CLIPSPACE\n  // Find the distance from the center point to the center top\n  // in altitude units using law of sines.\n  const halfFov = Math.atan(0.5 / altitude);\n  const topHalfSurfaceDistance =\n    Math.sin(halfFov) * altitude / Math.sin(Math.PI / 2 - pitchRadians - halfFov);\n\n  // Calculate z value of the farthest fragment that should be rendered.\n  const farZ = Math.cos(Math.PI / 2 - pitchRadians) * topHalfSurfaceDistance + altitude;\n\n  const projectionMatrix = __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"mat4\"].perspective(\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__viewport__[\"b\" /* createMat4 */])(),\n    2 * Math.atan((height / 2) / altitude), // fov in radians\n    width / height,                         // aspect ratio\n    0.1,                                    // near plane\n    farZ * 10.0                             // far plane\n  );\n\n  return projectionMatrix;\n}\n\nfunction makeViewMatrixFromMercatorParams({\n  width,\n  height,\n  longitude,\n  latitude,\n  zoom,\n  pitch,\n  bearing,\n  altitude\n}) {\n  // Center x, y\n  const scale = Math.pow(2, zoom);\n  // VIEW MATRIX: PROJECTS FROM VIRTUAL PIXELS TO CAMERA SPACE\n  // Note: As usual, matrix operation orders should be read in reverse\n  // since vectors will be multiplied from the right during transformation\n  const vm = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__viewport__[\"b\" /* createMat4 */])();\n\n  // Move camera to altitude\n  __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"mat4\"].translate(vm, vm, [0, 0, -altitude]);\n\n  // After the rotateX, z values are in pixel units. Convert them to\n  // altitude units. 1 altitude unit = the screen height.\n  __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"mat4\"].scale(vm, vm, [1, -1, 1 / height]);\n\n  // Rotate by bearing, and then by pitch (which tilts the view)\n  __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"mat4\"].rotateX(vm, vm, pitch * DEGREES_TO_RADIANS);\n  __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"mat4\"].rotateZ(vm, vm, -bearing * DEGREES_TO_RADIANS);\n\n  const [centerX, centerY] = projectFlat([longitude, latitude], scale);\n\n  const center = [-centerX, -centerY, 0, 1];\n  const viewCenter = __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"vec4\"].transformMat4([], center, vm);\n\n  const vmCentered = __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"mat4\"].translate([], vm, [-centerX, -centerY, 0]);\n\n  return {\n    viewMatrix: vmCentered,\n    viewMatrixUncentered: vm,\n    viewCenter\n  };\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL3ZpZXdwb3J0cy93ZWItbWVyY2F0b3Itdmlld3BvcnQuanM/NzIwZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBWaWV3IGFuZCBQcm9qZWN0aW9uIE1hdHJpeCBjYWxjdWxhdGlvbnMgZm9yIG1hcGJveC1qcyBzdHlsZVxuLy8gbWFwIHZpZXcgcHJvcGVydGllc1xuaW1wb3J0IFZpZXdwb3J0LCB7Y3JlYXRlTWF0NH0gZnJvbSAnLi92aWV3cG9ydCc7XG5pbXBvcnQge21hdDQsIHZlYzQsIHZlYzJ9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbi8vIENPTlNUQU5UU1xuY29uc3QgUEkgPSBNYXRoLlBJO1xuY29uc3QgUElfNCA9IFBJIC8gNDtcbmNvbnN0IERFR1JFRVNfVE9fUkFESUFOUyA9IFBJIC8gMTgwO1xuY29uc3QgUkFESUFOU19UT19ERUdSRUVTID0gMTgwIC8gUEk7XG5jb25zdCBUSUxFX1NJWkUgPSA1MTI7XG5jb25zdCBXT1JMRF9TQ0FMRSA9IFRJTEVfU0laRSAvICgyICogUEkpO1xuXG5jb25zdCBERUZBVUxUX01BUF9TVEFURSA9IHtcbiAgbGF0aXR1ZGU6IDM3LFxuICBsb25naXR1ZGU6IC0xMjIsXG4gIHpvb206IDExLFxuICBwaXRjaDogMCxcbiAgYmVhcmluZzogMCxcbiAgYWx0aXR1ZGU6IDEuNVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2ViTWVyY2F0b3JWaWV3cG9ydCBleHRlbmRzIFZpZXdwb3J0IHtcbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogQ3JlYXRlcyB2aWV3L3Byb2plY3Rpb24gbWF0cmljZXMgZnJvbSBtZXJjYXRvciBwYXJhbXNcbiAgICogTm90ZTogVGhlIFZpZXdwb3J0IGlzIGltbXV0YWJsZSBpbiB0aGUgc2Vuc2UgdGhhdCBpdCBvbmx5IGhhcyBhY2Nlc3NvcnMuXG4gICAqIEEgbmV3IHZpZXdwb3J0IGluc3RhbmNlIHNob3VsZCBiZSBjcmVhdGVkIGlmIGFueSBwYXJhbWV0ZXJzIGhhdmUgY2hhbmdlZC5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHQgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWVyY2F0b3I9dHJ1ZSAtIFdoZXRoZXIgdG8gdXNlIG1lcmNhdG9yIHByb2plY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC53aWR0aD0xIC0gV2lkdGggb2YgXCJ2aWV3cG9ydFwiIG9yIHdpbmRvd1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmhlaWdodD0xIC0gSGVpZ2h0IG9mIFwidmlld3BvcnRcIiBvciB3aW5kb3dcbiAgICogQHBhcmFtIHtBcnJheX0gb3B0LmNlbnRlcj1bMCwgMF0gLSBDZW50ZXIgb2Ygdmlld3BvcnRcbiAgICogICBbbG9uZ2l0dWRlLCBsYXRpdHVkZV0gb3IgW3gsIHldXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuc2NhbGU9MSAtIEVpdGhlciB1c2Ugc2NhbGUgb3Igem9vbVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LnBpdGNoPTAgLSBDYW1lcmEgYW5nbGUgaW4gZGVncmVlcyAoMCBpcyBzdHJhaWdodCBkb3duKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmJlYXJpbmc9MCAtIE1hcCByb3RhdGlvbiBpbiBkZWdyZWVzICgwIG1lYW5zIG5vcnRoIGlzIHVwKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmFsdGl0dWRlPSAtIEFsdGl0dWRlIG9mIGNhbWVyYSBpbiBzY3JlZW4gdW5pdHNcbiAgICpcbiAgICogV2ViIG1lcmNhdG9yIHByb2plY3Rpb24gc2hvcnQtaGFuZCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQubGF0aXR1ZGUgLSBDZW50ZXIgb2Ygdmlld3BvcnQgb24gbWFwIChhbHRlcm5hdGl2ZSB0byBvcHQuY2VudGVyKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmxvbmdpdHVkZSAtIENlbnRlciBvZiB2aWV3cG9ydCBvbiBtYXAgKGFsdGVybmF0aXZlIHRvIG9wdC5jZW50ZXIpXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuem9vbSAtIFNjYWxlID0gTWF0aC5wb3coMix6b29tKSBvbiBtYXAgKGFsdGVybmF0aXZlIHRvIG9wdC5zY2FsZSlcblxuICAgKiBOb3RlczpcbiAgICogIC0gT25seSBvbmUgb2YgY2VudGVyIG9yIFtsYXRpdHVkZSwgbG9uZ2l0dWRlXSBjYW4gYmUgc3BlY2lmaWVkXG4gICAqICAtIFtsYXRpdHVkZSwgbG9uZ2l0dWRlXSBjYW4gb25seSBiZSBzcGVjaWZpZWQgd2hlbiBcIm1lcmNhdG9yXCIgaXMgdHJ1ZVxuICAgKiAgLSBBbHRpdHVkZSBoYXMgYSBkZWZhdWx0IHZhbHVlIHRoYXQgbWF0Y2hlcyBhc3N1bXB0aW9ucyBpbiBtYXBib3gtZ2xcbiAgICogIC0gd2lkdGggYW5kIGhlaWdodCBhcmUgZm9yY2VkIHRvIDEgaWYgc3VwcGxpZWQgYXMgMCwgdG8gYXZvaWRcbiAgICogICAgZGl2aXNpb24gYnkgemVyby4gVGhpcyBpcyBpbnRlbmRlZCB0byByZWR1Y2UgdGhlIGJ1cmRlbiBvZiBhcHBzIHRvXG4gICAqICAgIHRvIGNoZWNrIHZhbHVlcyBiZWZvcmUgaW5zdGFudGlhdGluZyBhIFZpZXdwb3J0LlxuICAgKi9cbiAgLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSwgbWF4LXN0YXRlbWVudHMgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIC8vIE1hcCBzdGF0ZVxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBsYXRpdHVkZSxcbiAgICBsb25naXR1ZGUsXG4gICAgem9vbSxcbiAgICBwaXRjaCxcbiAgICBiZWFyaW5nLFxuICAgIGFsdGl0dWRlLFxuICAgIG1lcmNhdG9yRW5hYmxlZFxuICB9ID0ge30pIHtcbiAgICAvLyBWaWV3cG9ydCAtIHN1cHBvcnQgdW5kZWZpbmVkIGFyZ3VtZW50c1xuICAgIHdpZHRoID0gd2lkdGggIT09IHVuZGVmaW5lZCA/IHdpZHRoIDogREVGQVVMVF9NQVBfU1RBVEUud2lkdGg7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0ICE9PSB1bmRlZmluZWQgPyBoZWlnaHQgOiBERUZBVUxUX01BUF9TVEFURS5oZWlnaHQ7XG4gICAgem9vbSA9IHpvb20gIT09IHVuZGVmaW5lZCA/IHpvb20gOiBERUZBVUxUX01BUF9TVEFURS56b29tO1xuICAgIGxhdGl0dWRlID0gbGF0aXR1ZGUgIT09IHVuZGVmaW5lZCA/IGxhdGl0dWRlIDogREVGQVVMVF9NQVBfU1RBVEUubGF0aXR1ZGU7XG4gICAgbG9uZ2l0dWRlID0gbG9uZ2l0dWRlICE9PSB1bmRlZmluZWQgPyBsb25naXR1ZGUgOiBERUZBVUxUX01BUF9TVEFURS5sb25naXR1ZGU7XG4gICAgYmVhcmluZyA9IGJlYXJpbmcgIT09IHVuZGVmaW5lZCA/IGJlYXJpbmcgOiBERUZBVUxUX01BUF9TVEFURS5iZWFyaW5nO1xuICAgIHBpdGNoID0gcGl0Y2ggIT09IHVuZGVmaW5lZCA/IHBpdGNoIDogREVGQVVMVF9NQVBfU1RBVEUucGl0Y2g7XG4gICAgYWx0aXR1ZGUgPSBhbHRpdHVkZSAhPT0gdW5kZWZpbmVkID8gYWx0aXR1ZGUgOiBERUZBVUxUX01BUF9TVEFURS5hbHRpdHVkZTtcblxuICAgIC8vIFNpbGVudGx5IGFsbG93IGFwcHMgdG8gc2VuZCBpbiAwLDAgdG8gZmFjaWxpdGF0ZSBpc29tb3JwaGljIHJlbmRlciBldGNcbiAgICB3aWR0aCA9IHdpZHRoIHx8IDE7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IDE7XG5cbiAgICBjb25zdCBzY2FsZSA9IE1hdGgucG93KDIsIHpvb20pO1xuICAgIC8vIEFsdGl0dWRlIC0gcHJldmVudCBkaXZpc2lvbiBieSAwXG4gICAgLy8gVE9ETyAtIGp1c3QgdGhyb3cgYW4gRXJyb3IgaW5zdGVhZD9cbiAgICBhbHRpdHVkZSA9IE1hdGgubWF4KDAuNzUsIGFsdGl0dWRlKTtcblxuICAgIGNvbnN0IGRpc3RhbmNlU2NhbGVzID0gY2FsY3VsYXRlRGlzdGFuY2VTY2FsZXMoe2xhdGl0dWRlLCBsb25naXR1ZGUsIHNjYWxlfSk7XG5cbiAgICBjb25zdCBwcm9qZWN0aW9uTWF0cml4ID0gbWFrZVByb2plY3Rpb25NYXRyaXhGcm9tTWVyY2F0b3JQYXJhbXMoe1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBwaXRjaCxcbiAgICAgIGJlYXJpbmcsXG4gICAgICBhbHRpdHVkZVxuICAgIH0pO1xuXG4gICAgY29uc3Qge3ZpZXdNYXRyaXgsIHZpZXdNYXRyaXhVbmNlbnRlcmVkLCB2aWV3Q2VudGVyfSA9XG4gICAgICBtYWtlVmlld01hdHJpeEZyb21NZXJjYXRvclBhcmFtcyh7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGxvbmdpdHVkZSxcbiAgICAgICAgbGF0aXR1ZGUsXG4gICAgICAgIHpvb20sXG4gICAgICAgIHBpdGNoLFxuICAgICAgICBiZWFyaW5nLFxuICAgICAgICBhbHRpdHVkZSxcbiAgICAgICAgZGlzdGFuY2VTY2FsZXNcbiAgICAgIH0pO1xuXG4gICAgc3VwZXIoe3dpZHRoLCBoZWlnaHQsIHZpZXdNYXRyaXgsIHByb2plY3Rpb25NYXRyaXh9KTtcblxuICAgIC8vIEFkZCBhZGRpdGlvbmFsIG1hdHJpY2VzXG4gICAgdGhpcy52aWV3TWF0cml4VW5jZW50ZXJlZCA9IHZpZXdNYXRyaXhVbmNlbnRlcmVkO1xuICAgIHRoaXMudmlld0NlbnRlciA9IHZpZXdDZW50ZXI7XG5cbiAgICAvLyBTYXZlIHBhcmFtZXRlcnNcbiAgICB0aGlzLmxhdGl0dWRlID0gbGF0aXR1ZGU7XG4gICAgdGhpcy5sb25naXR1ZGUgPSBsb25naXR1ZGU7XG4gICAgdGhpcy56b29tID0gem9vbTtcbiAgICB0aGlzLnBpdGNoID0gcGl0Y2g7XG4gICAgdGhpcy5iZWFyaW5nID0gYmVhcmluZztcbiAgICB0aGlzLmFsdGl0dWRlID0gYWx0aXR1ZGU7XG5cbiAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG5cbiAgICB0aGlzLl9kaXN0YW5jZVNjYWxlcyA9IGRpc3RhbmNlU2NhbGVzO1xuXG4gICAgdGhpcy5nZXREaXN0YW5jZVNjYWxlcyA9IHRoaXMuZ2V0RGlzdGFuY2VTY2FsZXMuYmluZCh0aGlzKTtcbiAgICB0aGlzLm1ldGVyc1RvTG5nTGF0RGVsdGEgPSB0aGlzLm1ldGVyc1RvTG5nTGF0RGVsdGEuYmluZCh0aGlzKTtcbiAgICB0aGlzLmxuZ0xhdERlbHRhVG9NZXRlcnMgPSB0aGlzLmxuZ0xhdERlbHRhVG9NZXRlcnMuYmluZCh0aGlzKTtcbiAgICB0aGlzLmFkZE1ldGVyc1RvTG5nTGF0ID0gdGhpcy5hZGRNZXRlcnNUb0xuZ0xhdC5iaW5kKHRoaXMpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgY29tcGxleGl0eSwgbWF4LXN0YXRlbWVudHMgKi9cblxuICAvKipcbiAgICogUHJvamVjdCBbbG5nLGxhdF0gb24gc3BoZXJlIG9udG8gW3gseV0gb24gNTEyKjUxMiBNZXJjYXRvciBab29tIDAgdGlsZS5cbiAgICogUGVyZm9ybXMgdGhlIG5vbmxpbmVhciBwYXJ0IG9mIHRoZSB3ZWIgbWVyY2F0b3IgcHJvamVjdGlvbi5cbiAgICogUmVtYWluaW5nIHByb2plY3Rpb24gaXMgZG9uZSB3aXRoIDR4NCBtYXRyaWNlcyB3aGljaCBhbHNvIGhhbmRsZXNcbiAgICogcGVyc3BlY3RpdmUuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGxuZ0xhdCAtIFtsbmcsIGxhdF0gY29vcmRpbmF0ZXNcbiAgICogICBTcGVjaWZpZXMgYSBwb2ludCBvbiB0aGUgc3BoZXJlIHRvIHByb2plY3Qgb250byB0aGUgbWFwLlxuICAgKiBAcmV0dXJuIHtBcnJheX0gW3gseV0gY29vcmRpbmF0ZXMuXG4gICAqL1xuICBfcHJvamVjdEZsYXQobG5nTGF0LCBzY2FsZSA9IHRoaXMuc2NhbGUpIHtcbiAgICByZXR1cm4gcHJvamVjdEZsYXQobG5nTGF0LCBzY2FsZSk7XG4gIH1cblxuICAvKipcbiAgICogVW5wcm9qZWN0IHdvcmxkIHBvaW50IFt4LHldIG9uIG1hcCBvbnRvIHtsYXQsIGxvbn0gb24gc3BoZXJlXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fFZlY3Rvcn0geHkgLSBvYmplY3Qgd2l0aCB7eCx5fSBtZW1iZXJzXG4gICAqICByZXByZXNlbnRpbmcgcG9pbnQgb24gcHJvamVjdGVkIG1hcCBwbGFuZVxuICAgKiBAcmV0dXJuIHtHZW9Db29yZGluYXRlc30gLSBvYmplY3Qgd2l0aCB7bGF0LGxvbn0gb2YgcG9pbnQgb24gc3BoZXJlLlxuICAgKiAgIEhhcyB0b0FycmF5IG1ldGhvZCBpZiB5b3UgbmVlZCBhIEdlb0pTT04gQXJyYXkuXG4gICAqICAgUGVyIGNhcnRvZ3JhcGhpYyB0cmFkaXRpb24sIGxhdCBhbmQgbG9uIGFyZSBzcGVjaWZpZWQgYXMgZGVncmVlcy5cbiAgICovXG4gIF91bnByb2plY3RGbGF0KHh5LCBzY2FsZSA9IHRoaXMuc2NhbGUpIHtcbiAgICByZXR1cm4gdW5wcm9qZWN0RmxhdCh4eSwgc2NhbGUpO1xuICB9XG5cbiAgZ2V0RGlzdGFuY2VTY2FsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlU2NhbGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgbWV0ZXIgb2Zmc2V0IHRvIGEgbG5nbGF0IG9mZnNldFxuICAgKlxuICAgKiBOb3RlOiBVc2VzIHNpbXBsZSBsaW5lYXIgYXBwcm94aW1hdGlvbiBhcm91bmQgdGhlIHZpZXdwb3J0IGNlbnRlclxuICAgKiBFcnJvciBpbmNyZWFzZXMgd2l0aCBzaXplIG9mIG9mZnNldCAocm91Z2hseSAxJSBwZXIgMTAwa20pXG4gICAqXG4gICAqIEBwYXJhbSB7W051bWJlcixOdW1iZXJdfFtOdW1iZXIsTnVtYmVyLE51bWJlcl0pIHh5eiAtIGFycmF5IG9mIG1ldGVyIGRlbHRhc1xuICAgKiBAcmV0dXJuIHtbTnVtYmVyLE51bWJlcl18W051bWJlcixOdW1iZXIsTnVtYmVyXSkgLSBhcnJheSBvZiBbbG5nLGxhdCx6XSBkZWx0YXNcbiAgICovXG4gIG1ldGVyc1RvTG5nTGF0RGVsdGEoeHl6KSB7XG4gICAgY29uc3QgW3gsIHksIHogPSAwXSA9IHh5ejtcbiAgICBjb25zdCB7cGl4ZWxzUGVyTWV0ZXIsIGRlZ3JlZXNQZXJQaXhlbH0gPSB0aGlzLl9kaXN0YW5jZVNjYWxlcztcbiAgICBjb25zdCBkZWx0YUxuZyA9IHggKiBwaXhlbHNQZXJNZXRlclswXSAqIGRlZ3JlZXNQZXJQaXhlbFswXTtcbiAgICBjb25zdCBkZWx0YUxhdCA9IHkgKiBwaXhlbHNQZXJNZXRlclsxXSAqIGRlZ3JlZXNQZXJQaXhlbFsxXTtcbiAgICByZXR1cm4geHl6Lmxlbmd0aCA9PT0gMiA/IFtkZWx0YUxuZywgZGVsdGFMYXRdIDogW2RlbHRhTG5nLCBkZWx0YUxhdCwgel07XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSBsbmdsYXQgb2Zmc2V0IHRvIGEgbWV0ZXIgb2Zmc2V0XG4gICAqXG4gICAqIE5vdGU6IFVzZXMgc2ltcGxlIGxpbmVhciBhcHByb3hpbWF0aW9uIGFyb3VuZCB0aGUgdmlld3BvcnQgY2VudGVyXG4gICAqIEVycm9yIGluY3JlYXNlcyB3aXRoIHNpemUgb2Ygb2Zmc2V0IChyb3VnaGx5IDElIHBlciAxMDBrbSlcbiAgICpcbiAgICogQHBhcmFtIHtbTnVtYmVyLE51bWJlcl18W051bWJlcixOdW1iZXIsTnVtYmVyXSkgZGVsdGFMbmdMYXRaIC0gYXJyYXkgb2YgW2xuZyxsYXQsel0gZGVsdGFzXG4gICAqIEByZXR1cm4ge1tOdW1iZXIsTnVtYmVyXXxbTnVtYmVyLE51bWJlcixOdW1iZXJdKSAtIGFycmF5IG9mIG1ldGVyIGRlbHRhc1xuICAgKi9cbiAgbG5nTGF0RGVsdGFUb01ldGVycyhkZWx0YUxuZ0xhdFopIHtcbiAgICBjb25zdCBbZGVsdGFMbmcsIGRlbHRhTGF0LCBkZWx0YVogPSAwXSA9IGRlbHRhTG5nTGF0WjtcbiAgICBjb25zdCB7cGl4ZWxzUGVyRGVncmVlLCBtZXRlcnNQZXJQaXhlbH0gPSB0aGlzLl9kaXN0YW5jZVNjYWxlcztcbiAgICBjb25zdCBkZWx0YVggPSBkZWx0YUxuZyAqIHBpeGVsc1BlckRlZ3JlZVswXSAqIG1ldGVyc1BlclBpeGVsWzBdO1xuICAgIGNvbnN0IGRlbHRhWSA9IGRlbHRhTGF0ICogcGl4ZWxzUGVyRGVncmVlWzFdICogbWV0ZXJzUGVyUGl4ZWxbMV07XG4gICAgcmV0dXJuIGRlbHRhTG5nTGF0Wi5sZW5ndGggPT09IDIgPyBbZGVsdGFYLCBkZWx0YVldIDogW2RlbHRhWCwgZGVsdGFZLCBkZWx0YVpdO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG1ldGVyIGRlbHRhIHRvIGEgYmFzZSBsbmdsYXQgY29vcmRpbmF0ZSwgcmV0dXJuaW5nIGEgbmV3IGxuZ2xhdCBhcnJheVxuICAgKlxuICAgKiBOb3RlOiBVc2VzIHNpbXBsZSBsaW5lYXIgYXBwcm94aW1hdGlvbiBhcm91bmQgdGhlIHZpZXdwb3J0IGNlbnRlclxuICAgKiBFcnJvciBpbmNyZWFzZXMgd2l0aCBzaXplIG9mIG9mZnNldCAocm91Z2hseSAxJSBwZXIgMTAwa20pXG4gICAqXG4gICAqIEBwYXJhbSB7W051bWJlcixOdW1iZXJdfFtOdW1iZXIsTnVtYmVyLE51bWJlcl0pIGxuZ0xhdFogLSBiYXNlIGNvb3JkaW5hdGVcbiAgICogQHBhcmFtIHtbTnVtYmVyLE51bWJlcl18W051bWJlcixOdW1iZXIsTnVtYmVyXSkgeHl6IC0gYXJyYXkgb2YgbWV0ZXIgZGVsdGFzXG4gICAqIEByZXR1cm4ge1tOdW1iZXIsTnVtYmVyXXxbTnVtYmVyLE51bWJlcixOdW1iZXJdKSBhcnJheSBvZiBbbG5nLGxhdCx6XSBkZWx0YXNcbiAgICovXG4gIGFkZE1ldGVyc1RvTG5nTGF0KGxuZ0xhdFosIHh5eikge1xuICAgIGNvbnN0IFtsbmcsIGxhdCwgWiA9IDBdID0gbG5nTGF0WjtcbiAgICBjb25zdCBbZGVsdGFMbmcsIGRlbHRhTGF0LCBkZWx0YVogPSAwXSA9IHRoaXMubWV0ZXJzVG9MbmdMYXREZWx0YSh4eXopO1xuICAgIHJldHVybiBsbmdMYXRaLmxlbmd0aCA9PT0gMiA/XG4gICAgICBbbG5nICsgZGVsdGFMbmcsIGxhdCArIGRlbHRhTGF0XSA6XG4gICAgICBbbG5nICsgZGVsdGFMbmcsIGxhdCArIGRlbHRhTGF0LCBaICsgZGVsdGFaXTtcbiAgfVxuXG4gIC8vIElOVEVSTkFMIE1FVEhPRFNcblxuICBfZ2V0UGFyYW1zKCkge1xuICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVNjYWxlcztcbiAgfVxufVxuXG4vKipcbiAqIFByb2plY3QgW2xuZyxsYXRdIG9uIHNwaGVyZSBvbnRvIFt4LHldIG9uIDUxMio1MTIgTWVyY2F0b3IgWm9vbSAwIHRpbGUuXG4gKiBQZXJmb3JtcyB0aGUgbm9ubGluZWFyIHBhcnQgb2YgdGhlIHdlYiBtZXJjYXRvciBwcm9qZWN0aW9uLlxuICogUmVtYWluaW5nIHByb2plY3Rpb24gaXMgZG9uZSB3aXRoIDR4NCBtYXRyaWNlcyB3aGljaCBhbHNvIGhhbmRsZXNcbiAqIHBlcnNwZWN0aXZlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGxuZ0xhdCAtIFtsbmcsIGxhdF0gY29vcmRpbmF0ZXNcbiAqICAgU3BlY2lmaWVzIGEgcG9pbnQgb24gdGhlIHNwaGVyZSB0byBwcm9qZWN0IG9udG8gdGhlIG1hcC5cbiAqIEByZXR1cm4ge0FycmF5fSBbeCx5XSBjb29yZGluYXRlcy5cbiAqL1xuZnVuY3Rpb24gcHJvamVjdEZsYXQoW2xuZywgbGF0XSwgc2NhbGUpIHtcbiAgc2NhbGUgPSBzY2FsZSAqIFdPUkxEX1NDQUxFO1xuICBjb25zdCBsYW1iZGEyID0gbG5nICogREVHUkVFU19UT19SQURJQU5TO1xuICBjb25zdCBwaGkyID0gbGF0ICogREVHUkVFU19UT19SQURJQU5TO1xuICBjb25zdCB4ID0gc2NhbGUgKiAobGFtYmRhMiArIFBJKTtcbiAgY29uc3QgeSA9IHNjYWxlICogKFBJIC0gTWF0aC5sb2coTWF0aC50YW4oUElfNCArIHBoaTIgKiAwLjUpKSk7XG4gIHJldHVybiBbeCwgeV07XG59XG5cbi8qKlxuICogVW5wcm9qZWN0IHdvcmxkIHBvaW50IFt4LHldIG9uIG1hcCBvbnRvIHtsYXQsIGxvbn0gb24gc3BoZXJlXG4gKlxuICogQHBhcmFtIHtvYmplY3R8VmVjdG9yfSB4eSAtIG9iamVjdCB3aXRoIHt4LHl9IG1lbWJlcnNcbiAqICByZXByZXNlbnRpbmcgcG9pbnQgb24gcHJvamVjdGVkIG1hcCBwbGFuZVxuICogQHJldHVybiB7R2VvQ29vcmRpbmF0ZXN9IC0gb2JqZWN0IHdpdGgge2xhdCxsb259IG9mIHBvaW50IG9uIHNwaGVyZS5cbiAqICAgSGFzIHRvQXJyYXkgbWV0aG9kIGlmIHlvdSBuZWVkIGEgR2VvSlNPTiBBcnJheS5cbiAqICAgUGVyIGNhcnRvZ3JhcGhpYyB0cmFkaXRpb24sIGxhdCBhbmQgbG9uIGFyZSBzcGVjaWZpZWQgYXMgZGVncmVlcy5cbiAqL1xuZnVuY3Rpb24gdW5wcm9qZWN0RmxhdChbeCwgeV0sIHNjYWxlKSB7XG4gIHNjYWxlID0gc2NhbGUgKiBXT1JMRF9TQ0FMRTtcbiAgY29uc3QgbGFtYmRhMiA9IHggLyBzY2FsZSAtIFBJO1xuICBjb25zdCBwaGkyID0gMiAqIChNYXRoLmF0YW4oTWF0aC5leHAoUEkgLSB5IC8gc2NhbGUpKSAtIFBJXzQpO1xuICByZXR1cm4gW2xhbWJkYTIgKiBSQURJQU5TX1RPX0RFR1JFRVMsIHBoaTIgKiBSQURJQU5TX1RPX0RFR1JFRVNdO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBkaXN0YW5jZSBzY2FsZXMgaW4gbWV0ZXJzIGFyb3VuZCBjdXJyZW50IGxhdC9sb24sIGJvdGggZm9yXG4gKiBkZWdyZWVzIGFuZCBwaXhlbHMuXG4gKiBJbiBtZXJjYXRvciBwcm9qZWN0aW9uIG1vZGUsIHRoZSBkaXN0YW5jZSBzY2FsZXMgdmFyeSBzaWduaWZpY2FudGx5XG4gKiB3aXRoIGxhdGl0dWRlLlxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVEaXN0YW5jZVNjYWxlcyh7bGF0aXR1ZGUsIGxvbmdpdHVkZSwgc2NhbGV9KSB7XG4gIC8vIEFwcHJveGltYXRlbHkgMTExa20gcGVyIGRlZ3JlZSBhdCBlcXVhdG9yXG4gIGNvbnN0IE1FVEVSU19QRVJfREVHUkVFID0gMTExMDAwO1xuXG4gIGNvbnN0IGxhdENvc2luZSA9IE1hdGguY29zKGxhdGl0dWRlICogTWF0aC5QSSAvIDE4MCk7XG5cbiAgY29uc3QgbWV0ZXJzUGVyRGVncmVlID0gTUVURVJTX1BFUl9ERUdSRUUgKiBsYXRDb3NpbmU7XG5cbiAgLy8gQ2FsY3VsYXRlIG51bWJlciBvZiBwaXhlbHMgb2NjdXBpZWQgYnkgb25lIGRlZ3JlZSBsb25naXR1ZGVcbiAgLy8gYXJvdW5kIGN1cnJlbnQgbGF0L2xvblxuICBjb25zdCBwaXhlbHNQZXJEZWdyZWVYID0gdmVjMi5kaXN0YW5jZShcbiAgICBwcm9qZWN0RmxhdChbbG9uZ2l0dWRlICsgMC41LCBsYXRpdHVkZV0pLFxuICAgIHByb2plY3RGbGF0KFtsb25naXR1ZGUgLSAwLjUsIGxhdGl0dWRlXSlcbiAgKTtcbiAgLy8gQ2FsY3VsYXRlIG51bWJlciBvZiBwaXhlbHMgb2NjdXBpZWQgYnkgb25lIGRlZ3JlZSBsYXRpdHVkZVxuICAvLyBhcm91bmQgY3VycmVudCBsYXQvbG9uXG4gIGNvbnN0IHBpeGVsc1BlckRlZ3JlZVkgPSB2ZWMyLmRpc3RhbmNlKFxuICAgIHByb2plY3RGbGF0KFtsb25naXR1ZGUsIGxhdGl0dWRlICsgMC41XSksXG4gICAgcHJvamVjdEZsYXQoW2xvbmdpdHVkZSwgbGF0aXR1ZGUgLSAwLjVdKVxuICApO1xuXG4gIGNvbnN0IHBpeGVsc1Blck1ldGVyWCA9IHBpeGVsc1BlckRlZ3JlZVggLyBtZXRlcnNQZXJEZWdyZWU7XG4gIGNvbnN0IHBpeGVsc1Blck1ldGVyWSA9IHBpeGVsc1BlckRlZ3JlZVkgLyBtZXRlcnNQZXJEZWdyZWU7XG4gIGNvbnN0IHBpeGVsc1Blck1ldGVyWiA9IChwaXhlbHNQZXJNZXRlclggKyBwaXhlbHNQZXJNZXRlclkpIC8gMjtcbiAgLy8gY29uc3QgcGl4ZWxzUGVyTWV0ZXIgPSBbcGl4ZWxzUGVyTWV0ZXJYLCBwaXhlbHNQZXJNZXRlclksIHBpeGVsc1Blck1ldGVyWl07XG5cbiAgY29uc3Qgd29ybGRTaXplID0gVElMRV9TSVpFICogc2NhbGU7XG4gIGNvbnN0IGFsdFBpeGVsc1Blck1ldGVyID0gd29ybGRTaXplIC8gKDRlNyAqIGxhdENvc2luZSk7XG4gIGNvbnN0IHBpeGVsc1Blck1ldGVyID0gW2FsdFBpeGVsc1Blck1ldGVyLCBhbHRQaXhlbHNQZXJNZXRlciwgYWx0UGl4ZWxzUGVyTWV0ZXJdO1xuICBjb25zdCBtZXRlcnNQZXJQaXhlbCA9IFsxIC8gYWx0UGl4ZWxzUGVyTWV0ZXIsIDEgLyBhbHRQaXhlbHNQZXJNZXRlciwgMSAvIHBpeGVsc1Blck1ldGVyWl07XG5cbiAgY29uc3QgcGl4ZWxzUGVyRGVncmVlID0gW3BpeGVsc1BlckRlZ3JlZVgsIHBpeGVsc1BlckRlZ3JlZVksIHBpeGVsc1Blck1ldGVyWl07XG4gIGNvbnN0IGRlZ3JlZXNQZXJQaXhlbCA9IFsxIC8gcGl4ZWxzUGVyRGVncmVlWCwgMSAvIHBpeGVsc1BlckRlZ3JlZVksIDEgLyBwaXhlbHNQZXJNZXRlclpdO1xuXG4gIC8vIE1haW4gcmVzdWx0cywgdXNlZCBmb3IgY29udmVydGluZyBtZXRlcnMgdG8gbGF0bG5nIGRlbHRhcyBhbmQgc2NhbGluZyBvZmZzZXRzXG4gIHJldHVybiB7XG4gICAgcGl4ZWxzUGVyTWV0ZXIsXG4gICAgbWV0ZXJzUGVyUGl4ZWwsXG4gICAgcGl4ZWxzUGVyRGVncmVlLFxuICAgIGRlZ3JlZXNQZXJQaXhlbFxuICB9O1xufVxuXG4vLyBBVFRSSUJVVElPTjpcbi8vIHZpZXcgYW5kIHByb2plY3Rpb24gbWF0cml4IGNyZWF0aW9uIGlzIGludGVudGlvbmFsbHkga2VwdCBjb21wYXRpYmxlIHdpdGhcbi8vIG1hcGJveC1nbCdzIGltcGxlbWVudGF0aW9uIHRvIGVuc3VyZSB0aGF0IHNlYW1sZXNzIGludGVyb3BlcmF0aW9uXG4vLyB3aXRoIG1hcGJveCBhbmQgcmVhY3QtbWFwLWdsLiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbWFwYm94LWdsLWpzXG5mdW5jdGlvbiBtYWtlUHJvamVjdGlvbk1hdHJpeEZyb21NZXJjYXRvclBhcmFtcyh7XG4gIHdpZHRoLFxuICBoZWlnaHQsXG4gIHBpdGNoLFxuICBhbHRpdHVkZVxufSkge1xuICBjb25zdCBwaXRjaFJhZGlhbnMgPSBwaXRjaCAqIERFR1JFRVNfVE9fUkFESUFOUztcblxuICAvLyBQUk9KRUNUSU9OIE1BVFJJWDogUFJPSkVDVFMgRlJPTSBDQU1FUkEgU1BBQ0UgVE8gQ0xJUFNQQUNFXG4gIC8vIEZpbmQgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciBwb2ludCB0byB0aGUgY2VudGVyIHRvcFxuICAvLyBpbiBhbHRpdHVkZSB1bml0cyB1c2luZyBsYXcgb2Ygc2luZXMuXG4gIGNvbnN0IGhhbGZGb3YgPSBNYXRoLmF0YW4oMC41IC8gYWx0aXR1ZGUpO1xuICBjb25zdCB0b3BIYWxmU3VyZmFjZURpc3RhbmNlID1cbiAgICBNYXRoLnNpbihoYWxmRm92KSAqIGFsdGl0dWRlIC8gTWF0aC5zaW4oTWF0aC5QSSAvIDIgLSBwaXRjaFJhZGlhbnMgLSBoYWxmRm92KTtcblxuICAvLyBDYWxjdWxhdGUgeiB2YWx1ZSBvZiB0aGUgZmFydGhlc3QgZnJhZ21lbnQgdGhhdCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gIGNvbnN0IGZhclogPSBNYXRoLmNvcyhNYXRoLlBJIC8gMiAtIHBpdGNoUmFkaWFucykgKiB0b3BIYWxmU3VyZmFjZURpc3RhbmNlICsgYWx0aXR1ZGU7XG5cbiAgY29uc3QgcHJvamVjdGlvbk1hdHJpeCA9IG1hdDQucGVyc3BlY3RpdmUoXG4gICAgY3JlYXRlTWF0NCgpLFxuICAgIDIgKiBNYXRoLmF0YW4oKGhlaWdodCAvIDIpIC8gYWx0aXR1ZGUpLCAvLyBmb3YgaW4gcmFkaWFuc1xuICAgIHdpZHRoIC8gaGVpZ2h0LCAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhc3BlY3QgcmF0aW9cbiAgICAwLjEsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmVhciBwbGFuZVxuICAgIGZhclogKiAxMC4wICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmYXIgcGxhbmVcbiAgKTtcblxuICByZXR1cm4gcHJvamVjdGlvbk1hdHJpeDtcbn1cblxuZnVuY3Rpb24gbWFrZVZpZXdNYXRyaXhGcm9tTWVyY2F0b3JQYXJhbXMoe1xuICB3aWR0aCxcbiAgaGVpZ2h0LFxuICBsb25naXR1ZGUsXG4gIGxhdGl0dWRlLFxuICB6b29tLFxuICBwaXRjaCxcbiAgYmVhcmluZyxcbiAgYWx0aXR1ZGVcbn0pIHtcbiAgLy8gQ2VudGVyIHgsIHlcbiAgY29uc3Qgc2NhbGUgPSBNYXRoLnBvdygyLCB6b29tKTtcbiAgLy8gVklFVyBNQVRSSVg6IFBST0pFQ1RTIEZST00gVklSVFVBTCBQSVhFTFMgVE8gQ0FNRVJBIFNQQUNFXG4gIC8vIE5vdGU6IEFzIHVzdWFsLCBtYXRyaXggb3BlcmF0aW9uIG9yZGVycyBzaG91bGQgYmUgcmVhZCBpbiByZXZlcnNlXG4gIC8vIHNpbmNlIHZlY3RvcnMgd2lsbCBiZSBtdWx0aXBsaWVkIGZyb20gdGhlIHJpZ2h0IGR1cmluZyB0cmFuc2Zvcm1hdGlvblxuICBjb25zdCB2bSA9IGNyZWF0ZU1hdDQoKTtcblxuICAvLyBNb3ZlIGNhbWVyYSB0byBhbHRpdHVkZVxuICBtYXQ0LnRyYW5zbGF0ZSh2bSwgdm0sIFswLCAwLCAtYWx0aXR1ZGVdKTtcblxuICAvLyBBZnRlciB0aGUgcm90YXRlWCwgeiB2YWx1ZXMgYXJlIGluIHBpeGVsIHVuaXRzLiBDb252ZXJ0IHRoZW0gdG9cbiAgLy8gYWx0aXR1ZGUgdW5pdHMuIDEgYWx0aXR1ZGUgdW5pdCA9IHRoZSBzY3JlZW4gaGVpZ2h0LlxuICBtYXQ0LnNjYWxlKHZtLCB2bSwgWzEsIC0xLCAxIC8gaGVpZ2h0XSk7XG5cbiAgLy8gUm90YXRlIGJ5IGJlYXJpbmcsIGFuZCB0aGVuIGJ5IHBpdGNoICh3aGljaCB0aWx0cyB0aGUgdmlldylcbiAgbWF0NC5yb3RhdGVYKHZtLCB2bSwgcGl0Y2ggKiBERUdSRUVTX1RPX1JBRElBTlMpO1xuICBtYXQ0LnJvdGF0ZVoodm0sIHZtLCAtYmVhcmluZyAqIERFR1JFRVNfVE9fUkFESUFOUyk7XG5cbiAgY29uc3QgW2NlbnRlclgsIGNlbnRlclldID0gcHJvamVjdEZsYXQoW2xvbmdpdHVkZSwgbGF0aXR1ZGVdLCBzY2FsZSk7XG5cbiAgY29uc3QgY2VudGVyID0gWy1jZW50ZXJYLCAtY2VudGVyWSwgMCwgMV07XG4gIGNvbnN0IHZpZXdDZW50ZXIgPSB2ZWM0LnRyYW5zZm9ybU1hdDQoW10sIGNlbnRlciwgdm0pO1xuXG4gIGNvbnN0IHZtQ2VudGVyZWQgPSBtYXQ0LnRyYW5zbGF0ZShbXSwgdm0sIFstY2VudGVyWCwgLWNlbnRlclksIDBdKTtcblxuICByZXR1cm4ge1xuICAgIHZpZXdNYXRyaXg6IHZtQ2VudGVyZWQsXG4gICAgdmlld01hdHJpeFVuY2VudGVyZWQ6IHZtLFxuICAgIHZpZXdDZW50ZXJcbiAgfTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xpYi92aWV3cG9ydHMvd2ViLW1lcmNhdG9yLXZpZXdwb3J0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 26 */
/* exports provided: default */
/* exports used: default */
/*!********************************************************************!*\
  !*** ./src/layers/core/solid-polygon-layer/solid-polygon-layer.js ***!
  \********************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_utils__ = __webpack_require__(/*! ../../../lib/utils */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_luma_gl__ = __webpack_require__(/*! luma.gl */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__lib_utils_fp64__ = __webpack_require__(/*! ../../../lib/utils/fp64 */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__polygon_tesselator__ = __webpack_require__(/*! ./polygon-tesselator */ 84);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__polygon_tesselator_extruded__ = __webpack_require__(/*! ./polygon-tesselator-extruded */ 83);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__solid_polygon_layer_vertex_glsl__ = __webpack_require__(/*! ./solid-polygon-layer-vertex.glsl */ 87);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__solid_polygon_layer_vertex_64_glsl__ = __webpack_require__(/*! ./solid-polygon-layer-vertex-64.glsl */ 86);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__solid_polygon_layer_fragment_glsl__ = __webpack_require__(/*! ./solid-polygon-layer-fragment.glsl */ 85);\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\n\n// Polygon geometry generation is managed by the polygon tesselator\n\n\n\n\n\n\n\nconst defaultProps = {\n  // Whether to extrude in 2.5D\n  extruded: false,\n  // Whether to draw a GL.LINES wireframe of the polygon\n  wireframe: false,\n  fp64: false,\n\n  // Accessor for polygon geometry\n  getPolygon: f => __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"d\" /* get */])(f, 'polygon') || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"d\" /* get */])(f, 'geometry.coordinates'),\n  // Accessor for extrusion height\n  getElevation: f => __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"d\" /* get */])(f, 'elevation') || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"d\" /* get */])(f, 'properties.height') || 0,\n  // Accessor for color\n  getColor: f => __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"d\" /* get */])(f, 'color') || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"d\" /* get */])(f, 'properties.color'),\n\n  // Optional settings for 'lighting' shader module\n  lightSettings: {\n    lightsPosition: [-122.45, 37.75, 8000, -122.0, 38.00, 5000],\n    ambientRatio: 0.05,\n    diffuseRatio: 0.6,\n    specularRatio: 0.8,\n    lightsStrength: [2.0, 0.0, 0.0, 0.0],\n    numberOfLights: 2\n  }\n};\n\nclass SolidPolygonLayer extends __WEBPACK_IMPORTED_MODULE_0__lib__[\"a\" /* Layer */] {\n  getShaders() {\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__lib_utils_fp64__[\"b\" /* enable64bitSupport */])(this.props) ? {\n      vs: __WEBPACK_IMPORTED_MODULE_8__solid_polygon_layer_vertex_64_glsl__[\"a\" /* default */], fs: __WEBPACK_IMPORTED_MODULE_9__solid_polygon_layer_fragment_glsl__[\"a\" /* default */], modules: ['fp64', 'project64', 'lighting']\n    } : {\n      vs: __WEBPACK_IMPORTED_MODULE_7__solid_polygon_layer_vertex_glsl__[\"a\" /* default */], fs: __WEBPACK_IMPORTED_MODULE_9__solid_polygon_layer_fragment_glsl__[\"a\" /* default */], modules: ['lighting']\n    };\n  }\n\n  initializeState() {\n    const {gl} = this.context;\n    this.setState({\n      model: this._getModel(gl),\n      numInstances: 0,\n      IndexType: gl.getExtension('OES_element_index_uint') ? Uint32Array : Uint16Array\n    });\n\n    const {attributeManager} = this.state;\n    const noAlloc = true;\n    /* eslint-disable max-len */\n    attributeManager.add({\n      indices: {size: 1, isIndexed: true, update: this.calculateIndices, noAlloc},\n      positions: {size: 3, accessor: 'getElevation', update: this.calculatePositions, noAlloc},\n      normals: {size: 3, update: this.calculateNormals, noAlloc},\n      colors: {size: 4, type: __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].UNSIGNED_BYTE, accessor: 'getColor', update: this.calculateColors, noAlloc},\n      pickingColors: {size: 3, type: __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].UNSIGNED_BYTE, update: this.calculatePickingColors, noAlloc}\n    });\n    /* eslint-enable max-len */\n  }\n\n  updateAttribute({props, oldProps, changeFlags}) {\n    if (props.fp64 !== oldProps.fp64) {\n      const {attributeManager} = this.state;\n      attributeManager.invalidateAll();\n\n      if (props.fp64 && props.projectionMode === __WEBPACK_IMPORTED_MODULE_0__lib__[\"e\" /* COORDINATE_SYSTEM */].LNG_LAT) {\n        attributeManager.add({\n          positions64xyLow: {size: 2, update: this.calculatePositionsLow}\n        });\n      } else {\n        attributeManager.remove([\n          'positions64xyLow'\n        ]);\n      }\n    }\n  }\n\n  draw({uniforms}) {\n    const {extruded, lightSettings} = this.props;\n\n    this.state.model.render(Object.assign({}, uniforms, {\n      extruded: extruded ? 1.0 : 0.0\n    },\n    lightSettings));\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    super.updateState({props, oldProps, changeFlags});\n\n    const geometryChanged = this.updateGeometry({props, oldProps, changeFlags});\n\n    // Re-generate model if geometry changed\n    if (geometryChanged) {\n      const {gl} = this.context;\n      this.setState({model: this._getModel(gl)});\n    }\n    this.updateAttribute({props, oldProps, changeFlags});\n  }\n\n  updateGeometry({props, oldProps, changeFlags}) {\n    const regenerateModel = changeFlags.dataChanged ||\n      props.extruded !== oldProps.extruded ||\n      props.wireframe !== oldProps.wireframe || props.fp64 !== oldProps.fp64;\n\n    if (regenerateModel) {\n      const {getPolygon, extruded, wireframe, getElevation} = props;\n\n      // TODO - avoid creating a temporary array here: let the tesselator iterate\n      const polygons = props.data.map(getPolygon);\n\n      this.setState({\n        polygonTesselator: !extruded ?\n          new __WEBPACK_IMPORTED_MODULE_5__polygon_tesselator__[\"a\" /* PolygonTesselator */]({polygons, fp64: this.props.fp64}) :\n          new __WEBPACK_IMPORTED_MODULE_6__polygon_tesselator_extruded__[\"a\" /* PolygonTesselatorExtruded */]({polygons, wireframe,\n            getHeight: polygonIndex => getElevation(this.props.data[polygonIndex]),\n            fp64: this.props.fp64\n          })\n      });\n\n      this.state.attributeManager.invalidateAll();\n    }\n\n    return regenerateModel;\n  }\n\n  _getModel(gl) {\n    const shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"a\" /* assembleShaders */])(gl, this.getShaders());\n    return new __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"Model\"]({\n      gl,\n      id: this.props.id,\n      vs: shaders.vs,\n      fs: shaders.fs,\n      geometry: new __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"Geometry\"]({\n        drawMode: this.props.wireframe ? __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].LINES : __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].TRIANGLES\n      }),\n      vertexCount: 0,\n      isIndexed: true\n    });\n  }\n\n  calculateIndices(attribute) {\n    attribute.value = this.state.polygonTesselator.indices();\n    attribute.target = __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].ELEMENT_ARRAY_BUFFER;\n    this.state.model.setVertexCount(attribute.value.length / attribute.size);\n  }\n\n  calculatePositions(attribute) {\n    attribute.value = this.state.polygonTesselator.positions().positions;\n  }\n  calculatePositionsLow(attribute) {\n    attribute.value = this.state.polygonTesselator.positions().positions64xyLow;\n  }\n  calculateNormals(attribute) {\n    attribute.value = this.state.polygonTesselator.normals();\n  }\n\n  calculateColors(attribute) {\n    attribute.value = this.state.polygonTesselator.colors({\n      getColor: polygonIndex => this.props.getColor(this.props.data[polygonIndex])\n    });\n  }\n\n  // Override the default picking colors calculation\n  calculatePickingColors(attribute) {\n    attribute.value = this.state.polygonTesselator.pickingColors();\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = SolidPolygonLayer;\n\n\nSolidPolygonLayer.layerName = 'SolidPolygonLayer';\nSolidPolygonLayer.defaultProps = defaultProps;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvc29saWQtcG9seWdvbi1sYXllci9zb2xpZC1wb2x5Z29uLWxheWVyLmpzP2RhMDYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE2IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtMYXllcn0gZnJvbSAnLi4vLi4vLi4vbGliJztcbmltcG9ydCB7YXNzZW1ibGVTaGFkZXJzfSBmcm9tICcuLi8uLi8uLi9zaGFkZXItdXRpbHMnO1xuaW1wb3J0IHtnZXR9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscyc7XG5pbXBvcnQge0dMLCBNb2RlbCwgR2VvbWV0cnl9IGZyb20gJ2x1bWEuZ2wnO1xuaW1wb3J0IHtlbmFibGU2NGJpdFN1cHBvcnR9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscy9mcDY0JztcbmltcG9ydCB7Q09PUkRJTkFURV9TWVNURU19IGZyb20gJy4uLy4uLy4uL2xpYic7XG5cbi8vIFBvbHlnb24gZ2VvbWV0cnkgZ2VuZXJhdGlvbiBpcyBtYW5hZ2VkIGJ5IHRoZSBwb2x5Z29uIHRlc3NlbGF0b3JcbmltcG9ydCB7UG9seWdvblRlc3NlbGF0b3J9IGZyb20gJy4vcG9seWdvbi10ZXNzZWxhdG9yJztcbmltcG9ydCB7UG9seWdvblRlc3NlbGF0b3JFeHRydWRlZH0gZnJvbSAnLi9wb2x5Z29uLXRlc3NlbGF0b3ItZXh0cnVkZWQnO1xuXG5pbXBvcnQgc29saWRQb2x5Z29uVmVydGV4IGZyb20gJy4vc29saWQtcG9seWdvbi1sYXllci12ZXJ0ZXguZ2xzbCc7XG5pbXBvcnQgc29saWRQb2x5Z29uVmVydGV4NjQgZnJvbSAnLi9zb2xpZC1wb2x5Z29uLWxheWVyLXZlcnRleC02NC5nbHNsJztcbmltcG9ydCBzb2xpZFBvbHlnb25GcmFnbWVudCBmcm9tICcuL3NvbGlkLXBvbHlnb24tbGF5ZXItZnJhZ21lbnQuZ2xzbCc7XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgLy8gV2hldGhlciB0byBleHRydWRlIGluIDIuNURcbiAgZXh0cnVkZWQ6IGZhbHNlLFxuICAvLyBXaGV0aGVyIHRvIGRyYXcgYSBHTC5MSU5FUyB3aXJlZnJhbWUgb2YgdGhlIHBvbHlnb25cbiAgd2lyZWZyYW1lOiBmYWxzZSxcbiAgZnA2NDogZmFsc2UsXG5cbiAgLy8gQWNjZXNzb3IgZm9yIHBvbHlnb24gZ2VvbWV0cnlcbiAgZ2V0UG9seWdvbjogZiA9PiBnZXQoZiwgJ3BvbHlnb24nKSB8fCBnZXQoZiwgJ2dlb21ldHJ5LmNvb3JkaW5hdGVzJyksXG4gIC8vIEFjY2Vzc29yIGZvciBleHRydXNpb24gaGVpZ2h0XG4gIGdldEVsZXZhdGlvbjogZiA9PiBnZXQoZiwgJ2VsZXZhdGlvbicpIHx8IGdldChmLCAncHJvcGVydGllcy5oZWlnaHQnKSB8fCAwLFxuICAvLyBBY2Nlc3NvciBmb3IgY29sb3JcbiAgZ2V0Q29sb3I6IGYgPT4gZ2V0KGYsICdjb2xvcicpIHx8IGdldChmLCAncHJvcGVydGllcy5jb2xvcicpLFxuXG4gIC8vIE9wdGlvbmFsIHNldHRpbmdzIGZvciAnbGlnaHRpbmcnIHNoYWRlciBtb2R1bGVcbiAgbGlnaHRTZXR0aW5nczoge1xuICAgIGxpZ2h0c1Bvc2l0aW9uOiBbLTEyMi40NSwgMzcuNzUsIDgwMDAsIC0xMjIuMCwgMzguMDAsIDUwMDBdLFxuICAgIGFtYmllbnRSYXRpbzogMC4wNSxcbiAgICBkaWZmdXNlUmF0aW86IDAuNixcbiAgICBzcGVjdWxhclJhdGlvOiAwLjgsXG4gICAgbGlnaHRzU3RyZW5ndGg6IFsyLjAsIDAuMCwgMC4wLCAwLjBdLFxuICAgIG51bWJlck9mTGlnaHRzOiAyXG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNvbGlkUG9seWdvbkxheWVyIGV4dGVuZHMgTGF5ZXIge1xuICBnZXRTaGFkZXJzKCkge1xuICAgIHJldHVybiBlbmFibGU2NGJpdFN1cHBvcnQodGhpcy5wcm9wcykgPyB7XG4gICAgICB2czogc29saWRQb2x5Z29uVmVydGV4NjQsIGZzOiBzb2xpZFBvbHlnb25GcmFnbWVudCwgbW9kdWxlczogWydmcDY0JywgJ3Byb2plY3Q2NCcsICdsaWdodGluZyddXG4gICAgfSA6IHtcbiAgICAgIHZzOiBzb2xpZFBvbHlnb25WZXJ0ZXgsIGZzOiBzb2xpZFBvbHlnb25GcmFnbWVudCwgbW9kdWxlczogWydsaWdodGluZyddXG4gICAgfTtcbiAgfVxuXG4gIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgbW9kZWw6IHRoaXMuX2dldE1vZGVsKGdsKSxcbiAgICAgIG51bUluc3RhbmNlczogMCxcbiAgICAgIEluZGV4VHlwZTogZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfZWxlbWVudF9pbmRleF91aW50JykgPyBVaW50MzJBcnJheSA6IFVpbnQxNkFycmF5XG4gICAgfSk7XG5cbiAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IG5vQWxsb2MgPSB0cnVlO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZCh7XG4gICAgICBpbmRpY2VzOiB7c2l6ZTogMSwgaXNJbmRleGVkOiB0cnVlLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5kaWNlcywgbm9BbGxvY30sXG4gICAgICBwb3NpdGlvbnM6IHtzaXplOiAzLCBhY2Nlc3NvcjogJ2dldEVsZXZhdGlvbicsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVQb3NpdGlvbnMsIG5vQWxsb2N9LFxuICAgICAgbm9ybWFsczoge3NpemU6IDMsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVOb3JtYWxzLCBub0FsbG9jfSxcbiAgICAgIGNvbG9yczoge3NpemU6IDQsIHR5cGU6IEdMLlVOU0lHTkVEX0JZVEUsIGFjY2Vzc29yOiAnZ2V0Q29sb3InLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlQ29sb3JzLCBub0FsbG9jfSxcbiAgICAgIHBpY2tpbmdDb2xvcnM6IHtzaXplOiAzLCB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlUGlja2luZ0NvbG9ycywgbm9BbGxvY31cbiAgICB9KTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cbiAgfVxuXG4gIHVwZGF0ZUF0dHJpYnV0ZSh7cHJvcHMsIG9sZFByb3BzLCBjaGFuZ2VGbGFnc30pIHtcbiAgICBpZiAocHJvcHMuZnA2NCAhPT0gb2xkUHJvcHMuZnA2NCkge1xuICAgICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZUFsbCgpO1xuXG4gICAgICBpZiAocHJvcHMuZnA2NCAmJiBwcm9wcy5wcm9qZWN0aW9uTW9kZSA9PT0gQ09PUkRJTkFURV9TWVNURU0uTE5HX0xBVCkge1xuICAgICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZCh7XG4gICAgICAgICAgcG9zaXRpb25zNjR4eUxvdzoge3NpemU6IDIsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVQb3NpdGlvbnNMb3d9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cmlidXRlTWFuYWdlci5yZW1vdmUoW1xuICAgICAgICAgICdwb3NpdGlvbnM2NHh5TG93J1xuICAgICAgICBdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkcmF3KHt1bmlmb3Jtc30pIHtcbiAgICBjb25zdCB7ZXh0cnVkZWQsIGxpZ2h0U2V0dGluZ3N9ID0gdGhpcy5wcm9wcztcblxuICAgIHRoaXMuc3RhdGUubW9kZWwucmVuZGVyKE9iamVjdC5hc3NpZ24oe30sIHVuaWZvcm1zLCB7XG4gICAgICBleHRydWRlZDogZXh0cnVkZWQgPyAxLjAgOiAwLjBcbiAgICB9LFxuICAgIGxpZ2h0U2V0dGluZ3MpKTtcbiAgfVxuXG4gIHVwZGF0ZVN0YXRlKHtwcm9wcywgb2xkUHJvcHMsIGNoYW5nZUZsYWdzfSkge1xuICAgIHN1cGVyLnVwZGF0ZVN0YXRlKHtwcm9wcywgb2xkUHJvcHMsIGNoYW5nZUZsYWdzfSk7XG5cbiAgICBjb25zdCBnZW9tZXRyeUNoYW5nZWQgPSB0aGlzLnVwZGF0ZUdlb21ldHJ5KHtwcm9wcywgb2xkUHJvcHMsIGNoYW5nZUZsYWdzfSk7XG5cbiAgICAvLyBSZS1nZW5lcmF0ZSBtb2RlbCBpZiBnZW9tZXRyeSBjaGFuZ2VkXG4gICAgaWYgKGdlb21ldHJ5Q2hhbmdlZCkge1xuICAgICAgY29uc3Qge2dsfSA9IHRoaXMuY29udGV4dDtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe21vZGVsOiB0aGlzLl9nZXRNb2RlbChnbCl9KTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVBdHRyaWJ1dGUoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KTtcbiAgfVxuXG4gIHVwZGF0ZUdlb21ldHJ5KHtwcm9wcywgb2xkUHJvcHMsIGNoYW5nZUZsYWdzfSkge1xuICAgIGNvbnN0IHJlZ2VuZXJhdGVNb2RlbCA9IGNoYW5nZUZsYWdzLmRhdGFDaGFuZ2VkIHx8XG4gICAgICBwcm9wcy5leHRydWRlZCAhPT0gb2xkUHJvcHMuZXh0cnVkZWQgfHxcbiAgICAgIHByb3BzLndpcmVmcmFtZSAhPT0gb2xkUHJvcHMud2lyZWZyYW1lIHx8IHByb3BzLmZwNjQgIT09IG9sZFByb3BzLmZwNjQ7XG5cbiAgICBpZiAocmVnZW5lcmF0ZU1vZGVsKSB7XG4gICAgICBjb25zdCB7Z2V0UG9seWdvbiwgZXh0cnVkZWQsIHdpcmVmcmFtZSwgZ2V0RWxldmF0aW9ufSA9IHByb3BzO1xuXG4gICAgICAvLyBUT0RPIC0gYXZvaWQgY3JlYXRpbmcgYSB0ZW1wb3JhcnkgYXJyYXkgaGVyZTogbGV0IHRoZSB0ZXNzZWxhdG9yIGl0ZXJhdGVcbiAgICAgIGNvbnN0IHBvbHlnb25zID0gcHJvcHMuZGF0YS5tYXAoZ2V0UG9seWdvbik7XG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBwb2x5Z29uVGVzc2VsYXRvcjogIWV4dHJ1ZGVkID9cbiAgICAgICAgICBuZXcgUG9seWdvblRlc3NlbGF0b3Ioe3BvbHlnb25zLCBmcDY0OiB0aGlzLnByb3BzLmZwNjR9KSA6XG4gICAgICAgICAgbmV3IFBvbHlnb25UZXNzZWxhdG9yRXh0cnVkZWQoe3BvbHlnb25zLCB3aXJlZnJhbWUsXG4gICAgICAgICAgICBnZXRIZWlnaHQ6IHBvbHlnb25JbmRleCA9PiBnZXRFbGV2YXRpb24odGhpcy5wcm9wcy5kYXRhW3BvbHlnb25JbmRleF0pLFxuICAgICAgICAgICAgZnA2NDogdGhpcy5wcm9wcy5mcDY0XG4gICAgICAgICAgfSlcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnN0YXRlLmF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZUFsbCgpO1xuICAgIH1cblxuICAgIHJldHVybiByZWdlbmVyYXRlTW9kZWw7XG4gIH1cblxuICBfZ2V0TW9kZWwoZ2wpIHtcbiAgICBjb25zdCBzaGFkZXJzID0gYXNzZW1ibGVTaGFkZXJzKGdsLCB0aGlzLmdldFNoYWRlcnMoKSk7XG4gICAgcmV0dXJuIG5ldyBNb2RlbCh7XG4gICAgICBnbCxcbiAgICAgIGlkOiB0aGlzLnByb3BzLmlkLFxuICAgICAgdnM6IHNoYWRlcnMudnMsXG4gICAgICBmczogc2hhZGVycy5mcyxcbiAgICAgIGdlb21ldHJ5OiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICBkcmF3TW9kZTogdGhpcy5wcm9wcy53aXJlZnJhbWUgPyBHTC5MSU5FUyA6IEdMLlRSSUFOR0xFU1xuICAgICAgfSksXG4gICAgICB2ZXJ0ZXhDb3VudDogMCxcbiAgICAgIGlzSW5kZXhlZDogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgY2FsY3VsYXRlSW5kaWNlcyhhdHRyaWJ1dGUpIHtcbiAgICBhdHRyaWJ1dGUudmFsdWUgPSB0aGlzLnN0YXRlLnBvbHlnb25UZXNzZWxhdG9yLmluZGljZXMoKTtcbiAgICBhdHRyaWJ1dGUudGFyZ2V0ID0gR0wuRUxFTUVOVF9BUlJBWV9CVUZGRVI7XG4gICAgdGhpcy5zdGF0ZS5tb2RlbC5zZXRWZXJ0ZXhDb3VudChhdHRyaWJ1dGUudmFsdWUubGVuZ3RoIC8gYXR0cmlidXRlLnNpemUpO1xuICB9XG5cbiAgY2FsY3VsYXRlUG9zaXRpb25zKGF0dHJpYnV0ZSkge1xuICAgIGF0dHJpYnV0ZS52YWx1ZSA9IHRoaXMuc3RhdGUucG9seWdvblRlc3NlbGF0b3IucG9zaXRpb25zKCkucG9zaXRpb25zO1xuICB9XG4gIGNhbGN1bGF0ZVBvc2l0aW9uc0xvdyhhdHRyaWJ1dGUpIHtcbiAgICBhdHRyaWJ1dGUudmFsdWUgPSB0aGlzLnN0YXRlLnBvbHlnb25UZXNzZWxhdG9yLnBvc2l0aW9ucygpLnBvc2l0aW9uczY0eHlMb3c7XG4gIH1cbiAgY2FsY3VsYXRlTm9ybWFscyhhdHRyaWJ1dGUpIHtcbiAgICBhdHRyaWJ1dGUudmFsdWUgPSB0aGlzLnN0YXRlLnBvbHlnb25UZXNzZWxhdG9yLm5vcm1hbHMoKTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUNvbG9ycyhhdHRyaWJ1dGUpIHtcbiAgICBhdHRyaWJ1dGUudmFsdWUgPSB0aGlzLnN0YXRlLnBvbHlnb25UZXNzZWxhdG9yLmNvbG9ycyh7XG4gICAgICBnZXRDb2xvcjogcG9seWdvbkluZGV4ID0+IHRoaXMucHJvcHMuZ2V0Q29sb3IodGhpcy5wcm9wcy5kYXRhW3BvbHlnb25JbmRleF0pXG4gICAgfSk7XG4gIH1cblxuICAvLyBPdmVycmlkZSB0aGUgZGVmYXVsdCBwaWNraW5nIGNvbG9ycyBjYWxjdWxhdGlvblxuICBjYWxjdWxhdGVQaWNraW5nQ29sb3JzKGF0dHJpYnV0ZSkge1xuICAgIGF0dHJpYnV0ZS52YWx1ZSA9IHRoaXMuc3RhdGUucG9seWdvblRlc3NlbGF0b3IucGlja2luZ0NvbG9ycygpO1xuICB9XG59XG5cblNvbGlkUG9seWdvbkxheWVyLmxheWVyTmFtZSA9ICdTb2xpZFBvbHlnb25MYXllcic7XG5Tb2xpZFBvbHlnb25MYXllci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9sYXllcnMvY29yZS9zb2xpZC1wb2x5Z29uLWxheWVyL3NvbGlkLXBvbHlnb24tbGF5ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 27 */
/* exports provided: glArrayFromType, default */
/* exports used: default */
/*!**************************************!*\
  !*** ./src/lib/attribute-manager.js ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl__ = __webpack_require__(/*! luma.gl */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(/*! ./utils */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assert__ = __webpack_require__(/*! assert */ 6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_assert__);\n/* unused harmony export glArrayFromType */\n/* eslint-disable guard-for-in */\n\n\n\n\nfunction noop() {}\n\n/* eslint-disable complexity */\nfunction glArrayFromType(glType, {clamped = true} = {}) {\n  // Sorted in some order of likelihood to reduce amount of comparisons\n  switch (glType) {\n  case __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].FLOAT:\n    return Float32Array;\n  case __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].UNSIGNED_SHORT:\n  case __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].UNSIGNED_SHORT_5_6_5:\n  case __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].UNSIGNED_SHORT_4_4_4_4:\n  case __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].UNSIGNED_SHORT_5_5_5_1:\n    return Uint16Array;\n  case __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].UNSIGNED_INT:\n    return Uint32Array;\n  case __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].UNSIGNED_BYTE:\n    return clamped ? Uint8ClampedArray : Uint8Array;\n  case __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].BYTE:\n    return Int8Array;\n  case __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].SHORT:\n    return Int16Array;\n  case __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].INT:\n    return Int32Array;\n  default:\n    throw new Error('Failed to deduce type from array');\n  }\n}\n/* eslint-enable complexity */\n\nclass AttributeManager {\n  /**\n   * @classdesc\n   * Automated attribute generation and management. Suitable when a set of\n   * vertex shader attributes are generated by iteration over a data array,\n   * and updates to these attributes are needed either when the data itself\n   * changes, or when other data relevant to the calculations change.\n   *\n   * - First the application registers descriptions of its dynamic vertex\n   *   attributes using AttributeManager.add().\n   * - Then, when any change that affects attributes is detected by the\n   *   application, the app will call AttributeManager.invalidate().\n   * - Finally before it renders, it calls AttributeManager.update() to\n   *   ensure that attributes are automatically rebuilt if anything has been\n   *   invalidated.\n   *\n   * The application provided update functions describe how attributes\n   * should be updated from a data array and are expected to traverse\n   * that data array (or iterable) and fill in the attribute's typed array.\n   *\n   * Note that the attribute manager intentionally does not do advanced\n   * change detection, but instead makes it easy to build such detection\n   * by offering the ability to \"invalidate\" each attribute separately.\n   *\n   * Summary:\n   * - keeps track of valid state for each attribute\n   * - auto reallocates attributes when needed\n   * - auto updates attributes with registered updater functions\n   * - allows overriding with application supplied buffers\n   *\n   * Limitations:\n   * - There are currently no provisions for only invalidating a range of\n   *   indices in an attribute.\n   *\n   * @class\n   * @param {Object} [props]\n   * @param {String} [props.id] - identifier (for debugging)\n   */\n  constructor({id = 'attribute-manager'} = {}) {\n    this.id = id;\n    this.attributes = {};\n    this.updateTriggers = {};\n    this.allocedInstances = -1;\n    this.needsRedraw = true;\n    this.userData = {};\n\n    this.onUpdateStart = noop;\n    this.onUpdateEnd = noop;\n    this.onLog = this._defaultLog;\n\n    // For debugging sanity, prevent uninitialized members\n    Object.seal(this);\n  }\n\n  /**\n   * Adds attributes\n   * Takes a map of attribute descriptor objects\n   * - keys are attribute names\n   * - values are objects with attribute fields\n   *\n   * attribute.size - number of elements per object\n   * attribute.updater - number of elements\n   * attribute.instanced=0 - is this is an instanced attribute (a.k.a. divisor)\n   * attribute.noAlloc=false - if this attribute should not be allocated\n   *\n   * @example\n   * attributeManager.add({\n   *   positions: {size: 2, update: calculatePositions}\n   *   colors: {size: 3, update: calculateColors}\n   * });\n   *\n   * @param {Object} attributes - attribute map (see above)\n   * @param {Object} updaters - separate map of update functions (deprecated)\n   */\n  add(attributes, updaters = {}) {\n    this._add(attributes, updaters);\n  }\n\n /**\n   * Removes attributes\n   * Takes an array of attribute names and delete them from\n   * the attribute map if they exists\n   *\n   * @example\n   * attributeManager.remove(['position']);\n   *\n   * @param {Object} attributeNameArray - attribute name array (see above)\n   */\n  remove(attributeNameArray) {\n    for (let i = 0; i < attributeNameArray.length; i++) {\n      const name = attributeNameArray[i];\n      if (this.attributes[name] !== undefined) {\n        delete this.attributes[name];\n      }\n    }\n  }\n\n  /* Marks an attribute for update\n   * @param {string} triggerName: attribute or accessor name\n   */\n  invalidate(triggerName) {\n    const {attributes, updateTriggers} = this;\n    const attributesToUpdate = updateTriggers[triggerName];\n\n    if (!attributesToUpdate) {\n      let message =\n        `invalidating non-existent attribute ${triggerName} for ${this.id}\\n`;\n      message += `Valid attributes: ${Object.keys(attributes).join(', ')}`;\n      __WEBPACK_IMPORTED_MODULE_2_assert___default()(attributesToUpdate, message);\n    }\n    attributesToUpdate.forEach(name => {\n      const attribute = attributes[name];\n      if (attribute) {\n        attribute.needsUpdate = true;\n      }\n    });\n    // For performance tuning\n    this.onLog(1, `invalidated attribute ${attributesToUpdate} for ${this.id}`);\n  }\n\n  invalidateAll() {\n    const {attributes} = this;\n    for (const attributeName in attributes) {\n      this.invalidate(attributeName);\n    }\n  }\n\n  /**\n   * Ensure all attribute buffers are updated from props or data.\n   *\n   * Note: Any preallocated buffers in \"buffers\" matching registered attribute\n   * names will be used. No update will happen in this case.\n   * Note: Calls onUpdateStart and onUpdateEnd log callbacks before and after.\n   *\n   * @param {Object} opts - options\n   * @param {Object} opts.data - data (iterable object)\n   * @param {Object} opts.numInstances - count of data\n   * @param {Object} opts.buffers = {} - pre-allocated buffers\n   * @param {Object} opts.props - passed to updaters\n   * @param {Object} opts.context - Used as \"this\" context for updaters\n   */\n  update({\n    data,\n    numInstances,\n    props = {},\n    buffers = {},\n    context = {},\n    ignoreUnknownAttributes = false\n  } = {}) {\n    // First apply any application provided buffers\n    this._checkExternalBuffers({buffers, ignoreUnknownAttributes});\n    this._setExternalBuffers(buffers);\n\n    // Only initiate alloc/update (and logging) if actually needed\n    if (this._analyzeBuffers({numInstances})) {\n      this.onUpdateStart(this.id);\n      this._updateBuffers({numInstances, data, props, context});\n      this.onUpdateEnd(this.id);\n    }\n  }\n\n  /**\n   * Sets log functions to help trace or time attribute updates.\n   * Default logging uses luma logger.\n   *\n   * Note that the app may not be in control of when update is called,\n   * so hooks are provided for update start and end.\n   *\n   * @param {Object} [opts]\n   * @param {String} [opts.onLog=] - called to print\n   * @param {String} [opts.onUpdateStart=] - called before update() starts\n   * @param {String} [opts.onUpdateEnd=] - called after update() ends\n   */\n  setLogFunctions({\n    onLog,\n    onUpdateStart,\n    onUpdateEnd\n  } = {}) {\n    this.onLog = onLog !== undefined ? onLog : this.onLog;\n    this.onUpdateStart =\n      onUpdateStart !== undefined ? onUpdateStart : this.onUpdateStart;\n    this.onUpdateEnd =\n      onUpdateEnd !== undefined ? onUpdateEnd : this.onUpdateEnd;\n  }\n\n  /**\n   * Returns all attribute descriptors\n   * Note: Format matches luma.gl Model/Program.setAttributes()\n   * @return {Object} attributes - descriptors\n   */\n  getAttributes() {\n    return this.attributes;\n  }\n\n  /**\n   * Returns changed attribute descriptors\n   * This indicates which WebGLBuggers need to be updated\n   * @return {Object} attributes - descriptors\n   */\n  getChangedAttributes({clearChangedFlags = false}) {\n    const {attributes} = this;\n    const changedAttributes = {};\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      if (attribute.changed) {\n        attribute.changed = attribute.changed && !clearChangedFlags;\n        changedAttributes[attributeName] = attribute;\n      }\n    }\n    return changedAttributes;\n  }\n\n  /**\n   * Returns the redraw flag, optionally clearing it.\n   * Redraw flag will be set if any attributes attributes changed since\n   * flag was last cleared.\n   *\n   * @param {Object} [opts]\n   * @param {String} [opts.clearRedrawFlags=false] - whether to clear the flag\n   * @return {Boolean} - whether a redraw is needed.\n   */\n  getNeedsRedraw({clearRedrawFlags = false} = {}) {\n    let redraw = this.needsRedraw;\n    redraw = redraw || this.needsRedraw;\n    this.needsRedraw = this.needsRedraw && !clearRedrawFlags;\n    return redraw;\n  }\n\n  /**\n   * Sets the redraw flag.\n   * @param {Boolean} redraw=true\n   * @return {AttributeManager} - for chaining\n   */\n  setNeedsRedraw(redraw = true) {\n    this.needsRedraw = true;\n    return this;\n  }\n\n  // DEPRECATED METHODS\n\n  /**\n   * @deprecated since version 2.5, use add() instead\n   * Adds attributes\n   * @param {Object} attributes - attribute map (see above)\n   * @param {Object} updaters - separate map of update functions (deprecated)\n   */\n  addDynamic(attributes, updaters = {}) {\n    this._add(attributes, updaters);\n  }\n\n  /**\n   * @deprecated since version 2.5, use add() instead\n   * Adds attributes\n   * @param {Object} attributes - attribute map (see above)\n   * @param {Object} updaters - separate map of update functions (deprecated)\n   */\n  addInstanced(attributes, updaters = {}) {\n    this._add(attributes, updaters, {instanced: 1});\n  }\n\n  // PRIVATE METHODS\n\n  // Default logger\n  _defaultLog(level, message) {\n    __WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */].log(level, message);\n  }\n\n  // Used to register an attribute\n  _add(attributes, updaters = {}, _extraProps = {}) {\n\n    const newAttributes = {};\n\n    for (const attributeName in attributes) {\n      // support for separate update function map\n      // For now, just copy any attributes from that map into the main map\n      // TODO - Attribute maps are a deprecated feature, remove\n      if (attributeName in updaters) {\n        attributes[attributeName] =\n          Object.assign({}, attributes[attributeName], updaters[attributeName]);\n      }\n\n      const attribute = attributes[attributeName];\n\n      const isIndexed = attribute.isIndexed || attribute.elements;\n      const size = (attribute.elements && 1) || attribute.size;\n      const value = attribute.value || null;\n\n      // Initialize the attribute descriptor, with WebGL and metadata fields\n      const attributeData = Object.assign(\n        {\n          // Ensure that fields are present before Object.seal()\n          target: undefined,\n          userData: {}        // Reserved for application\n        },\n        // Metadata\n        attribute,\n        {\n          // State\n          isExternalBuffer: false,\n          needsAlloc: false,\n          needsUpdate: false,\n          changed: false,\n\n          // Luma fields\n          isIndexed,\n          size,\n          value\n        },\n        _extraProps\n      );\n      // Sanity - no app fields on our attributes. Use userData instead.\n      Object.seal(attributeData);\n\n      // Check all fields and generate helpful error messages\n      this._validateAttributeDefinition(attributeName, attributeData);\n\n      // Add to both attributes list (for registration with model)\n      newAttributes[attributeName] = attributeData;\n    }\n\n    Object.assign(this.attributes, newAttributes);\n\n    this._mapUpdateTriggersToAttributes();\n  }\n\n  // build updateTrigger name to attribute name mapping\n  _mapUpdateTriggersToAttributes() {\n    const triggers = {};\n\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n      let {accessor} = attribute;\n\n      // use attribute name as update trigger key\n      triggers[attributeName] = [attributeName];\n\n      // use accessor name as update trigger key\n      if (typeof accessor === 'string') {\n        accessor = [accessor];\n      }\n      if (Array.isArray(accessor)) {\n        accessor.forEach(accessorName => {\n          if (!triggers[accessorName]) {\n            triggers[accessorName] = [];\n          }\n          triggers[accessorName].push(attributeName);\n        });\n      }\n    }\n\n    this.updateTriggers = triggers;\n  }\n\n  _validateAttributeDefinition(attributeName, attribute) {\n    __WEBPACK_IMPORTED_MODULE_2_assert___default()(attribute.size >= 1 && attribute.size <= 4,\n      `Attribute definition for ${attributeName} invalid size`);\n\n    // Check that either 'accessor' or 'update' is a valid function\n    const hasUpdater = attribute.noAlloc ||\n      typeof attribute.update === 'function' ||\n      typeof attribute.accessor === 'string';\n    if (!hasUpdater) {\n      throw new Error(`Attribute ${attributeName} missing update or accessor`);\n    }\n  }\n\n  // Checks that any attribute buffers in props are valid\n  // Note: This is just to help app catch mistakes\n  _checkExternalBuffers({\n    buffers = {},\n    ignoreUnknownAttributes = false\n  } = {}) {\n    const {attributes} = this;\n    for (const attributeName in buffers) {\n      const attribute = attributes[attributeName];\n      if (!attribute && !ignoreUnknownAttributes) {\n        throw new Error(`Unknown attribute prop ${attributeName}`);\n      }\n      // const buffer = buffers[attributeName];\n      // TODO - check buffer type\n    }\n  }\n\n  // Set the buffers for the supplied attributes\n  // Update attribute buffers from any attributes in props\n  // Detach any previously set buffers, marking all\n  // Attributes for auto allocation\n  /* eslint-disable max-statements */\n  _setExternalBuffers(bufferMap) {\n    const {attributes, numInstances} = this;\n\n    // Copy the refs of any supplied buffers in the props\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      const buffer = bufferMap[attributeName];\n      attribute.isExternalBuffer = false;\n      if (buffer) {\n        if (!(buffer instanceof Float32Array)) {\n          throw new Error('Attribute properties must be of type Float32Array');\n        }\n        if (attribute.auto && buffer.length <= numInstances * attribute.size) {\n          throw new Error('Attribute prop array must match length and size');\n        }\n\n        attribute.isExternalBuffer = true;\n        attribute.needsUpdate = false;\n        if (attribute.value !== buffer) {\n          attribute.value = buffer;\n          attribute.changed = true;\n          this.needsRedraw = true;\n        }\n      }\n    }\n  }\n  /* eslint-enable max-statements */\n\n  /* Checks that typed arrays for attributes are big enough\n   * sets alloc flag if not\n   * @return {Boolean} whether any updates are needed\n   */\n  _analyzeBuffers({numInstances}) {\n    const {attributes} = this;\n    __WEBPACK_IMPORTED_MODULE_2_assert___default()(numInstances !== undefined, 'numInstances not defined');\n\n    // Track whether any allocations or updates are needed\n    let needsUpdate = false;\n\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      if (!attribute.isExternalBuffer) {\n        // Do we need to reallocate the attribute's typed array?\n        const needsAlloc =\n          attribute.value === null ||\n          attribute.value.length / attribute.size < numInstances;\n        if (needsAlloc && (attribute.update || attribute.accessor)) {\n          attribute.needsAlloc = true;\n          needsUpdate = true;\n        }\n        if (attribute.needsUpdate) {\n          needsUpdate = true;\n        }\n      }\n    }\n\n    return needsUpdate;\n  }\n\n  /**\n   * @private\n   * Calls update on any buffers that need update\n   * TODO? - If app supplied all attributes, no need to iterate over data\n   *\n   * @param {Object} opts - options\n   * @param {Object} opts.data - data (iterable object)\n   * @param {Object} opts.numInstances - count of data\n   * @param {Object} opts.buffers = {} - pre-allocated buffers\n   * @param {Object} opts.props - passed to updaters\n   * @param {Object} opts.context - Used as \"this\" context for updaters\n   */\n  /* eslint-disable max-statements, complexity */\n  _updateBuffers({numInstances, data, props, context}) {\n    const {attributes} = this;\n\n    // Allocate at least one element to ensure a valid buffer\n    const allocCount = Math.max(numInstances, 1);\n\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n\n      // Allocate a new typed array if needed\n      if (attribute.needsAlloc) {\n        const ArrayType = glArrayFromType(attribute.type || __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].FLOAT);\n        attribute.value = new ArrayType(attribute.size * allocCount);\n        this.onLog(2, `${this.id}:${attributeName} allocated ${allocCount}`);\n        attribute.needsAlloc = false;\n        attribute.needsUpdate = true;\n      }\n\n      // Call updater function if needed\n      if (attribute.needsUpdate) {\n        this._updateBuffer({attribute, attributeName, numInstances, data, props, context});\n      }\n    }\n\n    this.allocedInstances = allocCount;\n  }\n\n  _updateBuffer({attribute, attributeName, numInstances, data, props, context}) {\n    const {update, accessor} = attribute;\n    if (update) {\n      // Custom updater - typically for non-instanced layers\n      this.onLog(2, `${this.id}:${attributeName} updating ${numInstances}`);\n      update.call(context, attribute, {data, props, numInstances});\n      this._checkAttributeArray(attribute, attributeName);\n    } else if (accessor) {\n      // Standard updater\n      this._updateBufferViaStandardAccessor({attribute, data, props});\n      this._checkAttributeArray(attribute, attributeName);\n    } else {\n      this.onLog(2, `${this.id}:${attributeName} missing update function`);\n    }\n\n    attribute.needsUpdate = false;\n    attribute.changed = true;\n    this.needsRedraw = true;\n  }\n  /* eslint-enable max-statements */\n\n  _updateBufferViaStandardAccessor({attribute, data, props}) {\n    const {accessor, value, size} = attribute;\n    const accessorFunc = props[accessor];\n\n    __WEBPACK_IMPORTED_MODULE_2_assert___default()(typeof accessorFunc === 'function', `accessor \"${accessor}\" is not a function`);\n\n    let {defaultValue = [0, 0, 0, 0]} = attribute;\n    defaultValue = Array.isArray(defaultValue) ? defaultValue : [defaultValue];\n    let i = 0;\n    for (const object of data) {\n      let objectValue = accessorFunc(object);\n      objectValue = Array.isArray(objectValue) ? objectValue : [objectValue];\n      /* eslint-disable no-fallthrough, default-case */\n      switch (size) {\n      case 4: value[i + 3] = Number.isFinite(objectValue[3]) ? objectValue[3] : defaultValue[3];\n      case 3: value[i + 2] = Number.isFinite(objectValue[2]) ? objectValue[2] : defaultValue[2];\n      case 2: value[i + 1] = Number.isFinite(objectValue[1]) ? objectValue[1] : defaultValue[1];\n      case 1: value[i + 0] = Number.isFinite(objectValue[0]) ? objectValue[0] : defaultValue[0];\n      }\n      i += size;\n    }\n  }\n\n  _checkAttributeArray(attribute, attributeName) {\n    const {value} = attribute;\n    if (value && value.length >= 4) {\n      const valid =\n        Number.isFinite(value[0]) && Number.isFinite(value[1]) &&\n        Number.isFinite(value[2]) && Number.isFinite(value[3]);\n      if (!valid) {\n        throw new Error(`Illegal attribute generated for ${attributeName}`);\n      }\n    }\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = AttributeManager;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL2F0dHJpYnV0ZS1tYW5hZ2VyLmpzPzQyNTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgZ3VhcmQtZm9yLWluICovXG5pbXBvcnQge0dMfSBmcm9tICdsdW1hLmdsJztcbmltcG9ydCB7bG9nfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbi8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHkgKi9cbmV4cG9ydCBmdW5jdGlvbiBnbEFycmF5RnJvbVR5cGUoZ2xUeXBlLCB7Y2xhbXBlZCA9IHRydWV9ID0ge30pIHtcbiAgLy8gU29ydGVkIGluIHNvbWUgb3JkZXIgb2YgbGlrZWxpaG9vZCB0byByZWR1Y2UgYW1vdW50IG9mIGNvbXBhcmlzb25zXG4gIHN3aXRjaCAoZ2xUeXBlKSB7XG4gIGNhc2UgR0wuRkxPQVQ6XG4gICAgcmV0dXJuIEZsb2F0MzJBcnJheTtcbiAgY2FzZSBHTC5VTlNJR05FRF9TSE9SVDpcbiAgY2FzZSBHTC5VTlNJR05FRF9TSE9SVF81XzZfNTpcbiAgY2FzZSBHTC5VTlNJR05FRF9TSE9SVF80XzRfNF80OlxuICBjYXNlIEdMLlVOU0lHTkVEX1NIT1JUXzVfNV81XzE6XG4gICAgcmV0dXJuIFVpbnQxNkFycmF5O1xuICBjYXNlIEdMLlVOU0lHTkVEX0lOVDpcbiAgICByZXR1cm4gVWludDMyQXJyYXk7XG4gIGNhc2UgR0wuVU5TSUdORURfQllURTpcbiAgICByZXR1cm4gY2xhbXBlZCA/IFVpbnQ4Q2xhbXBlZEFycmF5IDogVWludDhBcnJheTtcbiAgY2FzZSBHTC5CWVRFOlxuICAgIHJldHVybiBJbnQ4QXJyYXk7XG4gIGNhc2UgR0wuU0hPUlQ6XG4gICAgcmV0dXJuIEludDE2QXJyYXk7XG4gIGNhc2UgR0wuSU5UOlxuICAgIHJldHVybiBJbnQzMkFycmF5O1xuICBkZWZhdWx0OlxuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGRlZHVjZSB0eXBlIGZyb20gYXJyYXknKTtcbiAgfVxufVxuLyogZXNsaW50LWVuYWJsZSBjb21wbGV4aXR5ICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF0dHJpYnV0ZU1hbmFnZXIge1xuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBBdXRvbWF0ZWQgYXR0cmlidXRlIGdlbmVyYXRpb24gYW5kIG1hbmFnZW1lbnQuIFN1aXRhYmxlIHdoZW4gYSBzZXQgb2ZcbiAgICogdmVydGV4IHNoYWRlciBhdHRyaWJ1dGVzIGFyZSBnZW5lcmF0ZWQgYnkgaXRlcmF0aW9uIG92ZXIgYSBkYXRhIGFycmF5LFxuICAgKiBhbmQgdXBkYXRlcyB0byB0aGVzZSBhdHRyaWJ1dGVzIGFyZSBuZWVkZWQgZWl0aGVyIHdoZW4gdGhlIGRhdGEgaXRzZWxmXG4gICAqIGNoYW5nZXMsIG9yIHdoZW4gb3RoZXIgZGF0YSByZWxldmFudCB0byB0aGUgY2FsY3VsYXRpb25zIGNoYW5nZS5cbiAgICpcbiAgICogLSBGaXJzdCB0aGUgYXBwbGljYXRpb24gcmVnaXN0ZXJzIGRlc2NyaXB0aW9ucyBvZiBpdHMgZHluYW1pYyB2ZXJ0ZXhcbiAgICogICBhdHRyaWJ1dGVzIHVzaW5nIEF0dHJpYnV0ZU1hbmFnZXIuYWRkKCkuXG4gICAqIC0gVGhlbiwgd2hlbiBhbnkgY2hhbmdlIHRoYXQgYWZmZWN0cyBhdHRyaWJ1dGVzIGlzIGRldGVjdGVkIGJ5IHRoZVxuICAgKiAgIGFwcGxpY2F0aW9uLCB0aGUgYXBwIHdpbGwgY2FsbCBBdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGUoKS5cbiAgICogLSBGaW5hbGx5IGJlZm9yZSBpdCByZW5kZXJzLCBpdCBjYWxscyBBdHRyaWJ1dGVNYW5hZ2VyLnVwZGF0ZSgpIHRvXG4gICAqICAgZW5zdXJlIHRoYXQgYXR0cmlidXRlcyBhcmUgYXV0b21hdGljYWxseSByZWJ1aWx0IGlmIGFueXRoaW5nIGhhcyBiZWVuXG4gICAqICAgaW52YWxpZGF0ZWQuXG4gICAqXG4gICAqIFRoZSBhcHBsaWNhdGlvbiBwcm92aWRlZCB1cGRhdGUgZnVuY3Rpb25zIGRlc2NyaWJlIGhvdyBhdHRyaWJ1dGVzXG4gICAqIHNob3VsZCBiZSB1cGRhdGVkIGZyb20gYSBkYXRhIGFycmF5IGFuZCBhcmUgZXhwZWN0ZWQgdG8gdHJhdmVyc2VcbiAgICogdGhhdCBkYXRhIGFycmF5IChvciBpdGVyYWJsZSkgYW5kIGZpbGwgaW4gdGhlIGF0dHJpYnV0ZSdzIHR5cGVkIGFycmF5LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIGF0dHJpYnV0ZSBtYW5hZ2VyIGludGVudGlvbmFsbHkgZG9lcyBub3QgZG8gYWR2YW5jZWRcbiAgICogY2hhbmdlIGRldGVjdGlvbiwgYnV0IGluc3RlYWQgbWFrZXMgaXQgZWFzeSB0byBidWlsZCBzdWNoIGRldGVjdGlvblxuICAgKiBieSBvZmZlcmluZyB0aGUgYWJpbGl0eSB0byBcImludmFsaWRhdGVcIiBlYWNoIGF0dHJpYnV0ZSBzZXBhcmF0ZWx5LlxuICAgKlxuICAgKiBTdW1tYXJ5OlxuICAgKiAtIGtlZXBzIHRyYWNrIG9mIHZhbGlkIHN0YXRlIGZvciBlYWNoIGF0dHJpYnV0ZVxuICAgKiAtIGF1dG8gcmVhbGxvY2F0ZXMgYXR0cmlidXRlcyB3aGVuIG5lZWRlZFxuICAgKiAtIGF1dG8gdXBkYXRlcyBhdHRyaWJ1dGVzIHdpdGggcmVnaXN0ZXJlZCB1cGRhdGVyIGZ1bmN0aW9uc1xuICAgKiAtIGFsbG93cyBvdmVycmlkaW5nIHdpdGggYXBwbGljYXRpb24gc3VwcGxpZWQgYnVmZmVyc1xuICAgKlxuICAgKiBMaW1pdGF0aW9uczpcbiAgICogLSBUaGVyZSBhcmUgY3VycmVudGx5IG5vIHByb3Zpc2lvbnMgZm9yIG9ubHkgaW52YWxpZGF0aW5nIGEgcmFuZ2Ugb2ZcbiAgICogICBpbmRpY2VzIGluIGFuIGF0dHJpYnV0ZS5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHNdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcHMuaWRdIC0gaWRlbnRpZmllciAoZm9yIGRlYnVnZ2luZylcbiAgICovXG4gIGNvbnN0cnVjdG9yKHtpZCA9ICdhdHRyaWJ1dGUtbWFuYWdlcid9ID0ge30pIHtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgdGhpcy51cGRhdGVUcmlnZ2VycyA9IHt9O1xuICAgIHRoaXMuYWxsb2NlZEluc3RhbmNlcyA9IC0xO1xuICAgIHRoaXMubmVlZHNSZWRyYXcgPSB0cnVlO1xuICAgIHRoaXMudXNlckRhdGEgPSB7fTtcblxuICAgIHRoaXMub25VcGRhdGVTdGFydCA9IG5vb3A7XG4gICAgdGhpcy5vblVwZGF0ZUVuZCA9IG5vb3A7XG4gICAgdGhpcy5vbkxvZyA9IHRoaXMuX2RlZmF1bHRMb2c7XG5cbiAgICAvLyBGb3IgZGVidWdnaW5nIHNhbml0eSwgcHJldmVudCB1bmluaXRpYWxpemVkIG1lbWJlcnNcbiAgICBPYmplY3Quc2VhbCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGF0dHJpYnV0ZXNcbiAgICogVGFrZXMgYSBtYXAgb2YgYXR0cmlidXRlIGRlc2NyaXB0b3Igb2JqZWN0c1xuICAgKiAtIGtleXMgYXJlIGF0dHJpYnV0ZSBuYW1lc1xuICAgKiAtIHZhbHVlcyBhcmUgb2JqZWN0cyB3aXRoIGF0dHJpYnV0ZSBmaWVsZHNcbiAgICpcbiAgICogYXR0cmlidXRlLnNpemUgLSBudW1iZXIgb2YgZWxlbWVudHMgcGVyIG9iamVjdFxuICAgKiBhdHRyaWJ1dGUudXBkYXRlciAtIG51bWJlciBvZiBlbGVtZW50c1xuICAgKiBhdHRyaWJ1dGUuaW5zdGFuY2VkPTAgLSBpcyB0aGlzIGlzIGFuIGluc3RhbmNlZCBhdHRyaWJ1dGUgKGEuay5hLiBkaXZpc29yKVxuICAgKiBhdHRyaWJ1dGUubm9BbGxvYz1mYWxzZSAtIGlmIHRoaXMgYXR0cmlidXRlIHNob3VsZCBub3QgYmUgYWxsb2NhdGVkXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGF0dHJpYnV0ZU1hbmFnZXIuYWRkKHtcbiAgICogICBwb3NpdGlvbnM6IHtzaXplOiAyLCB1cGRhdGU6IGNhbGN1bGF0ZVBvc2l0aW9uc31cbiAgICogICBjb2xvcnM6IHtzaXplOiAzLCB1cGRhdGU6IGNhbGN1bGF0ZUNvbG9yc31cbiAgICogfSk7XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzIC0gYXR0cmlidXRlIG1hcCAoc2VlIGFib3ZlKVxuICAgKiBAcGFyYW0ge09iamVjdH0gdXBkYXRlcnMgLSBzZXBhcmF0ZSBtYXAgb2YgdXBkYXRlIGZ1bmN0aW9ucyAoZGVwcmVjYXRlZClcbiAgICovXG4gIGFkZChhdHRyaWJ1dGVzLCB1cGRhdGVycyA9IHt9KSB7XG4gICAgdGhpcy5fYWRkKGF0dHJpYnV0ZXMsIHVwZGF0ZXJzKTtcbiAgfVxuXG4gLyoqXG4gICAqIFJlbW92ZXMgYXR0cmlidXRlc1xuICAgKiBUYWtlcyBhbiBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZXMgYW5kIGRlbGV0ZSB0aGVtIGZyb21cbiAgICogdGhlIGF0dHJpYnV0ZSBtYXAgaWYgdGhleSBleGlzdHNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYXR0cmlidXRlTWFuYWdlci5yZW1vdmUoWydwb3NpdGlvbiddKTtcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZU5hbWVBcnJheSAtIGF0dHJpYnV0ZSBuYW1lIGFycmF5IChzZWUgYWJvdmUpXG4gICAqL1xuICByZW1vdmUoYXR0cmlidXRlTmFtZUFycmF5KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRyaWJ1dGVOYW1lQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGVOYW1lQXJyYXlbaV07XG4gICAgICBpZiAodGhpcy5hdHRyaWJ1dGVzW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiBNYXJrcyBhbiBhdHRyaWJ1dGUgZm9yIHVwZGF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHJpZ2dlck5hbWU6IGF0dHJpYnV0ZSBvciBhY2Nlc3NvciBuYW1lXG4gICAqL1xuICBpbnZhbGlkYXRlKHRyaWdnZXJOYW1lKSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZXMsIHVwZGF0ZVRyaWdnZXJzfSA9IHRoaXM7XG4gICAgY29uc3QgYXR0cmlidXRlc1RvVXBkYXRlID0gdXBkYXRlVHJpZ2dlcnNbdHJpZ2dlck5hbWVdO1xuXG4gICAgaWYgKCFhdHRyaWJ1dGVzVG9VcGRhdGUpIHtcbiAgICAgIGxldCBtZXNzYWdlID1cbiAgICAgICAgYGludmFsaWRhdGluZyBub24tZXhpc3RlbnQgYXR0cmlidXRlICR7dHJpZ2dlck5hbWV9IGZvciAke3RoaXMuaWR9XFxuYDtcbiAgICAgIG1lc3NhZ2UgKz0gYFZhbGlkIGF0dHJpYnV0ZXM6ICR7T2JqZWN0LmtleXMoYXR0cmlidXRlcykuam9pbignLCAnKX1gO1xuICAgICAgYXNzZXJ0KGF0dHJpYnV0ZXNUb1VwZGF0ZSwgbWVzc2FnZSk7XG4gICAgfVxuICAgIGF0dHJpYnV0ZXNUb1VwZGF0ZS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgIGlmIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgYXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBGb3IgcGVyZm9ybWFuY2UgdHVuaW5nXG4gICAgdGhpcy5vbkxvZygxLCBgaW52YWxpZGF0ZWQgYXR0cmlidXRlICR7YXR0cmlidXRlc1RvVXBkYXRlfSBmb3IgJHt0aGlzLmlkfWApO1xuICB9XG5cbiAgaW52YWxpZGF0ZUFsbCgpIHtcbiAgICBjb25zdCB7YXR0cmlidXRlc30gPSB0aGlzO1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICB0aGlzLmludmFsaWRhdGUoYXR0cmlidXRlTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVuc3VyZSBhbGwgYXR0cmlidXRlIGJ1ZmZlcnMgYXJlIHVwZGF0ZWQgZnJvbSBwcm9wcyBvciBkYXRhLlxuICAgKlxuICAgKiBOb3RlOiBBbnkgcHJlYWxsb2NhdGVkIGJ1ZmZlcnMgaW4gXCJidWZmZXJzXCIgbWF0Y2hpbmcgcmVnaXN0ZXJlZCBhdHRyaWJ1dGVcbiAgICogbmFtZXMgd2lsbCBiZSB1c2VkLiBObyB1cGRhdGUgd2lsbCBoYXBwZW4gaW4gdGhpcyBjYXNlLlxuICAgKiBOb3RlOiBDYWxscyBvblVwZGF0ZVN0YXJ0IGFuZCBvblVwZGF0ZUVuZCBsb2cgY2FsbGJhY2tzIGJlZm9yZSBhbmQgYWZ0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5kYXRhIC0gZGF0YSAoaXRlcmFibGUgb2JqZWN0KVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5udW1JbnN0YW5jZXMgLSBjb3VudCBvZiBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmJ1ZmZlcnMgPSB7fSAtIHByZS1hbGxvY2F0ZWQgYnVmZmVyc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5wcm9wcyAtIHBhc3NlZCB0byB1cGRhdGVyc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5jb250ZXh0IC0gVXNlZCBhcyBcInRoaXNcIiBjb250ZXh0IGZvciB1cGRhdGVyc1xuICAgKi9cbiAgdXBkYXRlKHtcbiAgICBkYXRhLFxuICAgIG51bUluc3RhbmNlcyxcbiAgICBwcm9wcyA9IHt9LFxuICAgIGJ1ZmZlcnMgPSB7fSxcbiAgICBjb250ZXh0ID0ge30sXG4gICAgaWdub3JlVW5rbm93bkF0dHJpYnV0ZXMgPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICAvLyBGaXJzdCBhcHBseSBhbnkgYXBwbGljYXRpb24gcHJvdmlkZWQgYnVmZmVyc1xuICAgIHRoaXMuX2NoZWNrRXh0ZXJuYWxCdWZmZXJzKHtidWZmZXJzLCBpZ25vcmVVbmtub3duQXR0cmlidXRlc30pO1xuICAgIHRoaXMuX3NldEV4dGVybmFsQnVmZmVycyhidWZmZXJzKTtcblxuICAgIC8vIE9ubHkgaW5pdGlhdGUgYWxsb2MvdXBkYXRlIChhbmQgbG9nZ2luZykgaWYgYWN0dWFsbHkgbmVlZGVkXG4gICAgaWYgKHRoaXMuX2FuYWx5emVCdWZmZXJzKHtudW1JbnN0YW5jZXN9KSkge1xuICAgICAgdGhpcy5vblVwZGF0ZVN0YXJ0KHRoaXMuaWQpO1xuICAgICAgdGhpcy5fdXBkYXRlQnVmZmVycyh7bnVtSW5zdGFuY2VzLCBkYXRhLCBwcm9wcywgY29udGV4dH0pO1xuICAgICAgdGhpcy5vblVwZGF0ZUVuZCh0aGlzLmlkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBsb2cgZnVuY3Rpb25zIHRvIGhlbHAgdHJhY2Ugb3IgdGltZSBhdHRyaWJ1dGUgdXBkYXRlcy5cbiAgICogRGVmYXVsdCBsb2dnaW5nIHVzZXMgbHVtYSBsb2dnZXIuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgYXBwIG1heSBub3QgYmUgaW4gY29udHJvbCBvZiB3aGVuIHVwZGF0ZSBpcyBjYWxsZWQsXG4gICAqIHNvIGhvb2tzIGFyZSBwcm92aWRlZCBmb3IgdXBkYXRlIHN0YXJ0IGFuZCBlbmQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c11cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRzLm9uTG9nPV0gLSBjYWxsZWQgdG8gcHJpbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRzLm9uVXBkYXRlU3RhcnQ9XSAtIGNhbGxlZCBiZWZvcmUgdXBkYXRlKCkgc3RhcnRzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0cy5vblVwZGF0ZUVuZD1dIC0gY2FsbGVkIGFmdGVyIHVwZGF0ZSgpIGVuZHNcbiAgICovXG4gIHNldExvZ0Z1bmN0aW9ucyh7XG4gICAgb25Mb2csXG4gICAgb25VcGRhdGVTdGFydCxcbiAgICBvblVwZGF0ZUVuZFxuICB9ID0ge30pIHtcbiAgICB0aGlzLm9uTG9nID0gb25Mb2cgIT09IHVuZGVmaW5lZCA/IG9uTG9nIDogdGhpcy5vbkxvZztcbiAgICB0aGlzLm9uVXBkYXRlU3RhcnQgPVxuICAgICAgb25VcGRhdGVTdGFydCAhPT0gdW5kZWZpbmVkID8gb25VcGRhdGVTdGFydCA6IHRoaXMub25VcGRhdGVTdGFydDtcbiAgICB0aGlzLm9uVXBkYXRlRW5kID1cbiAgICAgIG9uVXBkYXRlRW5kICE9PSB1bmRlZmluZWQgPyBvblVwZGF0ZUVuZCA6IHRoaXMub25VcGRhdGVFbmQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgYXR0cmlidXRlIGRlc2NyaXB0b3JzXG4gICAqIE5vdGU6IEZvcm1hdCBtYXRjaGVzIGx1bWEuZ2wgTW9kZWwvUHJvZ3JhbS5zZXRBdHRyaWJ1dGVzKClcbiAgICogQHJldHVybiB7T2JqZWN0fSBhdHRyaWJ1dGVzIC0gZGVzY3JpcHRvcnNcbiAgICovXG4gIGdldEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGNoYW5nZWQgYXR0cmlidXRlIGRlc2NyaXB0b3JzXG4gICAqIFRoaXMgaW5kaWNhdGVzIHdoaWNoIFdlYkdMQnVnZ2VycyBuZWVkIHRvIGJlIHVwZGF0ZWRcbiAgICogQHJldHVybiB7T2JqZWN0fSBhdHRyaWJ1dGVzIC0gZGVzY3JpcHRvcnNcbiAgICovXG4gIGdldENoYW5nZWRBdHRyaWJ1dGVzKHtjbGVhckNoYW5nZWRGbGFncyA9IGZhbHNlfSkge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVzfSA9IHRoaXM7XG4gICAgY29uc3QgY2hhbmdlZEF0dHJpYnV0ZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGlmIChhdHRyaWJ1dGUuY2hhbmdlZCkge1xuICAgICAgICBhdHRyaWJ1dGUuY2hhbmdlZCA9IGF0dHJpYnV0ZS5jaGFuZ2VkICYmICFjbGVhckNoYW5nZWRGbGFncztcbiAgICAgICAgY2hhbmdlZEF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0gPSBhdHRyaWJ1dGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkQXR0cmlidXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZWRyYXcgZmxhZywgb3B0aW9uYWxseSBjbGVhcmluZyBpdC5cbiAgICogUmVkcmF3IGZsYWcgd2lsbCBiZSBzZXQgaWYgYW55IGF0dHJpYnV0ZXMgYXR0cmlidXRlcyBjaGFuZ2VkIHNpbmNlXG4gICAqIGZsYWcgd2FzIGxhc3QgY2xlYXJlZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdHMuY2xlYXJSZWRyYXdGbGFncz1mYWxzZV0gLSB3aGV0aGVyIHRvIGNsZWFyIHRoZSBmbGFnXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IC0gd2hldGhlciBhIHJlZHJhdyBpcyBuZWVkZWQuXG4gICAqL1xuICBnZXROZWVkc1JlZHJhdyh7Y2xlYXJSZWRyYXdGbGFncyA9IGZhbHNlfSA9IHt9KSB7XG4gICAgbGV0IHJlZHJhdyA9IHRoaXMubmVlZHNSZWRyYXc7XG4gICAgcmVkcmF3ID0gcmVkcmF3IHx8IHRoaXMubmVlZHNSZWRyYXc7XG4gICAgdGhpcy5uZWVkc1JlZHJhdyA9IHRoaXMubmVlZHNSZWRyYXcgJiYgIWNsZWFyUmVkcmF3RmxhZ3M7XG4gICAgcmV0dXJuIHJlZHJhdztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZWRyYXcgZmxhZy5cbiAgICogQHBhcmFtIHtCb29sZWFufSByZWRyYXc9dHJ1ZVxuICAgKiBAcmV0dXJuIHtBdHRyaWJ1dGVNYW5hZ2VyfSAtIGZvciBjaGFpbmluZ1xuICAgKi9cbiAgc2V0TmVlZHNSZWRyYXcocmVkcmF3ID0gdHJ1ZSkge1xuICAgIHRoaXMubmVlZHNSZWRyYXcgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gREVQUkVDQVRFRCBNRVRIT0RTXG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi41LCB1c2UgYWRkKCkgaW5zdGVhZFxuICAgKiBBZGRzIGF0dHJpYnV0ZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXMgLSBhdHRyaWJ1dGUgbWFwIChzZWUgYWJvdmUpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB1cGRhdGVycyAtIHNlcGFyYXRlIG1hcCBvZiB1cGRhdGUgZnVuY3Rpb25zIChkZXByZWNhdGVkKVxuICAgKi9cbiAgYWRkRHluYW1pYyhhdHRyaWJ1dGVzLCB1cGRhdGVycyA9IHt9KSB7XG4gICAgdGhpcy5fYWRkKGF0dHJpYnV0ZXMsIHVwZGF0ZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNSwgdXNlIGFkZCgpIGluc3RlYWRcbiAgICogQWRkcyBhdHRyaWJ1dGVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzIC0gYXR0cmlidXRlIG1hcCAoc2VlIGFib3ZlKVxuICAgKiBAcGFyYW0ge09iamVjdH0gdXBkYXRlcnMgLSBzZXBhcmF0ZSBtYXAgb2YgdXBkYXRlIGZ1bmN0aW9ucyAoZGVwcmVjYXRlZClcbiAgICovXG4gIGFkZEluc3RhbmNlZChhdHRyaWJ1dGVzLCB1cGRhdGVycyA9IHt9KSB7XG4gICAgdGhpcy5fYWRkKGF0dHJpYnV0ZXMsIHVwZGF0ZXJzLCB7aW5zdGFuY2VkOiAxfSk7XG4gIH1cblxuICAvLyBQUklWQVRFIE1FVEhPRFNcblxuICAvLyBEZWZhdWx0IGxvZ2dlclxuICBfZGVmYXVsdExvZyhsZXZlbCwgbWVzc2FnZSkge1xuICAgIGxvZy5sb2cobGV2ZWwsIG1lc3NhZ2UpO1xuICB9XG5cbiAgLy8gVXNlZCB0byByZWdpc3RlciBhbiBhdHRyaWJ1dGVcbiAgX2FkZChhdHRyaWJ1dGVzLCB1cGRhdGVycyA9IHt9LCBfZXh0cmFQcm9wcyA9IHt9KSB7XG5cbiAgICBjb25zdCBuZXdBdHRyaWJ1dGVzID0ge307XG5cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgLy8gc3VwcG9ydCBmb3Igc2VwYXJhdGUgdXBkYXRlIGZ1bmN0aW9uIG1hcFxuICAgICAgLy8gRm9yIG5vdywganVzdCBjb3B5IGFueSBhdHRyaWJ1dGVzIGZyb20gdGhhdCBtYXAgaW50byB0aGUgbWFpbiBtYXBcbiAgICAgIC8vIFRPRE8gLSBBdHRyaWJ1dGUgbWFwcyBhcmUgYSBkZXByZWNhdGVkIGZlYXR1cmUsIHJlbW92ZVxuICAgICAgaWYgKGF0dHJpYnV0ZU5hbWUgaW4gdXBkYXRlcnMpIHtcbiAgICAgICAgYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSA9XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSwgdXBkYXRlcnNbYXR0cmlidXRlTmFtZV0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuXG4gICAgICBjb25zdCBpc0luZGV4ZWQgPSBhdHRyaWJ1dGUuaXNJbmRleGVkIHx8IGF0dHJpYnV0ZS5lbGVtZW50cztcbiAgICAgIGNvbnN0IHNpemUgPSAoYXR0cmlidXRlLmVsZW1lbnRzICYmIDEpIHx8IGF0dHJpYnV0ZS5zaXplO1xuICAgICAgY29uc3QgdmFsdWUgPSBhdHRyaWJ1dGUudmFsdWUgfHwgbnVsbDtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgYXR0cmlidXRlIGRlc2NyaXB0b3IsIHdpdGggV2ViR0wgYW5kIG1ldGFkYXRhIGZpZWxkc1xuICAgICAgY29uc3QgYXR0cmlidXRlRGF0YSA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBFbnN1cmUgdGhhdCBmaWVsZHMgYXJlIHByZXNlbnQgYmVmb3JlIE9iamVjdC5zZWFsKClcbiAgICAgICAgICB0YXJnZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICB1c2VyRGF0YToge30gICAgICAgIC8vIFJlc2VydmVkIGZvciBhcHBsaWNhdGlvblxuICAgICAgICB9LFxuICAgICAgICAvLyBNZXRhZGF0YVxuICAgICAgICBhdHRyaWJ1dGUsXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBTdGF0ZVxuICAgICAgICAgIGlzRXh0ZXJuYWxCdWZmZXI6IGZhbHNlLFxuICAgICAgICAgIG5lZWRzQWxsb2M6IGZhbHNlLFxuICAgICAgICAgIG5lZWRzVXBkYXRlOiBmYWxzZSxcbiAgICAgICAgICBjaGFuZ2VkOiBmYWxzZSxcblxuICAgICAgICAgIC8vIEx1bWEgZmllbGRzXG4gICAgICAgICAgaXNJbmRleGVkLFxuICAgICAgICAgIHNpemUsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSxcbiAgICAgICAgX2V4dHJhUHJvcHNcbiAgICAgICk7XG4gICAgICAvLyBTYW5pdHkgLSBubyBhcHAgZmllbGRzIG9uIG91ciBhdHRyaWJ1dGVzLiBVc2UgdXNlckRhdGEgaW5zdGVhZC5cbiAgICAgIE9iamVjdC5zZWFsKGF0dHJpYnV0ZURhdGEpO1xuXG4gICAgICAvLyBDaGVjayBhbGwgZmllbGRzIGFuZCBnZW5lcmF0ZSBoZWxwZnVsIGVycm9yIG1lc3NhZ2VzXG4gICAgICB0aGlzLl92YWxpZGF0ZUF0dHJpYnV0ZURlZmluaXRpb24oYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlRGF0YSk7XG5cbiAgICAgIC8vIEFkZCB0byBib3RoIGF0dHJpYnV0ZXMgbGlzdCAoZm9yIHJlZ2lzdHJhdGlvbiB3aXRoIG1vZGVsKVxuICAgICAgbmV3QXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSA9IGF0dHJpYnV0ZURhdGE7XG4gICAgfVxuXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLmF0dHJpYnV0ZXMsIG5ld0F0dHJpYnV0ZXMpO1xuXG4gICAgdGhpcy5fbWFwVXBkYXRlVHJpZ2dlcnNUb0F0dHJpYnV0ZXMoKTtcbiAgfVxuXG4gIC8vIGJ1aWxkIHVwZGF0ZVRyaWdnZXIgbmFtZSB0byBhdHRyaWJ1dGUgbmFtZSBtYXBwaW5nXG4gIF9tYXBVcGRhdGVUcmlnZ2Vyc1RvQXR0cmlidXRlcygpIHtcbiAgICBjb25zdCB0cmlnZ2VycyA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgbGV0IHthY2Nlc3Nvcn0gPSBhdHRyaWJ1dGU7XG5cbiAgICAgIC8vIHVzZSBhdHRyaWJ1dGUgbmFtZSBhcyB1cGRhdGUgdHJpZ2dlciBrZXlcbiAgICAgIHRyaWdnZXJzW2F0dHJpYnV0ZU5hbWVdID0gW2F0dHJpYnV0ZU5hbWVdO1xuXG4gICAgICAvLyB1c2UgYWNjZXNzb3IgbmFtZSBhcyB1cGRhdGUgdHJpZ2dlciBrZXlcbiAgICAgIGlmICh0eXBlb2YgYWNjZXNzb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGFjY2Vzc29yID0gW2FjY2Vzc29yXTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFjY2Vzc29yKSkge1xuICAgICAgICBhY2Nlc3Nvci5mb3JFYWNoKGFjY2Vzc29yTmFtZSA9PiB7XG4gICAgICAgICAgaWYgKCF0cmlnZ2Vyc1thY2Nlc3Nvck5hbWVdKSB7XG4gICAgICAgICAgICB0cmlnZ2Vyc1thY2Nlc3Nvck5hbWVdID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyaWdnZXJzW2FjY2Vzc29yTmFtZV0ucHVzaChhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVUcmlnZ2VycyA9IHRyaWdnZXJzO1xuICB9XG5cbiAgX3ZhbGlkYXRlQXR0cmlidXRlRGVmaW5pdGlvbihhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGUpIHtcbiAgICBhc3NlcnQoYXR0cmlidXRlLnNpemUgPj0gMSAmJiBhdHRyaWJ1dGUuc2l6ZSA8PSA0LFxuICAgICAgYEF0dHJpYnV0ZSBkZWZpbml0aW9uIGZvciAke2F0dHJpYnV0ZU5hbWV9IGludmFsaWQgc2l6ZWApO1xuXG4gICAgLy8gQ2hlY2sgdGhhdCBlaXRoZXIgJ2FjY2Vzc29yJyBvciAndXBkYXRlJyBpcyBhIHZhbGlkIGZ1bmN0aW9uXG4gICAgY29uc3QgaGFzVXBkYXRlciA9IGF0dHJpYnV0ZS5ub0FsbG9jIHx8XG4gICAgICB0eXBlb2YgYXR0cmlidXRlLnVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIGF0dHJpYnV0ZS5hY2Nlc3NvciA9PT0gJ3N0cmluZyc7XG4gICAgaWYgKCFoYXNVcGRhdGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEF0dHJpYnV0ZSAke2F0dHJpYnV0ZU5hbWV9IG1pc3NpbmcgdXBkYXRlIG9yIGFjY2Vzc29yYCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2tzIHRoYXQgYW55IGF0dHJpYnV0ZSBidWZmZXJzIGluIHByb3BzIGFyZSB2YWxpZFxuICAvLyBOb3RlOiBUaGlzIGlzIGp1c3QgdG8gaGVscCBhcHAgY2F0Y2ggbWlzdGFrZXNcbiAgX2NoZWNrRXh0ZXJuYWxCdWZmZXJzKHtcbiAgICBidWZmZXJzID0ge30sXG4gICAgaWdub3JlVW5rbm93bkF0dHJpYnV0ZXMgPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICBjb25zdCB7YXR0cmlidXRlc30gPSB0aGlzO1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBidWZmZXJzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgaWYgKCFhdHRyaWJ1dGUgJiYgIWlnbm9yZVVua25vd25BdHRyaWJ1dGVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBhdHRyaWJ1dGUgcHJvcCAke2F0dHJpYnV0ZU5hbWV9YCk7XG4gICAgICB9XG4gICAgICAvLyBjb25zdCBidWZmZXIgPSBidWZmZXJzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgLy8gVE9ETyAtIGNoZWNrIGJ1ZmZlciB0eXBlXG4gICAgfVxuICB9XG5cbiAgLy8gU2V0IHRoZSBidWZmZXJzIGZvciB0aGUgc3VwcGxpZWQgYXR0cmlidXRlc1xuICAvLyBVcGRhdGUgYXR0cmlidXRlIGJ1ZmZlcnMgZnJvbSBhbnkgYXR0cmlidXRlcyBpbiBwcm9wc1xuICAvLyBEZXRhY2ggYW55IHByZXZpb3VzbHkgc2V0IGJ1ZmZlcnMsIG1hcmtpbmcgYWxsXG4gIC8vIEF0dHJpYnV0ZXMgZm9yIGF1dG8gYWxsb2NhdGlvblxuICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuICBfc2V0RXh0ZXJuYWxCdWZmZXJzKGJ1ZmZlck1hcCkge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVzLCBudW1JbnN0YW5jZXN9ID0gdGhpcztcblxuICAgIC8vIENvcHkgdGhlIHJlZnMgb2YgYW55IHN1cHBsaWVkIGJ1ZmZlcnMgaW4gdGhlIHByb3BzXG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICBjb25zdCBidWZmZXIgPSBidWZmZXJNYXBbYXR0cmlidXRlTmFtZV07XG4gICAgICBhdHRyaWJ1dGUuaXNFeHRlcm5hbEJ1ZmZlciA9IGZhbHNlO1xuICAgICAgaWYgKGJ1ZmZlcikge1xuICAgICAgICBpZiAoIShidWZmZXIgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRyaWJ1dGUgcHJvcGVydGllcyBtdXN0IGJlIG9mIHR5cGUgRmxvYXQzMkFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJpYnV0ZS5hdXRvICYmIGJ1ZmZlci5sZW5ndGggPD0gbnVtSW5zdGFuY2VzICogYXR0cmlidXRlLnNpemUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dHJpYnV0ZSBwcm9wIGFycmF5IG11c3QgbWF0Y2ggbGVuZ3RoIGFuZCBzaXplJyk7XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyaWJ1dGUuaXNFeHRlcm5hbEJ1ZmZlciA9IHRydWU7XG4gICAgICAgIGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICBpZiAoYXR0cmlidXRlLnZhbHVlICE9PSBidWZmZXIpIHtcbiAgICAgICAgICBhdHRyaWJ1dGUudmFsdWUgPSBidWZmZXI7XG4gICAgICAgICAgYXR0cmlidXRlLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMubmVlZHNSZWRyYXcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMgKi9cblxuICAvKiBDaGVja3MgdGhhdCB0eXBlZCBhcnJheXMgZm9yIGF0dHJpYnV0ZXMgYXJlIGJpZyBlbm91Z2hcbiAgICogc2V0cyBhbGxvYyBmbGFnIGlmIG5vdFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIGFueSB1cGRhdGVzIGFyZSBuZWVkZWRcbiAgICovXG4gIF9hbmFseXplQnVmZmVycyh7bnVtSW5zdGFuY2VzfSkge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVzfSA9IHRoaXM7XG4gICAgYXNzZXJ0KG51bUluc3RhbmNlcyAhPT0gdW5kZWZpbmVkLCAnbnVtSW5zdGFuY2VzIG5vdCBkZWZpbmVkJyk7XG5cbiAgICAvLyBUcmFjayB3aGV0aGVyIGFueSBhbGxvY2F0aW9ucyBvciB1cGRhdGVzIGFyZSBuZWVkZWRcbiAgICBsZXQgbmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgaWYgKCFhdHRyaWJ1dGUuaXNFeHRlcm5hbEJ1ZmZlcikge1xuICAgICAgICAvLyBEbyB3ZSBuZWVkIHRvIHJlYWxsb2NhdGUgdGhlIGF0dHJpYnV0ZSdzIHR5cGVkIGFycmF5P1xuICAgICAgICBjb25zdCBuZWVkc0FsbG9jID1cbiAgICAgICAgICBhdHRyaWJ1dGUudmFsdWUgPT09IG51bGwgfHxcbiAgICAgICAgICBhdHRyaWJ1dGUudmFsdWUubGVuZ3RoIC8gYXR0cmlidXRlLnNpemUgPCBudW1JbnN0YW5jZXM7XG4gICAgICAgIGlmIChuZWVkc0FsbG9jICYmIChhdHRyaWJ1dGUudXBkYXRlIHx8IGF0dHJpYnV0ZS5hY2Nlc3NvcikpIHtcbiAgICAgICAgICBhdHRyaWJ1dGUubmVlZHNBbGxvYyA9IHRydWU7XG4gICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyaWJ1dGUubmVlZHNVcGRhdGUpIHtcbiAgICAgICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmVlZHNVcGRhdGU7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQ2FsbHMgdXBkYXRlIG9uIGFueSBidWZmZXJzIHRoYXQgbmVlZCB1cGRhdGVcbiAgICogVE9ETz8gLSBJZiBhcHAgc3VwcGxpZWQgYWxsIGF0dHJpYnV0ZXMsIG5vIG5lZWQgdG8gaXRlcmF0ZSBvdmVyIGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmRhdGEgLSBkYXRhIChpdGVyYWJsZSBvYmplY3QpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLm51bUluc3RhbmNlcyAtIGNvdW50IG9mIGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuYnVmZmVycyA9IHt9IC0gcHJlLWFsbG9jYXRlZCBidWZmZXJzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLnByb3BzIC0gcGFzc2VkIHRvIHVwZGF0ZXJzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmNvbnRleHQgLSBVc2VkIGFzIFwidGhpc1wiIGNvbnRleHQgZm9yIHVwZGF0ZXJzXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cywgY29tcGxleGl0eSAqL1xuICBfdXBkYXRlQnVmZmVycyh7bnVtSW5zdGFuY2VzLCBkYXRhLCBwcm9wcywgY29udGV4dH0pIHtcbiAgICBjb25zdCB7YXR0cmlidXRlc30gPSB0aGlzO1xuXG4gICAgLy8gQWxsb2NhdGUgYXQgbGVhc3Qgb25lIGVsZW1lbnQgdG8gZW5zdXJlIGEgdmFsaWQgYnVmZmVyXG4gICAgY29uc3QgYWxsb2NDb3VudCA9IE1hdGgubWF4KG51bUluc3RhbmNlcywgMSk7XG5cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcblxuICAgICAgLy8gQWxsb2NhdGUgYSBuZXcgdHlwZWQgYXJyYXkgaWYgbmVlZGVkXG4gICAgICBpZiAoYXR0cmlidXRlLm5lZWRzQWxsb2MpIHtcbiAgICAgICAgY29uc3QgQXJyYXlUeXBlID0gZ2xBcnJheUZyb21UeXBlKGF0dHJpYnV0ZS50eXBlIHx8IEdMLkZMT0FUKTtcbiAgICAgICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IEFycmF5VHlwZShhdHRyaWJ1dGUuc2l6ZSAqIGFsbG9jQ291bnQpO1xuICAgICAgICB0aGlzLm9uTG9nKDIsIGAke3RoaXMuaWR9OiR7YXR0cmlidXRlTmFtZX0gYWxsb2NhdGVkICR7YWxsb2NDb3VudH1gKTtcbiAgICAgICAgYXR0cmlidXRlLm5lZWRzQWxsb2MgPSBmYWxzZTtcbiAgICAgICAgYXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2FsbCB1cGRhdGVyIGZ1bmN0aW9uIGlmIG5lZWRlZFxuICAgICAgaWYgKGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSkge1xuICAgICAgICB0aGlzLl91cGRhdGVCdWZmZXIoe2F0dHJpYnV0ZSwgYXR0cmlidXRlTmFtZSwgbnVtSW5zdGFuY2VzLCBkYXRhLCBwcm9wcywgY29udGV4dH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYWxsb2NlZEluc3RhbmNlcyA9IGFsbG9jQ291bnQ7XG4gIH1cblxuICBfdXBkYXRlQnVmZmVyKHthdHRyaWJ1dGUsIGF0dHJpYnV0ZU5hbWUsIG51bUluc3RhbmNlcywgZGF0YSwgcHJvcHMsIGNvbnRleHR9KSB7XG4gICAgY29uc3Qge3VwZGF0ZSwgYWNjZXNzb3J9ID0gYXR0cmlidXRlO1xuICAgIGlmICh1cGRhdGUpIHtcbiAgICAgIC8vIEN1c3RvbSB1cGRhdGVyIC0gdHlwaWNhbGx5IGZvciBub24taW5zdGFuY2VkIGxheWVyc1xuICAgICAgdGhpcy5vbkxvZygyLCBgJHt0aGlzLmlkfToke2F0dHJpYnV0ZU5hbWV9IHVwZGF0aW5nICR7bnVtSW5zdGFuY2VzfWApO1xuICAgICAgdXBkYXRlLmNhbGwoY29udGV4dCwgYXR0cmlidXRlLCB7ZGF0YSwgcHJvcHMsIG51bUluc3RhbmNlc30pO1xuICAgICAgdGhpcy5fY2hlY2tBdHRyaWJ1dGVBcnJheShhdHRyaWJ1dGUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYWNjZXNzb3IpIHtcbiAgICAgIC8vIFN0YW5kYXJkIHVwZGF0ZXJcbiAgICAgIHRoaXMuX3VwZGF0ZUJ1ZmZlclZpYVN0YW5kYXJkQWNjZXNzb3Ioe2F0dHJpYnV0ZSwgZGF0YSwgcHJvcHN9KTtcbiAgICAgIHRoaXMuX2NoZWNrQXR0cmlidXRlQXJyYXkoYXR0cmlidXRlLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbkxvZygyLCBgJHt0aGlzLmlkfToke2F0dHJpYnV0ZU5hbWV9IG1pc3NpbmcgdXBkYXRlIGZ1bmN0aW9uYCk7XG4gICAgfVxuXG4gICAgYXR0cmlidXRlLm5lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgYXR0cmlidXRlLmNoYW5nZWQgPSB0cnVlO1xuICAgIHRoaXMubmVlZHNSZWRyYXcgPSB0cnVlO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMgKi9cblxuICBfdXBkYXRlQnVmZmVyVmlhU3RhbmRhcmRBY2Nlc3Nvcih7YXR0cmlidXRlLCBkYXRhLCBwcm9wc30pIHtcbiAgICBjb25zdCB7YWNjZXNzb3IsIHZhbHVlLCBzaXplfSA9IGF0dHJpYnV0ZTtcbiAgICBjb25zdCBhY2Nlc3NvckZ1bmMgPSBwcm9wc1thY2Nlc3Nvcl07XG5cbiAgICBhc3NlcnQodHlwZW9mIGFjY2Vzc29yRnVuYyA9PT0gJ2Z1bmN0aW9uJywgYGFjY2Vzc29yIFwiJHthY2Nlc3Nvcn1cIiBpcyBub3QgYSBmdW5jdGlvbmApO1xuXG4gICAgbGV0IHtkZWZhdWx0VmFsdWUgPSBbMCwgMCwgMCwgMF19ID0gYXR0cmlidXRlO1xuICAgIGRlZmF1bHRWYWx1ZSA9IEFycmF5LmlzQXJyYXkoZGVmYXVsdFZhbHVlKSA/IGRlZmF1bHRWYWx1ZSA6IFtkZWZhdWx0VmFsdWVdO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBkYXRhKSB7XG4gICAgICBsZXQgb2JqZWN0VmFsdWUgPSBhY2Nlc3NvckZ1bmMob2JqZWN0KTtcbiAgICAgIG9iamVjdFZhbHVlID0gQXJyYXkuaXNBcnJheShvYmplY3RWYWx1ZSkgPyBvYmplY3RWYWx1ZSA6IFtvYmplY3RWYWx1ZV07XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1mYWxsdGhyb3VnaCwgZGVmYXVsdC1jYXNlICovXG4gICAgICBzd2l0Y2ggKHNpemUpIHtcbiAgICAgIGNhc2UgNDogdmFsdWVbaSArIDNdID0gTnVtYmVyLmlzRmluaXRlKG9iamVjdFZhbHVlWzNdKSA/IG9iamVjdFZhbHVlWzNdIDogZGVmYXVsdFZhbHVlWzNdO1xuICAgICAgY2FzZSAzOiB2YWx1ZVtpICsgMl0gPSBOdW1iZXIuaXNGaW5pdGUob2JqZWN0VmFsdWVbMl0pID8gb2JqZWN0VmFsdWVbMl0gOiBkZWZhdWx0VmFsdWVbMl07XG4gICAgICBjYXNlIDI6IHZhbHVlW2kgKyAxXSA9IE51bWJlci5pc0Zpbml0ZShvYmplY3RWYWx1ZVsxXSkgPyBvYmplY3RWYWx1ZVsxXSA6IGRlZmF1bHRWYWx1ZVsxXTtcbiAgICAgIGNhc2UgMTogdmFsdWVbaSArIDBdID0gTnVtYmVyLmlzRmluaXRlKG9iamVjdFZhbHVlWzBdKSA/IG9iamVjdFZhbHVlWzBdIDogZGVmYXVsdFZhbHVlWzBdO1xuICAgICAgfVxuICAgICAgaSArPSBzaXplO1xuICAgIH1cbiAgfVxuXG4gIF9jaGVja0F0dHJpYnV0ZUFycmF5KGF0dHJpYnV0ZSwgYXR0cmlidXRlTmFtZSkge1xuICAgIGNvbnN0IHt2YWx1ZX0gPSBhdHRyaWJ1dGU7XG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLmxlbmd0aCA+PSA0KSB7XG4gICAgICBjb25zdCB2YWxpZCA9XG4gICAgICAgIE51bWJlci5pc0Zpbml0ZSh2YWx1ZVswXSkgJiYgTnVtYmVyLmlzRmluaXRlKHZhbHVlWzFdKSAmJlxuICAgICAgICBOdW1iZXIuaXNGaW5pdGUodmFsdWVbMl0pICYmIE51bWJlci5pc0Zpbml0ZSh2YWx1ZVszXSk7XG4gICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSWxsZWdhbCBhdHRyaWJ1dGUgZ2VuZXJhdGVkIGZvciAke2F0dHJpYnV0ZU5hbWV9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9saWIvYXR0cmlidXRlLW1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 28 */
/* exports provided: default */
/* exports used: default */
/*!******************************!*\
  !*** ./src/lib/utils/log.js ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_assert__ = __webpack_require__(/*! assert */ 6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_assert__);\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = log;\n/* eslint-disable no-console */\n/* global console */\n\n\nfunction log(priority, ...args) {\n  __WEBPACK_IMPORTED_MODULE_0_assert___default()(Number.isFinite(priority), 'log priority must be a number');\n  if (priority <= log.priority) {\n    // Node doesn't have console.debug, but looks better in browser consoles\n    if (console.debug) {\n      console.debug(...args);\n    } else {\n      console.info(...args);\n    }\n  }\n}\n\nconst cache = {};\n\nfunction once(priority, arg, ...args) {\n  if (!cache[arg] && priority <= log.priority) {\n    console.warn(...[arg, ...args]);\n    cache[arg] = true;\n  }\n}\n\nlog.priority = 0;\nlog.log = log;\nlog.once = once;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL3V0aWxzL2xvZy5qcz9mMmY2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbi8qIGdsb2JhbCBjb25zb2xlICovXG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxvZyhwcmlvcml0eSwgLi4uYXJncykge1xuICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKHByaW9yaXR5KSwgJ2xvZyBwcmlvcml0eSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIGlmIChwcmlvcml0eSA8PSBsb2cucHJpb3JpdHkpIHtcbiAgICAvLyBOb2RlIGRvZXNuJ3QgaGF2ZSBjb25zb2xlLmRlYnVnLCBidXQgbG9va3MgYmV0dGVyIGluIGJyb3dzZXIgY29uc29sZXNcbiAgICBpZiAoY29uc29sZS5kZWJ1Zykge1xuICAgICAgY29uc29sZS5kZWJ1ZyguLi5hcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5pbmZvKC4uLmFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBjYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBvbmNlKHByaW9yaXR5LCBhcmcsIC4uLmFyZ3MpIHtcbiAgaWYgKCFjYWNoZVthcmddICYmIHByaW9yaXR5IDw9IGxvZy5wcmlvcml0eSkge1xuICAgIGNvbnNvbGUud2FybiguLi5bYXJnLCAuLi5hcmdzXSk7XG4gICAgY2FjaGVbYXJnXSA9IHRydWU7XG4gIH1cbn1cblxubG9nLnByaW9yaXR5ID0gMDtcbmxvZy5sb2cgPSBsb2c7XG5sb2cub25jZSA9IG9uY2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9saWIvdXRpbHMvbG9nLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 29 */
/* exports provided: default */
/* exports used: default */
/*!*******************************!*\
  !*** ./src/react/autobind.js ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (immutable) */ __webpack_exports__[\"a\"] = autobind;\nconst PREDEFINED = [\n  'constructor', 'render', 'componentWillMount', 'componentDidMount',\n  'componentWillReceiveProps', 'shouldComponentUpdate', 'componentWillUpdate',\n  'componentDidUpdate', 'componentWillUnmount'\n];\n\n/**\n * Binds the \"this\" argument of all functions on a class instance to the instance\n * @param {Object} obj - class instance (typically a react component)\n */\nfunction autobind(obj) {\n  const proto = Object.getPrototypeOf(obj);\n  const propNames = Object.getOwnPropertyNames(proto);\n  for (const key of propNames) {\n    if (typeof obj[key] === 'function') {\n      if (!PREDEFINED.find(name => key === name)) {\n        obj[key] = obj[key].bind(obj);\n      }\n    }\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcmVhY3QvYXV0b2JpbmQuanM/YmJhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBQUkVERUZJTkVEID0gW1xuICAnY29uc3RydWN0b3InLCAncmVuZGVyJywgJ2NvbXBvbmVudFdpbGxNb3VudCcsICdjb21wb25lbnREaWRNb3VudCcsXG4gICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJywgJ3Nob3VsZENvbXBvbmVudFVwZGF0ZScsICdjb21wb25lbnRXaWxsVXBkYXRlJyxcbiAgJ2NvbXBvbmVudERpZFVwZGF0ZScsICdjb21wb25lbnRXaWxsVW5tb3VudCdcbl07XG5cbi8qKlxuICogQmluZHMgdGhlIFwidGhpc1wiIGFyZ3VtZW50IG9mIGFsbCBmdW5jdGlvbnMgb24gYSBjbGFzcyBpbnN0YW5jZSB0byB0aGUgaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBjbGFzcyBpbnN0YW5jZSAodHlwaWNhbGx5IGEgcmVhY3QgY29tcG9uZW50KVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhdXRvYmluZChvYmopIHtcbiAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgY29uc3QgcHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pO1xuICBmb3IgKGNvbnN0IGtleSBvZiBwcm9wTmFtZXMpIHtcbiAgICBpZiAodHlwZW9mIG9ialtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoIVBSRURFRklORUQuZmluZChuYW1lID0+IGtleSA9PT0gbmFtZSkpIHtcbiAgICAgICAgb2JqW2tleV0gPSBvYmpba2V5XS5iaW5kKG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9yZWFjdC9hdXRvYmluZC5qc1xuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 30 */
/* exports provided: fp64, project, project64, lighting */
/* all exports used */
/*!*******************************************!*\
  !*** ./src/shader-utils/shader-chunks.js ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shaderlib_fp64__ = __webpack_require__(/*! ../shaderlib/fp64 */ 107);\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, \"fp64\", function() { return __WEBPACK_IMPORTED_MODULE_0__shaderlib_fp64__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shaderlib_project__ = __webpack_require__(/*! ../shaderlib/project */ 111);\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, \"project\", function() { return __WEBPACK_IMPORTED_MODULE_1__shaderlib_project__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shaderlib_project64__ = __webpack_require__(/*! ../shaderlib/project64 */ 113);\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, \"project64\", function() { return __WEBPACK_IMPORTED_MODULE_2__shaderlib_project64__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__shaderlib_lighting__ = __webpack_require__(/*! ../shaderlib/lighting */ 109);\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, \"lighting\", function() { return __WEBPACK_IMPORTED_MODULE_3__shaderlib_lighting__[\"a\"]; });\n// Load shader chunks\n\n\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2hhZGVyLXV0aWxzL3NoYWRlci1jaHVua3MuanM/YzIwZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBMb2FkIHNoYWRlciBjaHVua3NcbmV4cG9ydCAqIGZyb20gJy4uL3NoYWRlcmxpYi9mcDY0JztcbmV4cG9ydCAqIGZyb20gJy4uL3NoYWRlcmxpYi9wcm9qZWN0JztcbmV4cG9ydCAqIGZyb20gJy4uL3NoYWRlcmxpYi9wcm9qZWN0NjQnO1xuZXhwb3J0ICogZnJvbSAnLi4vc2hhZGVybGliL2xpZ2h0aW5nJztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3NoYWRlci11dGlscy9zaGFkZXItY2h1bmtzLmpzXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 31 */
/* exports provided: defaultColorRange */
/* exports used: defaultColorRange */
/*!**********************************!*\
  !*** ./src/utils/color-utils.js ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("const defaultColorRange = [\n  [255, 255, 178],\n  [254, 217, 118],\n  [254, 178, 76],\n  [253, 141, 60],\n  [240, 59, 32],\n  [189, 0, 38]\n];\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = defaultColorRange;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvY29sb3ItdXRpbHMuanM/MjMyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgZGVmYXVsdENvbG9yUmFuZ2UgPSBbXG4gIFsyNTUsIDI1NSwgMTc4XSxcbiAgWzI1NCwgMjE3LCAxMThdLFxuICBbMjU0LCAxNzgsIDc2XSxcbiAgWzI1MywgMTQxLCA2MF0sXG4gIFsyNDAsIDU5LCAzMl0sXG4gIFsxODksIDAsIDM4XVxuXTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3V0aWxzL2NvbG9yLXV0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 32 */
/* exports provided: linearScale, quantizeScale, clamp */
/* exports used: quantizeScale, linearScale */
/*!**********************************!*\
  !*** ./src/utils/scale-utils.js ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (immutable) */ __webpack_exports__[\"b\"] = linearScale;\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = quantizeScale;\n/* unused harmony export clamp */\n// Linear scale maps continuous domain to continuous range\nfunction linearScale(domain, range, value) {\n\n  return (value - domain[0]) / (domain[1] - domain[0]) * (range[1] - range[0]) + range[0];\n}\n\n// Quantize scale is similar to linear scales,\n// except it uses a discrete rather than continuous range\nfunction quantizeScale(domain, range, value) {\n  const step = (domain[1] - domain[0]) / range.length;\n  const idx = Math.floor((value - domain[0]) / step);\n  const clampIdx = Math.max(Math.min(idx, range.length - 1), 0);\n\n  return range[clampIdx];\n}\n\nfunction clamp([min, max], value) {\n  return Math.min(max, Math.max(min, value));\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvc2NhbGUtdXRpbHMuanM/YTQ4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBMaW5lYXIgc2NhbGUgbWFwcyBjb250aW51b3VzIGRvbWFpbiB0byBjb250aW51b3VzIHJhbmdlXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyU2NhbGUoZG9tYWluLCByYW5nZSwgdmFsdWUpIHtcblxuICByZXR1cm4gKHZhbHVlIC0gZG9tYWluWzBdKSAvIChkb21haW5bMV0gLSBkb21haW5bMF0pICogKHJhbmdlWzFdIC0gcmFuZ2VbMF0pICsgcmFuZ2VbMF07XG59XG5cbi8vIFF1YW50aXplIHNjYWxlIGlzIHNpbWlsYXIgdG8gbGluZWFyIHNjYWxlcyxcbi8vIGV4Y2VwdCBpdCB1c2VzIGEgZGlzY3JldGUgcmF0aGVyIHRoYW4gY29udGludW91cyByYW5nZVxuZXhwb3J0IGZ1bmN0aW9uIHF1YW50aXplU2NhbGUoZG9tYWluLCByYW5nZSwgdmFsdWUpIHtcbiAgY29uc3Qgc3RlcCA9IChkb21haW5bMV0gLSBkb21haW5bMF0pIC8gcmFuZ2UubGVuZ3RoO1xuICBjb25zdCBpZHggPSBNYXRoLmZsb29yKCh2YWx1ZSAtIGRvbWFpblswXSkgLyBzdGVwKTtcbiAgY29uc3QgY2xhbXBJZHggPSBNYXRoLm1heChNYXRoLm1pbihpZHgsIHJhbmdlLmxlbmd0aCAtIDEpLCAwKTtcblxuICByZXR1cm4gcmFuZ2VbY2xhbXBJZHhdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xhbXAoW21pbiwgbWF4XSwgdmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgubWluKG1heCwgTWF0aC5tYXgobWluLCB2YWx1ZSkpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdXRpbHMvc2NhbGUtdXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 33 */
/* unknown exports provided */
/* exports used: default */
/*!*************************************!*\
  !*** external "lodash.flattendeep" ***!
  \*************************************/
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_33__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJsb2Rhc2guZmxhdHRlbmRlZXBcIj81M2RhIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zM19fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwibG9kYXNoLmZsYXR0ZW5kZWVwXCJcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 34 */
/* unknown exports provided */
/* exports used: PropTypes, default, createElement */
/*!************************!*\
  !*** external "react" ***!
  \************************/
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_34__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJyZWFjdFwiPzNjNjIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzM0X187XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJyZWFjdFwiXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 35 */
/* exports provided: default */
/* exports used: default */
/*!************************************************!*\
  !*** ./src/layers/core/arc-layer/arc-layer.js ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl__ = __webpack_require__(/*! luma.gl */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__ = __webpack_require__(/*! ../../../lib/utils/fp64 */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__arc_layer_vertex_glsl__ = __webpack_require__(/*! ./arc-layer-vertex.glsl */ 56);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__arc_layer_vertex_64_glsl__ = __webpack_require__(/*! ./arc-layer-vertex-64.glsl */ 55);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__arc_layer_fragment_glsl__ = __webpack_require__(/*! ./arc-layer-fragment.glsl */ 54);\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\n\n\n\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\n\nconst defaultProps = {\n  strokeWidth: 1,\n  fp64: false,\n\n  getSourcePosition: x => x.sourcePosition,\n  getTargetPosition: x => x.targetPosition,\n  getSourceColor: x => x.color || DEFAULT_COLOR,\n  getTargetColor: x => x.color || DEFAULT_COLOR\n};\n\nclass ArcLayer extends __WEBPACK_IMPORTED_MODULE_0__lib__[\"a\" /* Layer */] {\n  getShaders() {\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__[\"b\" /* enable64bitSupport */])(this.props) ? {\n      vs: __WEBPACK_IMPORTED_MODULE_5__arc_layer_vertex_64_glsl__[\"a\" /* default */], fs: __WEBPACK_IMPORTED_MODULE_6__arc_layer_fragment_glsl__[\"a\" /* default */], modules: ['fp64', 'project64']\n    } : {\n      vs: __WEBPACK_IMPORTED_MODULE_4__arc_layer_vertex_glsl__[\"a\" /* default */], fs: __WEBPACK_IMPORTED_MODULE_6__arc_layer_fragment_glsl__[\"a\" /* default */], modules: []\n    };\n  }\n\n  initializeState() {\n    const {gl} = this.context;\n    this.setState({model: this._getModel(gl)});\n\n    const {attributeManager} = this.state;\n\n    /* eslint-disable max-len */\n    attributeManager.addInstanced({\n      instancePositions: {size: 4, accessor: ['getSourcePosition', 'getTargetPosition'], update: this.calculateInstancePositions},\n      instanceSourceColors: {size: 4, type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].UNSIGNED_BYTE, accessor: 'getSourceColor', update: this.calculateInstanceSourceColors},\n      instanceTargetColors: {size: 4, type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].UNSIGNED_BYTE, accessor: 'getTargetColor', update: this.calculateInstanceTargetColors}\n    });\n    /* eslint-enable max-len */\n  }\n\n  updateAttribute({props, oldProps, changeFlags}) {\n    if (props.fp64 !== oldProps.fp64) {\n      const {attributeManager} = this.state;\n      attributeManager.invalidateAll();\n\n      if (props.fp64 && props.projectionMode === __WEBPACK_IMPORTED_MODULE_0__lib__[\"e\" /* COORDINATE_SYSTEM */].LNG_LAT) {\n        attributeManager.addInstanced({\n          instancePositions64Low: {\n            size: 4,\n            accessor: ['getSourcePosition', 'getTargetPosition'],\n            update: this.calculateInstancePositions64Low\n          }\n        });\n      } else {\n        attributeManager.remove([\n          'instancePositions64Low'\n        ]);\n      }\n\n    }\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    super.updateState({props, oldProps, changeFlags});\n    // Re-generate model if geometry changed\n    if (props.fp64 !== oldProps.fp64) {\n      const {gl} = this.context;\n      this.setState({model: this._getModel(gl)});\n    }\n    this.updateAttribute({props, oldProps, changeFlags});\n  }\n\n  draw({uniforms}) {\n    const {strokeWidth} = this.props;\n\n    this.state.model.render(Object.assign({}, uniforms, {\n      strokeWidth\n    }));\n  }\n\n  _getModel(gl) {\n    let positions = [];\n    const NUM_SEGMENTS = 50;\n    /*\n     *  (0, -1)-------------_(1, -1)\n     *       |          _,-\"  |\n     *       o      _,-\"      o\n     *       |  _,-\"          |\n     *   (0, 1)\"-------------(1, 1)\n     */\n    for (let i = 0; i < NUM_SEGMENTS; i++) {\n      positions = positions.concat([i, -1, 0, i, 1, 0]);\n    }\n\n    const shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"a\" /* assembleShaders */])(gl, this.getShaders());\n\n    const model = new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Model\"]({\n      gl,\n      vs: shaders.vs,\n      fs: shaders.fs,\n      geometry: new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Geometry\"]({\n        drawMode: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].TRIANGLE_STRIP,\n        positions: new Float32Array(positions)\n      }),\n      isInstanced: true\n    });\n\n    model.setUniforms({numSegments: NUM_SEGMENTS});\n\n    return model;\n  }\n\n  calculateInstancePositions(attribute) {\n    const {data, getSourcePosition, getTargetPosition} = this.props;\n    const {value, size} = attribute;\n    let i = 0;\n    for (const object of data) {\n      const sourcePosition = getSourcePosition(object);\n      const targetPosition = getTargetPosition(object);\n      value[i + 0] = sourcePosition[0];\n      value[i + 1] = sourcePosition[1];\n      value[i + 2] = targetPosition[0];\n      value[i + 3] = targetPosition[1];\n      i += size;\n    }\n  }\n\n  calculateInstancePositions64Low(attribute) {\n    const {data, getSourcePosition, getTargetPosition} = this.props;\n    const {value, size} = attribute;\n    let i = 0;\n    for (const object of data) {\n      const sourcePosition = getSourcePosition(object);\n      const targetPosition = getTargetPosition(object);\n      value[i + 0] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__[\"a\" /* fp64ify */])(sourcePosition[0])[1];\n      value[i + 1] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__[\"a\" /* fp64ify */])(sourcePosition[1])[1];\n      value[i + 2] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__[\"a\" /* fp64ify */])(targetPosition[0])[1];\n      value[i + 3] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__[\"a\" /* fp64ify */])(targetPosition[1])[1];\n      i += size;\n    }\n  }\n\n  calculateInstanceSourceColors(attribute) {\n    const {data, getSourceColor} = this.props;\n    const {value, size} = attribute;\n    let i = 0;\n    for (const object of data) {\n      const color = getSourceColor(object);\n      value[i + 0] = color[0];\n      value[i + 1] = color[1];\n      value[i + 2] = color[2];\n      value[i + 3] = isNaN(color[3]) ? 255 : color[3];\n      i += size;\n    }\n  }\n\n  calculateInstanceTargetColors(attribute) {\n    const {data, getTargetColor} = this.props;\n    const {value, size} = attribute;\n    let i = 0;\n    for (const object of data) {\n      const color = getTargetColor(object);\n      value[i + 0] = color[0];\n      value[i + 1] = color[1];\n      value[i + 2] = color[2];\n      value[i + 3] = isNaN(color[3]) ? 255 : color[3];\n      i += size;\n    }\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = ArcLayer;\n\n\nArcLayer.layerName = 'ArcLayer';\nArcLayer.defaultProps = defaultProps;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvYXJjLWxheWVyL2FyYy1sYXllci5qcz8wZmZkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uLy4uLy4uL2xpYic7XG5pbXBvcnQge2Fzc2VtYmxlU2hhZGVyc30gZnJvbSAnLi4vLi4vLi4vc2hhZGVyLXV0aWxzJztcbmltcG9ydCB7R0wsIE1vZGVsLCBHZW9tZXRyeX0gZnJvbSAnbHVtYS5nbCc7XG5pbXBvcnQge2ZwNjRpZnksIGVuYWJsZTY0Yml0U3VwcG9ydH0gZnJvbSAnLi4vLi4vLi4vbGliL3V0aWxzL2ZwNjQnO1xuaW1wb3J0IHtDT09SRElOQVRFX1NZU1RFTX0gZnJvbSAnLi4vLi4vLi4vbGliJztcblxuaW1wb3J0IGFyY1ZlcnRleCBmcm9tICcuL2FyYy1sYXllci12ZXJ0ZXguZ2xzbCc7XG5pbXBvcnQgYXJjVmVydGV4NjQgZnJvbSAnLi9hcmMtbGF5ZXItdmVydGV4LTY0Lmdsc2wnO1xuaW1wb3J0IGFyY0ZyYWdtZW50IGZyb20gJy4vYXJjLWxheWVyLWZyYWdtZW50Lmdsc2wnO1xuXG5jb25zdCBERUZBVUxUX0NPTE9SID0gWzAsIDAsIDAsIDI1NV07XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgc3Ryb2tlV2lkdGg6IDEsXG4gIGZwNjQ6IGZhbHNlLFxuXG4gIGdldFNvdXJjZVBvc2l0aW9uOiB4ID0+IHguc291cmNlUG9zaXRpb24sXG4gIGdldFRhcmdldFBvc2l0aW9uOiB4ID0+IHgudGFyZ2V0UG9zaXRpb24sXG4gIGdldFNvdXJjZUNvbG9yOiB4ID0+IHguY29sb3IgfHwgREVGQVVMVF9DT0xPUixcbiAgZ2V0VGFyZ2V0Q29sb3I6IHggPT4geC5jb2xvciB8fCBERUZBVUxUX0NPTE9SXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcmNMYXllciBleHRlbmRzIExheWVyIHtcbiAgZ2V0U2hhZGVycygpIHtcbiAgICByZXR1cm4gZW5hYmxlNjRiaXRTdXBwb3J0KHRoaXMucHJvcHMpID8ge1xuICAgICAgdnM6IGFyY1ZlcnRleDY0LCBmczogYXJjRnJhZ21lbnQsIG1vZHVsZXM6IFsnZnA2NCcsICdwcm9qZWN0NjQnXVxuICAgIH0gOiB7XG4gICAgICB2czogYXJjVmVydGV4LCBmczogYXJjRnJhZ21lbnQsIG1vZHVsZXM6IFtdXG4gICAgfTtcbiAgfVxuXG4gIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuICAgIHRoaXMuc2V0U3RhdGUoe21vZGVsOiB0aGlzLl9nZXRNb2RlbChnbCl9KTtcblxuICAgIGNvbnN0IHthdHRyaWJ1dGVNYW5hZ2VyfSA9IHRoaXMuc3RhdGU7XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gICAgYXR0cmlidXRlTWFuYWdlci5hZGRJbnN0YW5jZWQoe1xuICAgICAgaW5zdGFuY2VQb3NpdGlvbnM6IHtzaXplOiA0LCBhY2Nlc3NvcjogWydnZXRTb3VyY2VQb3NpdGlvbicsICdnZXRUYXJnZXRQb3NpdGlvbiddLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnN9LFxuICAgICAgaW5zdGFuY2VTb3VyY2VDb2xvcnM6IHtzaXplOiA0LCB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLCBhY2Nlc3NvcjogJ2dldFNvdXJjZUNvbG9yJywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlU291cmNlQ29sb3JzfSxcbiAgICAgIGluc3RhbmNlVGFyZ2V0Q29sb3JzOiB7c2l6ZTogNCwgdHlwZTogR0wuVU5TSUdORURfQllURSwgYWNjZXNzb3I6ICdnZXRUYXJnZXRDb2xvcicsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVRhcmdldENvbG9yc31cbiAgICB9KTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cbiAgfVxuXG4gIHVwZGF0ZUF0dHJpYnV0ZSh7cHJvcHMsIG9sZFByb3BzLCBjaGFuZ2VGbGFnc30pIHtcbiAgICBpZiAocHJvcHMuZnA2NCAhPT0gb2xkUHJvcHMuZnA2NCkge1xuICAgICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZUFsbCgpO1xuXG4gICAgICBpZiAocHJvcHMuZnA2NCAmJiBwcm9wcy5wcm9qZWN0aW9uTW9kZSA9PT0gQ09PUkRJTkFURV9TWVNURU0uTE5HX0xBVCkge1xuICAgICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICAgICAgaW5zdGFuY2VQb3NpdGlvbnM2NExvdzoge1xuICAgICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICAgIGFjY2Vzc29yOiBbJ2dldFNvdXJjZVBvc2l0aW9uJywgJ2dldFRhcmdldFBvc2l0aW9uJ10sXG4gICAgICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnM2NExvd1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyaWJ1dGVNYW5hZ2VyLnJlbW92ZShbXG4gICAgICAgICAgJ2luc3RhbmNlUG9zaXRpb25zNjRMb3cnXG4gICAgICAgIF0pO1xuICAgICAgfVxuXG4gICAgfVxuICB9XG5cbiAgdXBkYXRlU3RhdGUoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KSB7XG4gICAgc3VwZXIudXBkYXRlU3RhdGUoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KTtcbiAgICAvLyBSZS1nZW5lcmF0ZSBtb2RlbCBpZiBnZW9tZXRyeSBjaGFuZ2VkXG4gICAgaWYgKHByb3BzLmZwNjQgIT09IG9sZFByb3BzLmZwNjQpIHtcbiAgICAgIGNvbnN0IHtnbH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICB0aGlzLnNldFN0YXRlKHttb2RlbDogdGhpcy5fZ2V0TW9kZWwoZ2wpfSk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlQXR0cmlidXRlKHtwcm9wcywgb2xkUHJvcHMsIGNoYW5nZUZsYWdzfSk7XG4gIH1cblxuICBkcmF3KHt1bmlmb3Jtc30pIHtcbiAgICBjb25zdCB7c3Ryb2tlV2lkdGh9ID0gdGhpcy5wcm9wcztcblxuICAgIHRoaXMuc3RhdGUubW9kZWwucmVuZGVyKE9iamVjdC5hc3NpZ24oe30sIHVuaWZvcm1zLCB7XG4gICAgICBzdHJva2VXaWR0aFxuICAgIH0pKTtcbiAgfVxuXG4gIF9nZXRNb2RlbChnbCkge1xuICAgIGxldCBwb3NpdGlvbnMgPSBbXTtcbiAgICBjb25zdCBOVU1fU0VHTUVOVFMgPSA1MDtcbiAgICAvKlxuICAgICAqICAoMCwgLTEpLS0tLS0tLS0tLS0tLV8oMSwgLTEpXG4gICAgICogICAgICAgfCAgICAgICAgICBfLC1cIiAgfFxuICAgICAqICAgICAgIG8gICAgICBfLC1cIiAgICAgIG9cbiAgICAgKiAgICAgICB8ICBfLC1cIiAgICAgICAgICB8XG4gICAgICogICAoMCwgMSlcIi0tLS0tLS0tLS0tLS0oMSwgMSlcbiAgICAgKi9cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5VTV9TRUdNRU5UUzsgaSsrKSB7XG4gICAgICBwb3NpdGlvbnMgPSBwb3NpdGlvbnMuY29uY2F0KFtpLCAtMSwgMCwgaSwgMSwgMF0pO1xuICAgIH1cblxuICAgIGNvbnN0IHNoYWRlcnMgPSBhc3NlbWJsZVNoYWRlcnMoZ2wsIHRoaXMuZ2V0U2hhZGVycygpKTtcblxuICAgIGNvbnN0IG1vZGVsID0gbmV3IE1vZGVsKHtcbiAgICAgIGdsLFxuICAgICAgdnM6IHNoYWRlcnMudnMsXG4gICAgICBmczogc2hhZGVycy5mcyxcbiAgICAgIGdlb21ldHJ5OiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICBkcmF3TW9kZTogR0wuVFJJQU5HTEVfU1RSSVAsXG4gICAgICAgIHBvc2l0aW9uczogbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbnMpXG4gICAgICB9KSxcbiAgICAgIGlzSW5zdGFuY2VkOiB0cnVlXG4gICAgfSk7XG5cbiAgICBtb2RlbC5zZXRVbmlmb3Jtcyh7bnVtU2VnbWVudHM6IE5VTV9TRUdNRU5UU30pO1xuXG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnMoYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2RhdGEsIGdldFNvdXJjZVBvc2l0aW9uLCBnZXRUYXJnZXRQb3NpdGlvbn0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHt2YWx1ZSwgc2l6ZX0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IHNvdXJjZVBvc2l0aW9uID0gZ2V0U291cmNlUG9zaXRpb24ob2JqZWN0KTtcbiAgICAgIGNvbnN0IHRhcmdldFBvc2l0aW9uID0gZ2V0VGFyZ2V0UG9zaXRpb24ob2JqZWN0KTtcbiAgICAgIHZhbHVlW2kgKyAwXSA9IHNvdXJjZVBvc2l0aW9uWzBdO1xuICAgICAgdmFsdWVbaSArIDFdID0gc291cmNlUG9zaXRpb25bMV07XG4gICAgICB2YWx1ZVtpICsgMl0gPSB0YXJnZXRQb3NpdGlvblswXTtcbiAgICAgIHZhbHVlW2kgKyAzXSA9IHRhcmdldFBvc2l0aW9uWzFdO1xuICAgICAgaSArPSBzaXplO1xuICAgIH1cbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zNjRMb3coYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2RhdGEsIGdldFNvdXJjZVBvc2l0aW9uLCBnZXRUYXJnZXRQb3NpdGlvbn0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHt2YWx1ZSwgc2l6ZX0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IHNvdXJjZVBvc2l0aW9uID0gZ2V0U291cmNlUG9zaXRpb24ob2JqZWN0KTtcbiAgICAgIGNvbnN0IHRhcmdldFBvc2l0aW9uID0gZ2V0VGFyZ2V0UG9zaXRpb24ob2JqZWN0KTtcbiAgICAgIHZhbHVlW2kgKyAwXSA9IGZwNjRpZnkoc291cmNlUG9zaXRpb25bMF0pWzFdO1xuICAgICAgdmFsdWVbaSArIDFdID0gZnA2NGlmeShzb3VyY2VQb3NpdGlvblsxXSlbMV07XG4gICAgICB2YWx1ZVtpICsgMl0gPSBmcDY0aWZ5KHRhcmdldFBvc2l0aW9uWzBdKVsxXTtcbiAgICAgIHZhbHVlW2kgKyAzXSA9IGZwNjRpZnkodGFyZ2V0UG9zaXRpb25bMV0pWzFdO1xuICAgICAgaSArPSBzaXplO1xuICAgIH1cbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlU291cmNlQ29sb3JzKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtkYXRhLCBnZXRTb3VyY2VDb2xvcn0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHt2YWx1ZSwgc2l6ZX0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gZ2V0U291cmNlQ29sb3Iob2JqZWN0KTtcbiAgICAgIHZhbHVlW2kgKyAwXSA9IGNvbG9yWzBdO1xuICAgICAgdmFsdWVbaSArIDFdID0gY29sb3JbMV07XG4gICAgICB2YWx1ZVtpICsgMl0gPSBjb2xvclsyXTtcbiAgICAgIHZhbHVlW2kgKyAzXSA9IGlzTmFOKGNvbG9yWzNdKSA/IDI1NSA6IGNvbG9yWzNdO1xuICAgICAgaSArPSBzaXplO1xuICAgIH1cbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlVGFyZ2V0Q29sb3JzKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtkYXRhLCBnZXRUYXJnZXRDb2xvcn0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHt2YWx1ZSwgc2l6ZX0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gZ2V0VGFyZ2V0Q29sb3Iob2JqZWN0KTtcbiAgICAgIHZhbHVlW2kgKyAwXSA9IGNvbG9yWzBdO1xuICAgICAgdmFsdWVbaSArIDFdID0gY29sb3JbMV07XG4gICAgICB2YWx1ZVtpICsgMl0gPSBjb2xvclsyXTtcbiAgICAgIHZhbHVlW2kgKyAzXSA9IGlzTmFOKGNvbG9yWzNdKSA/IDI1NSA6IGNvbG9yWzNdO1xuICAgICAgaSArPSBzaXplO1xuICAgIH1cbiAgfVxufVxuXG5BcmNMYXllci5sYXllck5hbWUgPSAnQXJjTGF5ZXInO1xuQXJjTGF5ZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGF5ZXJzL2NvcmUvYXJjLWxheWVyL2FyYy1sYXllci5qc1xuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 36 */
/* exports provided: default */
/* exports used: default */
/*!********************************************************!*\
  !*** ./src/layers/core/geojson-layer/geojson-layer.js ***!
  \********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__scatterplot_layer_scatterplot_layer__ = __webpack_require__(/*! ../scatterplot-layer/scatterplot-layer */ 20);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__path_layer_path_layer__ = __webpack_require__(/*! ../path-layer/path-layer */ 10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__solid_polygon_layer_solid_polygon_layer__ = __webpack_require__(/*! ../solid-polygon-layer/solid-polygon-layer */ 26);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geojson__ = __webpack_require__(/*! ./geojson */ 57);\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n// Use primitive layer to avoid \"Composite Composite\" layers for now\n\n\n\n\nconst defaultStrokeColor = [0xBD, 0xE2, 0x7A, 0xFF];\nconst defaultFillColor = [0xBD, 0xE2, 0x7A, 0xFF];\n\nconst defaultProps = {\n  stroked: true,\n  filled: true,\n  extruded: false,\n  wireframe: false,\n  fp64: false,\n\n  // TODO: Missing props: radiusMinPixels, strokeWidthMinPixels, ...\n\n  // Line and polygon outline color\n  getColor: f => __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__[\"f\" /* get */])(f, 'properties.strokeColor') || defaultStrokeColor,\n  // Point and polygon fill color\n  getFillColor: f => __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__[\"f\" /* get */])(f, 'properties.fillColor') || defaultFillColor,\n  // Point radius\n  getRadius: f => __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__[\"f\" /* get */])(f, 'properties.radius') || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__[\"f\" /* get */])(f, 'properties.size') || 5,\n  // Line and polygon outline accessors\n  getWidth: f => __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__[\"f\" /* get */])(f, 'properties.strokeWidth') || 1,\n  // Polygon extrusion accessor\n  getElevation: f => 1000\n};\n\nconst getCoordinates = f => __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__[\"f\" /* get */])(f, 'geometry.coordinates');\n\nclass GeoJsonLayer extends __WEBPACK_IMPORTED_MODULE_0__lib__[\"b\" /* CompositeLayer */] {\n  initializeState() {\n    this.state = {\n      features: {}\n    };\n  }\n\n  updateState({oldProps, props, changeFlags}) {\n    if (changeFlags.dataChanged) {\n      const {data} = this.props;\n      const features = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__geojson__[\"a\" /* getGeojsonFeatures */])(data);\n      this.state.features = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__geojson__[\"b\" /* separateGeojsonFeatures */])(features);\n    }\n  }\n\n  _onHoverSubLayer(info) {\n    info.object = (info.object && info.object.feature) || info.object;\n    this.props.onHover(info);\n  }\n\n  _onClickSubLayer(info) {\n    info.object = (info.object && info.object.feature) || info.object;\n    this.props.onClick(info);\n  }\n\n  renderLayers() {\n    const {features} = this.state;\n    const {pointFeatures, lineFeatures, polygonFeatures, polygonOutlineFeatures} = features;\n    const {getColor, getFillColor, getRadius, getWidth, getElevation, updateTriggers} = this.props;\n    const {id, stroked, filled, extruded, wireframe} = this.props;\n\n    let {} = this.props;\n    const drawPoints = pointFeatures && pointFeatures.length > 0;\n    const drawLines = lineFeatures && lineFeatures.length > 0;\n    const hasPolygonOutline = polygonOutlineFeatures && polygonOutlineFeatures.length > 0;\n    const hasPolygon = polygonFeatures && polygonFeatures.length > 0;\n\n    const onHover = this._onHoverSubLayer.bind(this);\n    const onClick = this._onClickSubLayer.bind(this);\n\n    // Filled Polygon Layer\n    const polygonFillLayer = filled &&\n      hasPolygon &&\n      new __WEBPACK_IMPORTED_MODULE_3__solid_polygon_layer_solid_polygon_layer__[\"a\" /* default */](Object.assign({}, this.props, {\n        id: `${id}-polygon-fill`,\n        data: polygonFeatures,\n        extruded,\n        wireframe: false,\n        getPolygon: getCoordinates,\n        getElevation,\n        getColor: getFillColor,\n        updateTriggers: {\n          getElevation: updateTriggers.getElevation,\n          getColor: updateTriggers.getFillColor\n        },\n        onHover,\n        onClick\n      }));\n\n    const polygonWireframeLayer = wireframe &&\n      extruded &&\n      hasPolygon &&\n      new __WEBPACK_IMPORTED_MODULE_3__solid_polygon_layer_solid_polygon_layer__[\"a\" /* default */](Object.assign({}, this.props, {\n        id: `${id}-polygon-wireframe`,\n        data: polygonFeatures,\n        extruded,\n        wireframe: true,\n        getPolygon: getCoordinates,\n        getElevation,\n        getColor,\n        updateTriggers: {\n          getElevation: updateTriggers.getElevation,\n          getColor: updateTriggers.getColor\n        },\n        onHover,\n        onClick\n      }));\n\n    const polygonOutlineLayer = !extruded &&\n      stroked &&\n      hasPolygonOutline &&\n      new __WEBPACK_IMPORTED_MODULE_2__path_layer_path_layer__[\"a\" /* default */](Object.assign({}, this.props, {\n        id: `${id}-polygon-outline`,\n        data: polygonOutlineFeatures,\n        getPath: getCoordinates,\n        getColor,\n        getWidth,\n        updateTriggers: {\n          getColor: updateTriggers.getColor,\n          getWidth: updateTriggers.getWidth\n        },\n        onHover,\n        onClick\n      }));\n\n    const lineLayer = drawLines && new __WEBPACK_IMPORTED_MODULE_2__path_layer_path_layer__[\"a\" /* default */](Object.assign({}, this.props, {\n      id: `${id}-line-paths`,\n      data: lineFeatures,\n      getPath: getCoordinates,\n      getColor,\n      getWidth,\n      onHover,\n      onClick,\n      updateTriggers: {\n        getColor: updateTriggers.getColor,\n        getWidth: updateTriggers.getWidth\n      }\n    }));\n\n    const pointLayer = drawPoints && new __WEBPACK_IMPORTED_MODULE_1__scatterplot_layer_scatterplot_layer__[\"a\" /* default */](Object.assign({}, this.props, {\n      id: `${id}-points`,\n      data: pointFeatures,\n      getPosition: getCoordinates,\n      getColor: getFillColor,\n      getRadius,\n      updateTriggers: {\n        getColor: updateTriggers.getFillColor,\n        getRadius: updateTriggers.getRadius\n      },\n      onHover,\n      onClick\n    }));\n\n    return [\n      polygonFillLayer,\n      polygonWireframeLayer,\n      polygonOutlineLayer,\n      lineLayer,\n      pointLayer\n    ].filter(Boolean);\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = GeoJsonLayer;\n\n\nGeoJsonLayer.layerName = 'GeoJsonLayer';\nGeoJsonLayer.defaultProps = defaultProps;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvZ2VvanNvbi1sYXllci9nZW9qc29uLWxheWVyLmpzPzZmM2QiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE2IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtDb21wb3NpdGVMYXllciwgZ2V0fSBmcm9tICcuLi8uLi8uLi9saWInO1xuaW1wb3J0IFNjYXR0ZXJwbG90TGF5ZXIgZnJvbSAnLi4vc2NhdHRlcnBsb3QtbGF5ZXIvc2NhdHRlcnBsb3QtbGF5ZXInO1xuaW1wb3J0IFBhdGhMYXllciBmcm9tICcuLi9wYXRoLWxheWVyL3BhdGgtbGF5ZXInO1xuLy8gVXNlIHByaW1pdGl2ZSBsYXllciB0byBhdm9pZCBcIkNvbXBvc2l0ZSBDb21wb3NpdGVcIiBsYXllcnMgZm9yIG5vd1xuaW1wb3J0IFNvbGlkUG9seWdvbkxheWVyIGZyb20gJy4uL3NvbGlkLXBvbHlnb24tbGF5ZXIvc29saWQtcG9seWdvbi1sYXllcic7XG5cbmltcG9ydCB7Z2V0R2VvanNvbkZlYXR1cmVzLCBzZXBhcmF0ZUdlb2pzb25GZWF0dXJlc30gZnJvbSAnLi9nZW9qc29uJztcblxuY29uc3QgZGVmYXVsdFN0cm9rZUNvbG9yID0gWzB4QkQsIDB4RTIsIDB4N0EsIDB4RkZdO1xuY29uc3QgZGVmYXVsdEZpbGxDb2xvciA9IFsweEJELCAweEUyLCAweDdBLCAweEZGXTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBzdHJva2VkOiB0cnVlLFxuICBmaWxsZWQ6IHRydWUsXG4gIGV4dHJ1ZGVkOiBmYWxzZSxcbiAgd2lyZWZyYW1lOiBmYWxzZSxcbiAgZnA2NDogZmFsc2UsXG5cbiAgLy8gVE9ETzogTWlzc2luZyBwcm9wczogcmFkaXVzTWluUGl4ZWxzLCBzdHJva2VXaWR0aE1pblBpeGVscywgLi4uXG5cbiAgLy8gTGluZSBhbmQgcG9seWdvbiBvdXRsaW5lIGNvbG9yXG4gIGdldENvbG9yOiBmID0+IGdldChmLCAncHJvcGVydGllcy5zdHJva2VDb2xvcicpIHx8IGRlZmF1bHRTdHJva2VDb2xvcixcbiAgLy8gUG9pbnQgYW5kIHBvbHlnb24gZmlsbCBjb2xvclxuICBnZXRGaWxsQ29sb3I6IGYgPT4gZ2V0KGYsICdwcm9wZXJ0aWVzLmZpbGxDb2xvcicpIHx8IGRlZmF1bHRGaWxsQ29sb3IsXG4gIC8vIFBvaW50IHJhZGl1c1xuICBnZXRSYWRpdXM6IGYgPT4gZ2V0KGYsICdwcm9wZXJ0aWVzLnJhZGl1cycpIHx8IGdldChmLCAncHJvcGVydGllcy5zaXplJykgfHwgNSxcbiAgLy8gTGluZSBhbmQgcG9seWdvbiBvdXRsaW5lIGFjY2Vzc29yc1xuICBnZXRXaWR0aDogZiA9PiBnZXQoZiwgJ3Byb3BlcnRpZXMuc3Ryb2tlV2lkdGgnKSB8fCAxLFxuICAvLyBQb2x5Z29uIGV4dHJ1c2lvbiBhY2Nlc3NvclxuICBnZXRFbGV2YXRpb246IGYgPT4gMTAwMFxufTtcblxuY29uc3QgZ2V0Q29vcmRpbmF0ZXMgPSBmID0+IGdldChmLCAnZ2VvbWV0cnkuY29vcmRpbmF0ZXMnKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2VvSnNvbkxheWVyIGV4dGVuZHMgQ29tcG9zaXRlTGF5ZXIge1xuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGZlYXR1cmVzOiB7fVxuICAgIH07XG4gIH1cblxuICB1cGRhdGVTdGF0ZSh7b2xkUHJvcHMsIHByb3BzLCBjaGFuZ2VGbGFnc30pIHtcbiAgICBpZiAoY2hhbmdlRmxhZ3MuZGF0YUNoYW5nZWQpIHtcbiAgICAgIGNvbnN0IHtkYXRhfSA9IHRoaXMucHJvcHM7XG4gICAgICBjb25zdCBmZWF0dXJlcyA9IGdldEdlb2pzb25GZWF0dXJlcyhkYXRhKTtcbiAgICAgIHRoaXMuc3RhdGUuZmVhdHVyZXMgPSBzZXBhcmF0ZUdlb2pzb25GZWF0dXJlcyhmZWF0dXJlcyk7XG4gICAgfVxuICB9XG5cbiAgX29uSG92ZXJTdWJMYXllcihpbmZvKSB7XG4gICAgaW5mby5vYmplY3QgPSAoaW5mby5vYmplY3QgJiYgaW5mby5vYmplY3QuZmVhdHVyZSkgfHwgaW5mby5vYmplY3Q7XG4gICAgdGhpcy5wcm9wcy5vbkhvdmVyKGluZm8pO1xuICB9XG5cbiAgX29uQ2xpY2tTdWJMYXllcihpbmZvKSB7XG4gICAgaW5mby5vYmplY3QgPSAoaW5mby5vYmplY3QgJiYgaW5mby5vYmplY3QuZmVhdHVyZSkgfHwgaW5mby5vYmplY3Q7XG4gICAgdGhpcy5wcm9wcy5vbkNsaWNrKGluZm8pO1xuICB9XG5cbiAgcmVuZGVyTGF5ZXJzKCkge1xuICAgIGNvbnN0IHtmZWF0dXJlc30gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHtwb2ludEZlYXR1cmVzLCBsaW5lRmVhdHVyZXMsIHBvbHlnb25GZWF0dXJlcywgcG9seWdvbk91dGxpbmVGZWF0dXJlc30gPSBmZWF0dXJlcztcbiAgICBjb25zdCB7Z2V0Q29sb3IsIGdldEZpbGxDb2xvciwgZ2V0UmFkaXVzLCBnZXRXaWR0aCwgZ2V0RWxldmF0aW9uLCB1cGRhdGVUcmlnZ2Vyc30gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHtpZCwgc3Ryb2tlZCwgZmlsbGVkLCBleHRydWRlZCwgd2lyZWZyYW1lfSA9IHRoaXMucHJvcHM7XG5cbiAgICBsZXQge30gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGRyYXdQb2ludHMgPSBwb2ludEZlYXR1cmVzICYmIHBvaW50RmVhdHVyZXMubGVuZ3RoID4gMDtcbiAgICBjb25zdCBkcmF3TGluZXMgPSBsaW5lRmVhdHVyZXMgJiYgbGluZUZlYXR1cmVzLmxlbmd0aCA+IDA7XG4gICAgY29uc3QgaGFzUG9seWdvbk91dGxpbmUgPSBwb2x5Z29uT3V0bGluZUZlYXR1cmVzICYmIHBvbHlnb25PdXRsaW5lRmVhdHVyZXMubGVuZ3RoID4gMDtcbiAgICBjb25zdCBoYXNQb2x5Z29uID0gcG9seWdvbkZlYXR1cmVzICYmIHBvbHlnb25GZWF0dXJlcy5sZW5ndGggPiAwO1xuXG4gICAgY29uc3Qgb25Ib3ZlciA9IHRoaXMuX29uSG92ZXJTdWJMYXllci5iaW5kKHRoaXMpO1xuICAgIGNvbnN0IG9uQ2xpY2sgPSB0aGlzLl9vbkNsaWNrU3ViTGF5ZXIuYmluZCh0aGlzKTtcblxuICAgIC8vIEZpbGxlZCBQb2x5Z29uIExheWVyXG4gICAgY29uc3QgcG9seWdvbkZpbGxMYXllciA9IGZpbGxlZCAmJlxuICAgICAgaGFzUG9seWdvbiAmJlxuICAgICAgbmV3IFNvbGlkUG9seWdvbkxheWVyKE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMsIHtcbiAgICAgICAgaWQ6IGAke2lkfS1wb2x5Z29uLWZpbGxgLFxuICAgICAgICBkYXRhOiBwb2x5Z29uRmVhdHVyZXMsXG4gICAgICAgIGV4dHJ1ZGVkLFxuICAgICAgICB3aXJlZnJhbWU6IGZhbHNlLFxuICAgICAgICBnZXRQb2x5Z29uOiBnZXRDb29yZGluYXRlcyxcbiAgICAgICAgZ2V0RWxldmF0aW9uLFxuICAgICAgICBnZXRDb2xvcjogZ2V0RmlsbENvbG9yLFxuICAgICAgICB1cGRhdGVUcmlnZ2Vyczoge1xuICAgICAgICAgIGdldEVsZXZhdGlvbjogdXBkYXRlVHJpZ2dlcnMuZ2V0RWxldmF0aW9uLFxuICAgICAgICAgIGdldENvbG9yOiB1cGRhdGVUcmlnZ2Vycy5nZXRGaWxsQ29sb3JcbiAgICAgICAgfSxcbiAgICAgICAgb25Ib3ZlcixcbiAgICAgICAgb25DbGlja1xuICAgICAgfSkpO1xuXG4gICAgY29uc3QgcG9seWdvbldpcmVmcmFtZUxheWVyID0gd2lyZWZyYW1lICYmXG4gICAgICBleHRydWRlZCAmJlxuICAgICAgaGFzUG9seWdvbiAmJlxuICAgICAgbmV3IFNvbGlkUG9seWdvbkxheWVyKE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMsIHtcbiAgICAgICAgaWQ6IGAke2lkfS1wb2x5Z29uLXdpcmVmcmFtZWAsXG4gICAgICAgIGRhdGE6IHBvbHlnb25GZWF0dXJlcyxcbiAgICAgICAgZXh0cnVkZWQsXG4gICAgICAgIHdpcmVmcmFtZTogdHJ1ZSxcbiAgICAgICAgZ2V0UG9seWdvbjogZ2V0Q29vcmRpbmF0ZXMsXG4gICAgICAgIGdldEVsZXZhdGlvbixcbiAgICAgICAgZ2V0Q29sb3IsXG4gICAgICAgIHVwZGF0ZVRyaWdnZXJzOiB7XG4gICAgICAgICAgZ2V0RWxldmF0aW9uOiB1cGRhdGVUcmlnZ2Vycy5nZXRFbGV2YXRpb24sXG4gICAgICAgICAgZ2V0Q29sb3I6IHVwZGF0ZVRyaWdnZXJzLmdldENvbG9yXG4gICAgICAgIH0sXG4gICAgICAgIG9uSG92ZXIsXG4gICAgICAgIG9uQ2xpY2tcbiAgICAgIH0pKTtcblxuICAgIGNvbnN0IHBvbHlnb25PdXRsaW5lTGF5ZXIgPSAhZXh0cnVkZWQgJiZcbiAgICAgIHN0cm9rZWQgJiZcbiAgICAgIGhhc1BvbHlnb25PdXRsaW5lICYmXG4gICAgICBuZXcgUGF0aExheWVyKE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMsIHtcbiAgICAgICAgaWQ6IGAke2lkfS1wb2x5Z29uLW91dGxpbmVgLFxuICAgICAgICBkYXRhOiBwb2x5Z29uT3V0bGluZUZlYXR1cmVzLFxuICAgICAgICBnZXRQYXRoOiBnZXRDb29yZGluYXRlcyxcbiAgICAgICAgZ2V0Q29sb3IsXG4gICAgICAgIGdldFdpZHRoLFxuICAgICAgICB1cGRhdGVUcmlnZ2Vyczoge1xuICAgICAgICAgIGdldENvbG9yOiB1cGRhdGVUcmlnZ2Vycy5nZXRDb2xvcixcbiAgICAgICAgICBnZXRXaWR0aDogdXBkYXRlVHJpZ2dlcnMuZ2V0V2lkdGhcbiAgICAgICAgfSxcbiAgICAgICAgb25Ib3ZlcixcbiAgICAgICAgb25DbGlja1xuICAgICAgfSkpO1xuXG4gICAgY29uc3QgbGluZUxheWVyID0gZHJhd0xpbmVzICYmIG5ldyBQYXRoTGF5ZXIoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcywge1xuICAgICAgaWQ6IGAke2lkfS1saW5lLXBhdGhzYCxcbiAgICAgIGRhdGE6IGxpbmVGZWF0dXJlcyxcbiAgICAgIGdldFBhdGg6IGdldENvb3JkaW5hdGVzLFxuICAgICAgZ2V0Q29sb3IsXG4gICAgICBnZXRXaWR0aCxcbiAgICAgIG9uSG92ZXIsXG4gICAgICBvbkNsaWNrLFxuICAgICAgdXBkYXRlVHJpZ2dlcnM6IHtcbiAgICAgICAgZ2V0Q29sb3I6IHVwZGF0ZVRyaWdnZXJzLmdldENvbG9yLFxuICAgICAgICBnZXRXaWR0aDogdXBkYXRlVHJpZ2dlcnMuZ2V0V2lkdGhcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBjb25zdCBwb2ludExheWVyID0gZHJhd1BvaW50cyAmJiBuZXcgU2NhdHRlcnBsb3RMYXllcihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7XG4gICAgICBpZDogYCR7aWR9LXBvaW50c2AsXG4gICAgICBkYXRhOiBwb2ludEZlYXR1cmVzLFxuICAgICAgZ2V0UG9zaXRpb246IGdldENvb3JkaW5hdGVzLFxuICAgICAgZ2V0Q29sb3I6IGdldEZpbGxDb2xvcixcbiAgICAgIGdldFJhZGl1cyxcbiAgICAgIHVwZGF0ZVRyaWdnZXJzOiB7XG4gICAgICAgIGdldENvbG9yOiB1cGRhdGVUcmlnZ2Vycy5nZXRGaWxsQ29sb3IsXG4gICAgICAgIGdldFJhZGl1czogdXBkYXRlVHJpZ2dlcnMuZ2V0UmFkaXVzXG4gICAgICB9LFxuICAgICAgb25Ib3ZlcixcbiAgICAgIG9uQ2xpY2tcbiAgICB9KSk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgcG9seWdvbkZpbGxMYXllcixcbiAgICAgIHBvbHlnb25XaXJlZnJhbWVMYXllcixcbiAgICAgIHBvbHlnb25PdXRsaW5lTGF5ZXIsXG4gICAgICBsaW5lTGF5ZXIsXG4gICAgICBwb2ludExheWVyXG4gICAgXS5maWx0ZXIoQm9vbGVhbik7XG4gIH1cbn1cblxuR2VvSnNvbkxheWVyLmxheWVyTmFtZSA9ICdHZW9Kc29uTGF5ZXInO1xuR2VvSnNvbkxheWVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xheWVycy9jb3JlL2dlb2pzb24tbGF5ZXIvZ2VvanNvbi1sYXllci5qc1xuLy8gbW9kdWxlIGlkID0gMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 37 */
/* exports provided: default */
/* exports used: default */
/*!**************************************************!*\
  !*** ./src/layers/core/grid-layer/grid-layer.js ***!
  \**************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__grid_cell_layer_grid_cell_layer__ = __webpack_require__(/*! ../grid-cell-layer/grid-cell-layer */ 18);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__grid_aggregator__ = __webpack_require__(/*! ./grid-aggregator */ 61);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_scale_utils__ = __webpack_require__(/*! ../../../utils/scale-utils */ 32);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_color_utils__ = __webpack_require__(/*! ../../../utils/color-utils */ 31);\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\n\nconst defaultCellSize = 1000;\nconst defaultElevationRange = [0, 1000];\nconst defaultElevationScale = 1;\n\nconst defaultProps = {\n  cellSize: defaultCellSize,\n  colorRange: __WEBPACK_IMPORTED_MODULE_4__utils_color_utils__[\"a\" /* defaultColorRange */],\n  elevationRange: defaultElevationRange,\n  elevationScale: defaultElevationScale,\n  getPosition: x => x.position,\n  fp64: false\n  // AUDIT - getWeight ?\n};\n\nfunction noop() {}\n\nfunction _needsReProjectPoints(oldProps, props) {\n  return oldProps.cellSize !== props.cellSize;\n}\n\nclass GridLayer extends __WEBPACK_IMPORTED_MODULE_0__lib__[\"a\" /* Layer */] {\n  initializeState() {\n    this.state = {\n      gridOffset: {yOffset: 0.0089, xOffset: 0.0113},\n      layerData: [],\n      countRange: null,\n      pickedCell: null\n    };\n  }\n\n  updateState({oldProps, props, changeFlags}) {\n    if (changeFlags.dataChanged || _needsReProjectPoints(oldProps, props)) {\n      const {data, cellSize, getPosition} = this.props;\n\n      const {gridOffset, layerData, countRange} =\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__grid_aggregator__[\"a\" /* pointToDensityGridData */])(data, cellSize, getPosition);\n\n      Object.assign(this.state, {gridOffset, layerData, countRange});\n    }\n  }\n\n  getPickingInfo(opts) {\n    const info = super.getPickingInfo(opts);\n    const pickedCell = this.state.pickedCell;\n\n    return Object.assign(info, {\n      layer: this,\n      // override index with cell index\n      index: pickedCell ? pickedCell.index : -1,\n      picked: Boolean(pickedCell),\n      // override object with picked cell\n      object: pickedCell\n    });\n  }\n\n  _onHoverSublayer(info) {\n\n    this.state.pickedCell = info.picked && info.index > -1 ?\n      this.state.layerData[info.index] : null;\n  }\n\n  _onGetSublayerColor(cell) {\n    const {colorRange} = this.props;\n    const colorDomain = this.props.colorDomain || this.state.countRange;\n\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_scale_utils__[\"a\" /* quantizeScale */])(colorDomain, colorRange, cell.count);\n  }\n\n  _onGetSublayerElevation(cell) {\n    const {elevationRange} = this.props;\n    const elevationDomain = this.props.elevationDomain || [0, this.state.countRange[1]];\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_scale_utils__[\"b\" /* linearScale */])(elevationDomain, elevationRange, cell.count);\n  }\n\n  renderLayers() {\n    const {id} = this.props;\n\n    return new __WEBPACK_IMPORTED_MODULE_1__grid_cell_layer_grid_cell_layer__[\"a\" /* default */](Object.assign({},\n      this.props, {\n        id: `${id}-density-grid`,\n        data: this.state.layerData,\n        latOffset: this.state.gridOffset.yOffset,\n        lonOffset: this.state.gridOffset.xOffset,\n        getColor: this._onGetSublayerColor.bind(this),\n        getElevation: this._onGetSublayerElevation.bind(this),\n        getPosition: d => d.position,\n        // Override user's onHover and onClick props\n        onHover: this._onHoverSublayer.bind(this),\n        onClick: noop,\n        updateTriggers: {\n          getColor: {colorRange: this.props.colorRange},\n          getElevation: {elevationRange: this.props.elevationRange}\n        }\n      }));\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = GridLayer;\n\n\nGridLayer.layerName = 'GridLayer';\nGridLayer.defaultProps = defaultProps;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvZ3JpZC1sYXllci9ncmlkLWxheWVyLmpzPzBiNTEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE2IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtMYXllcn0gZnJvbSAnLi4vLi4vLi4vbGliJztcbmltcG9ydCBHcmlkQ2VsbExheWVyIGZyb20gJy4uL2dyaWQtY2VsbC1sYXllci9ncmlkLWNlbGwtbGF5ZXInO1xuXG5pbXBvcnQge3BvaW50VG9EZW5zaXR5R3JpZERhdGF9IGZyb20gJy4vZ3JpZC1hZ2dyZWdhdG9yJztcbmltcG9ydCB7bGluZWFyU2NhbGUsIHF1YW50aXplU2NhbGV9IGZyb20gJy4uLy4uLy4uL3V0aWxzL3NjYWxlLXV0aWxzJztcbmltcG9ydCB7ZGVmYXVsdENvbG9yUmFuZ2V9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2NvbG9yLXV0aWxzJztcblxuY29uc3QgZGVmYXVsdENlbGxTaXplID0gMTAwMDtcbmNvbnN0IGRlZmF1bHRFbGV2YXRpb25SYW5nZSA9IFswLCAxMDAwXTtcbmNvbnN0IGRlZmF1bHRFbGV2YXRpb25TY2FsZSA9IDE7XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgY2VsbFNpemU6IGRlZmF1bHRDZWxsU2l6ZSxcbiAgY29sb3JSYW5nZTogZGVmYXVsdENvbG9yUmFuZ2UsXG4gIGVsZXZhdGlvblJhbmdlOiBkZWZhdWx0RWxldmF0aW9uUmFuZ2UsXG4gIGVsZXZhdGlvblNjYWxlOiBkZWZhdWx0RWxldmF0aW9uU2NhbGUsXG4gIGdldFBvc2l0aW9uOiB4ID0+IHgucG9zaXRpb24sXG4gIGZwNjQ6IGZhbHNlXG4gIC8vIEFVRElUIC0gZ2V0V2VpZ2h0ID9cbn07XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiBfbmVlZHNSZVByb2plY3RQb2ludHMob2xkUHJvcHMsIHByb3BzKSB7XG4gIHJldHVybiBvbGRQcm9wcy5jZWxsU2l6ZSAhPT0gcHJvcHMuY2VsbFNpemU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyaWRMYXllciBleHRlbmRzIExheWVyIHtcbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBncmlkT2Zmc2V0OiB7eU9mZnNldDogMC4wMDg5LCB4T2Zmc2V0OiAwLjAxMTN9LFxuICAgICAgbGF5ZXJEYXRhOiBbXSxcbiAgICAgIGNvdW50UmFuZ2U6IG51bGwsXG4gICAgICBwaWNrZWRDZWxsOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIHVwZGF0ZVN0YXRlKHtvbGRQcm9wcywgcHJvcHMsIGNoYW5nZUZsYWdzfSkge1xuICAgIGlmIChjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCB8fCBfbmVlZHNSZVByb2plY3RQb2ludHMob2xkUHJvcHMsIHByb3BzKSkge1xuICAgICAgY29uc3Qge2RhdGEsIGNlbGxTaXplLCBnZXRQb3NpdGlvbn0gPSB0aGlzLnByb3BzO1xuXG4gICAgICBjb25zdCB7Z3JpZE9mZnNldCwgbGF5ZXJEYXRhLCBjb3VudFJhbmdlfSA9XG4gICAgICAgIHBvaW50VG9EZW5zaXR5R3JpZERhdGEoZGF0YSwgY2VsbFNpemUsIGdldFBvc2l0aW9uKTtcblxuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLnN0YXRlLCB7Z3JpZE9mZnNldCwgbGF5ZXJEYXRhLCBjb3VudFJhbmdlfSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0UGlja2luZ0luZm8ob3B0cykge1xuICAgIGNvbnN0IGluZm8gPSBzdXBlci5nZXRQaWNraW5nSW5mbyhvcHRzKTtcbiAgICBjb25zdCBwaWNrZWRDZWxsID0gdGhpcy5zdGF0ZS5waWNrZWRDZWxsO1xuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oaW5mbywge1xuICAgICAgbGF5ZXI6IHRoaXMsXG4gICAgICAvLyBvdmVycmlkZSBpbmRleCB3aXRoIGNlbGwgaW5kZXhcbiAgICAgIGluZGV4OiBwaWNrZWRDZWxsID8gcGlja2VkQ2VsbC5pbmRleCA6IC0xLFxuICAgICAgcGlja2VkOiBCb29sZWFuKHBpY2tlZENlbGwpLFxuICAgICAgLy8gb3ZlcnJpZGUgb2JqZWN0IHdpdGggcGlja2VkIGNlbGxcbiAgICAgIG9iamVjdDogcGlja2VkQ2VsbFxuICAgIH0pO1xuICB9XG5cbiAgX29uSG92ZXJTdWJsYXllcihpbmZvKSB7XG5cbiAgICB0aGlzLnN0YXRlLnBpY2tlZENlbGwgPSBpbmZvLnBpY2tlZCAmJiBpbmZvLmluZGV4ID4gLTEgP1xuICAgICAgdGhpcy5zdGF0ZS5sYXllckRhdGFbaW5mby5pbmRleF0gOiBudWxsO1xuICB9XG5cbiAgX29uR2V0U3VibGF5ZXJDb2xvcihjZWxsKSB7XG4gICAgY29uc3Qge2NvbG9yUmFuZ2V9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBjb2xvckRvbWFpbiA9IHRoaXMucHJvcHMuY29sb3JEb21haW4gfHwgdGhpcy5zdGF0ZS5jb3VudFJhbmdlO1xuXG4gICAgcmV0dXJuIHF1YW50aXplU2NhbGUoY29sb3JEb21haW4sIGNvbG9yUmFuZ2UsIGNlbGwuY291bnQpO1xuICB9XG5cbiAgX29uR2V0U3VibGF5ZXJFbGV2YXRpb24oY2VsbCkge1xuICAgIGNvbnN0IHtlbGV2YXRpb25SYW5nZX0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGVsZXZhdGlvbkRvbWFpbiA9IHRoaXMucHJvcHMuZWxldmF0aW9uRG9tYWluIHx8IFswLCB0aGlzLnN0YXRlLmNvdW50UmFuZ2VbMV1dO1xuICAgIHJldHVybiBsaW5lYXJTY2FsZShlbGV2YXRpb25Eb21haW4sIGVsZXZhdGlvblJhbmdlLCBjZWxsLmNvdW50KTtcbiAgfVxuXG4gIHJlbmRlckxheWVycygpIHtcbiAgICBjb25zdCB7aWR9ID0gdGhpcy5wcm9wcztcblxuICAgIHJldHVybiBuZXcgR3JpZENlbGxMYXllcihPYmplY3QuYXNzaWduKHt9LFxuICAgICAgdGhpcy5wcm9wcywge1xuICAgICAgICBpZDogYCR7aWR9LWRlbnNpdHktZ3JpZGAsXG4gICAgICAgIGRhdGE6IHRoaXMuc3RhdGUubGF5ZXJEYXRhLFxuICAgICAgICBsYXRPZmZzZXQ6IHRoaXMuc3RhdGUuZ3JpZE9mZnNldC55T2Zmc2V0LFxuICAgICAgICBsb25PZmZzZXQ6IHRoaXMuc3RhdGUuZ3JpZE9mZnNldC54T2Zmc2V0LFxuICAgICAgICBnZXRDb2xvcjogdGhpcy5fb25HZXRTdWJsYXllckNvbG9yLmJpbmQodGhpcyksXG4gICAgICAgIGdldEVsZXZhdGlvbjogdGhpcy5fb25HZXRTdWJsYXllckVsZXZhdGlvbi5iaW5kKHRoaXMpLFxuICAgICAgICBnZXRQb3NpdGlvbjogZCA9PiBkLnBvc2l0aW9uLFxuICAgICAgICAvLyBPdmVycmlkZSB1c2VyJ3Mgb25Ib3ZlciBhbmQgb25DbGljayBwcm9wc1xuICAgICAgICBvbkhvdmVyOiB0aGlzLl9vbkhvdmVyU3VibGF5ZXIuYmluZCh0aGlzKSxcbiAgICAgICAgb25DbGljazogbm9vcCxcbiAgICAgICAgdXBkYXRlVHJpZ2dlcnM6IHtcbiAgICAgICAgICBnZXRDb2xvcjoge2NvbG9yUmFuZ2U6IHRoaXMucHJvcHMuY29sb3JSYW5nZX0sXG4gICAgICAgICAgZ2V0RWxldmF0aW9uOiB7ZWxldmF0aW9uUmFuZ2U6IHRoaXMucHJvcHMuZWxldmF0aW9uUmFuZ2V9XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgfVxufVxuXG5HcmlkTGF5ZXIubGF5ZXJOYW1lID0gJ0dyaWRMYXllcic7XG5HcmlkTGF5ZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGF5ZXJzL2NvcmUvZ3JpZC1sYXllci9ncmlkLWxheWVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 38 */
/* exports provided: default */
/* exports used: default */
/*!********************************************************!*\
  !*** ./src/layers/core/hexagon-layer/hexagon-layer.js ***!
  \********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__hexagon_cell_layer_hexagon_cell_layer__ = __webpack_require__(/*! ../hexagon-cell-layer/hexagon-cell-layer */ 19);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_utils__ = __webpack_require__(/*! ../../../lib/utils */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_scale_utils__ = __webpack_require__(/*! ../../../utils/scale-utils */ 32);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_color_utils__ = __webpack_require__(/*! ../../../utils/color-utils */ 31);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__hexagon_aggregator__ = __webpack_require__(/*! ./hexagon-aggregator */ 65);\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\n\n\nconst defaultProps = {\n  colorRange: __WEBPACK_IMPORTED_MODULE_4__utils_color_utils__[\"a\" /* defaultColorRange */],\n  elevationRange: [0, 1000],\n  elevationScale: 1,\n  radius: 1000,\n  coverage: 1,\n  hexagonAggregator: __WEBPACK_IMPORTED_MODULE_5__hexagon_aggregator__[\"a\" /* pointToHexbin */],\n  getPosition: x => x.position,\n  fp64: false\n  //\n};\n\nfunction noop() {}\n\nfunction _needsReProjectPoints(oldProps, props) {\n  return oldProps.radius !== props.radius;\n}\n\nfunction _getCountRange(hexagons) {\n  return [\n    Math.min.apply(null, hexagons.map(bin => bin.points.length)),\n    Math.max.apply(null, hexagons.map(bin => bin.points.length))\n  ];\n}\n\nclass HexagonLayer extends __WEBPACK_IMPORTED_MODULE_0__lib__[\"a\" /* Layer */] {\n  constructor(props) {\n    if (!props.radius) {\n      __WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"a\" /* log */].once(0, 'PointDensityHexagonLayer: radius in meter is needed to aggregate points into ' +\n        'hexagonal bins, Now using 1000 meter as default');\n\n      props.radius = defaultProps.radius;\n    }\n\n    super(props);\n  }\n\n  initializeState() {\n    this.state = {\n      hexagons: [],\n      countRange: null,\n      pickedCell: null\n    };\n  }\n\n  updateState({oldProps, props, changeFlags}) {\n    if (changeFlags.dataChanged || _needsReProjectPoints(oldProps, props)) {\n      const {hexagonAggregator} = this.props;\n      const {viewport} = this.context;\n\n      const hexagons = hexagonAggregator(this.props, viewport);\n      const countRange = _getCountRange(hexagons);\n\n      Object.assign(this.state, {hexagons, countRange});\n    }\n  }\n\n  getPickingInfo(opts) {\n    const info = super.getPickingInfo(opts);\n    const pickedCell = this.state.pickedCell;\n\n    return Object.assign(info, {\n      layer: this,\n      // override index with cell index\n      index: pickedCell ? pickedCell.index : -1,\n      picked: Boolean(pickedCell),\n      // override object with picked cell\n      object: pickedCell\n    });\n  }\n\n  _onHoverSublayer(info) {\n\n    this.state.pickedCell = info.picked && info.index > -1 ?\n      this.state.hexagons[info.index] : null;\n  }\n\n  _onGetSublayerColor(cell) {\n    const {colorRange} = this.props;\n    const colorDomain = this.props.colorDomain || this.state.countRange;\n\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_scale_utils__[\"a\" /* quantizeScale */])(colorDomain, colorRange, cell.points.length);\n  }\n\n  _onGetSublayerElevation(cell) {\n    const {elevationRange} = this.props;\n    const elevationDomain = this.props.elevationDomain || [0, this.state.countRange[1]];\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_scale_utils__[\"b\" /* linearScale */])(elevationDomain, elevationRange, cell.points.length);\n  }\n\n  renderLayers() {\n    const {id, radius} = this.props;\n\n    return new __WEBPACK_IMPORTED_MODULE_1__hexagon_cell_layer_hexagon_cell_layer__[\"a\" /* default */](Object.assign({},\n      this.props, {\n        id: `${id}-density-hexagon`,\n        data: this.state.hexagons,\n        radius,\n        angle: Math.PI,\n        getColor: this._onGetSublayerColor.bind(this),\n        getElevation: this._onGetSublayerElevation.bind(this),\n        // Override user's onHover and onClick props\n        onHover: this._onHoverSublayer.bind(this),\n        onClick: noop,\n        updateTriggers: {\n          getColor: {colorRange: this.props.colorRange},\n          getElevation: {elevationRange: this.props.elevationRange}\n        }\n      }));\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = HexagonLayer;\n\n\nHexagonLayer.layerName = 'HexagonLayer';\nHexagonLayer.defaultProps = defaultProps;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvaGV4YWdvbi1sYXllci9oZXhhZ29uLWxheWVyLmpzP2Q5YWYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE2IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtMYXllcn0gZnJvbSAnLi4vLi4vLi4vbGliJztcbmltcG9ydCBIZXhhZ29uQ2VsbExheWVyIGZyb20gJy4uL2hleGFnb24tY2VsbC1sYXllci9oZXhhZ29uLWNlbGwtbGF5ZXInO1xuaW1wb3J0IHtsb2d9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscyc7XG5cbmltcG9ydCB7cXVhbnRpemVTY2FsZSwgbGluZWFyU2NhbGV9IGZyb20gJy4uLy4uLy4uL3V0aWxzL3NjYWxlLXV0aWxzJztcbmltcG9ydCB7ZGVmYXVsdENvbG9yUmFuZ2V9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2NvbG9yLXV0aWxzJztcbmltcG9ydCB7cG9pbnRUb0hleGJpbn0gZnJvbSAnLi9oZXhhZ29uLWFnZ3JlZ2F0b3InO1xuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIGNvbG9yUmFuZ2U6IGRlZmF1bHRDb2xvclJhbmdlLFxuICBlbGV2YXRpb25SYW5nZTogWzAsIDEwMDBdLFxuICBlbGV2YXRpb25TY2FsZTogMSxcbiAgcmFkaXVzOiAxMDAwLFxuICBjb3ZlcmFnZTogMSxcbiAgaGV4YWdvbkFnZ3JlZ2F0b3I6IHBvaW50VG9IZXhiaW4sXG4gIGdldFBvc2l0aW9uOiB4ID0+IHgucG9zaXRpb24sXG4gIGZwNjQ6IGZhbHNlXG4gIC8vXG59O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gX25lZWRzUmVQcm9qZWN0UG9pbnRzKG9sZFByb3BzLCBwcm9wcykge1xuICByZXR1cm4gb2xkUHJvcHMucmFkaXVzICE9PSBwcm9wcy5yYWRpdXM7XG59XG5cbmZ1bmN0aW9uIF9nZXRDb3VudFJhbmdlKGhleGFnb25zKSB7XG4gIHJldHVybiBbXG4gICAgTWF0aC5taW4uYXBwbHkobnVsbCwgaGV4YWdvbnMubWFwKGJpbiA9PiBiaW4ucG9pbnRzLmxlbmd0aCkpLFxuICAgIE1hdGgubWF4LmFwcGx5KG51bGwsIGhleGFnb25zLm1hcChiaW4gPT4gYmluLnBvaW50cy5sZW5ndGgpKVxuICBdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIZXhhZ29uTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcy5yYWRpdXMpIHtcbiAgICAgIGxvZy5vbmNlKDAsICdQb2ludERlbnNpdHlIZXhhZ29uTGF5ZXI6IHJhZGl1cyBpbiBtZXRlciBpcyBuZWVkZWQgdG8gYWdncmVnYXRlIHBvaW50cyBpbnRvICcgK1xuICAgICAgICAnaGV4YWdvbmFsIGJpbnMsIE5vdyB1c2luZyAxMDAwIG1ldGVyIGFzIGRlZmF1bHQnKTtcblxuICAgICAgcHJvcHMucmFkaXVzID0gZGVmYXVsdFByb3BzLnJhZGl1cztcbiAgICB9XG5cbiAgICBzdXBlcihwcm9wcyk7XG4gIH1cblxuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGhleGFnb25zOiBbXSxcbiAgICAgIGNvdW50UmFuZ2U6IG51bGwsXG4gICAgICBwaWNrZWRDZWxsOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIHVwZGF0ZVN0YXRlKHtvbGRQcm9wcywgcHJvcHMsIGNoYW5nZUZsYWdzfSkge1xuICAgIGlmIChjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCB8fCBfbmVlZHNSZVByb2plY3RQb2ludHMob2xkUHJvcHMsIHByb3BzKSkge1xuICAgICAgY29uc3Qge2hleGFnb25BZ2dyZWdhdG9yfSA9IHRoaXMucHJvcHM7XG4gICAgICBjb25zdCB7dmlld3BvcnR9ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICBjb25zdCBoZXhhZ29ucyA9IGhleGFnb25BZ2dyZWdhdG9yKHRoaXMucHJvcHMsIHZpZXdwb3J0KTtcbiAgICAgIGNvbnN0IGNvdW50UmFuZ2UgPSBfZ2V0Q291bnRSYW5nZShoZXhhZ29ucyk7XG5cbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5zdGF0ZSwge2hleGFnb25zLCBjb3VudFJhbmdlfSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0UGlja2luZ0luZm8ob3B0cykge1xuICAgIGNvbnN0IGluZm8gPSBzdXBlci5nZXRQaWNraW5nSW5mbyhvcHRzKTtcbiAgICBjb25zdCBwaWNrZWRDZWxsID0gdGhpcy5zdGF0ZS5waWNrZWRDZWxsO1xuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oaW5mbywge1xuICAgICAgbGF5ZXI6IHRoaXMsXG4gICAgICAvLyBvdmVycmlkZSBpbmRleCB3aXRoIGNlbGwgaW5kZXhcbiAgICAgIGluZGV4OiBwaWNrZWRDZWxsID8gcGlja2VkQ2VsbC5pbmRleCA6IC0xLFxuICAgICAgcGlja2VkOiBCb29sZWFuKHBpY2tlZENlbGwpLFxuICAgICAgLy8gb3ZlcnJpZGUgb2JqZWN0IHdpdGggcGlja2VkIGNlbGxcbiAgICAgIG9iamVjdDogcGlja2VkQ2VsbFxuICAgIH0pO1xuICB9XG5cbiAgX29uSG92ZXJTdWJsYXllcihpbmZvKSB7XG5cbiAgICB0aGlzLnN0YXRlLnBpY2tlZENlbGwgPSBpbmZvLnBpY2tlZCAmJiBpbmZvLmluZGV4ID4gLTEgP1xuICAgICAgdGhpcy5zdGF0ZS5oZXhhZ29uc1tpbmZvLmluZGV4XSA6IG51bGw7XG4gIH1cblxuICBfb25HZXRTdWJsYXllckNvbG9yKGNlbGwpIHtcbiAgICBjb25zdCB7Y29sb3JSYW5nZX0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGNvbG9yRG9tYWluID0gdGhpcy5wcm9wcy5jb2xvckRvbWFpbiB8fCB0aGlzLnN0YXRlLmNvdW50UmFuZ2U7XG5cbiAgICByZXR1cm4gcXVhbnRpemVTY2FsZShjb2xvckRvbWFpbiwgY29sb3JSYW5nZSwgY2VsbC5wb2ludHMubGVuZ3RoKTtcbiAgfVxuXG4gIF9vbkdldFN1YmxheWVyRWxldmF0aW9uKGNlbGwpIHtcbiAgICBjb25zdCB7ZWxldmF0aW9uUmFuZ2V9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBlbGV2YXRpb25Eb21haW4gPSB0aGlzLnByb3BzLmVsZXZhdGlvbkRvbWFpbiB8fCBbMCwgdGhpcy5zdGF0ZS5jb3VudFJhbmdlWzFdXTtcbiAgICByZXR1cm4gbGluZWFyU2NhbGUoZWxldmF0aW9uRG9tYWluLCBlbGV2YXRpb25SYW5nZSwgY2VsbC5wb2ludHMubGVuZ3RoKTtcbiAgfVxuXG4gIHJlbmRlckxheWVycygpIHtcbiAgICBjb25zdCB7aWQsIHJhZGl1c30gPSB0aGlzLnByb3BzO1xuXG4gICAgcmV0dXJuIG5ldyBIZXhhZ29uQ2VsbExheWVyKE9iamVjdC5hc3NpZ24oe30sXG4gICAgICB0aGlzLnByb3BzLCB7XG4gICAgICAgIGlkOiBgJHtpZH0tZGVuc2l0eS1oZXhhZ29uYCxcbiAgICAgICAgZGF0YTogdGhpcy5zdGF0ZS5oZXhhZ29ucyxcbiAgICAgICAgcmFkaXVzLFxuICAgICAgICBhbmdsZTogTWF0aC5QSSxcbiAgICAgICAgZ2V0Q29sb3I6IHRoaXMuX29uR2V0U3VibGF5ZXJDb2xvci5iaW5kKHRoaXMpLFxuICAgICAgICBnZXRFbGV2YXRpb246IHRoaXMuX29uR2V0U3VibGF5ZXJFbGV2YXRpb24uYmluZCh0aGlzKSxcbiAgICAgICAgLy8gT3ZlcnJpZGUgdXNlcidzIG9uSG92ZXIgYW5kIG9uQ2xpY2sgcHJvcHNcbiAgICAgICAgb25Ib3ZlcjogdGhpcy5fb25Ib3ZlclN1YmxheWVyLmJpbmQodGhpcyksXG4gICAgICAgIG9uQ2xpY2s6IG5vb3AsXG4gICAgICAgIHVwZGF0ZVRyaWdnZXJzOiB7XG4gICAgICAgICAgZ2V0Q29sb3I6IHtjb2xvclJhbmdlOiB0aGlzLnByb3BzLmNvbG9yUmFuZ2V9LFxuICAgICAgICAgIGdldEVsZXZhdGlvbjoge2VsZXZhdGlvblJhbmdlOiB0aGlzLnByb3BzLmVsZXZhdGlvblJhbmdlfVxuICAgICAgICB9XG4gICAgICB9KSk7XG4gIH1cbn1cblxuSGV4YWdvbkxheWVyLmxheWVyTmFtZSA9ICdIZXhhZ29uTGF5ZXInO1xuSGV4YWdvbkxheWVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xheWVycy9jb3JlL2hleGFnb24tbGF5ZXIvaGV4YWdvbi1sYXllci5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 39 */
/* exports provided: default */
/* exports used: default */
/*!**************************************************!*\
  !*** ./src/layers/core/icon-layer/icon-layer.js ***!
  \**************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl__ = __webpack_require__(/*! luma.gl */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__ = __webpack_require__(/*! ../../../lib/utils/fp64 */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__icon_layer_vertex_glsl__ = __webpack_require__(/*! ./icon-layer-vertex.glsl */ 68);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__icon_layer_vertex_64_glsl__ = __webpack_require__(/*! ./icon-layer-vertex-64.glsl */ 67);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__icon_layer_fragment_glsl__ = __webpack_require__(/*! ./icon-layer-fragment.glsl */ 66);\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\n\n\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\n\n/*\n * @param {object} props\n * @param {Texture2D | string} props.iconAtlas - atlas image url or texture\n * @param {object} props.iconMapping - icon names mapped to icon definitions\n * @param {object} props.iconMapping[icon_name].x - x position of icon on the atlas image\n * @param {object} props.iconMapping[icon_name].y - y position of icon on the atlas image\n * @param {object} props.iconMapping[icon_name].width - width of icon on the atlas image\n * @param {object} props.iconMapping[icon_name].height - height of icon on the atlas image\n * @param {object} props.iconMapping[icon_name].anchorX - x anchor of icon on the atlas image,\n *   default to width / 2\n * @param {object} props.iconMapping[icon_name].anchorY - y anchor of icon on the atlas image,\n *   default to height / 2\n * @param {object} props.iconMapping[icon_name].mask - whether icon is treated as a transparency\n *   mask. If true, user defined color is applied. If false, original color from the image is\n *   applied. Default to false.\n * @param {number} props.size - icon size in pixels\n * @param {func} props.getPosition - returns anchor position of the icon, in [lng, lat, z]\n * @param {func} props.getIcon - returns icon name as a string\n * @param {func} props.getSize - returns icon size multiplier as a number\n * @param {func} props.getColor - returns color of the icon in [r, g, b, a]. Only works on icons\n *   with mask: true.\n */\nconst defaultProps = {\n  iconAtlas: null,\n  iconMapping: {},\n  sizeScale: 1,\n  fp64: false,\n\n  getPosition: x => x.position,\n  getIcon: x => x.icon,\n  getColor: x => x.color || DEFAULT_COLOR,\n  getSize: x => x.size || 1\n};\n\nclass IconLayer extends __WEBPACK_IMPORTED_MODULE_0__lib__[\"a\" /* Layer */] {\n  initializeState() {\n    const {attributeManager} = this.state;\n\n    /* eslint-disable max-len */\n    attributeManager.addInstanced({\n      instancePositions: {size: 3, accessor: 'getPosition', update: this.calculateInstancePositions},\n      instanceSizes: {size: 1, accessor: 'getSize', update: this.calculateInstanceSizes},\n      instanceOffsets: {size: 2, accessor: 'getIcon', update: this.calculateInstanceOffsets},\n      instanceIconFrames: {size: 4, accessor: 'getIcon', update: this.calculateInstanceIconFrames},\n      instanceColorModes: {size: 1, type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].UNSIGNED_BYTE, accessor: 'getIcon', update: this.calculateInstanceColorMode},\n      instanceColors: {size: 4, type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].UNSIGNED_BYTE, accessor: 'getColor', update: this.calculateInstanceColors}\n    });\n    /* eslint-enable max-len */\n\n    const {gl} = this.context;\n    this.setState({model: this._getModel(gl)});\n  }\n\n  updateAttribute({props, oldProps, changeFlags}) {\n    if (props.fp64 !== oldProps.fp64) {\n      const {attributeManager} = this.state;\n      attributeManager.invalidateAll();\n\n      if (props.fp64 && props.projectionMode === __WEBPACK_IMPORTED_MODULE_0__lib__[\"e\" /* COORDINATE_SYSTEM */].LNG_LAT) {\n        attributeManager.addInstanced({\n          instancePositions64xyLow: {\n            size: 2,\n            accessor: 'getPosition',\n            update: this.calculateInstancePositions64xyLow\n          }\n        });\n      } else {\n        attributeManager.remove([\n          'instancePositions64xyLow'\n        ]);\n      }\n\n    }\n  }\n\n  updateState({oldProps, props, changeFlags}) {\n    super.updateState({props, oldProps, changeFlags});\n\n    const {iconAtlas} = props;\n\n    if (oldProps.iconAtlas !== iconAtlas) {\n      const icons = {};\n      this.state.icons = icons;\n\n      if (iconAtlas instanceof __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Texture2D\"]) {\n        icons.texture = iconAtlas;\n      } else if (typeof iconAtlas === 'string') {\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"loadTextures\"])(this.context.gl, {\n          urls: [iconAtlas]\n        })\n        .then(([texture]) => {\n          icons.texture = texture;\n        });\n      }\n    }\n\n    if (props.fp64 !== oldProps.fp64) {\n      const {gl} = this.context;\n      this.setState({model: this._getModel(gl)});\n    }\n    this.updateAttribute({props, oldProps, changeFlags});\n\n  }\n\n  draw({uniforms}) {\n    const {sizeScale} = this.props;\n    const iconsTexture = this.state.icons && this.state.icons.texture;\n\n    if (iconsTexture) {\n      this.state.model.render(Object.assign({}, uniforms, {\n        iconsTexture,\n        iconsTextureDim: [iconsTexture.width, iconsTexture.height],\n        sizeScale\n      }));\n    }\n  }\n\n  getShaders() {\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__[\"b\" /* enable64bitSupport */])(this.props) ? {\n      vs: __WEBPACK_IMPORTED_MODULE_5__icon_layer_vertex_64_glsl__[\"a\" /* default */], fs: __WEBPACK_IMPORTED_MODULE_6__icon_layer_fragment_glsl__[\"a\" /* default */], modules: ['fp64', 'project64']\n    } : {\n      vs: __WEBPACK_IMPORTED_MODULE_4__icon_layer_vertex_glsl__[\"a\" /* default */], fs: __WEBPACK_IMPORTED_MODULE_6__icon_layer_fragment_glsl__[\"a\" /* default */], modules: []\n    };\n  }\n\n  _getModel(gl) {\n    const positions = [-1, -1, 0, -1, 1, 0, 1, 1, 0, 1, -1, 0];\n\n    const shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"a\" /* assembleShaders */])(gl, this.getShaders());\n\n    return new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Model\"]({\n      gl,\n      id: this.props.id,\n      vs: shaders.vs,\n      fs: shaders.fs,\n      geometry: new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Geometry\"]({\n        drawMode: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].TRIANGLE_FAN,\n        positions: new Float32Array(positions)\n      }),\n      isInstanced: true\n    });\n  }\n\n  calculateInstancePositions(attribute) {\n    const {data, getPosition} = this.props;\n    const {value} = attribute;\n    let i = 0;\n    for (const object of data) {\n      const position = getPosition(object);\n      value[i++] = position[0];\n      value[i++] = position[1];\n      value[i++] = position[2] || 0;\n    }\n  }\n\n  calculateInstancePositions64xyLow(attribute) {\n    const {data, getPosition} = this.props;\n    const {value} = attribute;\n    let i = 0;\n    for (const point of data) {\n      const position = getPosition(point);\n      value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__[\"a\" /* fp64ify */])(position[0])[1];\n      value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__[\"a\" /* fp64ify */])(position[1])[1];\n    }\n  }\n\n  calculateInstanceSizes(attribute) {\n    const {data, getSize} = this.props;\n    const {value} = attribute;\n    let i = 0;\n    for (const object of data) {\n      value[i++] = getSize(object);\n    }\n  }\n\n  calculateInstanceColors(attribute) {\n    const {data, getColor} = this.props;\n    const {value} = attribute;\n    let i = 0;\n    for (const object of data) {\n      const color = getColor(object);\n\n      value[i++] = color[0];\n      value[i++] = color[1];\n      value[i++] = color[2];\n      value[i++] = isNaN(color[3]) ? 255 : color[3];\n    }\n  }\n\n  calculateInstanceOffsets(attribute) {\n    const {data, iconMapping, getIcon} = this.props;\n    const {value} = attribute;\n    let i = 0;\n    for (const object of data) {\n      const icon = getIcon(object);\n      const rect = iconMapping[icon] || {};\n      value[i++] = (1 / 2 - rect.anchorX / rect.width) || 0;\n      value[i++] = (1 / 2 - rect.anchorY / rect.height) || 0;\n    }\n  }\n\n  calculateInstanceColorMode(attribute) {\n    const {data, iconMapping, getIcon} = this.props;\n    const {value} = attribute;\n    let i = 0;\n    for (const object of data) {\n      const icon = getIcon(object);\n      const colorMode = iconMapping[icon] && iconMapping[icon].mask;\n      value[i++] = colorMode ? 1 : 0;\n    }\n  }\n\n  calculateInstanceIconFrames(attribute) {\n    const {data, iconMapping, getIcon} = this.props;\n    const {value} = attribute;\n    let i = 0;\n    for (const object of data) {\n      const icon = getIcon(object);\n      const rect = iconMapping[icon] || {};\n      value[i++] = rect.x || 0;\n      value[i++] = rect.y || 0;\n      value[i++] = rect.width || 0;\n      value[i++] = rect.height || 0;\n    }\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = IconLayer;\n\n\nIconLayer.layerName = 'IconLayer';\nIconLayer.defaultProps = defaultProps;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvaWNvbi1sYXllci9pY29uLWxheWVyLmpzPzAxYzQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uLy4uLy4uL2xpYic7XG5pbXBvcnQge2Fzc2VtYmxlU2hhZGVyc30gZnJvbSAnLi4vLi4vLi4vc2hhZGVyLXV0aWxzJztcbmltcG9ydCB7R0wsIE1vZGVsLCBHZW9tZXRyeSwgVGV4dHVyZTJELCBsb2FkVGV4dHVyZXN9IGZyb20gJ2x1bWEuZ2wnO1xuaW1wb3J0IHtmcDY0aWZ5LCBlbmFibGU2NGJpdFN1cHBvcnR9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscy9mcDY0JztcbmltcG9ydCB7Q09PUkRJTkFURV9TWVNURU19IGZyb20gJy4uLy4uLy4uL2xpYic7XG5cbmltcG9ydCBpY29uVmVydGV4IGZyb20gJy4vaWNvbi1sYXllci12ZXJ0ZXguZ2xzbCc7XG5pbXBvcnQgaWNvblZlcnRleDY0IGZyb20gJy4vaWNvbi1sYXllci12ZXJ0ZXgtNjQuZ2xzbCc7XG5pbXBvcnQgaWNvbkZyYWdtZW50IGZyb20gJy4vaWNvbi1sYXllci1mcmFnbWVudC5nbHNsJztcblxuY29uc3QgREVGQVVMVF9DT0xPUiA9IFswLCAwLCAwLCAyNTVdO1xuXG4vKlxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge1RleHR1cmUyRCB8IHN0cmluZ30gcHJvcHMuaWNvbkF0bGFzIC0gYXRsYXMgaW1hZ2UgdXJsIG9yIHRleHR1cmVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcy5pY29uTWFwcGluZyAtIGljb24gbmFtZXMgbWFwcGVkIHRvIGljb24gZGVmaW5pdGlvbnNcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcy5pY29uTWFwcGluZ1tpY29uX25hbWVdLnggLSB4IHBvc2l0aW9uIG9mIGljb24gb24gdGhlIGF0bGFzIGltYWdlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMuaWNvbk1hcHBpbmdbaWNvbl9uYW1lXS55IC0geSBwb3NpdGlvbiBvZiBpY29uIG9uIHRoZSBhdGxhcyBpbWFnZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzLmljb25NYXBwaW5nW2ljb25fbmFtZV0ud2lkdGggLSB3aWR0aCBvZiBpY29uIG9uIHRoZSBhdGxhcyBpbWFnZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzLmljb25NYXBwaW5nW2ljb25fbmFtZV0uaGVpZ2h0IC0gaGVpZ2h0IG9mIGljb24gb24gdGhlIGF0bGFzIGltYWdlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMuaWNvbk1hcHBpbmdbaWNvbl9uYW1lXS5hbmNob3JYIC0geCBhbmNob3Igb2YgaWNvbiBvbiB0aGUgYXRsYXMgaW1hZ2UsXG4gKiAgIGRlZmF1bHQgdG8gd2lkdGggLyAyXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMuaWNvbk1hcHBpbmdbaWNvbl9uYW1lXS5hbmNob3JZIC0geSBhbmNob3Igb2YgaWNvbiBvbiB0aGUgYXRsYXMgaW1hZ2UsXG4gKiAgIGRlZmF1bHQgdG8gaGVpZ2h0IC8gMlxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzLmljb25NYXBwaW5nW2ljb25fbmFtZV0ubWFzayAtIHdoZXRoZXIgaWNvbiBpcyB0cmVhdGVkIGFzIGEgdHJhbnNwYXJlbmN5XG4gKiAgIG1hc2suIElmIHRydWUsIHVzZXIgZGVmaW5lZCBjb2xvciBpcyBhcHBsaWVkLiBJZiBmYWxzZSwgb3JpZ2luYWwgY29sb3IgZnJvbSB0aGUgaW1hZ2UgaXNcbiAqICAgYXBwbGllZC4gRGVmYXVsdCB0byBmYWxzZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwcm9wcy5zaXplIC0gaWNvbiBzaXplIGluIHBpeGVsc1xuICogQHBhcmFtIHtmdW5jfSBwcm9wcy5nZXRQb3NpdGlvbiAtIHJldHVybnMgYW5jaG9yIHBvc2l0aW9uIG9mIHRoZSBpY29uLCBpbiBbbG5nLCBsYXQsIHpdXG4gKiBAcGFyYW0ge2Z1bmN9IHByb3BzLmdldEljb24gLSByZXR1cm5zIGljb24gbmFtZSBhcyBhIHN0cmluZ1xuICogQHBhcmFtIHtmdW5jfSBwcm9wcy5nZXRTaXplIC0gcmV0dXJucyBpY29uIHNpemUgbXVsdGlwbGllciBhcyBhIG51bWJlclxuICogQHBhcmFtIHtmdW5jfSBwcm9wcy5nZXRDb2xvciAtIHJldHVybnMgY29sb3Igb2YgdGhlIGljb24gaW4gW3IsIGcsIGIsIGFdLiBPbmx5IHdvcmtzIG9uIGljb25zXG4gKiAgIHdpdGggbWFzazogdHJ1ZS5cbiAqL1xuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBpY29uQXRsYXM6IG51bGwsXG4gIGljb25NYXBwaW5nOiB7fSxcbiAgc2l6ZVNjYWxlOiAxLFxuICBmcDY0OiBmYWxzZSxcblxuICBnZXRQb3NpdGlvbjogeCA9PiB4LnBvc2l0aW9uLFxuICBnZXRJY29uOiB4ID0+IHguaWNvbixcbiAgZ2V0Q29sb3I6IHggPT4geC5jb2xvciB8fCBERUZBVUxUX0NPTE9SLFxuICBnZXRTaXplOiB4ID0+IHguc2l6ZSB8fCAxXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJY29uTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkSW5zdGFuY2VkKHtcbiAgICAgIGluc3RhbmNlUG9zaXRpb25zOiB7c2l6ZTogMywgYWNjZXNzb3I6ICdnZXRQb3NpdGlvbicsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9uc30sXG4gICAgICBpbnN0YW5jZVNpemVzOiB7c2l6ZTogMSwgYWNjZXNzb3I6ICdnZXRTaXplJywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlU2l6ZXN9LFxuICAgICAgaW5zdGFuY2VPZmZzZXRzOiB7c2l6ZTogMiwgYWNjZXNzb3I6ICdnZXRJY29uJywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlT2Zmc2V0c30sXG4gICAgICBpbnN0YW5jZUljb25GcmFtZXM6IHtzaXplOiA0LCBhY2Nlc3NvcjogJ2dldEljb24nLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VJY29uRnJhbWVzfSxcbiAgICAgIGluc3RhbmNlQ29sb3JNb2Rlczoge3NpemU6IDEsIHR5cGU6IEdMLlVOU0lHTkVEX0JZVEUsIGFjY2Vzc29yOiAnZ2V0SWNvbicsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZUNvbG9yTW9kZX0sXG4gICAgICBpbnN0YW5jZUNvbG9yczoge3NpemU6IDQsIHR5cGU6IEdMLlVOU0lHTkVEX0JZVEUsIGFjY2Vzc29yOiAnZ2V0Q29sb3InLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VDb2xvcnN9XG4gICAgfSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbiAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuICAgIHRoaXMuc2V0U3RhdGUoe21vZGVsOiB0aGlzLl9nZXRNb2RlbChnbCl9KTtcbiAgfVxuXG4gIHVwZGF0ZUF0dHJpYnV0ZSh7cHJvcHMsIG9sZFByb3BzLCBjaGFuZ2VGbGFnc30pIHtcbiAgICBpZiAocHJvcHMuZnA2NCAhPT0gb2xkUHJvcHMuZnA2NCkge1xuICAgICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZUFsbCgpO1xuXG4gICAgICBpZiAocHJvcHMuZnA2NCAmJiBwcm9wcy5wcm9qZWN0aW9uTW9kZSA9PT0gQ09PUkRJTkFURV9TWVNURU0uTE5HX0xBVCkge1xuICAgICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICAgICAgaW5zdGFuY2VQb3NpdGlvbnM2NHh5TG93OiB7XG4gICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgYWNjZXNzb3I6ICdnZXRQb3NpdGlvbicsXG4gICAgICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnM2NHh5TG93XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJpYnV0ZU1hbmFnZXIucmVtb3ZlKFtcbiAgICAgICAgICAnaW5zdGFuY2VQb3NpdGlvbnM2NHh5TG93J1xuICAgICAgICBdKTtcbiAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZVN0YXRlKHtvbGRQcm9wcywgcHJvcHMsIGNoYW5nZUZsYWdzfSkge1xuICAgIHN1cGVyLnVwZGF0ZVN0YXRlKHtwcm9wcywgb2xkUHJvcHMsIGNoYW5nZUZsYWdzfSk7XG5cbiAgICBjb25zdCB7aWNvbkF0bGFzfSA9IHByb3BzO1xuXG4gICAgaWYgKG9sZFByb3BzLmljb25BdGxhcyAhPT0gaWNvbkF0bGFzKSB7XG4gICAgICBjb25zdCBpY29ucyA9IHt9O1xuICAgICAgdGhpcy5zdGF0ZS5pY29ucyA9IGljb25zO1xuXG4gICAgICBpZiAoaWNvbkF0bGFzIGluc3RhbmNlb2YgVGV4dHVyZTJEKSB7XG4gICAgICAgIGljb25zLnRleHR1cmUgPSBpY29uQXRsYXM7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpY29uQXRsYXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGxvYWRUZXh0dXJlcyh0aGlzLmNvbnRleHQuZ2wsIHtcbiAgICAgICAgICB1cmxzOiBbaWNvbkF0bGFzXVxuICAgICAgICB9KVxuICAgICAgICAudGhlbigoW3RleHR1cmVdKSA9PiB7XG4gICAgICAgICAgaWNvbnMudGV4dHVyZSA9IHRleHR1cmU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9wcy5mcDY0ICE9PSBvbGRQcm9wcy5mcDY0KSB7XG4gICAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7bW9kZWw6IHRoaXMuX2dldE1vZGVsKGdsKX0pO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUF0dHJpYnV0ZSh7cHJvcHMsIG9sZFByb3BzLCBjaGFuZ2VGbGFnc30pO1xuXG4gIH1cblxuICBkcmF3KHt1bmlmb3Jtc30pIHtcbiAgICBjb25zdCB7c2l6ZVNjYWxlfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgaWNvbnNUZXh0dXJlID0gdGhpcy5zdGF0ZS5pY29ucyAmJiB0aGlzLnN0YXRlLmljb25zLnRleHR1cmU7XG5cbiAgICBpZiAoaWNvbnNUZXh0dXJlKSB7XG4gICAgICB0aGlzLnN0YXRlLm1vZGVsLnJlbmRlcihPYmplY3QuYXNzaWduKHt9LCB1bmlmb3Jtcywge1xuICAgICAgICBpY29uc1RleHR1cmUsXG4gICAgICAgIGljb25zVGV4dHVyZURpbTogW2ljb25zVGV4dHVyZS53aWR0aCwgaWNvbnNUZXh0dXJlLmhlaWdodF0sXG4gICAgICAgIHNpemVTY2FsZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxuXG4gIGdldFNoYWRlcnMoKSB7XG4gICAgcmV0dXJuIGVuYWJsZTY0Yml0U3VwcG9ydCh0aGlzLnByb3BzKSA/IHtcbiAgICAgIHZzOiBpY29uVmVydGV4NjQsIGZzOiBpY29uRnJhZ21lbnQsIG1vZHVsZXM6IFsnZnA2NCcsICdwcm9qZWN0NjQnXVxuICAgIH0gOiB7XG4gICAgICB2czogaWNvblZlcnRleCwgZnM6IGljb25GcmFnbWVudCwgbW9kdWxlczogW11cbiAgICB9O1xuICB9XG5cbiAgX2dldE1vZGVsKGdsKSB7XG4gICAgY29uc3QgcG9zaXRpb25zID0gWy0xLCAtMSwgMCwgLTEsIDEsIDAsIDEsIDEsIDAsIDEsIC0xLCAwXTtcblxuICAgIGNvbnN0IHNoYWRlcnMgPSBhc3NlbWJsZVNoYWRlcnMoZ2wsIHRoaXMuZ2V0U2hhZGVycygpKTtcblxuICAgIHJldHVybiBuZXcgTW9kZWwoe1xuICAgICAgZ2wsXG4gICAgICBpZDogdGhpcy5wcm9wcy5pZCxcbiAgICAgIHZzOiBzaGFkZXJzLnZzLFxuICAgICAgZnM6IHNoYWRlcnMuZnMsXG4gICAgICBnZW9tZXRyeTogbmV3IEdlb21ldHJ5KHtcbiAgICAgICAgZHJhd01vZGU6IEdMLlRSSUFOR0xFX0ZBTixcbiAgICAgICAgcG9zaXRpb25zOiBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9ucylcbiAgICAgIH0pLFxuICAgICAgaXNJbnN0YW5jZWQ6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtkYXRhLCBnZXRQb3NpdGlvbn0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHt2YWx1ZX0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UG9zaXRpb24ob2JqZWN0KTtcbiAgICAgIHZhbHVlW2krK10gPSBwb3NpdGlvblswXTtcbiAgICAgIHZhbHVlW2krK10gPSBwb3NpdGlvblsxXTtcbiAgICAgIHZhbHVlW2krK10gPSBwb3NpdGlvblsyXSB8fCAwO1xuICAgIH1cbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zNjR4eUxvdyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7ZGF0YSwgZ2V0UG9zaXRpb259ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7dmFsdWV9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IHBvaW50IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UG9zaXRpb24ocG9pbnQpO1xuICAgICAgdmFsdWVbaSsrXSA9IGZwNjRpZnkocG9zaXRpb25bMF0pWzFdO1xuICAgICAgdmFsdWVbaSsrXSA9IGZwNjRpZnkocG9zaXRpb25bMV0pWzFdO1xuICAgIH1cbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlU2l6ZXMoYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2RhdGEsIGdldFNpemV9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7dmFsdWV9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBkYXRhKSB7XG4gICAgICB2YWx1ZVtpKytdID0gZ2V0U2l6ZShvYmplY3QpO1xuICAgIH1cbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlQ29sb3JzKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtkYXRhLCBnZXRDb2xvcn0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHt2YWx1ZX0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gZ2V0Q29sb3Iob2JqZWN0KTtcblxuICAgICAgdmFsdWVbaSsrXSA9IGNvbG9yWzBdO1xuICAgICAgdmFsdWVbaSsrXSA9IGNvbG9yWzFdO1xuICAgICAgdmFsdWVbaSsrXSA9IGNvbG9yWzJdO1xuICAgICAgdmFsdWVbaSsrXSA9IGlzTmFOKGNvbG9yWzNdKSA/IDI1NSA6IGNvbG9yWzNdO1xuICAgIH1cbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlT2Zmc2V0cyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7ZGF0YSwgaWNvbk1hcHBpbmcsIGdldEljb259ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7dmFsdWV9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBkYXRhKSB7XG4gICAgICBjb25zdCBpY29uID0gZ2V0SWNvbihvYmplY3QpO1xuICAgICAgY29uc3QgcmVjdCA9IGljb25NYXBwaW5nW2ljb25dIHx8IHt9O1xuICAgICAgdmFsdWVbaSsrXSA9ICgxIC8gMiAtIHJlY3QuYW5jaG9yWCAvIHJlY3Qud2lkdGgpIHx8IDA7XG4gICAgICB2YWx1ZVtpKytdID0gKDEgLyAyIC0gcmVjdC5hbmNob3JZIC8gcmVjdC5oZWlnaHQpIHx8IDA7XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VDb2xvck1vZGUoYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2RhdGEsIGljb25NYXBwaW5nLCBnZXRJY29ufSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3ZhbHVlfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgZGF0YSkge1xuICAgICAgY29uc3QgaWNvbiA9IGdldEljb24ob2JqZWN0KTtcbiAgICAgIGNvbnN0IGNvbG9yTW9kZSA9IGljb25NYXBwaW5nW2ljb25dICYmIGljb25NYXBwaW5nW2ljb25dLm1hc2s7XG4gICAgICB2YWx1ZVtpKytdID0gY29sb3JNb2RlID8gMSA6IDA7XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VJY29uRnJhbWVzKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtkYXRhLCBpY29uTWFwcGluZywgZ2V0SWNvbn0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHt2YWx1ZX0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IGljb24gPSBnZXRJY29uKG9iamVjdCk7XG4gICAgICBjb25zdCByZWN0ID0gaWNvbk1hcHBpbmdbaWNvbl0gfHwge307XG4gICAgICB2YWx1ZVtpKytdID0gcmVjdC54IHx8IDA7XG4gICAgICB2YWx1ZVtpKytdID0gcmVjdC55IHx8IDA7XG4gICAgICB2YWx1ZVtpKytdID0gcmVjdC53aWR0aCB8fCAwO1xuICAgICAgdmFsdWVbaSsrXSA9IHJlY3QuaGVpZ2h0IHx8IDA7XG4gICAgfVxuICB9XG59XG5cbkljb25MYXllci5sYXllck5hbWUgPSAnSWNvbkxheWVyJztcbkljb25MYXllci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9sYXllcnMvY29yZS9pY29uLWxheWVyL2ljb24tbGF5ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 40 */
/* exports provided: default */
/* exports used: default */
/*!**************************************************!*\
  !*** ./src/layers/core/line-layer/line-layer.js ***!
  \**************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl__ = __webpack_require__(/*! luma.gl */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__ = __webpack_require__(/*! ../../../lib/utils/fp64 */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__line_layer_vertex_glsl__ = __webpack_require__(/*! ./line-layer-vertex.glsl */ 71);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__line_layer_vertex_64_glsl__ = __webpack_require__(/*! ./line-layer-vertex-64.glsl */ 70);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__line_layer_fragment_glsl__ = __webpack_require__(/*! ./line-layer-fragment.glsl */ 69);\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\n\n\n\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\n\nconst defaultProps = {\n  strokeWidth: 1,\n  fp64: false,\n\n  getSourcePosition: x => x.sourcePosition,\n  getTargetPosition: x => x.targetPosition,\n  getColor: x => x.color || DEFAULT_COLOR\n};\n\nclass LineLayer extends __WEBPACK_IMPORTED_MODULE_0__lib__[\"a\" /* Layer */] {\n  getShaders() {\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__[\"b\" /* enable64bitSupport */])(this.props) ? {\n      vs: __WEBPACK_IMPORTED_MODULE_5__line_layer_vertex_64_glsl__[\"a\" /* default */], fs: __WEBPACK_IMPORTED_MODULE_6__line_layer_fragment_glsl__[\"a\" /* default */], modules: ['fp64', 'project64']\n    } : {\n      vs: __WEBPACK_IMPORTED_MODULE_4__line_layer_vertex_glsl__[\"a\" /* default */], fs: __WEBPACK_IMPORTED_MODULE_6__line_layer_fragment_glsl__[\"a\" /* default */], modules: []\n    };\n  }\n\n  initializeState() {\n\n    const {gl} = this.context;\n    this.setState({model: this._getModel(gl)});\n\n    const {attributeManager} = this.state;\n\n    /* eslint-disable max-len */\n    attributeManager.addInstanced({\n      instanceSourcePositions: {size: 3, accessor: 'getSourcePosition', update: this.calculateInstanceSourcePositions},\n      instanceTargetPositions: {size: 3, accessor: 'getTargetPosition', update: this.calculateInstanceTargetPositions},\n      instanceColors: {size: 4, type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].UNSIGNED_BYTE, accessor: 'getColor', update: this.calculateInstanceColors}\n    });\n    /* eslint-enable max-len */\n  }\n\n  updateAttribute({props, oldProps, changeFlags}) {\n    if (props.fp64 !== oldProps.fp64) {\n      const {attributeManager} = this.state;\n      attributeManager.invalidateAll();\n\n      if (props.fp64 && props.projectionMode === __WEBPACK_IMPORTED_MODULE_0__lib__[\"e\" /* COORDINATE_SYSTEM */].LNG_LAT) {\n        attributeManager.addInstanced({\n          instanceSourceTargetPositions64xyLow: {\n            size: 4,\n            accessor: ['getSourcePosition', 'getTargetPosition'],\n            update: this.calculateInstanceSourceTargetPositions64xyLow\n          }\n        });\n      } else {\n        attributeManager.remove([\n          'instanceSourceTargetPositions64xyLow'\n        ]);\n      }\n    }\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    super.updateState({props, oldProps, changeFlags});\n\n    if (props.fp64 !== oldProps.fp64) {\n      const {gl} = this.context;\n      this.setState({model: this._getModel(gl)});\n    }\n    this.updateAttribute({props, oldProps, changeFlags});\n  }\n\n  draw({uniforms}) {\n    const {strokeWidth} = this.props;\n\n    this.state.model.render(Object.assign({}, uniforms, {\n      strokeWidth\n    }));\n  }\n\n  _getModel(gl) {\n    /*\n     *  (0, -1)-------------_(1, -1)\n     *       |          _,-\"  |\n     *       o      _,-\"      o\n     *       |  _,-\"          |\n     *   (0, 1)\"-------------(1, 1)\n     */\n    const positions = [0, -1, 0, 0, 1, 0, 1, -1, 0, 1, 1, 0];\n\n    const shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"a\" /* assembleShaders */])(gl, this.getShaders());\n\n    return new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Model\"]({\n      gl,\n      id: this.props.id,\n      vs: shaders.vs,\n      fs: shaders.fs,\n      geometry: new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Geometry\"]({\n        drawMode: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].TRIANGLE_STRIP,\n        positions: new Float32Array(positions)\n      }),\n      isInstanced: true\n    });\n  }\n\n  calculateInstanceSourcePositions(attribute) {\n    const {data, getSourcePosition} = this.props;\n    const {value, size} = attribute;\n    let i = 0;\n    for (const object of data) {\n      const sourcePosition = getSourcePosition(object);\n      value[i + 0] = sourcePosition[0];\n      value[i + 1] = sourcePosition[1];\n      value[i + 2] = isNaN(sourcePosition[2]) ? 0 : sourcePosition[2];\n      i += size;\n    }\n  }\n\n  calculateInstanceTargetPositions(attribute) {\n    const {data, getTargetPosition} = this.props;\n    const {value, size} = attribute;\n    let i = 0;\n    for (const object of data) {\n      const targetPosition = getTargetPosition(object);\n      value[i + 0] = targetPosition[0];\n      value[i + 1] = targetPosition[1];\n      value[i + 2] = isNaN(targetPosition[2]) ? 0 : targetPosition[2];\n      i += size;\n    }\n  }\n\n  calculateInstanceSourceTargetPositions64xyLow(attribute) {\n    const {data, getSourcePosition, getTargetPosition} = this.props;\n    const {value, size} = attribute;\n    let i = 0;\n    for (const object of data) {\n      const sourcePosition = getSourcePosition(object);\n      const targetPosition = getTargetPosition(object);\n      value[i + 0] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__[\"a\" /* fp64ify */])(sourcePosition[0])[1];\n      value[i + 1] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__[\"a\" /* fp64ify */])(sourcePosition[1])[1];\n      value[i + 2] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__[\"a\" /* fp64ify */])(targetPosition[0])[1];\n      value[i + 3] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__[\"a\" /* fp64ify */])(targetPosition[1])[1];\n      i += size;\n    }\n  }\n\n  calculateInstanceColors(attribute) {\n    const {data, getColor} = this.props;\n    const {value, size} = attribute;\n    let i = 0;\n    for (const object of data) {\n      const color = getColor(object);\n      value[i + 0] = color[0];\n      value[i + 1] = color[1];\n      value[i + 2] = color[2];\n      value[i + 3] = isNaN(color[3]) ? 255 : color[3];\n      i += size;\n    }\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = LineLayer;\n\n\nLineLayer.layerName = 'LineLayer';\nLineLayer.defaultProps = defaultProps;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvbGluZS1sYXllci9saW5lLWxheWVyLmpzPzA5NjgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtMYXllcn0gZnJvbSAnLi4vLi4vLi4vbGliJztcbmltcG9ydCB7YXNzZW1ibGVTaGFkZXJzfSBmcm9tICcuLi8uLi8uLi9zaGFkZXItdXRpbHMnO1xuaW1wb3J0IHtHTCwgTW9kZWwsIEdlb21ldHJ5fSBmcm9tICdsdW1hLmdsJztcbmltcG9ydCB7ZnA2NGlmeSwgZW5hYmxlNjRiaXRTdXBwb3J0fSBmcm9tICcuLi8uLi8uLi9saWIvdXRpbHMvZnA2NCc7XG5pbXBvcnQge0NPT1JESU5BVEVfU1lTVEVNfSBmcm9tICcuLi8uLi8uLi9saWInO1xuXG5pbXBvcnQgbGluZVZlcnRleCBmcm9tICcuL2xpbmUtbGF5ZXItdmVydGV4Lmdsc2wnO1xuaW1wb3J0IGxpbmVWZXJ0ZXg2NCBmcm9tICcuL2xpbmUtbGF5ZXItdmVydGV4LTY0Lmdsc2wnO1xuaW1wb3J0IGxpbmVGcmFnbWVudCBmcm9tICcuL2xpbmUtbGF5ZXItZnJhZ21lbnQuZ2xzbCc7XG5cbmNvbnN0IERFRkFVTFRfQ09MT1IgPSBbMCwgMCwgMCwgMjU1XTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBzdHJva2VXaWR0aDogMSxcbiAgZnA2NDogZmFsc2UsXG5cbiAgZ2V0U291cmNlUG9zaXRpb246IHggPT4geC5zb3VyY2VQb3NpdGlvbixcbiAgZ2V0VGFyZ2V0UG9zaXRpb246IHggPT4geC50YXJnZXRQb3NpdGlvbixcbiAgZ2V0Q29sb3I6IHggPT4geC5jb2xvciB8fCBERUZBVUxUX0NPTE9SXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5lTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIGdldFNoYWRlcnMoKSB7XG4gICAgcmV0dXJuIGVuYWJsZTY0Yml0U3VwcG9ydCh0aGlzLnByb3BzKSA/IHtcbiAgICAgIHZzOiBsaW5lVmVydGV4NjQsIGZzOiBsaW5lRnJhZ21lbnQsIG1vZHVsZXM6IFsnZnA2NCcsICdwcm9qZWN0NjQnXVxuICAgIH0gOiB7XG4gICAgICB2czogbGluZVZlcnRleCwgZnM6IGxpbmVGcmFnbWVudCwgbW9kdWxlczogW11cbiAgICB9O1xuICB9XG5cbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuXG4gICAgY29uc3Qge2dsfSA9IHRoaXMuY29udGV4dDtcbiAgICB0aGlzLnNldFN0YXRlKHttb2RlbDogdGhpcy5fZ2V0TW9kZWwoZ2wpfSk7XG5cbiAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkSW5zdGFuY2VkKHtcbiAgICAgIGluc3RhbmNlU291cmNlUG9zaXRpb25zOiB7c2l6ZTogMywgYWNjZXNzb3I6ICdnZXRTb3VyY2VQb3NpdGlvbicsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVNvdXJjZVBvc2l0aW9uc30sXG4gICAgICBpbnN0YW5jZVRhcmdldFBvc2l0aW9uczoge3NpemU6IDMsIGFjY2Vzc29yOiAnZ2V0VGFyZ2V0UG9zaXRpb24nLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VUYXJnZXRQb3NpdGlvbnN9LFxuICAgICAgaW5zdGFuY2VDb2xvcnM6IHtzaXplOiA0LCB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLCBhY2Nlc3NvcjogJ2dldENvbG9yJywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlQ29sb3JzfVxuICAgIH0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuICB9XG5cbiAgdXBkYXRlQXR0cmlidXRlKHtwcm9wcywgb2xkUHJvcHMsIGNoYW5nZUZsYWdzfSkge1xuICAgIGlmIChwcm9wcy5mcDY0ICE9PSBvbGRQcm9wcy5mcDY0KSB7XG4gICAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgICAgYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlQWxsKCk7XG5cbiAgICAgIGlmIChwcm9wcy5mcDY0ICYmIHByb3BzLnByb2plY3Rpb25Nb2RlID09PSBDT09SRElOQVRFX1NZU1RFTS5MTkdfTEFUKSB7XG4gICAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkSW5zdGFuY2VkKHtcbiAgICAgICAgICBpbnN0YW5jZVNvdXJjZVRhcmdldFBvc2l0aW9uczY0eHlMb3c6IHtcbiAgICAgICAgICAgIHNpemU6IDQsXG4gICAgICAgICAgICBhY2Nlc3NvcjogWydnZXRTb3VyY2VQb3NpdGlvbicsICdnZXRUYXJnZXRQb3NpdGlvbiddLFxuICAgICAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlU291cmNlVGFyZ2V0UG9zaXRpb25zNjR4eUxvd1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyaWJ1dGVNYW5hZ2VyLnJlbW92ZShbXG4gICAgICAgICAgJ2luc3RhbmNlU291cmNlVGFyZ2V0UG9zaXRpb25zNjR4eUxvdydcbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlU3RhdGUoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KSB7XG4gICAgc3VwZXIudXBkYXRlU3RhdGUoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KTtcblxuICAgIGlmIChwcm9wcy5mcDY0ICE9PSBvbGRQcm9wcy5mcDY0KSB7XG4gICAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7bW9kZWw6IHRoaXMuX2dldE1vZGVsKGdsKX0pO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUF0dHJpYnV0ZSh7cHJvcHMsIG9sZFByb3BzLCBjaGFuZ2VGbGFnc30pO1xuICB9XG5cbiAgZHJhdyh7dW5pZm9ybXN9KSB7XG4gICAgY29uc3Qge3N0cm9rZVdpZHRofSA9IHRoaXMucHJvcHM7XG5cbiAgICB0aGlzLnN0YXRlLm1vZGVsLnJlbmRlcihPYmplY3QuYXNzaWduKHt9LCB1bmlmb3Jtcywge1xuICAgICAgc3Ryb2tlV2lkdGhcbiAgICB9KSk7XG4gIH1cblxuICBfZ2V0TW9kZWwoZ2wpIHtcbiAgICAvKlxuICAgICAqICAoMCwgLTEpLS0tLS0tLS0tLS0tLV8oMSwgLTEpXG4gICAgICogICAgICAgfCAgICAgICAgICBfLC1cIiAgfFxuICAgICAqICAgICAgIG8gICAgICBfLC1cIiAgICAgIG9cbiAgICAgKiAgICAgICB8ICBfLC1cIiAgICAgICAgICB8XG4gICAgICogICAoMCwgMSlcIi0tLS0tLS0tLS0tLS0oMSwgMSlcbiAgICAgKi9cbiAgICBjb25zdCBwb3NpdGlvbnMgPSBbMCwgLTEsIDAsIDAsIDEsIDAsIDEsIC0xLCAwLCAxLCAxLCAwXTtcblxuICAgIGNvbnN0IHNoYWRlcnMgPSBhc3NlbWJsZVNoYWRlcnMoZ2wsIHRoaXMuZ2V0U2hhZGVycygpKTtcblxuICAgIHJldHVybiBuZXcgTW9kZWwoe1xuICAgICAgZ2wsXG4gICAgICBpZDogdGhpcy5wcm9wcy5pZCxcbiAgICAgIHZzOiBzaGFkZXJzLnZzLFxuICAgICAgZnM6IHNoYWRlcnMuZnMsXG4gICAgICBnZW9tZXRyeTogbmV3IEdlb21ldHJ5KHtcbiAgICAgICAgZHJhd01vZGU6IEdMLlRSSUFOR0xFX1NUUklQLFxuICAgICAgICBwb3NpdGlvbnM6IG5ldyBGbG9hdDMyQXJyYXkocG9zaXRpb25zKVxuICAgICAgfSksXG4gICAgICBpc0luc3RhbmNlZDogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VTb3VyY2VQb3NpdGlvbnMoYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2RhdGEsIGdldFNvdXJjZVBvc2l0aW9ufSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3ZhbHVlLCBzaXplfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgZGF0YSkge1xuICAgICAgY29uc3Qgc291cmNlUG9zaXRpb24gPSBnZXRTb3VyY2VQb3NpdGlvbihvYmplY3QpO1xuICAgICAgdmFsdWVbaSArIDBdID0gc291cmNlUG9zaXRpb25bMF07XG4gICAgICB2YWx1ZVtpICsgMV0gPSBzb3VyY2VQb3NpdGlvblsxXTtcbiAgICAgIHZhbHVlW2kgKyAyXSA9IGlzTmFOKHNvdXJjZVBvc2l0aW9uWzJdKSA/IDAgOiBzb3VyY2VQb3NpdGlvblsyXTtcbiAgICAgIGkgKz0gc2l6ZTtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZVRhcmdldFBvc2l0aW9ucyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7ZGF0YSwgZ2V0VGFyZ2V0UG9zaXRpb259ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7dmFsdWUsIHNpemV9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBkYXRhKSB7XG4gICAgICBjb25zdCB0YXJnZXRQb3NpdGlvbiA9IGdldFRhcmdldFBvc2l0aW9uKG9iamVjdCk7XG4gICAgICB2YWx1ZVtpICsgMF0gPSB0YXJnZXRQb3NpdGlvblswXTtcbiAgICAgIHZhbHVlW2kgKyAxXSA9IHRhcmdldFBvc2l0aW9uWzFdO1xuICAgICAgdmFsdWVbaSArIDJdID0gaXNOYU4odGFyZ2V0UG9zaXRpb25bMl0pID8gMCA6IHRhcmdldFBvc2l0aW9uWzJdO1xuICAgICAgaSArPSBzaXplO1xuICAgIH1cbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlU291cmNlVGFyZ2V0UG9zaXRpb25zNjR4eUxvdyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7ZGF0YSwgZ2V0U291cmNlUG9zaXRpb24sIGdldFRhcmdldFBvc2l0aW9ufSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3ZhbHVlLCBzaXplfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgZGF0YSkge1xuICAgICAgY29uc3Qgc291cmNlUG9zaXRpb24gPSBnZXRTb3VyY2VQb3NpdGlvbihvYmplY3QpO1xuICAgICAgY29uc3QgdGFyZ2V0UG9zaXRpb24gPSBnZXRUYXJnZXRQb3NpdGlvbihvYmplY3QpO1xuICAgICAgdmFsdWVbaSArIDBdID0gZnA2NGlmeShzb3VyY2VQb3NpdGlvblswXSlbMV07XG4gICAgICB2YWx1ZVtpICsgMV0gPSBmcDY0aWZ5KHNvdXJjZVBvc2l0aW9uWzFdKVsxXTtcbiAgICAgIHZhbHVlW2kgKyAyXSA9IGZwNjRpZnkodGFyZ2V0UG9zaXRpb25bMF0pWzFdO1xuICAgICAgdmFsdWVbaSArIDNdID0gZnA2NGlmeSh0YXJnZXRQb3NpdGlvblsxXSlbMV07XG4gICAgICBpICs9IHNpemU7XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VDb2xvcnMoYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2RhdGEsIGdldENvbG9yfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3ZhbHVlLCBzaXplfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgZGF0YSkge1xuICAgICAgY29uc3QgY29sb3IgPSBnZXRDb2xvcihvYmplY3QpO1xuICAgICAgdmFsdWVbaSArIDBdID0gY29sb3JbMF07XG4gICAgICB2YWx1ZVtpICsgMV0gPSBjb2xvclsxXTtcbiAgICAgIHZhbHVlW2kgKyAyXSA9IGNvbG9yWzJdO1xuICAgICAgdmFsdWVbaSArIDNdID0gaXNOYU4oY29sb3JbM10pID8gMjU1IDogY29sb3JbM107XG4gICAgICBpICs9IHNpemU7XG4gICAgfVxuICB9XG59XG5cbkxpbmVMYXllci5sYXllck5hbWUgPSAnTGluZUxheWVyJztcbkxpbmVMYXllci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9sYXllcnMvY29yZS9saW5lLWxheWVyL2xpbmUtbGF5ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 41 */
/* exports provided: default */
/* exports used: default */
/*!****************************************************************!*\
  !*** ./src/layers/core/point-cloud-layer/point-cloud-layer.js ***!
  \****************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl__ = __webpack_require__(/*! luma.gl */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__ = __webpack_require__(/*! ../../../lib/utils/fp64 */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__point_cloud_layer_vertex_glsl__ = __webpack_require__(/*! ./point-cloud-layer-vertex.glsl */ 77);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__point_cloud_layer_vertex_64_glsl__ = __webpack_require__(/*! ./point-cloud-layer-vertex-64.glsl */ 76);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__point_cloud_layer_fragment_glsl__ = __webpack_require__(/*! ./point-cloud-layer-fragment.glsl */ 75);\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\n\n\n\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\n\nconst defaultProps = {\n  radiusPixels: 10,  //  point radius in pixels\n  fp64: false,\n\n  getPosition: x => x.position,\n  getNormal: x => x.normal,\n  getColor: x => x.color || DEFAULT_COLOR,\n\n  lightSettings: {\n    lightsPosition: [0, 0, 5000, -1000, 1000, 8000, 5000, -5000, 1000],\n    ambientRatio: 0.2,\n    diffuseRatio: 0.6,\n    specularRatio: 0.8,\n    lightsStrength: [1.0, 0.0, 0.8, 0.0, 0.4, 0.0],\n    numberOfLights: 3\n  }\n};\n\nclass PointCloudLayer extends __WEBPACK_IMPORTED_MODULE_0__lib__[\"a\" /* Layer */] {\n  getShaders(id) {\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__[\"b\" /* enable64bitSupport */])(this.props) ? {\n      vs: __WEBPACK_IMPORTED_MODULE_5__point_cloud_layer_vertex_64_glsl__[\"a\" /* default */], fs: __WEBPACK_IMPORTED_MODULE_6__point_cloud_layer_fragment_glsl__[\"a\" /* default */], modules: ['fp64', 'project64', 'lighting']\n    } : {\n      vs: __WEBPACK_IMPORTED_MODULE_4__point_cloud_layer_vertex_glsl__[\"a\" /* default */], fs: __WEBPACK_IMPORTED_MODULE_6__point_cloud_layer_fragment_glsl__[\"a\" /* default */], modules: ['lighting']\n    };\n  }\n\n  initializeState() {\n    const {gl} = this.context;\n    this.setState({model: this._getModel(gl)});\n\n    /* eslint-disable max-len */\n    this.state.attributeManager.addInstanced({\n      instancePositions: {size: 3, accessor: 'getPosition', update: this.calculateInstancePositions},\n      instanceNormals: {size: 3, accessor: 'getNormal', defaultValue: 1, update: this.calculateInstanceNormals},\n      instanceColors: {size: 4, type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].UNSIGNED_BYTE, accessor: 'getColor', update: this.calculateInstanceColors}\n    });\n    /* eslint-enable max-len */\n  }\n\n  updateAttribute({props, oldProps, changeFlags}) {\n    if (props.fp64 !== oldProps.fp64) {\n      const {attributeManager} = this.state;\n      attributeManager.invalidateAll();\n\n      if (props.fp64 && props.projectionMode === __WEBPACK_IMPORTED_MODULE_0__lib__[\"e\" /* COORDINATE_SYSTEM */].LNG_LAT) {\n        attributeManager.addInstanced({\n          instancePositions64xyLow: {\n            size: 2,\n            accessor: 'getPosition',\n            update: this.calculateInstancePositions64xyLow\n          }\n        });\n      } else {\n        attributeManager.remove([\n          'instancePositions64xyLow'\n        ]);\n      }\n\n    }\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    super.updateState({props, oldProps, changeFlags});\n    if (props.fp64 !== oldProps.fp64) {\n      const {gl} = this.context;\n      this.setState({model: this._getModel(gl)});\n    }\n    this.updateAttribute({props, oldProps, changeFlags});\n  }\n\n  draw({uniforms}) {\n    const {radius, lightSettings} = this.props;\n    this.state.model.render(Object.assign({}, uniforms, {\n      radius\n    }, lightSettings));\n  }\n\n  _getModel(gl) {\n    // a triangle that minimally cover the unit circle\n    const positions = [];\n    for (let i = 0; i < 3; i++) {\n      const angle = i / 3 * Math.PI * 2;\n      positions.push(\n        Math.cos(angle) * 2,\n        Math.sin(angle) * 2,\n        0\n      );\n    }\n    const shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"a\" /* assembleShaders */])(gl, this.getShaders());\n\n    return new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Model\"]({\n      gl,\n      id: this.props.id,\n      vs: shaders.vs,\n      fs: shaders.fs,\n      geometry: new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Geometry\"]({\n        drawMode: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].TRIANGLES,\n        positions: new Float32Array(positions)\n      }),\n      isInstanced: true\n    });\n  }\n\n  calculateInstancePositions(attribute) {\n    const {data, getPosition} = this.props;\n    const {value} = attribute;\n    let i = 0;\n    for (const point of data) {\n      const position = getPosition(point);\n      value[i++] = position[0];\n      value[i++] = position[1];\n      value[i++] = position[2] || 0;\n    }\n  }\n\n  calculateInstancePositions64xyLow(attribute) {\n    const {data, getPosition} = this.props;\n    const {value} = attribute;\n    let i = 0;\n    for (const point of data) {\n      const position = getPosition(point);\n      value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__[\"a\" /* fp64ify */])(position[0])[1];\n      value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__[\"a\" /* fp64ify */])(position[1])[1];\n    }\n  }\n\n  calculateInstanceNormals(attribute) {\n    const {data, getNormal} = this.props;\n    const {value} = attribute;\n    let i = 0;\n    for (const point of data) {\n      const normal = getNormal(point);\n      value[i++] = normal[0];\n      value[i++] = normal[1];\n      value[i++] = normal[2];\n    }\n  }\n\n  calculateInstanceColors(attribute) {\n    const {data, getColor} = this.props;\n    const {value} = attribute;\n    let i = 0;\n    for (const point of data) {\n      const color = getColor(point);\n      value[i++] = color[0];\n      value[i++] = color[1];\n      value[i++] = color[2];\n      value[i++] = isNaN(color[3]) ? 255 : color[3];\n    }\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = PointCloudLayer;\n\n\nPointCloudLayer.layerName = 'PointCloudLayer';\nPointCloudLayer.defaultProps = defaultProps;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvcG9pbnQtY2xvdWQtbGF5ZXIvcG9pbnQtY2xvdWQtbGF5ZXIuanM/ZDcxOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge0xheWVyfSBmcm9tICcuLi8uLi8uLi9saWInO1xuaW1wb3J0IHthc3NlbWJsZVNoYWRlcnN9IGZyb20gJy4uLy4uLy4uL3NoYWRlci11dGlscyc7XG5pbXBvcnQge0dMLCBNb2RlbCwgR2VvbWV0cnl9IGZyb20gJ2x1bWEuZ2wnO1xuaW1wb3J0IHtmcDY0aWZ5LCBlbmFibGU2NGJpdFN1cHBvcnR9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscy9mcDY0JztcbmltcG9ydCB7Q09PUkRJTkFURV9TWVNURU19IGZyb20gJy4uLy4uLy4uL2xpYic7XG5cbmltcG9ydCBwb2ludENsb3VkVmVydGV4IGZyb20gJy4vcG9pbnQtY2xvdWQtbGF5ZXItdmVydGV4Lmdsc2wnO1xuaW1wb3J0IHBvaW50Q2xvdWRWZXJ0ZXg2NCBmcm9tICcuL3BvaW50LWNsb3VkLWxheWVyLXZlcnRleC02NC5nbHNsJztcbmltcG9ydCBwb2ludENsb3VkRnJhZ21lbnQgZnJvbSAnLi9wb2ludC1jbG91ZC1sYXllci1mcmFnbWVudC5nbHNsJztcblxuY29uc3QgREVGQVVMVF9DT0xPUiA9IFswLCAwLCAwLCAyNTVdO1xuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIHJhZGl1c1BpeGVsczogMTAsICAvLyAgcG9pbnQgcmFkaXVzIGluIHBpeGVsc1xuICBmcDY0OiBmYWxzZSxcblxuICBnZXRQb3NpdGlvbjogeCA9PiB4LnBvc2l0aW9uLFxuICBnZXROb3JtYWw6IHggPT4geC5ub3JtYWwsXG4gIGdldENvbG9yOiB4ID0+IHguY29sb3IgfHwgREVGQVVMVF9DT0xPUixcblxuICBsaWdodFNldHRpbmdzOiB7XG4gICAgbGlnaHRzUG9zaXRpb246IFswLCAwLCA1MDAwLCAtMTAwMCwgMTAwMCwgODAwMCwgNTAwMCwgLTUwMDAsIDEwMDBdLFxuICAgIGFtYmllbnRSYXRpbzogMC4yLFxuICAgIGRpZmZ1c2VSYXRpbzogMC42LFxuICAgIHNwZWN1bGFyUmF0aW86IDAuOCxcbiAgICBsaWdodHNTdHJlbmd0aDogWzEuMCwgMC4wLCAwLjgsIDAuMCwgMC40LCAwLjBdLFxuICAgIG51bWJlck9mTGlnaHRzOiAzXG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvaW50Q2xvdWRMYXllciBleHRlbmRzIExheWVyIHtcbiAgZ2V0U2hhZGVycyhpZCkge1xuICAgIHJldHVybiBlbmFibGU2NGJpdFN1cHBvcnQodGhpcy5wcm9wcykgPyB7XG4gICAgICB2czogcG9pbnRDbG91ZFZlcnRleDY0LCBmczogcG9pbnRDbG91ZEZyYWdtZW50LCBtb2R1bGVzOiBbJ2ZwNjQnLCAncHJvamVjdDY0JywgJ2xpZ2h0aW5nJ11cbiAgICB9IDoge1xuICAgICAgdnM6IHBvaW50Q2xvdWRWZXJ0ZXgsIGZzOiBwb2ludENsb3VkRnJhZ21lbnQsIG1vZHVsZXM6IFsnbGlnaHRpbmcnXVxuICAgIH07XG4gIH1cblxuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgY29uc3Qge2dsfSA9IHRoaXMuY29udGV4dDtcbiAgICB0aGlzLnNldFN0YXRlKHttb2RlbDogdGhpcy5fZ2V0TW9kZWwoZ2wpfSk7XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gICAgdGhpcy5zdGF0ZS5hdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICBpbnN0YW5jZVBvc2l0aW9uczoge3NpemU6IDMsIGFjY2Vzc29yOiAnZ2V0UG9zaXRpb24nLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnN9LFxuICAgICAgaW5zdGFuY2VOb3JtYWxzOiB7c2l6ZTogMywgYWNjZXNzb3I6ICdnZXROb3JtYWwnLCBkZWZhdWx0VmFsdWU6IDEsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZU5vcm1hbHN9LFxuICAgICAgaW5zdGFuY2VDb2xvcnM6IHtzaXplOiA0LCB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLCBhY2Nlc3NvcjogJ2dldENvbG9yJywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlQ29sb3JzfVxuICAgIH0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuICB9XG5cbiAgdXBkYXRlQXR0cmlidXRlKHtwcm9wcywgb2xkUHJvcHMsIGNoYW5nZUZsYWdzfSkge1xuICAgIGlmIChwcm9wcy5mcDY0ICE9PSBvbGRQcm9wcy5mcDY0KSB7XG4gICAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgICAgYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlQWxsKCk7XG5cbiAgICAgIGlmIChwcm9wcy5mcDY0ICYmIHByb3BzLnByb2plY3Rpb25Nb2RlID09PSBDT09SRElOQVRFX1NZU1RFTS5MTkdfTEFUKSB7XG4gICAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkSW5zdGFuY2VkKHtcbiAgICAgICAgICBpbnN0YW5jZVBvc2l0aW9uczY0eHlMb3c6IHtcbiAgICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgICBhY2Nlc3NvcjogJ2dldFBvc2l0aW9uJyxcbiAgICAgICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9uczY0eHlMb3dcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cmlidXRlTWFuYWdlci5yZW1vdmUoW1xuICAgICAgICAgICdpbnN0YW5jZVBvc2l0aW9uczY0eHlMb3cnXG4gICAgICAgIF0pO1xuICAgICAgfVxuXG4gICAgfVxuICB9XG5cbiAgdXBkYXRlU3RhdGUoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KSB7XG4gICAgc3VwZXIudXBkYXRlU3RhdGUoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KTtcbiAgICBpZiAocHJvcHMuZnA2NCAhPT0gb2xkUHJvcHMuZnA2NCkge1xuICAgICAgY29uc3Qge2dsfSA9IHRoaXMuY29udGV4dDtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe21vZGVsOiB0aGlzLl9nZXRNb2RlbChnbCl9KTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVBdHRyaWJ1dGUoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KTtcbiAgfVxuXG4gIGRyYXcoe3VuaWZvcm1zfSkge1xuICAgIGNvbnN0IHtyYWRpdXMsIGxpZ2h0U2V0dGluZ3N9ID0gdGhpcy5wcm9wcztcbiAgICB0aGlzLnN0YXRlLm1vZGVsLnJlbmRlcihPYmplY3QuYXNzaWduKHt9LCB1bmlmb3Jtcywge1xuICAgICAgcmFkaXVzXG4gICAgfSwgbGlnaHRTZXR0aW5ncykpO1xuICB9XG5cbiAgX2dldE1vZGVsKGdsKSB7XG4gICAgLy8gYSB0cmlhbmdsZSB0aGF0IG1pbmltYWxseSBjb3ZlciB0aGUgdW5pdCBjaXJjbGVcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgY29uc3QgYW5nbGUgPSBpIC8gMyAqIE1hdGguUEkgKiAyO1xuICAgICAgcG9zaXRpb25zLnB1c2goXG4gICAgICAgIE1hdGguY29zKGFuZ2xlKSAqIDIsXG4gICAgICAgIE1hdGguc2luKGFuZ2xlKSAqIDIsXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHNoYWRlcnMgPSBhc3NlbWJsZVNoYWRlcnMoZ2wsIHRoaXMuZ2V0U2hhZGVycygpKTtcblxuICAgIHJldHVybiBuZXcgTW9kZWwoe1xuICAgICAgZ2wsXG4gICAgICBpZDogdGhpcy5wcm9wcy5pZCxcbiAgICAgIHZzOiBzaGFkZXJzLnZzLFxuICAgICAgZnM6IHNoYWRlcnMuZnMsXG4gICAgICBnZW9tZXRyeTogbmV3IEdlb21ldHJ5KHtcbiAgICAgICAgZHJhd01vZGU6IEdMLlRSSUFOR0xFUyxcbiAgICAgICAgcG9zaXRpb25zOiBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9ucylcbiAgICAgIH0pLFxuICAgICAgaXNJbnN0YW5jZWQ6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtkYXRhLCBnZXRQb3NpdGlvbn0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHt2YWx1ZX0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3QgcG9pbnQgb2YgZGF0YSkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRQb3NpdGlvbihwb2ludCk7XG4gICAgICB2YWx1ZVtpKytdID0gcG9zaXRpb25bMF07XG4gICAgICB2YWx1ZVtpKytdID0gcG9zaXRpb25bMV07XG4gICAgICB2YWx1ZVtpKytdID0gcG9zaXRpb25bMl0gfHwgMDtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9uczY0eHlMb3coYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2RhdGEsIGdldFBvc2l0aW9ufSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3ZhbHVlfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBwb2ludCBvZiBkYXRhKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFBvc2l0aW9uKHBvaW50KTtcbiAgICAgIHZhbHVlW2krK10gPSBmcDY0aWZ5KHBvc2l0aW9uWzBdKVsxXTtcbiAgICAgIHZhbHVlW2krK10gPSBmcDY0aWZ5KHBvc2l0aW9uWzFdKVsxXTtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZU5vcm1hbHMoYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2RhdGEsIGdldE5vcm1hbH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHt2YWx1ZX0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3QgcG9pbnQgb2YgZGF0YSkge1xuICAgICAgY29uc3Qgbm9ybWFsID0gZ2V0Tm9ybWFsKHBvaW50KTtcbiAgICAgIHZhbHVlW2krK10gPSBub3JtYWxbMF07XG4gICAgICB2YWx1ZVtpKytdID0gbm9ybWFsWzFdO1xuICAgICAgdmFsdWVbaSsrXSA9IG5vcm1hbFsyXTtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZUNvbG9ycyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7ZGF0YSwgZ2V0Q29sb3J9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7dmFsdWV9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IHBvaW50IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gZ2V0Q29sb3IocG9pbnQpO1xuICAgICAgdmFsdWVbaSsrXSA9IGNvbG9yWzBdO1xuICAgICAgdmFsdWVbaSsrXSA9IGNvbG9yWzFdO1xuICAgICAgdmFsdWVbaSsrXSA9IGNvbG9yWzJdO1xuICAgICAgdmFsdWVbaSsrXSA9IGlzTmFOKGNvbG9yWzNdKSA/IDI1NSA6IGNvbG9yWzNdO1xuICAgIH1cbiAgfVxufVxuXG5Qb2ludENsb3VkTGF5ZXIubGF5ZXJOYW1lID0gJ1BvaW50Q2xvdWRMYXllcic7XG5Qb2ludENsb3VkTGF5ZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGF5ZXJzL2NvcmUvcG9pbnQtY2xvdWQtbGF5ZXIvcG9pbnQtY2xvdWQtbGF5ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 42 */
/* exports provided: default */
/* exports used: default */
/*!********************************************************!*\
  !*** ./src/layers/core/polygon-layer/polygon-layer.js ***!
  \********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__solid_polygon_layer_solid_polygon_layer__ = __webpack_require__(/*! ../solid-polygon-layer/solid-polygon-layer */ 26);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__path_layer_path_layer__ = __webpack_require__(/*! ../path-layer/path-layer */ 10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__solid_polygon_layer_polygon__ = __webpack_require__(/*! ../solid-polygon-layer/polygon */ 13);\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\nconst defaultColor = [0xBD, 0xE2, 0x7A, 0xFF];\nconst defaultFillColor = [0xBD, 0xE2, 0x7A, 0xFF];\n\nconst defaultProps = {\n  stroked: true,\n  filled: true,\n  extruded: false,\n  wireframe: false,\n  fp64: false,\n\n  // TODO: Missing props: radiusMinPixels, strokeWidthMinPixels, ...\n\n  // Polygon fill color\n  getFillColor: f => __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__[\"f\" /* get */])(f, 'fillColor') || defaultFillColor,\n  // Point, line and polygon outline color\n  getColor: f => __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__[\"f\" /* get */])(f, 'color') || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__[\"f\" /* get */])(f, 'strokeColor') || defaultColor,\n  // Line and polygon outline accessors\n  getWidth: f => __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__[\"f\" /* get */])(f, 'strokeWidth') || 1,\n  // Polygon extrusion accessor\n  getElevation: f => 1000\n};\n\nclass PolygonLayer extends __WEBPACK_IMPORTED_MODULE_0__lib__[\"b\" /* CompositeLayer */] {\n  initializeState() {\n    this.state = {\n      paths: [],\n      onHover: this._onHoverSubLayer.bind(this),\n      onClick: this._onClickSubLayer.bind(this)\n    };\n  }\n\n  updateState({oldProps, props, changeFlags}) {\n    if (changeFlags.dataChanged) {\n      const {data, getPolygon} = this.props;\n      this.state.paths = [];\n      data.forEach(object => {\n        const complexPolygon = __WEBPACK_IMPORTED_MODULE_3__solid_polygon_layer_polygon__[\"a\" /* normalize */](getPolygon(object));\n        complexPolygon.forEach(polygon => this.state.paths.push({\n          path: polygon,\n          object\n        }));\n      });\n    }\n  }\n\n  _onHoverSubLayer(info) {\n    info.object = (info.object && info.object.feature) || info.object;\n    this.props.onHover(info);\n  }\n\n  _onClickSubLayer(info) {\n    info.object = (info.object && info.object.feature) || info.object;\n    this.props.onClick(info);\n  }\n\n  renderLayers() {\n    const {getFillColor, getColor, getWidth, getElevation, updateTriggers} = this.props;\n    const {data, id, stroked, filled, extruded, wireframe} = this.props;\n    const {paths, onHover, onClick} = this.state;\n\n    const hasData = data && data.length > 0;\n\n    // Filled Polygon Layer\n    const polygonLayer = filled && hasData && new __WEBPACK_IMPORTED_MODULE_1__solid_polygon_layer_solid_polygon_layer__[\"a\" /* default */](Object.assign({},\n      this.props, {\n        id: `${id}-fill`,\n        data,\n        getElevation,\n        getColor: getFillColor,\n        extruded,\n        wireframe: false,\n        updateTriggers: {\n          getElevation: updateTriggers.getElevation,\n          getColor: updateTriggers.getFillColor\n        }\n      }));\n\n    const polygonWireframeLayer = extruded &&\n      wireframe &&\n      hasData &&\n      new __WEBPACK_IMPORTED_MODULE_1__solid_polygon_layer_solid_polygon_layer__[\"a\" /* default */](Object.assign({},\n      this.props, {\n        id: `${id}-wireframe`,\n        data,\n        getElevation,\n        getColor,\n        extruded: true,\n        wireframe: true,\n        updateTriggers: {\n          getElevation: updateTriggers.getElevation,\n          getColor: updateTriggers.getColor\n        }\n      }));\n\n    // Polygon outline layer\n    const polygonOutlineLayer = !extruded &&\n      stroked &&\n      hasData &&\n      new __WEBPACK_IMPORTED_MODULE_2__path_layer_path_layer__[\"a\" /* default */](Object.assign({}, this.props, {\n        id: `${id}-stroke`,\n        data: paths,\n        getPath: x => x.path,\n        getColor,\n        getWidth,\n        onHover,\n        onClick,\n        updateTriggers: {\n          getWidth: updateTriggers.getWidth,\n          getColor: updateTriggers.getColor\n        }\n      }));\n\n    return [\n      polygonLayer,\n      polygonWireframeLayer,\n      polygonOutlineLayer\n    ].filter(Boolean);\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = PolygonLayer;\n\n\nPolygonLayer.layerName = 'PolygonLayer';\nPolygonLayer.defaultProps = defaultProps;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvcG9seWdvbi1sYXllci9wb2x5Z29uLWxheWVyLmpzP2ExMWMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE2IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtDb21wb3NpdGVMYXllciwgZ2V0fSBmcm9tICcuLi8uLi8uLi9saWInO1xuaW1wb3J0IFNvbGlkUG9seWdvbkxheWVyIGZyb20gJy4uL3NvbGlkLXBvbHlnb24tbGF5ZXIvc29saWQtcG9seWdvbi1sYXllcic7XG5pbXBvcnQgUGF0aExheWVyIGZyb20gJy4uL3BhdGgtbGF5ZXIvcGF0aC1sYXllcic7XG5pbXBvcnQgKiBhcyBQb2x5Z29uIGZyb20gJy4uL3NvbGlkLXBvbHlnb24tbGF5ZXIvcG9seWdvbic7XG5cbmNvbnN0IGRlZmF1bHRDb2xvciA9IFsweEJELCAweEUyLCAweDdBLCAweEZGXTtcbmNvbnN0IGRlZmF1bHRGaWxsQ29sb3IgPSBbMHhCRCwgMHhFMiwgMHg3QSwgMHhGRl07XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgc3Ryb2tlZDogdHJ1ZSxcbiAgZmlsbGVkOiB0cnVlLFxuICBleHRydWRlZDogZmFsc2UsXG4gIHdpcmVmcmFtZTogZmFsc2UsXG4gIGZwNjQ6IGZhbHNlLFxuXG4gIC8vIFRPRE86IE1pc3NpbmcgcHJvcHM6IHJhZGl1c01pblBpeGVscywgc3Ryb2tlV2lkdGhNaW5QaXhlbHMsIC4uLlxuXG4gIC8vIFBvbHlnb24gZmlsbCBjb2xvclxuICBnZXRGaWxsQ29sb3I6IGYgPT4gZ2V0KGYsICdmaWxsQ29sb3InKSB8fCBkZWZhdWx0RmlsbENvbG9yLFxuICAvLyBQb2ludCwgbGluZSBhbmQgcG9seWdvbiBvdXRsaW5lIGNvbG9yXG4gIGdldENvbG9yOiBmID0+IGdldChmLCAnY29sb3InKSB8fCBnZXQoZiwgJ3N0cm9rZUNvbG9yJykgfHwgZGVmYXVsdENvbG9yLFxuICAvLyBMaW5lIGFuZCBwb2x5Z29uIG91dGxpbmUgYWNjZXNzb3JzXG4gIGdldFdpZHRoOiBmID0+IGdldChmLCAnc3Ryb2tlV2lkdGgnKSB8fCAxLFxuICAvLyBQb2x5Z29uIGV4dHJ1c2lvbiBhY2Nlc3NvclxuICBnZXRFbGV2YXRpb246IGYgPT4gMTAwMFxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9seWdvbkxheWVyIGV4dGVuZHMgQ29tcG9zaXRlTGF5ZXIge1xuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHBhdGhzOiBbXSxcbiAgICAgIG9uSG92ZXI6IHRoaXMuX29uSG92ZXJTdWJMYXllci5iaW5kKHRoaXMpLFxuICAgICAgb25DbGljazogdGhpcy5fb25DbGlja1N1YkxheWVyLmJpbmQodGhpcylcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlU3RhdGUoe29sZFByb3BzLCBwcm9wcywgY2hhbmdlRmxhZ3N9KSB7XG4gICAgaWYgKGNoYW5nZUZsYWdzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICBjb25zdCB7ZGF0YSwgZ2V0UG9seWdvbn0gPSB0aGlzLnByb3BzO1xuICAgICAgdGhpcy5zdGF0ZS5wYXRocyA9IFtdO1xuICAgICAgZGF0YS5mb3JFYWNoKG9iamVjdCA9PiB7XG4gICAgICAgIGNvbnN0IGNvbXBsZXhQb2x5Z29uID0gUG9seWdvbi5ub3JtYWxpemUoZ2V0UG9seWdvbihvYmplY3QpKTtcbiAgICAgICAgY29tcGxleFBvbHlnb24uZm9yRWFjaChwb2x5Z29uID0+IHRoaXMuc3RhdGUucGF0aHMucHVzaCh7XG4gICAgICAgICAgcGF0aDogcG9seWdvbixcbiAgICAgICAgICBvYmplY3RcbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgX29uSG92ZXJTdWJMYXllcihpbmZvKSB7XG4gICAgaW5mby5vYmplY3QgPSAoaW5mby5vYmplY3QgJiYgaW5mby5vYmplY3QuZmVhdHVyZSkgfHwgaW5mby5vYmplY3Q7XG4gICAgdGhpcy5wcm9wcy5vbkhvdmVyKGluZm8pO1xuICB9XG5cbiAgX29uQ2xpY2tTdWJMYXllcihpbmZvKSB7XG4gICAgaW5mby5vYmplY3QgPSAoaW5mby5vYmplY3QgJiYgaW5mby5vYmplY3QuZmVhdHVyZSkgfHwgaW5mby5vYmplY3Q7XG4gICAgdGhpcy5wcm9wcy5vbkNsaWNrKGluZm8pO1xuICB9XG5cbiAgcmVuZGVyTGF5ZXJzKCkge1xuICAgIGNvbnN0IHtnZXRGaWxsQ29sb3IsIGdldENvbG9yLCBnZXRXaWR0aCwgZ2V0RWxldmF0aW9uLCB1cGRhdGVUcmlnZ2Vyc30gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHtkYXRhLCBpZCwgc3Ryb2tlZCwgZmlsbGVkLCBleHRydWRlZCwgd2lyZWZyYW1lfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3BhdGhzLCBvbkhvdmVyLCBvbkNsaWNrfSA9IHRoaXMuc3RhdGU7XG5cbiAgICBjb25zdCBoYXNEYXRhID0gZGF0YSAmJiBkYXRhLmxlbmd0aCA+IDA7XG5cbiAgICAvLyBGaWxsZWQgUG9seWdvbiBMYXllclxuICAgIGNvbnN0IHBvbHlnb25MYXllciA9IGZpbGxlZCAmJiBoYXNEYXRhICYmIG5ldyBTb2xpZFBvbHlnb25MYXllcihPYmplY3QuYXNzaWduKHt9LFxuICAgICAgdGhpcy5wcm9wcywge1xuICAgICAgICBpZDogYCR7aWR9LWZpbGxgLFxuICAgICAgICBkYXRhLFxuICAgICAgICBnZXRFbGV2YXRpb24sXG4gICAgICAgIGdldENvbG9yOiBnZXRGaWxsQ29sb3IsXG4gICAgICAgIGV4dHJ1ZGVkLFxuICAgICAgICB3aXJlZnJhbWU6IGZhbHNlLFxuICAgICAgICB1cGRhdGVUcmlnZ2Vyczoge1xuICAgICAgICAgIGdldEVsZXZhdGlvbjogdXBkYXRlVHJpZ2dlcnMuZ2V0RWxldmF0aW9uLFxuICAgICAgICAgIGdldENvbG9yOiB1cGRhdGVUcmlnZ2Vycy5nZXRGaWxsQ29sb3JcbiAgICAgICAgfVxuICAgICAgfSkpO1xuXG4gICAgY29uc3QgcG9seWdvbldpcmVmcmFtZUxheWVyID0gZXh0cnVkZWQgJiZcbiAgICAgIHdpcmVmcmFtZSAmJlxuICAgICAgaGFzRGF0YSAmJlxuICAgICAgbmV3IFNvbGlkUG9seWdvbkxheWVyKE9iamVjdC5hc3NpZ24oe30sXG4gICAgICB0aGlzLnByb3BzLCB7XG4gICAgICAgIGlkOiBgJHtpZH0td2lyZWZyYW1lYCxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgZ2V0RWxldmF0aW9uLFxuICAgICAgICBnZXRDb2xvcixcbiAgICAgICAgZXh0cnVkZWQ6IHRydWUsXG4gICAgICAgIHdpcmVmcmFtZTogdHJ1ZSxcbiAgICAgICAgdXBkYXRlVHJpZ2dlcnM6IHtcbiAgICAgICAgICBnZXRFbGV2YXRpb246IHVwZGF0ZVRyaWdnZXJzLmdldEVsZXZhdGlvbixcbiAgICAgICAgICBnZXRDb2xvcjogdXBkYXRlVHJpZ2dlcnMuZ2V0Q29sb3JcbiAgICAgICAgfVxuICAgICAgfSkpO1xuXG4gICAgLy8gUG9seWdvbiBvdXRsaW5lIGxheWVyXG4gICAgY29uc3QgcG9seWdvbk91dGxpbmVMYXllciA9ICFleHRydWRlZCAmJlxuICAgICAgc3Ryb2tlZCAmJlxuICAgICAgaGFzRGF0YSAmJlxuICAgICAgbmV3IFBhdGhMYXllcihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7XG4gICAgICAgIGlkOiBgJHtpZH0tc3Ryb2tlYCxcbiAgICAgICAgZGF0YTogcGF0aHMsXG4gICAgICAgIGdldFBhdGg6IHggPT4geC5wYXRoLFxuICAgICAgICBnZXRDb2xvcixcbiAgICAgICAgZ2V0V2lkdGgsXG4gICAgICAgIG9uSG92ZXIsXG4gICAgICAgIG9uQ2xpY2ssXG4gICAgICAgIHVwZGF0ZVRyaWdnZXJzOiB7XG4gICAgICAgICAgZ2V0V2lkdGg6IHVwZGF0ZVRyaWdnZXJzLmdldFdpZHRoLFxuICAgICAgICAgIGdldENvbG9yOiB1cGRhdGVUcmlnZ2Vycy5nZXRDb2xvclxuICAgICAgICB9XG4gICAgICB9KSk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgcG9seWdvbkxheWVyLFxuICAgICAgcG9seWdvbldpcmVmcmFtZUxheWVyLFxuICAgICAgcG9seWdvbk91dGxpbmVMYXllclxuICAgIF0uZmlsdGVyKEJvb2xlYW4pO1xuICB9XG59XG5cblBvbHlnb25MYXllci5sYXllck5hbWUgPSAnUG9seWdvbkxheWVyJztcblBvbHlnb25MYXllci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9sYXllcnMvY29yZS9wb2x5Z29uLWxheWVyL3BvbHlnb24tbGF5ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 43 */
/* exports provided: default */
/* exports used: default */
/*!****************************************************************!*\
  !*** ./src/layers/core/screen-grid-layer/screen-grid-layer.js ***!
  \****************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl__ = __webpack_require__(/*! luma.gl */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__screen_grid_layer_vertex_glsl__ = __webpack_require__(/*! ./screen-grid-layer-vertex.glsl */ 82);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__screen_grid_layer_fragment_glsl__ = __webpack_require__(/*! ./screen-grid-layer-fragment.glsl */ 81);\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\n\nconst defaultProps = {\n  cellSizePixels: 100,\n\n  // Color range?\n  minColor: [0, 0, 0, 255],\n  maxColor: [0, 255, 0, 255],\n\n  getPosition: d => d.position,\n  getWeight: d => 1\n};\n\nclass ScreenGridLayer extends __WEBPACK_IMPORTED_MODULE_0__lib__[\"a\" /* Layer */] {\n  getShaders() {\n    return {\n      vs: __WEBPACK_IMPORTED_MODULE_3__screen_grid_layer_vertex_glsl__[\"a\" /* default */],\n      fs: __WEBPACK_IMPORTED_MODULE_4__screen_grid_layer_fragment_glsl__[\"a\" /* default */]\n    };\n  }\n\n  constructor(props) {\n    super(props);\n    this._checkRemovedProp('unitWidth', 'cellSizePixels');\n    this._checkRemovedProp('unitHeight', 'cellSizePixels');\n  }\n\n  initializeState() {\n    const {attributeManager} = this.state;\n    /* eslint-disable max-len */\n    attributeManager.addInstanced({\n      instancePositions: {size: 3, update: this.calculateInstancePositions},\n      instanceCount: {size: 1, accessor: ['getPosition', 'getWeight'], update: this.calculateInstanceCount}\n    });\n    /* eslint-disable max-len */\n\n    const {gl} = this.context;\n    this.setState({model: this.getModel(gl)});\n  }\n\n  updateState({oldProps, props, changeFlags}) {\n    super.updateState({props, oldProps, changeFlags});\n    const cellSizeChanged =\n      props.cellSizePixels !== oldProps.cellSizePixels;\n\n    if (cellSizeChanged || changeFlags.viewportChanged) {\n      this.updateCell();\n    }\n  }\n\n  draw({uniforms}) {\n    const {minColor, maxColor} = this.props;\n    const {model, cellScale, maxCount} = this.state;\n    const {gl} = this.context;\n    gl.depthMask(true);\n    uniforms = Object.assign({}, uniforms, {minColor, maxColor, cellScale, maxCount});\n    model.render(uniforms);\n  }\n\n  getModel(gl) {\n    const shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"a\" /* assembleShaders */])(gl, this.getShaders());\n\n    return new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Model\"]({\n      gl,\n      id: this.props.id,\n      vs: shaders.vs,\n      fs: shaders.fs,\n      geometry: new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Geometry\"]({\n        drawMode: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].TRIANGLE_FAN,\n        vertices: new Float32Array([0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0])\n      }),\n      isInstanced: true\n    });\n  }\n\n  updateCell() {\n    const {width, height} = this.context.viewport;\n    const {cellSizePixels} = this.props;\n\n    const MARGIN = 2;\n    const cellScale = new Float32Array([\n      (cellSizePixels - MARGIN) / width * 2,\n      -(cellSizePixels - MARGIN) / height * 2,\n      1\n    ]);\n    const numCol = Math.ceil(width / cellSizePixels);\n    const numRow = Math.ceil(height / cellSizePixels);\n\n    this.setState({\n      cellScale,\n      numCol,\n      numRow,\n      numInstances: numCol * numRow\n    });\n\n    const {attributeManager} = this.state;\n    attributeManager.invalidateAll();\n  }\n\n  calculateInstancePositions(attribute, {numInstances}) {\n    const {width, height} = this.context.viewport;\n    const {cellSizePixels} = this.props;\n    const {numCol} = this.state;\n    const {value, size} = attribute;\n\n    for (let i = 0; i < numInstances; i++) {\n      const x = i % numCol;\n      const y = Math.floor(i / numCol);\n      value[i * size + 0] = x * cellSizePixels / width * 2 - 1;\n      value[i * size + 1] = 1 - y * cellSizePixels / height * 2;\n      value[i * size + 2] = 0;\n    }\n  }\n\n  calculateInstanceCount(attribute) {\n    const {data, cellSizePixels, getPosition, getWeight} = this.props;\n    const {numCol, numRow} = this.state;\n    const {value} = attribute;\n    let maxCount = 0;\n\n    value.fill(0.0);\n\n    for (const point of data) {\n      const pixel = this.project(getPosition(point));\n      const colId = Math.floor(pixel[0] / cellSizePixels);\n      const rowId = Math.floor(pixel[1] / cellSizePixels);\n      if (colId >= 0 && colId < numCol && rowId >= 0 && rowId < numRow) {\n        const i = colId + rowId * numCol;\n        value[i] += getWeight(point);\n        if (value[i] > maxCount) {\n          maxCount = value[i];\n        }\n      }\n    }\n\n    this.setState({maxCount});\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = ScreenGridLayer;\n\n\nScreenGridLayer.layerName = 'ScreenGridLayer';\nScreenGridLayer.defaultProps = defaultProps;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvc2NyZWVuLWdyaWQtbGF5ZXIvc2NyZWVuLWdyaWQtbGF5ZXIuanM/NmY3YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge0xheWVyfSBmcm9tICcuLi8uLi8uLi9saWInO1xuaW1wb3J0IHthc3NlbWJsZVNoYWRlcnN9IGZyb20gJy4uLy4uLy4uL3NoYWRlci11dGlscyc7XG5pbXBvcnQge0dMLCBNb2RlbCwgR2VvbWV0cnl9IGZyb20gJ2x1bWEuZ2wnO1xuXG5pbXBvcnQgc2NyZWVuR3JpZFZlcnRleCBmcm9tICcuL3NjcmVlbi1ncmlkLWxheWVyLXZlcnRleC5nbHNsJztcbmltcG9ydCBzY3JlZW5HcmlkRnJhZ21lbnQgZnJvbSAnLi9zY3JlZW4tZ3JpZC1sYXllci1mcmFnbWVudC5nbHNsJztcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBjZWxsU2l6ZVBpeGVsczogMTAwLFxuXG4gIC8vIENvbG9yIHJhbmdlP1xuICBtaW5Db2xvcjogWzAsIDAsIDAsIDI1NV0sXG4gIG1heENvbG9yOiBbMCwgMjU1LCAwLCAyNTVdLFxuXG4gIGdldFBvc2l0aW9uOiBkID0+IGQucG9zaXRpb24sXG4gIGdldFdlaWdodDogZCA9PiAxXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY3JlZW5HcmlkTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIGdldFNoYWRlcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZzOiBzY3JlZW5HcmlkVmVydGV4LFxuICAgICAgZnM6IHNjcmVlbkdyaWRGcmFnbWVudFxuICAgIH07XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLl9jaGVja1JlbW92ZWRQcm9wKCd1bml0V2lkdGgnLCAnY2VsbFNpemVQaXhlbHMnKTtcbiAgICB0aGlzLl9jaGVja1JlbW92ZWRQcm9wKCd1bml0SGVpZ2h0JywgJ2NlbGxTaXplUGl4ZWxzJyk7XG4gIH1cblxuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gICAgYXR0cmlidXRlTWFuYWdlci5hZGRJbnN0YW5jZWQoe1xuICAgICAgaW5zdGFuY2VQb3NpdGlvbnM6IHtzaXplOiAzLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnN9LFxuICAgICAgaW5zdGFuY2VDb3VudDoge3NpemU6IDEsIGFjY2Vzc29yOiBbJ2dldFBvc2l0aW9uJywgJ2dldFdlaWdodCddLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VDb3VudH1cbiAgICB9KTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbiAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuICAgIHRoaXMuc2V0U3RhdGUoe21vZGVsOiB0aGlzLmdldE1vZGVsKGdsKX0pO1xuICB9XG5cbiAgdXBkYXRlU3RhdGUoe29sZFByb3BzLCBwcm9wcywgY2hhbmdlRmxhZ3N9KSB7XG4gICAgc3VwZXIudXBkYXRlU3RhdGUoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KTtcbiAgICBjb25zdCBjZWxsU2l6ZUNoYW5nZWQgPVxuICAgICAgcHJvcHMuY2VsbFNpemVQaXhlbHMgIT09IG9sZFByb3BzLmNlbGxTaXplUGl4ZWxzO1xuXG4gICAgaWYgKGNlbGxTaXplQ2hhbmdlZCB8fCBjaGFuZ2VGbGFncy52aWV3cG9ydENoYW5nZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlQ2VsbCgpO1xuICAgIH1cbiAgfVxuXG4gIGRyYXcoe3VuaWZvcm1zfSkge1xuICAgIGNvbnN0IHttaW5Db2xvciwgbWF4Q29sb3J9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7bW9kZWwsIGNlbGxTY2FsZSwgbWF4Q291bnR9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuICAgIGdsLmRlcHRoTWFzayh0cnVlKTtcbiAgICB1bmlmb3JtcyA9IE9iamVjdC5hc3NpZ24oe30sIHVuaWZvcm1zLCB7bWluQ29sb3IsIG1heENvbG9yLCBjZWxsU2NhbGUsIG1heENvdW50fSk7XG4gICAgbW9kZWwucmVuZGVyKHVuaWZvcm1zKTtcbiAgfVxuXG4gIGdldE1vZGVsKGdsKSB7XG4gICAgY29uc3Qgc2hhZGVycyA9IGFzc2VtYmxlU2hhZGVycyhnbCwgdGhpcy5nZXRTaGFkZXJzKCkpO1xuXG4gICAgcmV0dXJuIG5ldyBNb2RlbCh7XG4gICAgICBnbCxcbiAgICAgIGlkOiB0aGlzLnByb3BzLmlkLFxuICAgICAgdnM6IHNoYWRlcnMudnMsXG4gICAgICBmczogc2hhZGVycy5mcyxcbiAgICAgIGdlb21ldHJ5OiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICBkcmF3TW9kZTogR0wuVFJJQU5HTEVfRkFOLFxuICAgICAgICB2ZXJ0aWNlczogbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMCwgMSwgMCwgMCwgMSwgMSwgMCwgMCwgMSwgMF0pXG4gICAgICB9KSxcbiAgICAgIGlzSW5zdGFuY2VkOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICB1cGRhdGVDZWxsKCkge1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHRoaXMuY29udGV4dC52aWV3cG9ydDtcbiAgICBjb25zdCB7Y2VsbFNpemVQaXhlbHN9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IE1BUkdJTiA9IDI7XG4gICAgY29uc3QgY2VsbFNjYWxlID0gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAoY2VsbFNpemVQaXhlbHMgLSBNQVJHSU4pIC8gd2lkdGggKiAyLFxuICAgICAgLShjZWxsU2l6ZVBpeGVscyAtIE1BUkdJTikgLyBoZWlnaHQgKiAyLFxuICAgICAgMVxuICAgIF0pO1xuICAgIGNvbnN0IG51bUNvbCA9IE1hdGguY2VpbCh3aWR0aCAvIGNlbGxTaXplUGl4ZWxzKTtcbiAgICBjb25zdCBudW1Sb3cgPSBNYXRoLmNlaWwoaGVpZ2h0IC8gY2VsbFNpemVQaXhlbHMpO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBjZWxsU2NhbGUsXG4gICAgICBudW1Db2wsXG4gICAgICBudW1Sb3csXG4gICAgICBudW1JbnN0YW5jZXM6IG51bUNvbCAqIG51bVJvd1xuICAgIH0pO1xuXG4gICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGVBbGwoKTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zKGF0dHJpYnV0ZSwge251bUluc3RhbmNlc30pIHtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0aGlzLmNvbnRleHQudmlld3BvcnQ7XG4gICAgY29uc3Qge2NlbGxTaXplUGl4ZWxzfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge251bUNvbH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHt2YWx1ZSwgc2l6ZX0gPSBhdHRyaWJ1dGU7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUluc3RhbmNlczsgaSsrKSB7XG4gICAgICBjb25zdCB4ID0gaSAlIG51bUNvbDtcbiAgICAgIGNvbnN0IHkgPSBNYXRoLmZsb29yKGkgLyBudW1Db2wpO1xuICAgICAgdmFsdWVbaSAqIHNpemUgKyAwXSA9IHggKiBjZWxsU2l6ZVBpeGVscyAvIHdpZHRoICogMiAtIDE7XG4gICAgICB2YWx1ZVtpICogc2l6ZSArIDFdID0gMSAtIHkgKiBjZWxsU2l6ZVBpeGVscyAvIGhlaWdodCAqIDI7XG4gICAgICB2YWx1ZVtpICogc2l6ZSArIDJdID0gMDtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZUNvdW50KGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtkYXRhLCBjZWxsU2l6ZVBpeGVscywgZ2V0UG9zaXRpb24sIGdldFdlaWdodH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHtudW1Db2wsIG51bVJvd30gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHt2YWx1ZX0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IG1heENvdW50ID0gMDtcblxuICAgIHZhbHVlLmZpbGwoMC4wKTtcblxuICAgIGZvciAoY29uc3QgcG9pbnQgb2YgZGF0YSkge1xuICAgICAgY29uc3QgcGl4ZWwgPSB0aGlzLnByb2plY3QoZ2V0UG9zaXRpb24ocG9pbnQpKTtcbiAgICAgIGNvbnN0IGNvbElkID0gTWF0aC5mbG9vcihwaXhlbFswXSAvIGNlbGxTaXplUGl4ZWxzKTtcbiAgICAgIGNvbnN0IHJvd0lkID0gTWF0aC5mbG9vcihwaXhlbFsxXSAvIGNlbGxTaXplUGl4ZWxzKTtcbiAgICAgIGlmIChjb2xJZCA+PSAwICYmIGNvbElkIDwgbnVtQ29sICYmIHJvd0lkID49IDAgJiYgcm93SWQgPCBudW1Sb3cpIHtcbiAgICAgICAgY29uc3QgaSA9IGNvbElkICsgcm93SWQgKiBudW1Db2w7XG4gICAgICAgIHZhbHVlW2ldICs9IGdldFdlaWdodChwb2ludCk7XG4gICAgICAgIGlmICh2YWx1ZVtpXSA+IG1heENvdW50KSB7XG4gICAgICAgICAgbWF4Q291bnQgPSB2YWx1ZVtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUoe21heENvdW50fSk7XG4gIH1cbn1cblxuU2NyZWVuR3JpZExheWVyLmxheWVyTmFtZSA9ICdTY3JlZW5HcmlkTGF5ZXInO1xuU2NyZWVuR3JpZExheWVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xheWVycy9jb3JlL3NjcmVlbi1ncmlkLWxheWVyL3NjcmVlbi1ncmlkLWxheWVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 44 */
/* exports provided: default */
/* exports used: default */
/*!**************************************************************************!*\
  !*** ./src/layers/deprecated/choropleth-layer-64/choropleth-layer-64.js ***!
  \**************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__choropleth_layer_choropleth_layer__ = __webpack_require__(/*! ../choropleth-layer/choropleth-layer */ 21);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_utils__ = __webpack_require__(/*! ../../../lib/utils */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash_flattendeep__ = __webpack_require__(/*! lodash.flattendeep */ 33);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash_flattendeep___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash_flattendeep__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__choropleth_layer_vertex_64_glsl__ = __webpack_require__(/*! ./choropleth-layer-vertex-64.glsl */ 88);\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\nclass ChoroplethLayer64 extends __WEBPACK_IMPORTED_MODULE_0__choropleth_layer_choropleth_layer__[\"a\" /* default */] {\n\n  constructor(props) {\n    super(props);\n    __WEBPACK_IMPORTED_MODULE_1__lib_utils__[\"a\" /* log */].once('ChoroplethLayer64 is deprecated. Consider using GeoJsonLayer instead');\n  }\n\n  initializeState() {\n    super.initializeState();\n\n    this.state.attributeManager.addDynamic({\n      positions64: {size: 4, update: this.calculatePositions64},\n      heights64: {size: 2, update: this.calculateHeights64}\n    });\n  }\n\n  getShaders() {\n    return {\n      vs: __WEBPACK_IMPORTED_MODULE_3__choropleth_layer_vertex_64_glsl__[\"a\" /* default */],\n      fs: super.getShaders().fs,\n      fp64: true,\n      project64: true\n    };\n  }\n\n  calculatePositions64(attribute) {\n    const vertices = __WEBPACK_IMPORTED_MODULE_2_lodash_flattendeep___default()(this.state.choropleths);\n    attribute.value = new Float32Array(vertices.length / 3 * 4);\n    for (let index = 0; index < vertices.length / 3; index++) {\n      [\n        attribute.value[index * 4],\n        attribute.value[index * 4 + 1]\n      ] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__lib_utils__[\"c\" /* fp64ify */])(vertices[index * 3]);\n      [\n        attribute.value[index * 4 + 2],\n        attribute.value[index * 4 + 3]\n      ] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__lib_utils__[\"c\" /* fp64ify */])(vertices[index * 3 + 1]);\n    }\n  }\n\n  calculateHeights64(attribute) {\n    const vertices = __WEBPACK_IMPORTED_MODULE_2_lodash_flattendeep___default()(this.state.choropleths);\n    attribute.value = new Float32Array(vertices.length / 3 * 2);\n    for (let index = 0; index < vertices.length / 3; index++) {\n      [\n        attribute.value[index * 2],\n        attribute.value[index * 2 + 1]\n      ] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__lib_utils__[\"c\" /* fp64ify */])(vertices[index * 3 + 2]);\n    }\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = ChoroplethLayer64;\n\n\nChoroplethLayer64.layerName = 'ChoroplethLayer64';\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2RlcHJlY2F0ZWQvY2hvcm9wbGV0aC1sYXllci02NC9jaG9yb3BsZXRoLWxheWVyLTY0LmpzPzRhZjgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IENob3JvcGxldGhMYXllciBmcm9tICcuLi9jaG9yb3BsZXRoLWxheWVyL2Nob3JvcGxldGgtbGF5ZXInO1xuaW1wb3J0IHtmcDY0aWZ5LCBsb2d9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscyc7XG5pbXBvcnQgZmxhdHRlbkRlZXAgZnJvbSAnbG9kYXNoLmZsYXR0ZW5kZWVwJztcblxuaW1wb3J0IGNob3JvcGxldGhWZXJ0ZXg2NCBmcm9tICcuL2Nob3JvcGxldGgtbGF5ZXItdmVydGV4LTY0Lmdsc2wnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaG9yb3BsZXRoTGF5ZXI2NCBleHRlbmRzIENob3JvcGxldGhMYXllciB7XG5cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgbG9nLm9uY2UoJ0Nob3JvcGxldGhMYXllcjY0IGlzIGRlcHJlY2F0ZWQuIENvbnNpZGVyIHVzaW5nIEdlb0pzb25MYXllciBpbnN0ZWFkJyk7XG4gIH1cblxuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgc3VwZXIuaW5pdGlhbGl6ZVN0YXRlKCk7XG5cbiAgICB0aGlzLnN0YXRlLmF0dHJpYnV0ZU1hbmFnZXIuYWRkRHluYW1pYyh7XG4gICAgICBwb3NpdGlvbnM2NDoge3NpemU6IDQsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVQb3NpdGlvbnM2NH0sXG4gICAgICBoZWlnaHRzNjQ6IHtzaXplOiAyLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSGVpZ2h0czY0fVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0U2hhZGVycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdnM6IGNob3JvcGxldGhWZXJ0ZXg2NCxcbiAgICAgIGZzOiBzdXBlci5nZXRTaGFkZXJzKCkuZnMsXG4gICAgICBmcDY0OiB0cnVlLFxuICAgICAgcHJvamVjdDY0OiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIGNhbGN1bGF0ZVBvc2l0aW9uczY0KGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHZlcnRpY2VzID0gZmxhdHRlbkRlZXAodGhpcy5zdGF0ZS5jaG9yb3BsZXRocyk7XG4gICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0aWNlcy5sZW5ndGggLyAzICogNCk7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHZlcnRpY2VzLmxlbmd0aCAvIDM7IGluZGV4KyspIHtcbiAgICAgIFtcbiAgICAgICAgYXR0cmlidXRlLnZhbHVlW2luZGV4ICogNF0sXG4gICAgICAgIGF0dHJpYnV0ZS52YWx1ZVtpbmRleCAqIDQgKyAxXVxuICAgICAgXSA9IGZwNjRpZnkodmVydGljZXNbaW5kZXggKiAzXSk7XG4gICAgICBbXG4gICAgICAgIGF0dHJpYnV0ZS52YWx1ZVtpbmRleCAqIDQgKyAyXSxcbiAgICAgICAgYXR0cmlidXRlLnZhbHVlW2luZGV4ICogNCArIDNdXG4gICAgICBdID0gZnA2NGlmeSh2ZXJ0aWNlc1tpbmRleCAqIDMgKyAxXSk7XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlSGVpZ2h0czY0KGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHZlcnRpY2VzID0gZmxhdHRlbkRlZXAodGhpcy5zdGF0ZS5jaG9yb3BsZXRocyk7XG4gICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0aWNlcy5sZW5ndGggLyAzICogMik7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHZlcnRpY2VzLmxlbmd0aCAvIDM7IGluZGV4KyspIHtcbiAgICAgIFtcbiAgICAgICAgYXR0cmlidXRlLnZhbHVlW2luZGV4ICogMl0sXG4gICAgICAgIGF0dHJpYnV0ZS52YWx1ZVtpbmRleCAqIDIgKyAxXVxuICAgICAgXSA9IGZwNjRpZnkodmVydGljZXNbaW5kZXggKiAzICsgMl0pO1xuICAgIH1cbiAgfVxufVxuXG5DaG9yb3BsZXRoTGF5ZXI2NC5sYXllck5hbWUgPSAnQ2hvcm9wbGV0aExheWVyNjQnO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGF5ZXJzL2RlcHJlY2F0ZWQvY2hvcm9wbGV0aC1sYXllci02NC9jaG9yb3BsZXRoLWxheWVyLTY0LmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 45 */
/* exports provided: default */
/* exports used: default */
/*!********************************************************************************************!*\
  !*** ./src/layers/deprecated/extruded-choropleth-layer-64/extruded-choropleth-layer-64.js ***!
  \********************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__ = __webpack_require__(/*! ../../../lib/utils/fp64 */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_luma_gl__ = __webpack_require__(/*! luma.gl */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__lib_utils__ = __webpack_require__(/*! ../../../lib/utils */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_earcut__ = __webpack_require__(/*! earcut */ 8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_earcut___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_earcut__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_gl_matrix__ = __webpack_require__(/*! gl-matrix */ 7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_gl_matrix___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_gl_matrix__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__extruded_choropleth_layer_vertex_glsl__ = __webpack_require__(/*! ./extruded-choropleth-layer-vertex.glsl */ 93);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__extruded_choropleth_layer_fragment_glsl__ = __webpack_require__(/*! ./extruded-choropleth-layer-fragment.glsl */ 92);\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\n\n\n\n\n\nconst DEFAULT_COLOR = [180, 180, 200];\nconst DEFAULT_AMBIENT_COLOR = [255, 255, 255];\nconst DEFAULT_POINTLIGHT_AMBIENT_COEFFICIENT = 0.1;\nconst DEFAULT_POINTLIGHT_LOCATION = [40.4406, -79.9959, 100];\nconst DEFAULT_POINTLIGHT_COLOR = [255, 255, 255];\nconst DEFAULT_POINTLIGHT_ATTENUATION = 1.0;\nconst DEFAULT_MATERIAL_SPECULAR_COLOR = [255, 255, 255];\nconst DEFAULT_MATERIAL_SHININESS = 1;\n\nconst defaultProps = {\n  opacity: 1,\n  elevation: 1\n};\n\nclass ExtrudedChoroplethLayer64 extends __WEBPACK_IMPORTED_MODULE_0__lib__[\"a\" /* Layer */] {\n  constructor(props) {\n    super(props);\n    __WEBPACK_IMPORTED_MODULE_4__lib_utils__[\"a\" /* log */].once('ExtrudedChoroplethLayer64 is deprecated. Consider using GeoJsonLayer instead');\n  }\n\n  initializeState() {\n    const {attributeManager} = this.state;\n    attributeManager.add({\n      indices: {size: 1, isIndexed: true, update: this.calculateIndices},\n      positions: {size: 4, update: this.calculatePositions},\n      heights: {size: 2, update: this.calculateHeights},\n      normals: {size: 3, update: this.calculateNormals},\n      colors: {size: 4, update: this.calculateColors}\n    });\n\n    const {gl} = this.context;\n    this.setState({\n      numInstances: 0,\n      model: this.getModel(gl)\n    });\n  }\n\n  updateState({changeFlags}) {\n    const {attributeManager} = this.state;\n    if (changeFlags.dataChanged) {\n      this.extractExtrudedChoropleth();\n      attributeManager.invalidateAll();\n    }\n\n    const {\n      elevation,\n      color, ambientColor, pointLightColor,\n      pointLightLocation, pointLightAmbientCoefficient,\n      pointLightAttenuation, materialSpecularColor, materialShininess\n    } = this.props;\n\n    this.setUniforms({\n      elevation: Number.isFinite(elevation) ? elevation : 1,\n      colors: color || DEFAULT_COLOR,\n      uAmbientColor: ambientColor || DEFAULT_AMBIENT_COLOR,\n      uPointLightAmbientCoefficient:\n        pointLightAmbientCoefficient || DEFAULT_POINTLIGHT_AMBIENT_COEFFICIENT,\n      uPointLightLocation: pointLightLocation || DEFAULT_POINTLIGHT_LOCATION,\n      uPointLightColor: pointLightColor || DEFAULT_POINTLIGHT_COLOR,\n      uPointLightAttenuation: pointLightAttenuation || DEFAULT_POINTLIGHT_ATTENUATION,\n      uMaterialSpecularColor: materialSpecularColor || DEFAULT_MATERIAL_SPECULAR_COLOR,\n      uMaterialShininess: materialShininess || DEFAULT_MATERIAL_SHININESS\n    });\n  }\n\n  draw({uniforms}) {\n    this.state.model.render(uniforms);\n  }\n\n  getPickingInfo(opts) {\n    const info = super.getPickingInfo(opts);\n    const index = this.decodePickingColor(info.color);\n    const feature = index >= 0 ? this.props.data.features[index] : null;\n    info.feature = feature;\n    info.object = feature;\n    return info;\n  }\n\n  getShaders() {\n    return {\n      vs: __WEBPACK_IMPORTED_MODULE_7__extruded_choropleth_layer_vertex_glsl__[\"a\" /* default */],\n      fs: __WEBPACK_IMPORTED_MODULE_8__extruded_choropleth_layer_fragment_glsl__[\"a\" /* default */],\n      fp64: true,\n      project64: true\n    };\n  }\n\n  getModel(gl) {\n    // Make sure we have 32 bit support\n    // TODO - this could be done automatically by luma in \"draw\"\n    // when it detects 32 bit indices\n    if (!gl.getExtension('OES_element_index_uint')) {\n      throw new Error('Extruded choropleth layer needs 32 bit indices');\n    }\n\n    // Buildings are 3d so depth test should be enabled\n    // TODO - it is a little heavy handed to have a layer set this\n    // Alternatively, check depth test and warn if not set, or add a prop\n    // setDepthTest that is on by default.\n    gl.enable(__WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].DEPTH_TEST);\n    gl.depthFunc(__WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].LEQUAL);\n\n    const shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"a\" /* assembleShaders */])(gl, this.getShaders());\n\n    return new __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"Model\"]({\n      gl,\n      id: this.props.id,\n      vs: shaders.vs,\n      fs: shaders.fs,\n      geometry: new __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"Geometry\"]({\n        drawMode: this.props.drawWireframe ? __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].LINES : __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].TRIANGLES\n      }),\n      vertexCount: 0,\n      isIndexed: true\n    });\n  }\n\n  // each top vertex is on 3 surfaces\n  // each bottom vertex is on 2 surfaces\n  calculatePositions(attribute) {\n    let {positions} = this.state;\n    if (!positions) {\n      positions = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__lib_utils__[\"b\" /* flatten */])(this.state.groupedVertices.map(\n        vertices => {\n          const topVertices = Array.prototype.concat.apply([], vertices);\n          const baseVertices = topVertices.map(v => [v[0], v[1], 0]);\n          return this.props.drawWireframe ? [topVertices, baseVertices] :\n            [topVertices, topVertices, topVertices, baseVertices, baseVertices];\n        }\n      ));\n    }\n\n    attribute.value = new Float32Array(positions.length / 3 * 4);\n\n    for (let i = 0; i < positions.length / 3; i++) {\n      [attribute.value[i * 4 + 0], attribute.value[i * 4 + 1]] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__[\"a\" /* fp64ify */])(positions[i * 3 + 0]);\n      [attribute.value[i * 4 + 2], attribute.value[i * 4 + 3]] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__[\"a\" /* fp64ify */])(positions[i * 3 + 1]);\n    }\n  }\n\n  calculateHeights(attribute) {\n    let {positions} = this.state;\n    if (!positions) {\n      positions = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__lib_utils__[\"b\" /* flatten */])(this.state.groupedVertices.map(\n        vertices => {\n          const topVertices = Array.prototype.concat.apply([], vertices);\n          const baseVertices = topVertices.map(v => [v[0], v[1], 0]);\n          return this.props.drawWireframe ? [topVertices, baseVertices] :\n            [topVertices, topVertices, topVertices, baseVertices, baseVertices];\n        }\n      ));\n    }\n\n    attribute.value = new Float32Array(positions.length / 3 * 2);\n    for (let i = 0; i < positions.length / 3; i++) {\n      [attribute.value[i * 2 + 0], attribute.value[i * 2 + 1]] =\n       __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__[\"a\" /* fp64ify */])(positions[i * 3 + 2] + 0.1);\n    }\n  }\n\n  calculateNormals(attribute) {\n    const up = [0, 1, 0];\n\n    const normals = this.state.groupedVertices.map(\n      (vertices, buildingIndex) => {\n        const topNormals = new Array(countVertices(vertices)).fill(up);\n        const sideNormals = vertices.map(polygon =>\n          this.calculateSideNormals(polygon));\n        const sideNormalsForward = sideNormals.map(n => n[0]);\n        const sideNormalsBackward = sideNormals.map(n => n[1]);\n\n        return this.props.drawWireframe ? [topNormals, topNormals] :\n        [topNormals, sideNormalsForward, sideNormalsBackward,\n          sideNormalsForward, sideNormalsBackward];\n      }\n    );\n\n    attribute.value = new Float32Array(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__lib_utils__[\"b\" /* flatten */])(normals));\n  }\n\n  calculateSideNormals(vertices) {\n    const numVertices = vertices.length;\n    const normals = [];\n\n    for (let i = 0; i < numVertices - 1; i++) {\n      const n = getNormal(vertices[i], vertices[i + 1]);\n      normals.push(n);\n    }\n\n    return [\n      [...normals, normals[0]],\n      [normals[0], ...normals]\n    ];\n  }\n\n  calculateIndices(attribute) {\n    // adjust index offset for multiple buildings\n    const multiplier = this.props.drawWireframe ? 2 : 5;\n    const offsets = this.state.groupedVertices.reduce(\n      (acc, vertices) =>\n        [...acc, acc[acc.length - 1] + countVertices(vertices) * multiplier],\n      [0]\n    );\n\n    const indices = this.state.groupedVertices.map(\n      (vertices, buildingIndex) => this.props.drawWireframe ?\n        // 1. get sequentially ordered indices of each building wireframe\n        // 2. offset them by the number of indices in previous buildings\n        this.calculateContourIndices(vertices, offsets[buildingIndex]) :\n        // 1. get triangulated indices for the internal areas\n        // 2. offset them by the number of indices in previous buildings\n        this.calculateSurfaceIndices(vertices, offsets[buildingIndex])\n    );\n\n    attribute.value = new Uint32Array(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__lib_utils__[\"b\" /* flatten */])(indices));\n    attribute.target = __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].ELEMENT_ARRAY_BUFFER;\n    this.state.model.setVertexCount(attribute.value.length / attribute.size);\n  }\n\n  calculateColors(attribute) {\n    const colors = this.state.groupedVertices.map(\n      (vertices, buildingIndex) => {\n        const {color} = this.props;\n        const baseColor = Array.isArray(color) ? color[0] : color;\n        const topColor = Array.isArray(color) ?\n          color[color.length - 1] : color;\n        const numVertices = countVertices(vertices);\n\n        const topColors = new Array(numVertices).fill(topColor);\n        const baseColors = new Array(numVertices).fill(baseColor);\n        return this.props.drawWireframe ? [topColors, baseColors] :\n          [topColors, topColors, topColors, baseColors, baseColors];\n      }\n    );\n    attribute.value = new Float32Array(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__lib_utils__[\"b\" /* flatten */])(colors));\n  }\n\n  extractExtrudedChoropleth() {\n    const {data} = this.props;\n    // Generate a flat list of buildings\n    this.state.buildings = [];\n    for (const building of data.features) {\n      const {properties, geometry} = building;\n      const {coordinates, type} = geometry;\n      if (!properties.height) {\n        properties.height = Math.random() * 1000;\n      }\n      switch (type) {\n      case 'MultiPolygon':\n        // Maps to multiple buildings\n        const buildings = coordinates.map(\n          coords => ({coordinates: coords, properties})\n        );\n        this.state.buildings.push(...buildings);\n        break;\n      case 'Polygon':\n        // Maps to a single building\n        this.state.buildings.push({coordinates, properties});\n        break;\n      default:\n        // We are ignoring Points for now\n      }\n    }\n\n    // Generate vertices for the building list\n    this.state.groupedVertices = this.state.buildings.map(\n      building => building.coordinates.map(\n        polygon => polygon.map(\n          coordinate => [\n            coordinate[0],\n            coordinate[1],\n            building.properties.height || 10\n          ]\n        )\n      )\n    );\n  }\n\n  calculateContourIndices(vertices, offset) {\n    const stride = countVertices(vertices);\n\n    return vertices.map(polygon => {\n      const indices = [offset];\n      const numVertices = polygon.length;\n\n      // building top\n      // use vertex pairs for GL.LINES => [0, 1, 1, 2, 2, ..., n-1, n-1, 0]\n      for (let i = 1; i < numVertices - 1; i++) {\n        indices.push(i + offset, i + offset);\n      }\n      indices.push(offset);\n\n      // building sides\n      for (let i = 0; i < numVertices - 1; i++) {\n        indices.push(i + offset, i + stride + offset);\n      }\n\n      offset += numVertices;\n      return indices;\n    });\n  }\n\n  calculateSurfaceIndices(vertices, offset) {\n    const stride = countVertices(vertices);\n    let holes = null;\n    const quad = [\n      [0, 1], [0, 3], [1, 2],\n      [1, 2], [0, 3], [1, 4]\n    ];\n\n    if (vertices.length > 1) {\n      holes = vertices.reduce(\n        (acc, polygon) => [...acc, acc[acc.length - 1] + polygon.length],\n        [0]\n      ).slice(1, vertices.length);\n    }\n\n    const topIndices = __WEBPACK_IMPORTED_MODULE_5_earcut___default()(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__lib_utils__[\"b\" /* flatten */])(vertices), holes, 3)\n      .map(index => index + offset);\n\n    const sideIndices = vertices.map(polygon => {\n      const numVertices = polygon.length;\n      // building top\n      const indices = [];\n\n      // building sides\n      for (let i = 0; i < numVertices - 1; i++) {\n        indices.push(...drawRectangle(i));\n      }\n\n      offset += numVertices;\n      return indices;\n    });\n\n    return [topIndices, sideIndices];\n\n    function drawRectangle(i) {\n      return quad.map(v => i + v[0] + stride * v[1] + offset);\n    }\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = ExtrudedChoroplethLayer64;\n\n\nExtrudedChoroplethLayer64.layerName = 'ExtrudedChoroplethLayer64';\nExtrudedChoroplethLayer64.defaultProps = defaultProps;\n\n/*\n * helpers\n */\n// get normal vector of line segment\nfunction getNormal(p1, p2) {\n  if (p1[0] === p2[0] && p1[1] === p2[1]) {\n    return [1, 0, 0];\n  }\n\n  const degrees2radians = Math.PI / 180;\n\n  const lon1 = degrees2radians * p1[0];\n  const lon2 = degrees2radians * p2[0];\n  const lat1 = degrees2radians * p1[1];\n  const lat2 = degrees2radians * p2[1];\n\n  const a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n  const b = Math.cos(lat1) * Math.sin(lat2) -\n     Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n\n  return __WEBPACK_IMPORTED_MODULE_6_gl_matrix__[\"vec3\"].normalize([], [b, 0, -a]);\n}\n\n// count number of vertices in geojson polygon\nfunction countVertices(vertices) {\n  return vertices.reduce((count, polygon) => count + polygon.length, 0);\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2RlcHJlY2F0ZWQvZXh0cnVkZWQtY2hvcm9wbGV0aC1sYXllci02NC9leHRydWRlZC1jaG9yb3BsZXRoLWxheWVyLTY0LmpzPzNkN2UiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtMYXllcn0gZnJvbSAnLi4vLi4vLi4vbGliJztcbmltcG9ydCB7YXNzZW1ibGVTaGFkZXJzfSBmcm9tICcuLi8uLi8uLi9zaGFkZXItdXRpbHMnO1xuaW1wb3J0IHtmcDY0aWZ5fSBmcm9tICcuLi8uLi8uLi9saWIvdXRpbHMvZnA2NCc7XG5pbXBvcnQge0dMLCBNb2RlbCwgR2VvbWV0cnl9IGZyb20gJ2x1bWEuZ2wnO1xuaW1wb3J0IHtmbGF0dGVuLCBsb2d9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscyc7XG5pbXBvcnQgZWFyY3V0IGZyb20gJ2VhcmN1dCc7XG5pbXBvcnQge3ZlYzN9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmltcG9ydCBleHRydWRlZENob3JvcGxldGhWZXJ0ZXggZnJvbSAnLi9leHRydWRlZC1jaG9yb3BsZXRoLWxheWVyLXZlcnRleC5nbHNsJztcbmltcG9ydCBleHRydWRlZENob3JvcGxldGhGcmFnbWVudCBmcm9tICcuL2V4dHJ1ZGVkLWNob3JvcGxldGgtbGF5ZXItZnJhZ21lbnQuZ2xzbCc7XG5cbmNvbnN0IERFRkFVTFRfQ09MT1IgPSBbMTgwLCAxODAsIDIwMF07XG5jb25zdCBERUZBVUxUX0FNQklFTlRfQ09MT1IgPSBbMjU1LCAyNTUsIDI1NV07XG5jb25zdCBERUZBVUxUX1BPSU5UTElHSFRfQU1CSUVOVF9DT0VGRklDSUVOVCA9IDAuMTtcbmNvbnN0IERFRkFVTFRfUE9JTlRMSUdIVF9MT0NBVElPTiA9IFs0MC40NDA2LCAtNzkuOTk1OSwgMTAwXTtcbmNvbnN0IERFRkFVTFRfUE9JTlRMSUdIVF9DT0xPUiA9IFsyNTUsIDI1NSwgMjU1XTtcbmNvbnN0IERFRkFVTFRfUE9JTlRMSUdIVF9BVFRFTlVBVElPTiA9IDEuMDtcbmNvbnN0IERFRkFVTFRfTUFURVJJQUxfU1BFQ1VMQVJfQ09MT1IgPSBbMjU1LCAyNTUsIDI1NV07XG5jb25zdCBERUZBVUxUX01BVEVSSUFMX1NISU5JTkVTUyA9IDE7XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgb3BhY2l0eTogMSxcbiAgZWxldmF0aW9uOiAxXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFeHRydWRlZENob3JvcGxldGhMYXllcjY0IGV4dGVuZHMgTGF5ZXIge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICBsb2cub25jZSgnRXh0cnVkZWRDaG9yb3BsZXRoTGF5ZXI2NCBpcyBkZXByZWNhdGVkLiBDb25zaWRlciB1c2luZyBHZW9Kc29uTGF5ZXIgaW5zdGVhZCcpO1xuICB9XG5cbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVNYW5hZ2VyfSA9IHRoaXMuc3RhdGU7XG4gICAgYXR0cmlidXRlTWFuYWdlci5hZGQoe1xuICAgICAgaW5kaWNlczoge3NpemU6IDEsIGlzSW5kZXhlZDogdHJ1ZSwgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluZGljZXN9LFxuICAgICAgcG9zaXRpb25zOiB7c2l6ZTogNCwgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZVBvc2l0aW9uc30sXG4gICAgICBoZWlnaHRzOiB7c2l6ZTogMiwgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUhlaWdodHN9LFxuICAgICAgbm9ybWFsczoge3NpemU6IDMsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVOb3JtYWxzfSxcbiAgICAgIGNvbG9yczoge3NpemU6IDQsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVDb2xvcnN9XG4gICAgfSk7XG5cbiAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgbnVtSW5zdGFuY2VzOiAwLFxuICAgICAgbW9kZWw6IHRoaXMuZ2V0TW9kZWwoZ2wpXG4gICAgfSk7XG4gIH1cblxuICB1cGRhdGVTdGF0ZSh7Y2hhbmdlRmxhZ3N9KSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoY2hhbmdlRmxhZ3MuZGF0YUNoYW5nZWQpIHtcbiAgICAgIHRoaXMuZXh0cmFjdEV4dHJ1ZGVkQ2hvcm9wbGV0aCgpO1xuICAgICAgYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlQWxsKCk7XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgZWxldmF0aW9uLFxuICAgICAgY29sb3IsIGFtYmllbnRDb2xvciwgcG9pbnRMaWdodENvbG9yLFxuICAgICAgcG9pbnRMaWdodExvY2F0aW9uLCBwb2ludExpZ2h0QW1iaWVudENvZWZmaWNpZW50LFxuICAgICAgcG9pbnRMaWdodEF0dGVudWF0aW9uLCBtYXRlcmlhbFNwZWN1bGFyQ29sb3IsIG1hdGVyaWFsU2hpbmluZXNzXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICB0aGlzLnNldFVuaWZvcm1zKHtcbiAgICAgIGVsZXZhdGlvbjogTnVtYmVyLmlzRmluaXRlKGVsZXZhdGlvbikgPyBlbGV2YXRpb24gOiAxLFxuICAgICAgY29sb3JzOiBjb2xvciB8fCBERUZBVUxUX0NPTE9SLFxuICAgICAgdUFtYmllbnRDb2xvcjogYW1iaWVudENvbG9yIHx8IERFRkFVTFRfQU1CSUVOVF9DT0xPUixcbiAgICAgIHVQb2ludExpZ2h0QW1iaWVudENvZWZmaWNpZW50OlxuICAgICAgICBwb2ludExpZ2h0QW1iaWVudENvZWZmaWNpZW50IHx8IERFRkFVTFRfUE9JTlRMSUdIVF9BTUJJRU5UX0NPRUZGSUNJRU5ULFxuICAgICAgdVBvaW50TGlnaHRMb2NhdGlvbjogcG9pbnRMaWdodExvY2F0aW9uIHx8IERFRkFVTFRfUE9JTlRMSUdIVF9MT0NBVElPTixcbiAgICAgIHVQb2ludExpZ2h0Q29sb3I6IHBvaW50TGlnaHRDb2xvciB8fCBERUZBVUxUX1BPSU5UTElHSFRfQ09MT1IsXG4gICAgICB1UG9pbnRMaWdodEF0dGVudWF0aW9uOiBwb2ludExpZ2h0QXR0ZW51YXRpb24gfHwgREVGQVVMVF9QT0lOVExJR0hUX0FUVEVOVUFUSU9OLFxuICAgICAgdU1hdGVyaWFsU3BlY3VsYXJDb2xvcjogbWF0ZXJpYWxTcGVjdWxhckNvbG9yIHx8IERFRkFVTFRfTUFURVJJQUxfU1BFQ1VMQVJfQ09MT1IsXG4gICAgICB1TWF0ZXJpYWxTaGluaW5lc3M6IG1hdGVyaWFsU2hpbmluZXNzIHx8IERFRkFVTFRfTUFURVJJQUxfU0hJTklORVNTXG4gICAgfSk7XG4gIH1cblxuICBkcmF3KHt1bmlmb3Jtc30pIHtcbiAgICB0aGlzLnN0YXRlLm1vZGVsLnJlbmRlcih1bmlmb3Jtcyk7XG4gIH1cblxuICBnZXRQaWNraW5nSW5mbyhvcHRzKSB7XG4gICAgY29uc3QgaW5mbyA9IHN1cGVyLmdldFBpY2tpbmdJbmZvKG9wdHMpO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5kZWNvZGVQaWNraW5nQ29sb3IoaW5mby5jb2xvcik7XG4gICAgY29uc3QgZmVhdHVyZSA9IGluZGV4ID49IDAgPyB0aGlzLnByb3BzLmRhdGEuZmVhdHVyZXNbaW5kZXhdIDogbnVsbDtcbiAgICBpbmZvLmZlYXR1cmUgPSBmZWF0dXJlO1xuICAgIGluZm8ub2JqZWN0ID0gZmVhdHVyZTtcbiAgICByZXR1cm4gaW5mbztcbiAgfVxuXG4gIGdldFNoYWRlcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZzOiBleHRydWRlZENob3JvcGxldGhWZXJ0ZXgsXG4gICAgICBmczogZXh0cnVkZWRDaG9yb3BsZXRoRnJhZ21lbnQsXG4gICAgICBmcDY0OiB0cnVlLFxuICAgICAgcHJvamVjdDY0OiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIGdldE1vZGVsKGdsKSB7XG4gICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgMzIgYml0IHN1cHBvcnRcbiAgICAvLyBUT0RPIC0gdGhpcyBjb3VsZCBiZSBkb25lIGF1dG9tYXRpY2FsbHkgYnkgbHVtYSBpbiBcImRyYXdcIlxuICAgIC8vIHdoZW4gaXQgZGV0ZWN0cyAzMiBiaXQgaW5kaWNlc1xuICAgIGlmICghZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfZWxlbWVudF9pbmRleF91aW50JykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXh0cnVkZWQgY2hvcm9wbGV0aCBsYXllciBuZWVkcyAzMiBiaXQgaW5kaWNlcycpO1xuICAgIH1cblxuICAgIC8vIEJ1aWxkaW5ncyBhcmUgM2Qgc28gZGVwdGggdGVzdCBzaG91bGQgYmUgZW5hYmxlZFxuICAgIC8vIFRPRE8gLSBpdCBpcyBhIGxpdHRsZSBoZWF2eSBoYW5kZWQgdG8gaGF2ZSBhIGxheWVyIHNldCB0aGlzXG4gICAgLy8gQWx0ZXJuYXRpdmVseSwgY2hlY2sgZGVwdGggdGVzdCBhbmQgd2FybiBpZiBub3Qgc2V0LCBvciBhZGQgYSBwcm9wXG4gICAgLy8gc2V0RGVwdGhUZXN0IHRoYXQgaXMgb24gYnkgZGVmYXVsdC5cbiAgICBnbC5lbmFibGUoR0wuREVQVEhfVEVTVCk7XG4gICAgZ2wuZGVwdGhGdW5jKEdMLkxFUVVBTCk7XG5cbiAgICBjb25zdCBzaGFkZXJzID0gYXNzZW1ibGVTaGFkZXJzKGdsLCB0aGlzLmdldFNoYWRlcnMoKSk7XG5cbiAgICByZXR1cm4gbmV3IE1vZGVsKHtcbiAgICAgIGdsLFxuICAgICAgaWQ6IHRoaXMucHJvcHMuaWQsXG4gICAgICB2czogc2hhZGVycy52cyxcbiAgICAgIGZzOiBzaGFkZXJzLmZzLFxuICAgICAgZ2VvbWV0cnk6IG5ldyBHZW9tZXRyeSh7XG4gICAgICAgIGRyYXdNb2RlOiB0aGlzLnByb3BzLmRyYXdXaXJlZnJhbWUgPyBHTC5MSU5FUyA6IEdMLlRSSUFOR0xFU1xuICAgICAgfSksXG4gICAgICB2ZXJ0ZXhDb3VudDogMCxcbiAgICAgIGlzSW5kZXhlZDogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgLy8gZWFjaCB0b3AgdmVydGV4IGlzIG9uIDMgc3VyZmFjZXNcbiAgLy8gZWFjaCBib3R0b20gdmVydGV4IGlzIG9uIDIgc3VyZmFjZXNcbiAgY2FsY3VsYXRlUG9zaXRpb25zKGF0dHJpYnV0ZSkge1xuICAgIGxldCB7cG9zaXRpb25zfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKCFwb3NpdGlvbnMpIHtcbiAgICAgIHBvc2l0aW9ucyA9IGZsYXR0ZW4odGhpcy5zdGF0ZS5ncm91cGVkVmVydGljZXMubWFwKFxuICAgICAgICB2ZXJ0aWNlcyA9PiB7XG4gICAgICAgICAgY29uc3QgdG9wVmVydGljZXMgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCB2ZXJ0aWNlcyk7XG4gICAgICAgICAgY29uc3QgYmFzZVZlcnRpY2VzID0gdG9wVmVydGljZXMubWFwKHYgPT4gW3ZbMF0sIHZbMV0sIDBdKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5kcmF3V2lyZWZyYW1lID8gW3RvcFZlcnRpY2VzLCBiYXNlVmVydGljZXNdIDpcbiAgICAgICAgICAgIFt0b3BWZXJ0aWNlcywgdG9wVmVydGljZXMsIHRvcFZlcnRpY2VzLCBiYXNlVmVydGljZXMsIGJhc2VWZXJ0aWNlc107XG4gICAgICAgIH1cbiAgICAgICkpO1xuICAgIH1cblxuICAgIGF0dHJpYnV0ZS52YWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkocG9zaXRpb25zLmxlbmd0aCAvIDMgKiA0KTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aCAvIDM7IGkrKykge1xuICAgICAgW2F0dHJpYnV0ZS52YWx1ZVtpICogNCArIDBdLCBhdHRyaWJ1dGUudmFsdWVbaSAqIDQgKyAxXV0gPSBmcDY0aWZ5KHBvc2l0aW9uc1tpICogMyArIDBdKTtcbiAgICAgIFthdHRyaWJ1dGUudmFsdWVbaSAqIDQgKyAyXSwgYXR0cmlidXRlLnZhbHVlW2kgKiA0ICsgM11dID0gZnA2NGlmeShwb3NpdGlvbnNbaSAqIDMgKyAxXSk7XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlSGVpZ2h0cyhhdHRyaWJ1dGUpIHtcbiAgICBsZXQge3Bvc2l0aW9uc30gPSB0aGlzLnN0YXRlO1xuICAgIGlmICghcG9zaXRpb25zKSB7XG4gICAgICBwb3NpdGlvbnMgPSBmbGF0dGVuKHRoaXMuc3RhdGUuZ3JvdXBlZFZlcnRpY2VzLm1hcChcbiAgICAgICAgdmVydGljZXMgPT4ge1xuICAgICAgICAgIGNvbnN0IHRvcFZlcnRpY2VzID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgdmVydGljZXMpO1xuICAgICAgICAgIGNvbnN0IGJhc2VWZXJ0aWNlcyA9IHRvcFZlcnRpY2VzLm1hcCh2ID0+IFt2WzBdLCB2WzFdLCAwXSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuZHJhd1dpcmVmcmFtZSA/IFt0b3BWZXJ0aWNlcywgYmFzZVZlcnRpY2VzXSA6XG4gICAgICAgICAgICBbdG9wVmVydGljZXMsIHRvcFZlcnRpY2VzLCB0b3BWZXJ0aWNlcywgYmFzZVZlcnRpY2VzLCBiYXNlVmVydGljZXNdO1xuICAgICAgICB9XG4gICAgICApKTtcbiAgICB9XG5cbiAgICBhdHRyaWJ1dGUudmFsdWUgPSBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9ucy5sZW5ndGggLyAzICogMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoIC8gMzsgaSsrKSB7XG4gICAgICBbYXR0cmlidXRlLnZhbHVlW2kgKiAyICsgMF0sIGF0dHJpYnV0ZS52YWx1ZVtpICogMiArIDFdXSA9XG4gICAgICAgZnA2NGlmeShwb3NpdGlvbnNbaSAqIDMgKyAyXSArIDAuMSk7XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlTm9ybWFscyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB1cCA9IFswLCAxLCAwXTtcblxuICAgIGNvbnN0IG5vcm1hbHMgPSB0aGlzLnN0YXRlLmdyb3VwZWRWZXJ0aWNlcy5tYXAoXG4gICAgICAodmVydGljZXMsIGJ1aWxkaW5nSW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgdG9wTm9ybWFscyA9IG5ldyBBcnJheShjb3VudFZlcnRpY2VzKHZlcnRpY2VzKSkuZmlsbCh1cCk7XG4gICAgICAgIGNvbnN0IHNpZGVOb3JtYWxzID0gdmVydGljZXMubWFwKHBvbHlnb24gPT5cbiAgICAgICAgICB0aGlzLmNhbGN1bGF0ZVNpZGVOb3JtYWxzKHBvbHlnb24pKTtcbiAgICAgICAgY29uc3Qgc2lkZU5vcm1hbHNGb3J3YXJkID0gc2lkZU5vcm1hbHMubWFwKG4gPT4gblswXSk7XG4gICAgICAgIGNvbnN0IHNpZGVOb3JtYWxzQmFja3dhcmQgPSBzaWRlTm9ybWFscy5tYXAobiA9PiBuWzFdKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5kcmF3V2lyZWZyYW1lID8gW3RvcE5vcm1hbHMsIHRvcE5vcm1hbHNdIDpcbiAgICAgICAgW3RvcE5vcm1hbHMsIHNpZGVOb3JtYWxzRm9yd2FyZCwgc2lkZU5vcm1hbHNCYWNrd2FyZCxcbiAgICAgICAgICBzaWRlTm9ybWFsc0ZvcndhcmQsIHNpZGVOb3JtYWxzQmFja3dhcmRdO1xuICAgICAgfVxuICAgICk7XG5cbiAgICBhdHRyaWJ1dGUudmFsdWUgPSBuZXcgRmxvYXQzMkFycmF5KGZsYXR0ZW4obm9ybWFscykpO1xuICB9XG5cbiAgY2FsY3VsYXRlU2lkZU5vcm1hbHModmVydGljZXMpIHtcbiAgICBjb25zdCBudW1WZXJ0aWNlcyA9IHZlcnRpY2VzLmxlbmd0aDtcbiAgICBjb25zdCBub3JtYWxzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVZlcnRpY2VzIC0gMTsgaSsrKSB7XG4gICAgICBjb25zdCBuID0gZ2V0Tm9ybWFsKHZlcnRpY2VzW2ldLCB2ZXJ0aWNlc1tpICsgMV0pO1xuICAgICAgbm9ybWFscy5wdXNoKG4pO1xuICAgIH1cblxuICAgIHJldHVybiBbXG4gICAgICBbLi4ubm9ybWFscywgbm9ybWFsc1swXV0sXG4gICAgICBbbm9ybWFsc1swXSwgLi4ubm9ybWFsc11cbiAgICBdO1xuICB9XG5cbiAgY2FsY3VsYXRlSW5kaWNlcyhhdHRyaWJ1dGUpIHtcbiAgICAvLyBhZGp1c3QgaW5kZXggb2Zmc2V0IGZvciBtdWx0aXBsZSBidWlsZGluZ3NcbiAgICBjb25zdCBtdWx0aXBsaWVyID0gdGhpcy5wcm9wcy5kcmF3V2lyZWZyYW1lID8gMiA6IDU7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuc3RhdGUuZ3JvdXBlZFZlcnRpY2VzLnJlZHVjZShcbiAgICAgIChhY2MsIHZlcnRpY2VzKSA9PlxuICAgICAgICBbLi4uYWNjLCBhY2NbYWNjLmxlbmd0aCAtIDFdICsgY291bnRWZXJ0aWNlcyh2ZXJ0aWNlcykgKiBtdWx0aXBsaWVyXSxcbiAgICAgIFswXVxuICAgICk7XG5cbiAgICBjb25zdCBpbmRpY2VzID0gdGhpcy5zdGF0ZS5ncm91cGVkVmVydGljZXMubWFwKFxuICAgICAgKHZlcnRpY2VzLCBidWlsZGluZ0luZGV4KSA9PiB0aGlzLnByb3BzLmRyYXdXaXJlZnJhbWUgP1xuICAgICAgICAvLyAxLiBnZXQgc2VxdWVudGlhbGx5IG9yZGVyZWQgaW5kaWNlcyBvZiBlYWNoIGJ1aWxkaW5nIHdpcmVmcmFtZVxuICAgICAgICAvLyAyLiBvZmZzZXQgdGhlbSBieSB0aGUgbnVtYmVyIG9mIGluZGljZXMgaW4gcHJldmlvdXMgYnVpbGRpbmdzXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlQ29udG91ckluZGljZXModmVydGljZXMsIG9mZnNldHNbYnVpbGRpbmdJbmRleF0pIDpcbiAgICAgICAgLy8gMS4gZ2V0IHRyaWFuZ3VsYXRlZCBpbmRpY2VzIGZvciB0aGUgaW50ZXJuYWwgYXJlYXNcbiAgICAgICAgLy8gMi4gb2Zmc2V0IHRoZW0gYnkgdGhlIG51bWJlciBvZiBpbmRpY2VzIGluIHByZXZpb3VzIGJ1aWxkaW5nc1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZVN1cmZhY2VJbmRpY2VzKHZlcnRpY2VzLCBvZmZzZXRzW2J1aWxkaW5nSW5kZXhdKVxuICAgICk7XG5cbiAgICBhdHRyaWJ1dGUudmFsdWUgPSBuZXcgVWludDMyQXJyYXkoZmxhdHRlbihpbmRpY2VzKSk7XG4gICAgYXR0cmlidXRlLnRhcmdldCA9IEdMLkVMRU1FTlRfQVJSQVlfQlVGRkVSO1xuICAgIHRoaXMuc3RhdGUubW9kZWwuc2V0VmVydGV4Q291bnQoYXR0cmlidXRlLnZhbHVlLmxlbmd0aCAvIGF0dHJpYnV0ZS5zaXplKTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUNvbG9ycyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCBjb2xvcnMgPSB0aGlzLnN0YXRlLmdyb3VwZWRWZXJ0aWNlcy5tYXAoXG4gICAgICAodmVydGljZXMsIGJ1aWxkaW5nSW5kZXgpID0+IHtcbiAgICAgICAgY29uc3Qge2NvbG9yfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IGJhc2VDb2xvciA9IEFycmF5LmlzQXJyYXkoY29sb3IpID8gY29sb3JbMF0gOiBjb2xvcjtcbiAgICAgICAgY29uc3QgdG9wQ29sb3IgPSBBcnJheS5pc0FycmF5KGNvbG9yKSA/XG4gICAgICAgICAgY29sb3JbY29sb3IubGVuZ3RoIC0gMV0gOiBjb2xvcjtcbiAgICAgICAgY29uc3QgbnVtVmVydGljZXMgPSBjb3VudFZlcnRpY2VzKHZlcnRpY2VzKTtcblxuICAgICAgICBjb25zdCB0b3BDb2xvcnMgPSBuZXcgQXJyYXkobnVtVmVydGljZXMpLmZpbGwodG9wQ29sb3IpO1xuICAgICAgICBjb25zdCBiYXNlQ29sb3JzID0gbmV3IEFycmF5KG51bVZlcnRpY2VzKS5maWxsKGJhc2VDb2xvcik7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmRyYXdXaXJlZnJhbWUgPyBbdG9wQ29sb3JzLCBiYXNlQ29sb3JzXSA6XG4gICAgICAgICAgW3RvcENvbG9ycywgdG9wQ29sb3JzLCB0b3BDb2xvcnMsIGJhc2VDb2xvcnMsIGJhc2VDb2xvcnNdO1xuICAgICAgfVxuICAgICk7XG4gICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IEZsb2F0MzJBcnJheShmbGF0dGVuKGNvbG9ycykpO1xuICB9XG5cbiAgZXh0cmFjdEV4dHJ1ZGVkQ2hvcm9wbGV0aCgpIHtcbiAgICBjb25zdCB7ZGF0YX0gPSB0aGlzLnByb3BzO1xuICAgIC8vIEdlbmVyYXRlIGEgZmxhdCBsaXN0IG9mIGJ1aWxkaW5nc1xuICAgIHRoaXMuc3RhdGUuYnVpbGRpbmdzID0gW107XG4gICAgZm9yIChjb25zdCBidWlsZGluZyBvZiBkYXRhLmZlYXR1cmVzKSB7XG4gICAgICBjb25zdCB7cHJvcGVydGllcywgZ2VvbWV0cnl9ID0gYnVpbGRpbmc7XG4gICAgICBjb25zdCB7Y29vcmRpbmF0ZXMsIHR5cGV9ID0gZ2VvbWV0cnk7XG4gICAgICBpZiAoIXByb3BlcnRpZXMuaGVpZ2h0KSB7XG4gICAgICAgIHByb3BlcnRpZXMuaGVpZ2h0ID0gTWF0aC5yYW5kb20oKSAqIDEwMDA7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ011bHRpUG9seWdvbic6XG4gICAgICAgIC8vIE1hcHMgdG8gbXVsdGlwbGUgYnVpbGRpbmdzXG4gICAgICAgIGNvbnN0IGJ1aWxkaW5ncyA9IGNvb3JkaW5hdGVzLm1hcChcbiAgICAgICAgICBjb29yZHMgPT4gKHtjb29yZGluYXRlczogY29vcmRzLCBwcm9wZXJ0aWVzfSlcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5idWlsZGluZ3MucHVzaCguLi5idWlsZGluZ3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1BvbHlnb24nOlxuICAgICAgICAvLyBNYXBzIHRvIGEgc2luZ2xlIGJ1aWxkaW5nXG4gICAgICAgIHRoaXMuc3RhdGUuYnVpbGRpbmdzLnB1c2goe2Nvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gV2UgYXJlIGlnbm9yaW5nIFBvaW50cyBmb3Igbm93XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgdmVydGljZXMgZm9yIHRoZSBidWlsZGluZyBsaXN0XG4gICAgdGhpcy5zdGF0ZS5ncm91cGVkVmVydGljZXMgPSB0aGlzLnN0YXRlLmJ1aWxkaW5ncy5tYXAoXG4gICAgICBidWlsZGluZyA9PiBidWlsZGluZy5jb29yZGluYXRlcy5tYXAoXG4gICAgICAgIHBvbHlnb24gPT4gcG9seWdvbi5tYXAoXG4gICAgICAgICAgY29vcmRpbmF0ZSA9PiBbXG4gICAgICAgICAgICBjb29yZGluYXRlWzBdLFxuICAgICAgICAgICAgY29vcmRpbmF0ZVsxXSxcbiAgICAgICAgICAgIGJ1aWxkaW5nLnByb3BlcnRpZXMuaGVpZ2h0IHx8IDEwXG4gICAgICAgICAgXVxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUNvbnRvdXJJbmRpY2VzKHZlcnRpY2VzLCBvZmZzZXQpIHtcbiAgICBjb25zdCBzdHJpZGUgPSBjb3VudFZlcnRpY2VzKHZlcnRpY2VzKTtcblxuICAgIHJldHVybiB2ZXJ0aWNlcy5tYXAocG9seWdvbiA9PiB7XG4gICAgICBjb25zdCBpbmRpY2VzID0gW29mZnNldF07XG4gICAgICBjb25zdCBudW1WZXJ0aWNlcyA9IHBvbHlnb24ubGVuZ3RoO1xuXG4gICAgICAvLyBidWlsZGluZyB0b3BcbiAgICAgIC8vIHVzZSB2ZXJ0ZXggcGFpcnMgZm9yIEdMLkxJTkVTID0+IFswLCAxLCAxLCAyLCAyLCAuLi4sIG4tMSwgbi0xLCAwXVxuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBudW1WZXJ0aWNlcyAtIDE7IGkrKykge1xuICAgICAgICBpbmRpY2VzLnB1c2goaSArIG9mZnNldCwgaSArIG9mZnNldCk7XG4gICAgICB9XG4gICAgICBpbmRpY2VzLnB1c2gob2Zmc2V0KTtcblxuICAgICAgLy8gYnVpbGRpbmcgc2lkZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVmVydGljZXMgLSAxOyBpKyspIHtcbiAgICAgICAgaW5kaWNlcy5wdXNoKGkgKyBvZmZzZXQsIGkgKyBzdHJpZGUgKyBvZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICBvZmZzZXQgKz0gbnVtVmVydGljZXM7XG4gICAgICByZXR1cm4gaW5kaWNlcztcbiAgICB9KTtcbiAgfVxuXG4gIGNhbGN1bGF0ZVN1cmZhY2VJbmRpY2VzKHZlcnRpY2VzLCBvZmZzZXQpIHtcbiAgICBjb25zdCBzdHJpZGUgPSBjb3VudFZlcnRpY2VzKHZlcnRpY2VzKTtcbiAgICBsZXQgaG9sZXMgPSBudWxsO1xuICAgIGNvbnN0IHF1YWQgPSBbXG4gICAgICBbMCwgMV0sIFswLCAzXSwgWzEsIDJdLFxuICAgICAgWzEsIDJdLCBbMCwgM10sIFsxLCA0XVxuICAgIF07XG5cbiAgICBpZiAodmVydGljZXMubGVuZ3RoID4gMSkge1xuICAgICAgaG9sZXMgPSB2ZXJ0aWNlcy5yZWR1Y2UoXG4gICAgICAgIChhY2MsIHBvbHlnb24pID0+IFsuLi5hY2MsIGFjY1thY2MubGVuZ3RoIC0gMV0gKyBwb2x5Z29uLmxlbmd0aF0sXG4gICAgICAgIFswXVxuICAgICAgKS5zbGljZSgxLCB2ZXJ0aWNlcy5sZW5ndGgpO1xuICAgIH1cblxuICAgIGNvbnN0IHRvcEluZGljZXMgPSBlYXJjdXQoZmxhdHRlbih2ZXJ0aWNlcyksIGhvbGVzLCAzKVxuICAgICAgLm1hcChpbmRleCA9PiBpbmRleCArIG9mZnNldCk7XG5cbiAgICBjb25zdCBzaWRlSW5kaWNlcyA9IHZlcnRpY2VzLm1hcChwb2x5Z29uID0+IHtcbiAgICAgIGNvbnN0IG51bVZlcnRpY2VzID0gcG9seWdvbi5sZW5ndGg7XG4gICAgICAvLyBidWlsZGluZyB0b3BcbiAgICAgIGNvbnN0IGluZGljZXMgPSBbXTtcblxuICAgICAgLy8gYnVpbGRpbmcgc2lkZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVmVydGljZXMgLSAxOyBpKyspIHtcbiAgICAgICAgaW5kaWNlcy5wdXNoKC4uLmRyYXdSZWN0YW5nbGUoaSkpO1xuICAgICAgfVxuXG4gICAgICBvZmZzZXQgKz0gbnVtVmVydGljZXM7XG4gICAgICByZXR1cm4gaW5kaWNlcztcbiAgICB9KTtcblxuICAgIHJldHVybiBbdG9wSW5kaWNlcywgc2lkZUluZGljZXNdO1xuXG4gICAgZnVuY3Rpb24gZHJhd1JlY3RhbmdsZShpKSB7XG4gICAgICByZXR1cm4gcXVhZC5tYXAodiA9PiBpICsgdlswXSArIHN0cmlkZSAqIHZbMV0gKyBvZmZzZXQpO1xuICAgIH1cbiAgfVxufVxuXG5FeHRydWRlZENob3JvcGxldGhMYXllcjY0LmxheWVyTmFtZSA9ICdFeHRydWRlZENob3JvcGxldGhMYXllcjY0JztcbkV4dHJ1ZGVkQ2hvcm9wbGV0aExheWVyNjQuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuXG4vKlxuICogaGVscGVyc1xuICovXG4vLyBnZXQgbm9ybWFsIHZlY3RvciBvZiBsaW5lIHNlZ21lbnRcbmZ1bmN0aW9uIGdldE5vcm1hbChwMSwgcDIpIHtcbiAgaWYgKHAxWzBdID09PSBwMlswXSAmJiBwMVsxXSA9PT0gcDJbMV0pIHtcbiAgICByZXR1cm4gWzEsIDAsIDBdO1xuICB9XG5cbiAgY29uc3QgZGVncmVlczJyYWRpYW5zID0gTWF0aC5QSSAvIDE4MDtcblxuICBjb25zdCBsb24xID0gZGVncmVlczJyYWRpYW5zICogcDFbMF07XG4gIGNvbnN0IGxvbjIgPSBkZWdyZWVzMnJhZGlhbnMgKiBwMlswXTtcbiAgY29uc3QgbGF0MSA9IGRlZ3JlZXMycmFkaWFucyAqIHAxWzFdO1xuICBjb25zdCBsYXQyID0gZGVncmVlczJyYWRpYW5zICogcDJbMV07XG5cbiAgY29uc3QgYSA9IE1hdGguc2luKGxvbjIgLSBsb24xKSAqIE1hdGguY29zKGxhdDIpO1xuICBjb25zdCBiID0gTWF0aC5jb3MobGF0MSkgKiBNYXRoLnNpbihsYXQyKSAtXG4gICAgIE1hdGguc2luKGxhdDEpICogTWF0aC5jb3MobGF0MikgKiBNYXRoLmNvcyhsb24yIC0gbG9uMSk7XG5cbiAgcmV0dXJuIHZlYzMubm9ybWFsaXplKFtdLCBbYiwgMCwgLWFdKTtcbn1cblxuLy8gY291bnQgbnVtYmVyIG9mIHZlcnRpY2VzIGluIGdlb2pzb24gcG9seWdvblxuZnVuY3Rpb24gY291bnRWZXJ0aWNlcyh2ZXJ0aWNlcykge1xuICByZXR1cm4gdmVydGljZXMucmVkdWNlKChjb3VudCwgcG9seWdvbikgPT4gY291bnQgKyBwb2x5Z29uLmxlbmd0aCwgMCk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9sYXllcnMvZGVwcmVjYXRlZC9leHRydWRlZC1jaG9yb3BsZXRoLWxheWVyLTY0L2V4dHJ1ZGVkLWNob3JvcGxldGgtbGF5ZXItNjQuanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 46 */
/* unknown exports provided */
/* all exports used */
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 47 */
/* unknown exports provided */
/* exports used: version */
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/***/ (function(module, exports) {

eval("module.exports = {\n\t\"name\": \"deck.gl\",\n\t\"description\": \"A suite of 3D-enabled data visualization overlays, suitable for react-map-gl\",\n\t\"license\": \"MIT\",\n\t\"version\": \"4.0.0-rc1\",\n\t\"keywords\": [\n\t\t\"webgl\",\n\t\t\"visualization\",\n\t\t\"overlay\",\n\t\t\"layer\"\n\t],\n\t\"repository\": {\n\t\t\"type\": \"git\",\n\t\t\"url\": \"https://github.com/uber/deck.gl.git\"\n\t},\n\t\"main\": \"dist/index.js\",\n\t\"module\": \"dist-es6/index.js\",\n\t\"files\": [\n\t\t\"dist\",\n\t\t\"dist-es6\",\n\t\t\"src\"\n\t],\n\t\"scripts\": {\n\t\t\"start\": \"(cd examples/layer-browser && npm run start-local)\",\n\t\t\"build-clean\": \"rm -fr dist dist-es6 && mkdir -p dist dist-es6 \",\n\t\t\"build-es6\": \"rm -fr dist-es6 && babel src --out-dir dist-es6 --plugins=static-fs --source-maps inline\",\n\t\t\"build-es5\": \"rm -fr dist && babel src --out-dir dist --plugins=static-fs,transform-es2015-modules-commonjs --source-maps inline\",\n\t\t\"build-buble\": \"buble dist-es6 -o dist --no modules --y dangerousForOf --objectAssign\",\n\t\t\"build\": \"npm run build-clean && npm run build-es6 && npm run build-es5 && webpack -d --display-modules\",\n\t\t\"lint\": \"eslint src test examples && npm run lint-yarn\",\n\t\t\"lint-yarn\": \"!(find . -name yarn.lock -exec grep -l unpm.u {} \\\\; | egrep '.*')\",\n\t\t\"publish-prod\": \"npm run build && npm run test && npm run test-dist && npm publish\",\n\t\t\"publish-beta\": \"npm run build && npm run test && npm run test-dist && npm publish --tag beta\",\n\t\t\"test\": \"npm run lint && npm run test-node\",\n\t\t\"test-node\": \"node test/node.js\",\n\t\t\"test-dist\": \"node test/node-dist.js\",\n\t\t\"test-browser\": \"webpack-dev-server --config webpack.config.test-browser.js --progress --hot --open --port 3010\",\n\t\t\"bench\": \"node test/bench/node.js\",\n\t\t\"bench-browser\": \"webpack-dev-server --config webpack.config.bench-browser.js --progress --hot --open --port 3011\",\n\t\t\"test-fp64\": \"(cd test/fp64-test && webpack-dev-server --config webpack.config.test-fp64.js --progress --hot --open)\",\n\t\t\"test-rendering\": \"(cd test/rendering-test && webpack-dev-server --config webpack.config.test-rendering.js --progress --hot --open)\"\n\t},\n\t\"dependencies\": {\n\t\t\"d3-hexbin\": \"^0.2.1\",\n\t\t\"earcut\": \"^2.0.6\",\n\t\t\"gl-matrix\": \"^2.3.2\",\n\t\t\"lodash.flattendeep\": \"^4.4.0\"\n\t},\n\t\"devDependencies\": {\n\t\t\"babel-cli\": \"^6.22.2\",\n\t\t\"babel-core\": \"^6.22.1\",\n\t\t\"babel-loader\": \"^6.2.10\",\n\t\t\"babel-plugin-static-fs\": \"^1.1.0\",\n\t\t\"babel-plugin-transform-es2015-modules-commonjs\": \"^6.22.0\",\n\t\t\"babel-polyfill\": \"^6.20.0\",\n\t\t\"babel-preset-es2015\": \"^6.4.3\",\n\t\t\"benchmark\": \"^2.1.3\",\n\t\t\"brfs-babel\": \"^1.0.0\",\n\t\t\"buble\": \"^0.15.1\",\n\t\t\"buble-loader\": \"^0.4.0\",\n\t\t\"colorbrewer\": \"^1.0.0\",\n\t\t\"eslint\": \"^3.0.0\",\n\t\t\"eslint-config-uber-es2015\": \"^3.0.0\",\n\t\t\"eslint-config-uber-jsx\": \"^3.0.0\",\n\t\t\"eslint-plugin-react\": \"~6.7.0\",\n\t\t\"faucet\": \"0.0.1\",\n\t\t\"file-loader\": \"^0.10.1\",\n\t\t\"gl\": \"^4.0.3\",\n\t\t\"immutable\": \"^3.8.1\",\n\t\t\"luma.gl\": \"3.0.0-beta.11\",\n\t\t\"module-alias\": \"^2.0.0\",\n\t\t\"pre-commit\": \"^1.2.2\",\n\t\t\"raw-loader\": \"^0.5.1\",\n\t\t\"react\": \"^15.4.0\",\n\t\t\"react-addons-test-utils\": \"^15.4.2\",\n\t\t\"react-dom\": \"^15.4.0\",\n\t\t\"reify\": \"^0.4.4\",\n\t\t\"tap-browser-color\": \"^0.1.2\",\n\t\t\"tape\": \"^4.5.1\",\n\t\t\"tape-catch\": \"^1.0.4\",\n\t\t\"transform-loader\": \"^0.2.3\",\n\t\t\"uglify-js\": \"^2.6.1\",\n\t\t\"url-loader\": \"^0.5.7\",\n\t\t\"webpack\": \"^2.2.0\",\n\t\t\"webpack-dev-server\": \"^2.2.0\"\n\t},\n\t\"peerDependencies\": {\n\t\t\"luma.gl\": \"^3.0.0-beta.11\",\n\t\t\"react\": \"0.14.x - 15.x\",\n\t\t\"react-dom\": \"0.14.x - 15.x\"\n\t},\n\t\"babel\": {\n\t\t\"presets\": [\n\t\t\t[\n\t\t\t\t\"es2015\",\n\t\t\t\t{\n\t\t\t\t\t\"modules\": false\n\t\t\t\t}\n\t\t\t]\n\t\t]\n\t}\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlLmpzb24/ZWQ4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHtcblx0XCJuYW1lXCI6IFwiZGVjay5nbFwiLFxuXHRcImRlc2NyaXB0aW9uXCI6IFwiQSBzdWl0ZSBvZiAzRC1lbmFibGVkIGRhdGEgdmlzdWFsaXphdGlvbiBvdmVybGF5cywgc3VpdGFibGUgZm9yIHJlYWN0LW1hcC1nbFwiLFxuXHRcImxpY2Vuc2VcIjogXCJNSVRcIixcblx0XCJ2ZXJzaW9uXCI6IFwiNC4wLjAtcmMxXCIsXG5cdFwia2V5d29yZHNcIjogW1xuXHRcdFwid2ViZ2xcIixcblx0XHRcInZpc3VhbGl6YXRpb25cIixcblx0XHRcIm92ZXJsYXlcIixcblx0XHRcImxheWVyXCJcblx0XSxcblx0XCJyZXBvc2l0b3J5XCI6IHtcblx0XHRcInR5cGVcIjogXCJnaXRcIixcblx0XHRcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS91YmVyL2RlY2suZ2wuZ2l0XCJcblx0fSxcblx0XCJtYWluXCI6IFwiZGlzdC9pbmRleC5qc1wiLFxuXHRcIm1vZHVsZVwiOiBcImRpc3QtZXM2L2luZGV4LmpzXCIsXG5cdFwiZmlsZXNcIjogW1xuXHRcdFwiZGlzdFwiLFxuXHRcdFwiZGlzdC1lczZcIixcblx0XHRcInNyY1wiXG5cdF0sXG5cdFwic2NyaXB0c1wiOiB7XG5cdFx0XCJzdGFydFwiOiBcIihjZCBleGFtcGxlcy9sYXllci1icm93c2VyICYmIG5wbSBydW4gc3RhcnQtbG9jYWwpXCIsXG5cdFx0XCJidWlsZC1jbGVhblwiOiBcInJtIC1mciBkaXN0IGRpc3QtZXM2ICYmIG1rZGlyIC1wIGRpc3QgZGlzdC1lczYgXCIsXG5cdFx0XCJidWlsZC1lczZcIjogXCJybSAtZnIgZGlzdC1lczYgJiYgYmFiZWwgc3JjIC0tb3V0LWRpciBkaXN0LWVzNiAtLXBsdWdpbnM9c3RhdGljLWZzIC0tc291cmNlLW1hcHMgaW5saW5lXCIsXG5cdFx0XCJidWlsZC1lczVcIjogXCJybSAtZnIgZGlzdCAmJiBiYWJlbCBzcmMgLS1vdXQtZGlyIGRpc3QgLS1wbHVnaW5zPXN0YXRpYy1mcyx0cmFuc2Zvcm0tZXMyMDE1LW1vZHVsZXMtY29tbW9uanMgLS1zb3VyY2UtbWFwcyBpbmxpbmVcIixcblx0XHRcImJ1aWxkLWJ1YmxlXCI6IFwiYnVibGUgZGlzdC1lczYgLW8gZGlzdCAtLW5vIG1vZHVsZXMgLS15IGRhbmdlcm91c0Zvck9mIC0tb2JqZWN0QXNzaWduXCIsXG5cdFx0XCJidWlsZFwiOiBcIm5wbSBydW4gYnVpbGQtY2xlYW4gJiYgbnBtIHJ1biBidWlsZC1lczYgJiYgbnBtIHJ1biBidWlsZC1lczUgJiYgd2VicGFjayAtZCAtLWRpc3BsYXktbW9kdWxlc1wiLFxuXHRcdFwibGludFwiOiBcImVzbGludCBzcmMgdGVzdCBleGFtcGxlcyAmJiBucG0gcnVuIGxpbnQteWFyblwiLFxuXHRcdFwibGludC15YXJuXCI6IFwiIShmaW5kIC4gLW5hbWUgeWFybi5sb2NrIC1leGVjIGdyZXAgLWwgdW5wbS51IHt9IFxcXFw7IHwgZWdyZXAgJy4qJylcIixcblx0XHRcInB1Ymxpc2gtcHJvZFwiOiBcIm5wbSBydW4gYnVpbGQgJiYgbnBtIHJ1biB0ZXN0ICYmIG5wbSBydW4gdGVzdC1kaXN0ICYmIG5wbSBwdWJsaXNoXCIsXG5cdFx0XCJwdWJsaXNoLWJldGFcIjogXCJucG0gcnVuIGJ1aWxkICYmIG5wbSBydW4gdGVzdCAmJiBucG0gcnVuIHRlc3QtZGlzdCAmJiBucG0gcHVibGlzaCAtLXRhZyBiZXRhXCIsXG5cdFx0XCJ0ZXN0XCI6IFwibnBtIHJ1biBsaW50ICYmIG5wbSBydW4gdGVzdC1ub2RlXCIsXG5cdFx0XCJ0ZXN0LW5vZGVcIjogXCJub2RlIHRlc3Qvbm9kZS5qc1wiLFxuXHRcdFwidGVzdC1kaXN0XCI6IFwibm9kZSB0ZXN0L25vZGUtZGlzdC5qc1wiLFxuXHRcdFwidGVzdC1icm93c2VyXCI6IFwid2VicGFjay1kZXYtc2VydmVyIC0tY29uZmlnIHdlYnBhY2suY29uZmlnLnRlc3QtYnJvd3Nlci5qcyAtLXByb2dyZXNzIC0taG90IC0tb3BlbiAtLXBvcnQgMzAxMFwiLFxuXHRcdFwiYmVuY2hcIjogXCJub2RlIHRlc3QvYmVuY2gvbm9kZS5qc1wiLFxuXHRcdFwiYmVuY2gtYnJvd3NlclwiOiBcIndlYnBhY2stZGV2LXNlcnZlciAtLWNvbmZpZyB3ZWJwYWNrLmNvbmZpZy5iZW5jaC1icm93c2VyLmpzIC0tcHJvZ3Jlc3MgLS1ob3QgLS1vcGVuIC0tcG9ydCAzMDExXCIsXG5cdFx0XCJ0ZXN0LWZwNjRcIjogXCIoY2QgdGVzdC9mcDY0LXRlc3QgJiYgd2VicGFjay1kZXYtc2VydmVyIC0tY29uZmlnIHdlYnBhY2suY29uZmlnLnRlc3QtZnA2NC5qcyAtLXByb2dyZXNzIC0taG90IC0tb3BlbilcIixcblx0XHRcInRlc3QtcmVuZGVyaW5nXCI6IFwiKGNkIHRlc3QvcmVuZGVyaW5nLXRlc3QgJiYgd2VicGFjay1kZXYtc2VydmVyIC0tY29uZmlnIHdlYnBhY2suY29uZmlnLnRlc3QtcmVuZGVyaW5nLmpzIC0tcHJvZ3Jlc3MgLS1ob3QgLS1vcGVuKVwiXG5cdH0sXG5cdFwiZGVwZW5kZW5jaWVzXCI6IHtcblx0XHRcImQzLWhleGJpblwiOiBcIl4wLjIuMVwiLFxuXHRcdFwiZWFyY3V0XCI6IFwiXjIuMC42XCIsXG5cdFx0XCJnbC1tYXRyaXhcIjogXCJeMi4zLjJcIixcblx0XHRcImxvZGFzaC5mbGF0dGVuZGVlcFwiOiBcIl40LjQuMFwiXG5cdH0sXG5cdFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcblx0XHRcImJhYmVsLWNsaVwiOiBcIl42LjIyLjJcIixcblx0XHRcImJhYmVsLWNvcmVcIjogXCJeNi4yMi4xXCIsXG5cdFx0XCJiYWJlbC1sb2FkZXJcIjogXCJeNi4yLjEwXCIsXG5cdFx0XCJiYWJlbC1wbHVnaW4tc3RhdGljLWZzXCI6IFwiXjEuMS4wXCIsXG5cdFx0XCJiYWJlbC1wbHVnaW4tdHJhbnNmb3JtLWVzMjAxNS1tb2R1bGVzLWNvbW1vbmpzXCI6IFwiXjYuMjIuMFwiLFxuXHRcdFwiYmFiZWwtcG9seWZpbGxcIjogXCJeNi4yMC4wXCIsXG5cdFx0XCJiYWJlbC1wcmVzZXQtZXMyMDE1XCI6IFwiXjYuNC4zXCIsXG5cdFx0XCJiZW5jaG1hcmtcIjogXCJeMi4xLjNcIixcblx0XHRcImJyZnMtYmFiZWxcIjogXCJeMS4wLjBcIixcblx0XHRcImJ1YmxlXCI6IFwiXjAuMTUuMVwiLFxuXHRcdFwiYnVibGUtbG9hZGVyXCI6IFwiXjAuNC4wXCIsXG5cdFx0XCJjb2xvcmJyZXdlclwiOiBcIl4xLjAuMFwiLFxuXHRcdFwiZXNsaW50XCI6IFwiXjMuMC4wXCIsXG5cdFx0XCJlc2xpbnQtY29uZmlnLXViZXItZXMyMDE1XCI6IFwiXjMuMC4wXCIsXG5cdFx0XCJlc2xpbnQtY29uZmlnLXViZXItanN4XCI6IFwiXjMuMC4wXCIsXG5cdFx0XCJlc2xpbnQtcGx1Z2luLXJlYWN0XCI6IFwifjYuNy4wXCIsXG5cdFx0XCJmYXVjZXRcIjogXCIwLjAuMVwiLFxuXHRcdFwiZmlsZS1sb2FkZXJcIjogXCJeMC4xMC4xXCIsXG5cdFx0XCJnbFwiOiBcIl40LjAuM1wiLFxuXHRcdFwiaW1tdXRhYmxlXCI6IFwiXjMuOC4xXCIsXG5cdFx0XCJsdW1hLmdsXCI6IFwiMy4wLjAtYmV0YS4xMVwiLFxuXHRcdFwibW9kdWxlLWFsaWFzXCI6IFwiXjIuMC4wXCIsXG5cdFx0XCJwcmUtY29tbWl0XCI6IFwiXjEuMi4yXCIsXG5cdFx0XCJyYXctbG9hZGVyXCI6IFwiXjAuNS4xXCIsXG5cdFx0XCJyZWFjdFwiOiBcIl4xNS40LjBcIixcblx0XHRcInJlYWN0LWFkZG9ucy10ZXN0LXV0aWxzXCI6IFwiXjE1LjQuMlwiLFxuXHRcdFwicmVhY3QtZG9tXCI6IFwiXjE1LjQuMFwiLFxuXHRcdFwicmVpZnlcIjogXCJeMC40LjRcIixcblx0XHRcInRhcC1icm93c2VyLWNvbG9yXCI6IFwiXjAuMS4yXCIsXG5cdFx0XCJ0YXBlXCI6IFwiXjQuNS4xXCIsXG5cdFx0XCJ0YXBlLWNhdGNoXCI6IFwiXjEuMC40XCIsXG5cdFx0XCJ0cmFuc2Zvcm0tbG9hZGVyXCI6IFwiXjAuMi4zXCIsXG5cdFx0XCJ1Z2xpZnktanNcIjogXCJeMi42LjFcIixcblx0XHRcInVybC1sb2FkZXJcIjogXCJeMC41LjdcIixcblx0XHRcIndlYnBhY2tcIjogXCJeMi4yLjBcIixcblx0XHRcIndlYnBhY2stZGV2LXNlcnZlclwiOiBcIl4yLjIuMFwiXG5cdH0sXG5cdFwicGVlckRlcGVuZGVuY2llc1wiOiB7XG5cdFx0XCJsdW1hLmdsXCI6IFwiXjMuMC4wLWJldGEuMTFcIixcblx0XHRcInJlYWN0XCI6IFwiMC4xNC54IC0gMTUueFwiLFxuXHRcdFwicmVhY3QtZG9tXCI6IFwiMC4xNC54IC0gMTUueFwiXG5cdH0sXG5cdFwiYmFiZWxcIjoge1xuXHRcdFwicHJlc2V0c1wiOiBbXG5cdFx0XHRbXG5cdFx0XHRcdFwiZXMyMDE1XCIsXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRcIm1vZHVsZXNcIjogZmFsc2Vcblx0XHRcdFx0fVxuXHRcdFx0XVxuXHRcdF1cblx0fVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhY2thZ2UuanNvblxuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 48 */
/* exports provided: default */
/* exports used: default */
/*!***************************************************************************************!*\
  !*** ./src/experimental/effects/reflection-effect/reflection-effect-fragment.glsl.js ***!
  \***************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME reflection-effect-fs\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform sampler2D reflectionTexture;\nuniform int reflectionTextureWidth;\nuniform int reflectionTextureHeight;\n\nuniform float reflectivity;\nuniform float blur;\n\n\nvarying vec2 uv;\n\n#define KERNEL_SIZE 7\n\n/*\n * Samples from tex with a gaussian-shaped patch, centered at uv and\n * with standard deviation sigma.  The size of the texture in\n * pixels must be specified by dim\n */\nvec4 sample_gaussian(sampler2D tex, vec2 dim, vec2 uv, float sigma) {\n  if (sigma == 0.0) {\n    return texture2D(tex, uv);\n  }\n\n  vec2 delta = 1.0 / dim;\n  vec2 top_left = uv - delta * float(KERNEL_SIZE+1) / 2.0;\n\n  vec4 color = vec4(0);\n  float sum = 0.0;\n  for (int i = 0; i <  KERNEL_SIZE; ++i) {\n    for (int j = 0; j < KERNEL_SIZE; ++j) {\n      vec2 uv2 = top_left + vec2(i, j) * delta;\n      float d = length((uv2 - uv) * dim);\n      float f = exp(-(d*d) / (2.0*sigma * sigma));\n      color += f * texture2D(tex, uv2);\n      sum += f;\n    }\n  }\n  return color / sum;\n}\n\nvoid main(void) {\n  //map blur in [0, 1] to sigma in [0, inf]\n  //alpha will determine the \"steepness\" of our curve.\n  //this was picked just to make the scale feel \"natural\"\n  //if our image is 1000 pixels wide, a blur of 0.5 should correspond\n  //to a sigma of 1 pixels\n  float alpha = 1000.0;\n  float sigma = blur / (alpha * (1.0 - blur));\n  //let this be our standard deviation in terms of screen-widths.\n  //rewrite this in terms of pixels.\n  sigma *= float(reflectionTextureWidth);\n\n\n  gl_FragColor = sample_gaussian(reflectionTexture, vec2(reflectionTextureWidth,\n    reflectionTextureHeight), vec2(uv.x, 1. - uv.y), sigma);\n  //because our canvas expects alphas to be pre-multiplied, we multiply by whole\n  //color vector by reflectivity, not just the alpha channel\n  gl_FragColor *= reflectivity;\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZXhwZXJpbWVudGFsL2VmZmVjdHMvcmVmbGVjdGlvbi1lZmZlY3QvcmVmbGVjdGlvbi1lZmZlY3QtZnJhZ21lbnQuZ2xzbC5qcz9lY2FiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmV4cG9ydCBkZWZhdWx0IGBcXFxuI2RlZmluZSBTSEFERVJfTkFNRSByZWZsZWN0aW9uLWVmZmVjdC1mc1xuXG4jaWZkZWYgR0xfRVNcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiNlbmRpZlxuXG51bmlmb3JtIHNhbXBsZXIyRCByZWZsZWN0aW9uVGV4dHVyZTtcbnVuaWZvcm0gaW50IHJlZmxlY3Rpb25UZXh0dXJlV2lkdGg7XG51bmlmb3JtIGludCByZWZsZWN0aW9uVGV4dHVyZUhlaWdodDtcblxudW5pZm9ybSBmbG9hdCByZWZsZWN0aXZpdHk7XG51bmlmb3JtIGZsb2F0IGJsdXI7XG5cblxudmFyeWluZyB2ZWMyIHV2O1xuXG4jZGVmaW5lIEtFUk5FTF9TSVpFIDdcblxuLypcbiAqIFNhbXBsZXMgZnJvbSB0ZXggd2l0aCBhIGdhdXNzaWFuLXNoYXBlZCBwYXRjaCwgY2VudGVyZWQgYXQgdXYgYW5kXG4gKiB3aXRoIHN0YW5kYXJkIGRldmlhdGlvbiBzaWdtYS4gIFRoZSBzaXplIG9mIHRoZSB0ZXh0dXJlIGluXG4gKiBwaXhlbHMgbXVzdCBiZSBzcGVjaWZpZWQgYnkgZGltXG4gKi9cbnZlYzQgc2FtcGxlX2dhdXNzaWFuKHNhbXBsZXIyRCB0ZXgsIHZlYzIgZGltLCB2ZWMyIHV2LCBmbG9hdCBzaWdtYSkge1xuICBpZiAoc2lnbWEgPT0gMC4wKSB7XG4gICAgcmV0dXJuIHRleHR1cmUyRCh0ZXgsIHV2KTtcbiAgfVxuXG4gIHZlYzIgZGVsdGEgPSAxLjAgLyBkaW07XG4gIHZlYzIgdG9wX2xlZnQgPSB1diAtIGRlbHRhICogZmxvYXQoS0VSTkVMX1NJWkUrMSkgLyAyLjA7XG5cbiAgdmVjNCBjb2xvciA9IHZlYzQoMCk7XG4gIGZsb2F0IHN1bSA9IDAuMDtcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCAgS0VSTkVMX1NJWkU7ICsraSkge1xuICAgIGZvciAoaW50IGogPSAwOyBqIDwgS0VSTkVMX1NJWkU7ICsraikge1xuICAgICAgdmVjMiB1djIgPSB0b3BfbGVmdCArIHZlYzIoaSwgaikgKiBkZWx0YTtcbiAgICAgIGZsb2F0IGQgPSBsZW5ndGgoKHV2MiAtIHV2KSAqIGRpbSk7XG4gICAgICBmbG9hdCBmID0gZXhwKC0oZCpkKSAvICgyLjAqc2lnbWEgKiBzaWdtYSkpO1xuICAgICAgY29sb3IgKz0gZiAqIHRleHR1cmUyRCh0ZXgsIHV2Mik7XG4gICAgICBzdW0gKz0gZjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbG9yIC8gc3VtO1xufVxuXG52b2lkIG1haW4odm9pZCkge1xuICAvL21hcCBibHVyIGluIFswLCAxXSB0byBzaWdtYSBpbiBbMCwgaW5mXVxuICAvL2FscGhhIHdpbGwgZGV0ZXJtaW5lIHRoZSBcInN0ZWVwbmVzc1wiIG9mIG91ciBjdXJ2ZS5cbiAgLy90aGlzIHdhcyBwaWNrZWQganVzdCB0byBtYWtlIHRoZSBzY2FsZSBmZWVsIFwibmF0dXJhbFwiXG4gIC8vaWYgb3VyIGltYWdlIGlzIDEwMDAgcGl4ZWxzIHdpZGUsIGEgYmx1ciBvZiAwLjUgc2hvdWxkIGNvcnJlc3BvbmRcbiAgLy90byBhIHNpZ21hIG9mIDEgcGl4ZWxzXG4gIGZsb2F0IGFscGhhID0gMTAwMC4wO1xuICBmbG9hdCBzaWdtYSA9IGJsdXIgLyAoYWxwaGEgKiAoMS4wIC0gYmx1cikpO1xuICAvL2xldCB0aGlzIGJlIG91ciBzdGFuZGFyZCBkZXZpYXRpb24gaW4gdGVybXMgb2Ygc2NyZWVuLXdpZHRocy5cbiAgLy9yZXdyaXRlIHRoaXMgaW4gdGVybXMgb2YgcGl4ZWxzLlxuICBzaWdtYSAqPSBmbG9hdChyZWZsZWN0aW9uVGV4dHVyZVdpZHRoKTtcblxuXG4gIGdsX0ZyYWdDb2xvciA9IHNhbXBsZV9nYXVzc2lhbihyZWZsZWN0aW9uVGV4dHVyZSwgdmVjMihyZWZsZWN0aW9uVGV4dHVyZVdpZHRoLFxuICAgIHJlZmxlY3Rpb25UZXh0dXJlSGVpZ2h0KSwgdmVjMih1di54LCAxLiAtIHV2LnkpLCBzaWdtYSk7XG4gIC8vYmVjYXVzZSBvdXIgY2FudmFzIGV4cGVjdHMgYWxwaGFzIHRvIGJlIHByZS1tdWx0aXBsaWVkLCB3ZSBtdWx0aXBseSBieSB3aG9sZVxuICAvL2NvbG9yIHZlY3RvciBieSByZWZsZWN0aXZpdHksIG5vdCBqdXN0IHRoZSBhbHBoYSBjaGFubmVsXG4gIGdsX0ZyYWdDb2xvciAqPSByZWZsZWN0aXZpdHk7XG59XG5gO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZXhwZXJpbWVudGFsL2VmZmVjdHMvcmVmbGVjdGlvbi1lZmZlY3QvcmVmbGVjdGlvbi1lZmZlY3QtZnJhZ21lbnQuZ2xzbC5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 49 */
/* exports provided: default */
/* exports used: default */
/*!*************************************************************************************!*\
  !*** ./src/experimental/effects/reflection-effect/reflection-effect-vertex.glsl.js ***!
  \*************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME reflection-effect-vs\n\nattribute vec3 vertices;\n\nvarying vec2 uv;\n\nvoid main(void) {\n  uv = vertices.xy;\n  gl_Position = vec4(2. * vertices.xy - vec2(1., 1.), 1., 1.);\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZXhwZXJpbWVudGFsL2VmZmVjdHMvcmVmbGVjdGlvbi1lZmZlY3QvcmVmbGVjdGlvbi1lZmZlY3QtdmVydGV4Lmdsc2wuanM/ZjhiNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbiNkZWZpbmUgU0hBREVSX05BTUUgcmVmbGVjdGlvbi1lZmZlY3QtdnNcblxuYXR0cmlidXRlIHZlYzMgdmVydGljZXM7XG5cbnZhcnlpbmcgdmVjMiB1djtcblxudm9pZCBtYWluKHZvaWQpIHtcbiAgdXYgPSB2ZXJ0aWNlcy54eTtcbiAgZ2xfUG9zaXRpb24gPSB2ZWM0KDIuICogdmVydGljZXMueHkgLSB2ZWMyKDEuLCAxLiksIDEuLCAxLik7XG59XG5gO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZXhwZXJpbWVudGFsL2VmZmVjdHMvcmVmbGVjdGlvbi1lZmZlY3QvcmVmbGVjdGlvbi1lZmZlY3QtdmVydGV4Lmdsc2wuanNcbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 50 */
/* exports provided: default */
/* exports used: default */
/*!*************************************************************************!*\
  !*** ./src/experimental/effects/reflection-effect/reflection-effect.js ***!
  \*************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl__ = __webpack_require__(/*! luma.gl */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib__ = __webpack_require__(/*! ../../lib */ 9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_viewports__ = __webpack_require__(/*! ../../../lib/viewports */ 16);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__reflection_effect_vertex_glsl__ = __webpack_require__(/*! ./reflection-effect-vertex.glsl */ 49);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__reflection_effect_fragment_glsl__ = __webpack_require__(/*! ./reflection-effect-fragment.glsl */ 48);\n/* global window */\n\n\n\n\n\n\n\n\nclass ReflectionEffect extends __WEBPACK_IMPORTED_MODULE_2__lib__[\"b\" /* Effect */] {\n\n  /**\n   * @classdesc\n   * ReflectionEffect\n   *\n   * @class\n   * @param reflectivity How visible reflections should be over the map, between 0 and 1\n   * @param blur how blurry the reflection should be, between 0 and 1\n   */\n\n  constructor(reflectivity = 0.5, blur = 0.5) {\n    super();\n    this.reflectivity = reflectivity;\n    this.blur = blur;\n    this.framebuffer = null;\n    this.setNeedsRedraw();\n  }\n\n  getShaders() {\n    return {\n      vs: __WEBPACK_IMPORTED_MODULE_4__reflection_effect_vertex_glsl__[\"a\" /* default */],\n      fs: __WEBPACK_IMPORTED_MODULE_5__reflection_effect_fragment_glsl__[\"a\" /* default */]\n    };\n  }\n\n  initialize({gl, layerManager}) {\n    const shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"a\" /* assembleShaders */])(gl, this.getShaders());\n\n    this.unitQuad = new __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"Model\"]({\n      gl,\n      id: 'reflection-effect',\n      vs: shaders.vs,\n      fs: shaders.fs,\n      geometry: new __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"Geometry\"]({\n        drawMode: __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].TRIANGLE_FAN,\n        vertices: new Float32Array([0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0])\n      })\n    });\n    this.framebuffer = new __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"Framebuffer\"](gl, {depth: true});\n\n  }\n\n  preDraw({gl, layerManager}) {\n    const {viewport} = layerManager.context;\n    /*\n     * the renderer already has a reference to this, but we don't have a reference to the renderer.\n     * when we refactor the camera code, we should make sure we get a reference to the renderer so\n     * that we can keep this in one place.\n     */\n    const dpi = (typeof window !== 'undefined' && window.devicePixelRatio) || 1;\n    this.framebuffer.resize({width: dpi * viewport.width, height: dpi * viewport.height});\n    const pitch = viewport.pitch;\n    this.framebuffer.bind();\n    /* this is a huge hack around the existing viewport class.\n     * TODO in the future, once we implement bona-fide cameras, we really need to fix this.\n     */\n    layerManager.setViewport(\n      new __WEBPACK_IMPORTED_MODULE_3__lib_viewports__[\"a\" /* WebMercatorViewport */](Object.assign({}, viewport, {pitch: -180 - pitch}))\n    );\n    gl.clear(__WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].COLOR_BUFFER_BIT | __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].DEPTH_BUFFER_BIT);\n\n    layerManager.drawLayers({pass: 'reflection'});\n    layerManager.setViewport(viewport);\n    this.framebuffer.unbind();\n  }\n\n  draw({gl, layerManager}) {\n    /*\n     * Render our unit quad.\n     * This will cover the entire screen, but will lie behind all other geometry.\n     * This quad will sample the previously generated reflection texture\n     * in order to create the reflection effect\n     */\n    this.unitQuad.render({\n      reflectionTexture: this.framebuffer.texture,\n      reflectionTextureWidth: this.framebuffer.width,\n      reflectionTextureHeight: this.framebuffer.height,\n      reflectivity: this.reflectivity,\n      blur: this.blur\n    });\n  }\n\n  finalize({gl, layerManager}) {\n    /* TODO: Free resources? */\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = ReflectionEffect;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZXhwZXJpbWVudGFsL2VmZmVjdHMvcmVmbGVjdGlvbi1lZmZlY3QvcmVmbGVjdGlvbi1lZmZlY3QuanM/ZTcwNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQge0dMLCBGcmFtZWJ1ZmZlciwgTW9kZWwsIEdlb21ldHJ5fSBmcm9tICdsdW1hLmdsJztcbmltcG9ydCB7YXNzZW1ibGVTaGFkZXJzfSBmcm9tICcuLi8uLi8uLi9zaGFkZXItdXRpbHMnO1xuaW1wb3J0IHtFZmZlY3R9IGZyb20gJy4uLy4uL2xpYic7XG5pbXBvcnQge1dlYk1lcmNhdG9yVmlld3BvcnR9IGZyb20gJy4uLy4uLy4uL2xpYi92aWV3cG9ydHMnO1xuXG5pbXBvcnQgcmVmbGVjdGlvblZlcnRleCBmcm9tICcuL3JlZmxlY3Rpb24tZWZmZWN0LXZlcnRleC5nbHNsJztcbmltcG9ydCByZWZsZWN0aW9uRnJhZ21lbnQgZnJvbSAnLi9yZWZsZWN0aW9uLWVmZmVjdC1mcmFnbWVudC5nbHNsJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVmbGVjdGlvbkVmZmVjdCBleHRlbmRzIEVmZmVjdCB7XG5cbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogUmVmbGVjdGlvbkVmZmVjdFxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHJlZmxlY3Rpdml0eSBIb3cgdmlzaWJsZSByZWZsZWN0aW9ucyBzaG91bGQgYmUgb3ZlciB0aGUgbWFwLCBiZXR3ZWVuIDAgYW5kIDFcbiAgICogQHBhcmFtIGJsdXIgaG93IGJsdXJyeSB0aGUgcmVmbGVjdGlvbiBzaG91bGQgYmUsIGJldHdlZW4gMCBhbmQgMVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcihyZWZsZWN0aXZpdHkgPSAwLjUsIGJsdXIgPSAwLjUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucmVmbGVjdGl2aXR5ID0gcmVmbGVjdGl2aXR5O1xuICAgIHRoaXMuYmx1ciA9IGJsdXI7XG4gICAgdGhpcy5mcmFtZWJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5zZXROZWVkc1JlZHJhdygpO1xuICB9XG5cbiAgZ2V0U2hhZGVycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdnM6IHJlZmxlY3Rpb25WZXJ0ZXgsXG4gICAgICBmczogcmVmbGVjdGlvbkZyYWdtZW50XG4gICAgfTtcbiAgfVxuXG4gIGluaXRpYWxpemUoe2dsLCBsYXllck1hbmFnZXJ9KSB7XG4gICAgY29uc3Qgc2hhZGVycyA9IGFzc2VtYmxlU2hhZGVycyhnbCwgdGhpcy5nZXRTaGFkZXJzKCkpO1xuXG4gICAgdGhpcy51bml0UXVhZCA9IG5ldyBNb2RlbCh7XG4gICAgICBnbCxcbiAgICAgIGlkOiAncmVmbGVjdGlvbi1lZmZlY3QnLFxuICAgICAgdnM6IHNoYWRlcnMudnMsXG4gICAgICBmczogc2hhZGVycy5mcyxcbiAgICAgIGdlb21ldHJ5OiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICBkcmF3TW9kZTogR0wuVFJJQU5HTEVfRkFOLFxuICAgICAgICB2ZXJ0aWNlczogbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMCwgMSwgMCwgMCwgMSwgMSwgMCwgMCwgMSwgMF0pXG4gICAgICB9KVxuICAgIH0pO1xuICAgIHRoaXMuZnJhbWVidWZmZXIgPSBuZXcgRnJhbWVidWZmZXIoZ2wsIHtkZXB0aDogdHJ1ZX0pO1xuXG4gIH1cblxuICBwcmVEcmF3KHtnbCwgbGF5ZXJNYW5hZ2VyfSkge1xuICAgIGNvbnN0IHt2aWV3cG9ydH0gPSBsYXllck1hbmFnZXIuY29udGV4dDtcbiAgICAvKlxuICAgICAqIHRoZSByZW5kZXJlciBhbHJlYWR5IGhhcyBhIHJlZmVyZW5jZSB0byB0aGlzLCBidXQgd2UgZG9uJ3QgaGF2ZSBhIHJlZmVyZW5jZSB0byB0aGUgcmVuZGVyZXIuXG4gICAgICogd2hlbiB3ZSByZWZhY3RvciB0aGUgY2FtZXJhIGNvZGUsIHdlIHNob3VsZCBtYWtlIHN1cmUgd2UgZ2V0IGEgcmVmZXJlbmNlIHRvIHRoZSByZW5kZXJlciBzb1xuICAgICAqIHRoYXQgd2UgY2FuIGtlZXAgdGhpcyBpbiBvbmUgcGxhY2UuXG4gICAgICovXG4gICAgY29uc3QgZHBpID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSB8fCAxO1xuICAgIHRoaXMuZnJhbWVidWZmZXIucmVzaXplKHt3aWR0aDogZHBpICogdmlld3BvcnQud2lkdGgsIGhlaWdodDogZHBpICogdmlld3BvcnQuaGVpZ2h0fSk7XG4gICAgY29uc3QgcGl0Y2ggPSB2aWV3cG9ydC5waXRjaDtcbiAgICB0aGlzLmZyYW1lYnVmZmVyLmJpbmQoKTtcbiAgICAvKiB0aGlzIGlzIGEgaHVnZSBoYWNrIGFyb3VuZCB0aGUgZXhpc3Rpbmcgdmlld3BvcnQgY2xhc3MuXG4gICAgICogVE9ETyBpbiB0aGUgZnV0dXJlLCBvbmNlIHdlIGltcGxlbWVudCBib25hLWZpZGUgY2FtZXJhcywgd2UgcmVhbGx5IG5lZWQgdG8gZml4IHRoaXMuXG4gICAgICovXG4gICAgbGF5ZXJNYW5hZ2VyLnNldFZpZXdwb3J0KFxuICAgICAgbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQoT2JqZWN0LmFzc2lnbih7fSwgdmlld3BvcnQsIHtwaXRjaDogLTE4MCAtIHBpdGNofSkpXG4gICAgKTtcbiAgICBnbC5jbGVhcihHTC5DT0xPUl9CVUZGRVJfQklUIHwgR0wuREVQVEhfQlVGRkVSX0JJVCk7XG5cbiAgICBsYXllck1hbmFnZXIuZHJhd0xheWVycyh7cGFzczogJ3JlZmxlY3Rpb24nfSk7XG4gICAgbGF5ZXJNYW5hZ2VyLnNldFZpZXdwb3J0KHZpZXdwb3J0KTtcbiAgICB0aGlzLmZyYW1lYnVmZmVyLnVuYmluZCgpO1xuICB9XG5cbiAgZHJhdyh7Z2wsIGxheWVyTWFuYWdlcn0pIHtcbiAgICAvKlxuICAgICAqIFJlbmRlciBvdXIgdW5pdCBxdWFkLlxuICAgICAqIFRoaXMgd2lsbCBjb3ZlciB0aGUgZW50aXJlIHNjcmVlbiwgYnV0IHdpbGwgbGllIGJlaGluZCBhbGwgb3RoZXIgZ2VvbWV0cnkuXG4gICAgICogVGhpcyBxdWFkIHdpbGwgc2FtcGxlIHRoZSBwcmV2aW91c2x5IGdlbmVyYXRlZCByZWZsZWN0aW9uIHRleHR1cmVcbiAgICAgKiBpbiBvcmRlciB0byBjcmVhdGUgdGhlIHJlZmxlY3Rpb24gZWZmZWN0XG4gICAgICovXG4gICAgdGhpcy51bml0UXVhZC5yZW5kZXIoe1xuICAgICAgcmVmbGVjdGlvblRleHR1cmU6IHRoaXMuZnJhbWVidWZmZXIudGV4dHVyZSxcbiAgICAgIHJlZmxlY3Rpb25UZXh0dXJlV2lkdGg6IHRoaXMuZnJhbWVidWZmZXIud2lkdGgsXG4gICAgICByZWZsZWN0aW9uVGV4dHVyZUhlaWdodDogdGhpcy5mcmFtZWJ1ZmZlci5oZWlnaHQsXG4gICAgICByZWZsZWN0aXZpdHk6IHRoaXMucmVmbGVjdGl2aXR5LFxuICAgICAgYmx1cjogdGhpcy5ibHVyXG4gICAgfSk7XG4gIH1cblxuICBmaW5hbGl6ZSh7Z2wsIGxheWVyTWFuYWdlcn0pIHtcbiAgICAvKiBUT0RPOiBGcmVlIHJlc291cmNlcz8gKi9cbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZXhwZXJpbWVudGFsL2VmZmVjdHMvcmVmbGVjdGlvbi1lZmZlY3QvcmVmbGVjdGlvbi1lZmZlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 51 */
/* exports provided: EffectManager, Effect, ReflectionEffect */
/* exports used: Effect, EffectManager */
/*!***********************************!*\
  !*** ./src/experimental/index.js ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ./lib */ 9);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return __WEBPACK_IMPORTED_MODULE_0__lib__[\"a\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_0__lib__[\"b\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__effects_reflection_effect__ = __webpack_require__(/*! ./effects/reflection-effect */ 17);\n/* unused harmony reexport ReflectionEffect */\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZXhwZXJpbWVudGFsL2luZGV4LmpzP2M0M2YiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHtFZmZlY3RNYW5hZ2VyLCBFZmZlY3R9IGZyb20gJy4vbGliJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBSZWZsZWN0aW9uRWZmZWN0fSBmcm9tICcuL2VmZmVjdHMvcmVmbGVjdGlvbi1lZmZlY3QnO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZXhwZXJpbWVudGFsL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 52 */
/* exports provided: default */
/* exports used: default */
/*!************************************************!*\
  !*** ./src/experimental/lib/effect-manager.js ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* eslint-disable no-try-catch */\n\nclass EffectManager {\n  constructor({gl, layerManager}) {\n    this.gl = gl;\n    this.layerManager = layerManager;\n    this._effects = [];\n  }\n\n  /**\n   * Adds an effect to be managed.  That effect's initialize function will\n   * be called, and the effect's preDraw and draw callbacks will be\n   * called at the appropriate times in the render loop\n   * @param {Effect} effect - the effect to be added\n   */\n  addEffect(effect) {\n    this._effects.push(effect);\n    this._sortEffects();\n    effect.initialize({gl: this.gl, layerManager: this.layerManager});\n  }\n\n  /**\n   * Removes an effect that is already being managed.  That effect's\n   * finalize function will be called, and its callbacks will no longer\n   * be envoked in the render loop\n   * @param {Effect} effect - the effect to be removed\n   * @return {bool} - True if the effect was already being managed, and\n   * thus successfully removed; false otherwise\n   */\n  removeEffect(effect) {\n    const i = this._effects.indexOf(effect);\n    if (i >= 0) {\n      effect.finalize({gl: this.gl, layerManager: this.layerManager});\n      this._effects.splice(i, 1);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Envoke the preDraw callback of all managed events, in order of\n   * decreasing priority\n   */\n  preDraw() {\n    for (const effect of this._effects) {\n      if (effect.needsRedraw) {\n        effect.preDraw({gl: this.gl, layerManager: this.layerManager});\n      }\n    }\n  }\n\n  /**\n   * Envoke the draw callback of all managed events, in order of\n   * decreasing priority\n   */\n  draw() {\n    for (const effect of this._effects) {\n      if (effect.needsRedraw) {\n        effect.draw({gl: this.gl, layerManager: this.layerManager});\n      }\n    }\n  }\n\n  _sortEffects() {\n    this._effects.sort((a, b) => {\n      if (a.priority > b.priority) {\n        return -1;\n      } else if (a.priority < b.priority) {\n        return 1;\n      }\n      return a.count - b.count;\n    });\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = EffectManager;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZXhwZXJpbWVudGFsL2xpYi9lZmZlY3QtbWFuYWdlci5qcz9jMmFiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLXRyeS1jYXRjaCAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFZmZlY3RNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3Ioe2dsLCBsYXllck1hbmFnZXJ9KSB7XG4gICAgdGhpcy5nbCA9IGdsO1xuICAgIHRoaXMubGF5ZXJNYW5hZ2VyID0gbGF5ZXJNYW5hZ2VyO1xuICAgIHRoaXMuX2VmZmVjdHMgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGVmZmVjdCB0byBiZSBtYW5hZ2VkLiAgVGhhdCBlZmZlY3QncyBpbml0aWFsaXplIGZ1bmN0aW9uIHdpbGxcbiAgICogYmUgY2FsbGVkLCBhbmQgdGhlIGVmZmVjdCdzIHByZURyYXcgYW5kIGRyYXcgY2FsbGJhY2tzIHdpbGwgYmVcbiAgICogY2FsbGVkIGF0IHRoZSBhcHByb3ByaWF0ZSB0aW1lcyBpbiB0aGUgcmVuZGVyIGxvb3BcbiAgICogQHBhcmFtIHtFZmZlY3R9IGVmZmVjdCAtIHRoZSBlZmZlY3QgdG8gYmUgYWRkZWRcbiAgICovXG4gIGFkZEVmZmVjdChlZmZlY3QpIHtcbiAgICB0aGlzLl9lZmZlY3RzLnB1c2goZWZmZWN0KTtcbiAgICB0aGlzLl9zb3J0RWZmZWN0cygpO1xuICAgIGVmZmVjdC5pbml0aWFsaXplKHtnbDogdGhpcy5nbCwgbGF5ZXJNYW5hZ2VyOiB0aGlzLmxheWVyTWFuYWdlcn0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gZWZmZWN0IHRoYXQgaXMgYWxyZWFkeSBiZWluZyBtYW5hZ2VkLiAgVGhhdCBlZmZlY3Qnc1xuICAgKiBmaW5hbGl6ZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCwgYW5kIGl0cyBjYWxsYmFja3Mgd2lsbCBubyBsb25nZXJcbiAgICogYmUgZW52b2tlZCBpbiB0aGUgcmVuZGVyIGxvb3BcbiAgICogQHBhcmFtIHtFZmZlY3R9IGVmZmVjdCAtIHRoZSBlZmZlY3QgdG8gYmUgcmVtb3ZlZFxuICAgKiBAcmV0dXJuIHtib29sfSAtIFRydWUgaWYgdGhlIGVmZmVjdCB3YXMgYWxyZWFkeSBiZWluZyBtYW5hZ2VkLCBhbmRcbiAgICogdGh1cyBzdWNjZXNzZnVsbHkgcmVtb3ZlZDsgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICByZW1vdmVFZmZlY3QoZWZmZWN0KSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX2VmZmVjdHMuaW5kZXhPZihlZmZlY3QpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgIGVmZmVjdC5maW5hbGl6ZSh7Z2w6IHRoaXMuZ2wsIGxheWVyTWFuYWdlcjogdGhpcy5sYXllck1hbmFnZXJ9KTtcbiAgICAgIHRoaXMuX2VmZmVjdHMuc3BsaWNlKGksIDEpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnZva2UgdGhlIHByZURyYXcgY2FsbGJhY2sgb2YgYWxsIG1hbmFnZWQgZXZlbnRzLCBpbiBvcmRlciBvZlxuICAgKiBkZWNyZWFzaW5nIHByaW9yaXR5XG4gICAqL1xuICBwcmVEcmF3KCkge1xuICAgIGZvciAoY29uc3QgZWZmZWN0IG9mIHRoaXMuX2VmZmVjdHMpIHtcbiAgICAgIGlmIChlZmZlY3QubmVlZHNSZWRyYXcpIHtcbiAgICAgICAgZWZmZWN0LnByZURyYXcoe2dsOiB0aGlzLmdsLCBsYXllck1hbmFnZXI6IHRoaXMubGF5ZXJNYW5hZ2VyfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVudm9rZSB0aGUgZHJhdyBjYWxsYmFjayBvZiBhbGwgbWFuYWdlZCBldmVudHMsIGluIG9yZGVyIG9mXG4gICAqIGRlY3JlYXNpbmcgcHJpb3JpdHlcbiAgICovXG4gIGRyYXcoKSB7XG4gICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgdGhpcy5fZWZmZWN0cykge1xuICAgICAgaWYgKGVmZmVjdC5uZWVkc1JlZHJhdykge1xuICAgICAgICBlZmZlY3QuZHJhdyh7Z2w6IHRoaXMuZ2wsIGxheWVyTWFuYWdlcjogdGhpcy5sYXllck1hbmFnZXJ9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfc29ydEVmZmVjdHMoKSB7XG4gICAgdGhpcy5fZWZmZWN0cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBpZiAoYS5wcmlvcml0eSA+IGIucHJpb3JpdHkpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIGlmIChhLnByaW9yaXR5IDwgYi5wcmlvcml0eSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhLmNvdW50IC0gYi5jb3VudDtcbiAgICB9KTtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZXhwZXJpbWVudGFsL2xpYi9lZmZlY3QtbWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 53 */
/* exports provided: default */
/* exports used: default */
/*!****************************************!*\
  !*** ./src/experimental/lib/effect.js ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("let counter = 0;\n\nclass Effect {\n\n  constructor() {\n    this.count = counter++;\n    this.visible = true;\n    this.priority = 0;\n    this.needsRedraw = false;\n  }\n\n  /**\n   * subclasses should override to set up any resources needed\n   */\n  initialize({gl, layerManager}) {\n  }\n  /**\n   * and subclasses should free those resources here\n   */\n  finalize({gl, layerManager}) {\n  }\n  /**\n   * override for a callback immediately before drawing each frame\n   */\n  preDraw({gl, layerManager}) {\n  }\n  /**\n   * override for a callback immediately after drawing a frame's layers\n   */\n  draw({gl, layerManager}) {\n  }\n\n  setNeedsRedraw(redraw = true) {\n    this.needsRedraw = redraw;\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = Effect;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZXhwZXJpbWVudGFsL2xpYi9lZmZlY3QuanM/ODA0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgY291bnRlciA9IDA7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVmZmVjdCB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jb3VudCA9IGNvdW50ZXIrKztcbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgIHRoaXMucHJpb3JpdHkgPSAwO1xuICAgIHRoaXMubmVlZHNSZWRyYXcgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0byBzZXQgdXAgYW55IHJlc291cmNlcyBuZWVkZWRcbiAgICovXG4gIGluaXRpYWxpemUoe2dsLCBsYXllck1hbmFnZXJ9KSB7XG4gIH1cbiAgLyoqXG4gICAqIGFuZCBzdWJjbGFzc2VzIHNob3VsZCBmcmVlIHRob3NlIHJlc291cmNlcyBoZXJlXG4gICAqL1xuICBmaW5hbGl6ZSh7Z2wsIGxheWVyTWFuYWdlcn0pIHtcbiAgfVxuICAvKipcbiAgICogb3ZlcnJpZGUgZm9yIGEgY2FsbGJhY2sgaW1tZWRpYXRlbHkgYmVmb3JlIGRyYXdpbmcgZWFjaCBmcmFtZVxuICAgKi9cbiAgcHJlRHJhdyh7Z2wsIGxheWVyTWFuYWdlcn0pIHtcbiAgfVxuICAvKipcbiAgICogb3ZlcnJpZGUgZm9yIGEgY2FsbGJhY2sgaW1tZWRpYXRlbHkgYWZ0ZXIgZHJhd2luZyBhIGZyYW1lJ3MgbGF5ZXJzXG4gICAqL1xuICBkcmF3KHtnbCwgbGF5ZXJNYW5hZ2VyfSkge1xuICB9XG5cbiAgc2V0TmVlZHNSZWRyYXcocmVkcmF3ID0gdHJ1ZSkge1xuICAgIHRoaXMubmVlZHNSZWRyYXcgPSByZWRyYXc7XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2V4cGVyaW1lbnRhbC9saWIvZWZmZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 54 */
/* exports provided: default */
/* exports used: default */
/*!**************************************************************!*\
  !*** ./src/layers/core/arc-layer/arc-layer-fragment.glsl.js ***!
  \**************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME arc-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvYXJjLWxheWVyL2FyYy1sYXllci1mcmFnbWVudC5nbHNsLmpzPzhjNTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuZXhwb3J0IGRlZmF1bHQgYFxcXG4jZGVmaW5lIFNIQURFUl9OQU1FIGFyYy1sYXllci1mcmFnbWVudC1zaGFkZXJcblxuI2lmZGVmIEdMX0VTXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4jZW5kaWZcblxudmFyeWluZyB2ZWM0IHZDb2xvcjtcblxudm9pZCBtYWluKHZvaWQpIHtcbiAgZ2xfRnJhZ0NvbG9yID0gdkNvbG9yO1xufVxuYDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xheWVycy9jb3JlL2FyYy1sYXllci9hcmMtbGF5ZXItZnJhZ21lbnQuZ2xzbC5qc1xuLy8gbW9kdWxlIGlkID0gNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 55 */
/* exports provided: default */
/* exports used: default */
/*!***************************************************************!*\
  !*** ./src/layers/core/arc-layer/arc-layer-vertex-64.glsl.js ***!
  \***************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME arc-layer-vertex-64-shader\n\nattribute vec3 positions;\nattribute vec4 instanceSourceColors;\nattribute vec4 instanceTargetColors;\n\nattribute vec4 instancePositions;\nattribute vec4 instancePositions64Low;\n\nattribute vec3 instancePickingColors;\n\nuniform float numSegments;\nuniform vec2 viewportSize;\nuniform float strokeWidth;\nuniform float opacity;\nuniform float renderPickingBuffer;\n\nvarying vec4 vColor;\n\nvec2 paraboloid_fp64(vec2 source[2], vec2 target[2], float ratio) {\n\n  vec2 x[2];\n  vec2_mix_fp64(source, target, ratio, x);\n  vec2 center[2];\n  vec2_mix_fp64(source, target, 0.5, center);\n\n  vec2 dSourceCenter = vec2_distance_fp64(source, center);\n  vec2 dXCenter = vec2_distance_fp64(x, center);\n  return mul_fp64(sum_fp64(dSourceCenter, dXCenter), sub_fp64(dSourceCenter, dXCenter));\n}\n\n// offset vector by strokeWidth pixels\n// offset_direction is -1 (left) or 1 (right)\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace * viewportSize);\n  // rotate by 90 degrees\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  vec2 offset_screenspace = dir_screenspace * offset_direction * strokeWidth / 2.0;\n  vec2 offset_clipspace = offset_screenspace / viewportSize * 2.0;\n\n  return offset_clipspace;\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));\n}\n\nvoid get_pos_fp64(vec2 source[2], vec2 target[2], float segmentRatio, out vec2 position[4]) {\n\n  vec2 vertex_height = paraboloid_fp64(source, target, segmentRatio);\n\n  vec2 position_temp[2];\n\n  vec2_mix_fp64(source, target, segmentRatio, position_temp);\n\n  position[0] = position_temp[0];\n  position[1] = position_temp[1];\n\n  if (vertex_height.x < 0.0 || (vertex_height.x == 0.0 && vertex_height.y <= 0.0)) {\n    vertex_height = vec2(0.0, 0.0);\n  }\n\n  position[2] = sqrt_fp64(vertex_height);\n  position[3] = vec2(1.0, 0.0);\n}\n\nvoid main(void) {\n  vec4 instanceSourcePositions64 = vec4(instancePositions.x,\n    instancePositions64Low.x, instancePositions.y, instancePositions64Low.y);\n  vec4 instanceTargetPositions64 = vec4(instancePositions.z,\n    instancePositions64Low.z, instancePositions.w, instancePositions64Low.w);\n\n  vec2 projected_source_coord[2];\n  vec2 projected_target_coord[2];\n\n  project_position_fp64(instanceSourcePositions64, projected_source_coord);\n  project_position_fp64(instanceTargetPositions64, projected_target_coord);\n\n  float segmentIndex = positions.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n\n  // if it's the first point, use next - current as direction\n  // otherwise use current - prev\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n\n  vec2 curr_pos_modelspace[4];\n\n  get_pos_fp64(projected_source_coord, projected_target_coord, segmentRatio,\n    curr_pos_modelspace);\n\n  vec2 next_pos_modelspace[4];\n\n  get_pos_fp64(projected_source_coord, projected_target_coord, nextSegmentRatio,\n    next_pos_modelspace);\n\n  vec4 curr_pos_clipspace = project_to_clipspace_fp64(curr_pos_modelspace);\n  vec4 next_pos_clipspace = project_to_clipspace_fp64(next_pos_modelspace);\n\n  vec2 offset = getExtrusionOffset(next_pos_clipspace.xy - curr_pos_clipspace.xy, positions.y);\n\n  gl_Position = curr_pos_clipspace + vec4(offset, 0.0, 0.0);\n\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio) / 255.;\n\n  vColor = mix(\n    vec4(color.rgb, color.a * opacity),\n    vec4(instancePickingColors / 255., 1.),\n    renderPickingBuffer\n  );\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvYXJjLWxheWVyL2FyYy1sYXllci12ZXJ0ZXgtNjQuZ2xzbC5qcz9lYzM1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNiBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmV4cG9ydCBkZWZhdWx0IGBcXFxuI2RlZmluZSBTSEFERVJfTkFNRSBhcmMtbGF5ZXItdmVydGV4LTY0LXNoYWRlclxuXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbnM7XG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZVNvdXJjZUNvbG9ycztcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlVGFyZ2V0Q29sb3JzO1xuXG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZVBvc2l0aW9ucztcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlUG9zaXRpb25zNjRMb3c7XG5cbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUGlja2luZ0NvbG9ycztcblxudW5pZm9ybSBmbG9hdCBudW1TZWdtZW50cztcbnVuaWZvcm0gdmVjMiB2aWV3cG9ydFNpemU7XG51bmlmb3JtIGZsb2F0IHN0cm9rZVdpZHRoO1xudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xudW5pZm9ybSBmbG9hdCByZW5kZXJQaWNraW5nQnVmZmVyO1xuXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xuXG52ZWMyIHBhcmFib2xvaWRfZnA2NCh2ZWMyIHNvdXJjZVsyXSwgdmVjMiB0YXJnZXRbMl0sIGZsb2F0IHJhdGlvKSB7XG5cbiAgdmVjMiB4WzJdO1xuICB2ZWMyX21peF9mcDY0KHNvdXJjZSwgdGFyZ2V0LCByYXRpbywgeCk7XG4gIHZlYzIgY2VudGVyWzJdO1xuICB2ZWMyX21peF9mcDY0KHNvdXJjZSwgdGFyZ2V0LCAwLjUsIGNlbnRlcik7XG5cbiAgdmVjMiBkU291cmNlQ2VudGVyID0gdmVjMl9kaXN0YW5jZV9mcDY0KHNvdXJjZSwgY2VudGVyKTtcbiAgdmVjMiBkWENlbnRlciA9IHZlYzJfZGlzdGFuY2VfZnA2NCh4LCBjZW50ZXIpO1xuICByZXR1cm4gbXVsX2ZwNjQoc3VtX2ZwNjQoZFNvdXJjZUNlbnRlciwgZFhDZW50ZXIpLCBzdWJfZnA2NChkU291cmNlQ2VudGVyLCBkWENlbnRlcikpO1xufVxuXG4vLyBvZmZzZXQgdmVjdG9yIGJ5IHN0cm9rZVdpZHRoIHBpeGVsc1xuLy8gb2Zmc2V0X2RpcmVjdGlvbiBpcyAtMSAobGVmdCkgb3IgMSAocmlnaHQpXG52ZWMyIGdldEV4dHJ1c2lvbk9mZnNldCh2ZWMyIGxpbmVfY2xpcHNwYWNlLCBmbG9hdCBvZmZzZXRfZGlyZWN0aW9uKSB7XG4gIC8vIG5vcm1hbGl6ZWQgZGlyZWN0aW9uIG9mIHRoZSBsaW5lXG4gIHZlYzIgZGlyX3NjcmVlbnNwYWNlID0gbm9ybWFsaXplKGxpbmVfY2xpcHNwYWNlICogdmlld3BvcnRTaXplKTtcbiAgLy8gcm90YXRlIGJ5IDkwIGRlZ3JlZXNcbiAgZGlyX3NjcmVlbnNwYWNlID0gdmVjMigtZGlyX3NjcmVlbnNwYWNlLnksIGRpcl9zY3JlZW5zcGFjZS54KTtcblxuICB2ZWMyIG9mZnNldF9zY3JlZW5zcGFjZSA9IGRpcl9zY3JlZW5zcGFjZSAqIG9mZnNldF9kaXJlY3Rpb24gKiBzdHJva2VXaWR0aCAvIDIuMDtcbiAgdmVjMiBvZmZzZXRfY2xpcHNwYWNlID0gb2Zmc2V0X3NjcmVlbnNwYWNlIC8gdmlld3BvcnRTaXplICogMi4wO1xuXG4gIHJldHVybiBvZmZzZXRfY2xpcHNwYWNlO1xufVxuXG5mbG9hdCBnZXRTZWdtZW50UmF0aW8oZmxvYXQgaW5kZXgpIHtcbiAgcmV0dXJuIHNtb290aHN0ZXAoMC4wLCAxLjAsIGluZGV4IC8gKG51bVNlZ21lbnRzIC0gMS4wKSk7XG59XG5cbnZvaWQgZ2V0X3Bvc19mcDY0KHZlYzIgc291cmNlWzJdLCB2ZWMyIHRhcmdldFsyXSwgZmxvYXQgc2VnbWVudFJhdGlvLCBvdXQgdmVjMiBwb3NpdGlvbls0XSkge1xuXG4gIHZlYzIgdmVydGV4X2hlaWdodCA9IHBhcmFib2xvaWRfZnA2NChzb3VyY2UsIHRhcmdldCwgc2VnbWVudFJhdGlvKTtcblxuICB2ZWMyIHBvc2l0aW9uX3RlbXBbMl07XG5cbiAgdmVjMl9taXhfZnA2NChzb3VyY2UsIHRhcmdldCwgc2VnbWVudFJhdGlvLCBwb3NpdGlvbl90ZW1wKTtcblxuICBwb3NpdGlvblswXSA9IHBvc2l0aW9uX3RlbXBbMF07XG4gIHBvc2l0aW9uWzFdID0gcG9zaXRpb25fdGVtcFsxXTtcblxuICBpZiAodmVydGV4X2hlaWdodC54IDwgMC4wIHx8ICh2ZXJ0ZXhfaGVpZ2h0LnggPT0gMC4wICYmIHZlcnRleF9oZWlnaHQueSA8PSAwLjApKSB7XG4gICAgdmVydGV4X2hlaWdodCA9IHZlYzIoMC4wLCAwLjApO1xuICB9XG5cbiAgcG9zaXRpb25bMl0gPSBzcXJ0X2ZwNjQodmVydGV4X2hlaWdodCk7XG4gIHBvc2l0aW9uWzNdID0gdmVjMigxLjAsIDAuMCk7XG59XG5cbnZvaWQgbWFpbih2b2lkKSB7XG4gIHZlYzQgaW5zdGFuY2VTb3VyY2VQb3NpdGlvbnM2NCA9IHZlYzQoaW5zdGFuY2VQb3NpdGlvbnMueCxcbiAgICBpbnN0YW5jZVBvc2l0aW9uczY0TG93LngsIGluc3RhbmNlUG9zaXRpb25zLnksIGluc3RhbmNlUG9zaXRpb25zNjRMb3cueSk7XG4gIHZlYzQgaW5zdGFuY2VUYXJnZXRQb3NpdGlvbnM2NCA9IHZlYzQoaW5zdGFuY2VQb3NpdGlvbnMueixcbiAgICBpbnN0YW5jZVBvc2l0aW9uczY0TG93LnosIGluc3RhbmNlUG9zaXRpb25zLncsIGluc3RhbmNlUG9zaXRpb25zNjRMb3cudyk7XG5cbiAgdmVjMiBwcm9qZWN0ZWRfc291cmNlX2Nvb3JkWzJdO1xuICB2ZWMyIHByb2plY3RlZF90YXJnZXRfY29vcmRbMl07XG5cbiAgcHJvamVjdF9wb3NpdGlvbl9mcDY0KGluc3RhbmNlU291cmNlUG9zaXRpb25zNjQsIHByb2plY3RlZF9zb3VyY2VfY29vcmQpO1xuICBwcm9qZWN0X3Bvc2l0aW9uX2ZwNjQoaW5zdGFuY2VUYXJnZXRQb3NpdGlvbnM2NCwgcHJvamVjdGVkX3RhcmdldF9jb29yZCk7XG5cbiAgZmxvYXQgc2VnbWVudEluZGV4ID0gcG9zaXRpb25zLng7XG4gIGZsb2F0IHNlZ21lbnRSYXRpbyA9IGdldFNlZ21lbnRSYXRpbyhzZWdtZW50SW5kZXgpO1xuXG4gIC8vIGlmIGl0J3MgdGhlIGZpcnN0IHBvaW50LCB1c2UgbmV4dCAtIGN1cnJlbnQgYXMgZGlyZWN0aW9uXG4gIC8vIG90aGVyd2lzZSB1c2UgY3VycmVudCAtIHByZXZcbiAgZmxvYXQgaW5kZXhEaXIgPSBtaXgoLTEuMCwgMS4wLCBzdGVwKHNlZ21lbnRJbmRleCwgMC4wKSk7XG4gIGZsb2F0IG5leHRTZWdtZW50UmF0aW8gPSBnZXRTZWdtZW50UmF0aW8oc2VnbWVudEluZGV4ICsgaW5kZXhEaXIpO1xuXG4gIHZlYzIgY3Vycl9wb3NfbW9kZWxzcGFjZVs0XTtcblxuICBnZXRfcG9zX2ZwNjQocHJvamVjdGVkX3NvdXJjZV9jb29yZCwgcHJvamVjdGVkX3RhcmdldF9jb29yZCwgc2VnbWVudFJhdGlvLFxuICAgIGN1cnJfcG9zX21vZGVsc3BhY2UpO1xuXG4gIHZlYzIgbmV4dF9wb3NfbW9kZWxzcGFjZVs0XTtcblxuICBnZXRfcG9zX2ZwNjQocHJvamVjdGVkX3NvdXJjZV9jb29yZCwgcHJvamVjdGVkX3RhcmdldF9jb29yZCwgbmV4dFNlZ21lbnRSYXRpbyxcbiAgICBuZXh0X3Bvc19tb2RlbHNwYWNlKTtcblxuICB2ZWM0IGN1cnJfcG9zX2NsaXBzcGFjZSA9IHByb2plY3RfdG9fY2xpcHNwYWNlX2ZwNjQoY3Vycl9wb3NfbW9kZWxzcGFjZSk7XG4gIHZlYzQgbmV4dF9wb3NfY2xpcHNwYWNlID0gcHJvamVjdF90b19jbGlwc3BhY2VfZnA2NChuZXh0X3Bvc19tb2RlbHNwYWNlKTtcblxuICB2ZWMyIG9mZnNldCA9IGdldEV4dHJ1c2lvbk9mZnNldChuZXh0X3Bvc19jbGlwc3BhY2UueHkgLSBjdXJyX3Bvc19jbGlwc3BhY2UueHksIHBvc2l0aW9ucy55KTtcblxuICBnbF9Qb3NpdGlvbiA9IGN1cnJfcG9zX2NsaXBzcGFjZSArIHZlYzQob2Zmc2V0LCAwLjAsIDAuMCk7XG5cbiAgdmVjNCBjb2xvciA9IG1peChpbnN0YW5jZVNvdXJjZUNvbG9ycywgaW5zdGFuY2VUYXJnZXRDb2xvcnMsIHNlZ21lbnRSYXRpbykgLyAyNTUuO1xuXG4gIHZDb2xvciA9IG1peChcbiAgICB2ZWM0KGNvbG9yLnJnYiwgY29sb3IuYSAqIG9wYWNpdHkpLFxuICAgIHZlYzQoaW5zdGFuY2VQaWNraW5nQ29sb3JzIC8gMjU1LiwgMS4pLFxuICAgIHJlbmRlclBpY2tpbmdCdWZmZXJcbiAgKTtcbn1cbmA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9sYXllcnMvY29yZS9hcmMtbGF5ZXIvYXJjLWxheWVyLXZlcnRleC02NC5nbHNsLmpzXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 56 */
/* exports provided: default */
/* exports used: default */
/*!************************************************************!*\
  !*** ./src/layers/core/arc-layer/arc-layer-vertex.glsl.js ***!
  \************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME arc-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec4 instanceSourceColors;\nattribute vec4 instanceTargetColors;\nattribute vec4 instancePositions;\nattribute vec3 instancePickingColors;\n\nuniform float numSegments;\nuniform vec2 viewportSize;\nuniform float strokeWidth;\nuniform float opacity;\nuniform float renderPickingBuffer;\n\nvarying vec4 vColor;\n\nfloat paraboloid(vec2 source, vec2 target, float ratio) {\n\n  vec2 x = mix(source, target, ratio);\n  vec2 center = mix(source, target, 0.5);\n\n  float dSourceCenter = distance(source, center);\n  float dXCenter = distance(x, center);\n  return (dSourceCenter + dXCenter) * (dSourceCenter - dXCenter);\n}\n\n// offset vector by strokeWidth pixels\n// offset_direction is -1 (left) or 1 (right)\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace * viewportSize);\n  // rotate by 90 degrees\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  vec2 offset_screenspace = dir_screenspace * offset_direction * strokeWidth / 2.0;\n  vec2 offset_clipspace = offset_screenspace / viewportSize * 2.0;\n\n  return offset_clipspace;\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));\n}\n\nvec3 getPos(vec2 source, vec2 target, float segmentRatio) {\n  float vertex_height = paraboloid(source, target, segmentRatio);\n\n  return vec3(\n    mix(source, target, segmentRatio),\n    sqrt(max(0.0, vertex_height))\n  );\n}\n\nvoid main(void) {\n  vec2 source = project_position(instancePositions.xy);\n  vec2 target = project_position(instancePositions.zw);\n\n  float segmentIndex = positions.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n  // if it's the first point, use next - current as direction\n  // otherwise use current - prev\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n\n  vec3 currPos = getPos(source, target, segmentRatio);\n  vec3 nextPos = getPos(source, target, nextSegmentRatio);\n  vec4 curr = project_to_clipspace(vec4(currPos, 1.0));\n  vec4 next = project_to_clipspace(vec4(nextPos, 1.0));\n\n  // extrude\n  vec2 offset = getExtrusionOffset((next.xy - curr.xy) * indexDir, positions.y);\n  gl_Position = curr + vec4(offset, 0.0, 0.0);\n\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio) / 255.;\n\n  vColor = mix(\n    vec4(color.rgb, color.a * opacity),\n    vec4(instancePickingColors / 255., 1.),\n    renderPickingBuffer\n  );\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvYXJjLWxheWVyL2FyYy1sYXllci12ZXJ0ZXguZ2xzbC5qcz84MjFiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmV4cG9ydCBkZWZhdWx0IGBcXFxuI2RlZmluZSBTSEFERVJfTkFNRSBhcmMtbGF5ZXItdmVydGV4LXNoYWRlclxuXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbnM7XG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZVNvdXJjZUNvbG9ycztcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlVGFyZ2V0Q29sb3JzO1xuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VQb3NpdGlvbnM7XG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBpY2tpbmdDb2xvcnM7XG5cbnVuaWZvcm0gZmxvYXQgbnVtU2VnbWVudHM7XG51bmlmb3JtIHZlYzIgdmlld3BvcnRTaXplO1xudW5pZm9ybSBmbG9hdCBzdHJva2VXaWR0aDtcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcbnVuaWZvcm0gZmxvYXQgcmVuZGVyUGlja2luZ0J1ZmZlcjtcblxudmFyeWluZyB2ZWM0IHZDb2xvcjtcblxuZmxvYXQgcGFyYWJvbG9pZCh2ZWMyIHNvdXJjZSwgdmVjMiB0YXJnZXQsIGZsb2F0IHJhdGlvKSB7XG5cbiAgdmVjMiB4ID0gbWl4KHNvdXJjZSwgdGFyZ2V0LCByYXRpbyk7XG4gIHZlYzIgY2VudGVyID0gbWl4KHNvdXJjZSwgdGFyZ2V0LCAwLjUpO1xuXG4gIGZsb2F0IGRTb3VyY2VDZW50ZXIgPSBkaXN0YW5jZShzb3VyY2UsIGNlbnRlcik7XG4gIGZsb2F0IGRYQ2VudGVyID0gZGlzdGFuY2UoeCwgY2VudGVyKTtcbiAgcmV0dXJuIChkU291cmNlQ2VudGVyICsgZFhDZW50ZXIpICogKGRTb3VyY2VDZW50ZXIgLSBkWENlbnRlcik7XG59XG5cbi8vIG9mZnNldCB2ZWN0b3IgYnkgc3Ryb2tlV2lkdGggcGl4ZWxzXG4vLyBvZmZzZXRfZGlyZWN0aW9uIGlzIC0xIChsZWZ0KSBvciAxIChyaWdodClcbnZlYzIgZ2V0RXh0cnVzaW9uT2Zmc2V0KHZlYzIgbGluZV9jbGlwc3BhY2UsIGZsb2F0IG9mZnNldF9kaXJlY3Rpb24pIHtcbiAgLy8gbm9ybWFsaXplZCBkaXJlY3Rpb24gb2YgdGhlIGxpbmVcbiAgdmVjMiBkaXJfc2NyZWVuc3BhY2UgPSBub3JtYWxpemUobGluZV9jbGlwc3BhY2UgKiB2aWV3cG9ydFNpemUpO1xuICAvLyByb3RhdGUgYnkgOTAgZGVncmVlc1xuICBkaXJfc2NyZWVuc3BhY2UgPSB2ZWMyKC1kaXJfc2NyZWVuc3BhY2UueSwgZGlyX3NjcmVlbnNwYWNlLngpO1xuXG4gIHZlYzIgb2Zmc2V0X3NjcmVlbnNwYWNlID0gZGlyX3NjcmVlbnNwYWNlICogb2Zmc2V0X2RpcmVjdGlvbiAqIHN0cm9rZVdpZHRoIC8gMi4wO1xuICB2ZWMyIG9mZnNldF9jbGlwc3BhY2UgPSBvZmZzZXRfc2NyZWVuc3BhY2UgLyB2aWV3cG9ydFNpemUgKiAyLjA7XG5cbiAgcmV0dXJuIG9mZnNldF9jbGlwc3BhY2U7XG59XG5cbmZsb2F0IGdldFNlZ21lbnRSYXRpbyhmbG9hdCBpbmRleCkge1xuICByZXR1cm4gc21vb3Roc3RlcCgwLjAsIDEuMCwgaW5kZXggLyAobnVtU2VnbWVudHMgLSAxLjApKTtcbn1cblxudmVjMyBnZXRQb3ModmVjMiBzb3VyY2UsIHZlYzIgdGFyZ2V0LCBmbG9hdCBzZWdtZW50UmF0aW8pIHtcbiAgZmxvYXQgdmVydGV4X2hlaWdodCA9IHBhcmFib2xvaWQoc291cmNlLCB0YXJnZXQsIHNlZ21lbnRSYXRpbyk7XG5cbiAgcmV0dXJuIHZlYzMoXG4gICAgbWl4KHNvdXJjZSwgdGFyZ2V0LCBzZWdtZW50UmF0aW8pLFxuICAgIHNxcnQobWF4KDAuMCwgdmVydGV4X2hlaWdodCkpXG4gICk7XG59XG5cbnZvaWQgbWFpbih2b2lkKSB7XG4gIHZlYzIgc291cmNlID0gcHJvamVjdF9wb3NpdGlvbihpbnN0YW5jZVBvc2l0aW9ucy54eSk7XG4gIHZlYzIgdGFyZ2V0ID0gcHJvamVjdF9wb3NpdGlvbihpbnN0YW5jZVBvc2l0aW9ucy56dyk7XG5cbiAgZmxvYXQgc2VnbWVudEluZGV4ID0gcG9zaXRpb25zLng7XG4gIGZsb2F0IHNlZ21lbnRSYXRpbyA9IGdldFNlZ21lbnRSYXRpbyhzZWdtZW50SW5kZXgpO1xuICAvLyBpZiBpdCdzIHRoZSBmaXJzdCBwb2ludCwgdXNlIG5leHQgLSBjdXJyZW50IGFzIGRpcmVjdGlvblxuICAvLyBvdGhlcndpc2UgdXNlIGN1cnJlbnQgLSBwcmV2XG4gIGZsb2F0IGluZGV4RGlyID0gbWl4KC0xLjAsIDEuMCwgc3RlcChzZWdtZW50SW5kZXgsIDAuMCkpO1xuICBmbG9hdCBuZXh0U2VnbWVudFJhdGlvID0gZ2V0U2VnbWVudFJhdGlvKHNlZ21lbnRJbmRleCArIGluZGV4RGlyKTtcblxuICB2ZWMzIGN1cnJQb3MgPSBnZXRQb3Moc291cmNlLCB0YXJnZXQsIHNlZ21lbnRSYXRpbyk7XG4gIHZlYzMgbmV4dFBvcyA9IGdldFBvcyhzb3VyY2UsIHRhcmdldCwgbmV4dFNlZ21lbnRSYXRpbyk7XG4gIHZlYzQgY3VyciA9IHByb2plY3RfdG9fY2xpcHNwYWNlKHZlYzQoY3VyclBvcywgMS4wKSk7XG4gIHZlYzQgbmV4dCA9IHByb2plY3RfdG9fY2xpcHNwYWNlKHZlYzQobmV4dFBvcywgMS4wKSk7XG5cbiAgLy8gZXh0cnVkZVxuICB2ZWMyIG9mZnNldCA9IGdldEV4dHJ1c2lvbk9mZnNldCgobmV4dC54eSAtIGN1cnIueHkpICogaW5kZXhEaXIsIHBvc2l0aW9ucy55KTtcbiAgZ2xfUG9zaXRpb24gPSBjdXJyICsgdmVjNChvZmZzZXQsIDAuMCwgMC4wKTtcblxuICB2ZWM0IGNvbG9yID0gbWl4KGluc3RhbmNlU291cmNlQ29sb3JzLCBpbnN0YW5jZVRhcmdldENvbG9ycywgc2VnbWVudFJhdGlvKSAvIDI1NS47XG5cbiAgdkNvbG9yID0gbWl4KFxuICAgIHZlYzQoY29sb3IucmdiLCBjb2xvci5hICogb3BhY2l0eSksXG4gICAgdmVjNChpbnN0YW5jZVBpY2tpbmdDb2xvcnMgLyAyNTUuLCAxLiksXG4gICAgcmVuZGVyUGlja2luZ0J1ZmZlclxuICApO1xufVxuYDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xheWVycy9jb3JlL2FyYy1sYXllci9hcmMtbGF5ZXItdmVydGV4Lmdsc2wuanNcbi8vIG1vZHVsZSBpZCA9IDU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 57 */
/* exports provided: getGeojsonFeatures, separateGeojsonFeatures */
/* exports used: getGeojsonFeatures, separateGeojsonFeatures */
/*!**************************************************!*\
  !*** ./src/layers/core/geojson-layer/geojson.js ***!
  \**************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 0);\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = getGeojsonFeatures;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = separateGeojsonFeatures;\n\n\n/**\n * \"Normalizes\" complete or partial GeoJSON data into iterable list of features\n * Can accept GeoJSON geometry or \"Feature\", \"FeatureCollection\" in addition\n * to plain arrays and iterables.\n * Works by extracting the feature array or wrapping single objects in an array,\n * so that subsequent code can simply iterate over features.\n *\n * @param {object} geojson - geojson data\n * @param {Object|Array} data - geojson object (FeatureCollection, Feature or\n *  Geometry) or array of features\n * @return {Array|\"iteratable\"} - iterable list of features\n */\nfunction getGeojsonFeatures(geojson) {\n  // If array, assume this is a list of features\n  if (Array.isArray(geojson)) {\n    return geojson;\n  }\n\n  const type = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__[\"f\" /* get */])(geojson, 'type');\n  switch (type) {\n  case 'Point':\n  case 'MultiPoint':\n  case 'LineString':\n  case 'MultiLineString':\n  case 'Polygon':\n  case 'MultiPolygon':\n  case 'GeometryCollection':\n    // Wrap the geometry object in a 'Feature' object and wrap in an array\n    return [\n      {type: 'Feature', properties: {}, geometry: geojson}\n    ];\n  case 'Feature':\n    // Wrap the feature in a 'Features' array\n    return [geojson];\n  case 'FeatureCollection':\n    // Just return the 'Features' array from the collection\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__[\"f\" /* get */])(geojson, 'features');\n  default:\n    throw new Error('Unknown geojson type');\n  }\n}\n\n// Linearize\nfunction separateGeojsonFeatures(features) {\n  const pointFeatures = [];\n  const lineFeatures = [];\n  const polygonFeatures = [];\n  const polygonOutlineFeatures = [];\n\n  features.forEach(feature => {\n    const type = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__[\"f\" /* get */])(feature, 'geometry.type');\n    const coordinates = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__[\"f\" /* get */])(feature, 'geometry.coordinates');\n    const properties = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__[\"f\" /* get */])(feature, 'properties');\n    switch (type) {\n    case 'Point':\n      pointFeatures.push(feature);\n      break;\n    case 'MultiPoint':\n      // TODO - split multipoints\n      coordinates.forEach(point => {\n        pointFeatures.push({geometry: {coordinates: point}, properties, feature});\n      });\n      break;\n    case 'LineString':\n      lineFeatures.push(feature);\n      break;\n    case 'MultiLineString':\n      // Break multilinestrings into multiple lines with same properties\n      coordinates.forEach(path => {\n        lineFeatures.push({geometry: {coordinates: path}, properties, feature});\n      });\n      break;\n    case 'Polygon':\n      polygonFeatures.push(feature);\n      // Break polygon into multiple lines with same properties\n      coordinates.forEach(path => {\n        polygonOutlineFeatures.push({geometry: {coordinates: path}, properties, feature});\n      });\n      break;\n    case 'MultiPolygon':\n      // Break multipolygons into multiple polygons with same properties\n      coordinates.forEach(polygon => {\n        polygonFeatures.push({geometry: {coordinates: polygon}, properties, feature});\n        // Break polygon into multiple lines with same properties\n        polygon.forEach(path => {\n          polygonOutlineFeatures.push({geometry: {coordinates: path}, properties, feature});\n        });\n      });\n      break;\n      // Not yet supported\n    case 'GeometryCollection':\n    default:\n      throw new Error(`GeoJsonLayer: ${type} not supported.`);\n    }\n  });\n\n  return {\n    pointFeatures,\n    lineFeatures,\n    polygonFeatures,\n    polygonOutlineFeatures\n  };\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvZ2VvanNvbi1sYXllci9nZW9qc29uLmpzPzE4NjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtnZXR9IGZyb20gJy4uLy4uLy4uL2xpYic7XG5cbi8qKlxuICogXCJOb3JtYWxpemVzXCIgY29tcGxldGUgb3IgcGFydGlhbCBHZW9KU09OIGRhdGEgaW50byBpdGVyYWJsZSBsaXN0IG9mIGZlYXR1cmVzXG4gKiBDYW4gYWNjZXB0IEdlb0pTT04gZ2VvbWV0cnkgb3IgXCJGZWF0dXJlXCIsIFwiRmVhdHVyZUNvbGxlY3Rpb25cIiBpbiBhZGRpdGlvblxuICogdG8gcGxhaW4gYXJyYXlzIGFuZCBpdGVyYWJsZXMuXG4gKiBXb3JrcyBieSBleHRyYWN0aW5nIHRoZSBmZWF0dXJlIGFycmF5IG9yIHdyYXBwaW5nIHNpbmdsZSBvYmplY3RzIGluIGFuIGFycmF5LFxuICogc28gdGhhdCBzdWJzZXF1ZW50IGNvZGUgY2FuIHNpbXBseSBpdGVyYXRlIG92ZXIgZmVhdHVyZXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGdlb2pzb24gLSBnZW9qc29uIGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBkYXRhIC0gZ2VvanNvbiBvYmplY3QgKEZlYXR1cmVDb2xsZWN0aW9uLCBGZWF0dXJlIG9yXG4gKiAgR2VvbWV0cnkpIG9yIGFycmF5IG9mIGZlYXR1cmVzXG4gKiBAcmV0dXJuIHtBcnJheXxcIml0ZXJhdGFibGVcIn0gLSBpdGVyYWJsZSBsaXN0IG9mIGZlYXR1cmVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRHZW9qc29uRmVhdHVyZXMoZ2VvanNvbikge1xuICAvLyBJZiBhcnJheSwgYXNzdW1lIHRoaXMgaXMgYSBsaXN0IG9mIGZlYXR1cmVzXG4gIGlmIChBcnJheS5pc0FycmF5KGdlb2pzb24pKSB7XG4gICAgcmV0dXJuIGdlb2pzb247XG4gIH1cblxuICBjb25zdCB0eXBlID0gZ2V0KGdlb2pzb24sICd0eXBlJyk7XG4gIHN3aXRjaCAodHlwZSkge1xuICBjYXNlICdQb2ludCc6XG4gIGNhc2UgJ011bHRpUG9pbnQnOlxuICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgY2FzZSAnUG9seWdvbic6XG4gIGNhc2UgJ011bHRpUG9seWdvbic6XG4gIGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XG4gICAgLy8gV3JhcCB0aGUgZ2VvbWV0cnkgb2JqZWN0IGluIGEgJ0ZlYXR1cmUnIG9iamVjdCBhbmQgd3JhcCBpbiBhbiBhcnJheVxuICAgIHJldHVybiBbXG4gICAgICB7dHlwZTogJ0ZlYXR1cmUnLCBwcm9wZXJ0aWVzOiB7fSwgZ2VvbWV0cnk6IGdlb2pzb259XG4gICAgXTtcbiAgY2FzZSAnRmVhdHVyZSc6XG4gICAgLy8gV3JhcCB0aGUgZmVhdHVyZSBpbiBhICdGZWF0dXJlcycgYXJyYXlcbiAgICByZXR1cm4gW2dlb2pzb25dO1xuICBjYXNlICdGZWF0dXJlQ29sbGVjdGlvbic6XG4gICAgLy8gSnVzdCByZXR1cm4gdGhlICdGZWF0dXJlcycgYXJyYXkgZnJvbSB0aGUgY29sbGVjdGlvblxuICAgIHJldHVybiBnZXQoZ2VvanNvbiwgJ2ZlYXR1cmVzJyk7XG4gIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGdlb2pzb24gdHlwZScpO1xuICB9XG59XG5cbi8vIExpbmVhcml6ZVxuZXhwb3J0IGZ1bmN0aW9uIHNlcGFyYXRlR2VvanNvbkZlYXR1cmVzKGZlYXR1cmVzKSB7XG4gIGNvbnN0IHBvaW50RmVhdHVyZXMgPSBbXTtcbiAgY29uc3QgbGluZUZlYXR1cmVzID0gW107XG4gIGNvbnN0IHBvbHlnb25GZWF0dXJlcyA9IFtdO1xuICBjb25zdCBwb2x5Z29uT3V0bGluZUZlYXR1cmVzID0gW107XG5cbiAgZmVhdHVyZXMuZm9yRWFjaChmZWF0dXJlID0+IHtcbiAgICBjb25zdCB0eXBlID0gZ2V0KGZlYXR1cmUsICdnZW9tZXRyeS50eXBlJyk7XG4gICAgY29uc3QgY29vcmRpbmF0ZXMgPSBnZXQoZmVhdHVyZSwgJ2dlb21ldHJ5LmNvb3JkaW5hdGVzJyk7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IGdldChmZWF0dXJlLCAncHJvcGVydGllcycpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ1BvaW50JzpcbiAgICAgIHBvaW50RmVhdHVyZXMucHVzaChmZWF0dXJlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ011bHRpUG9pbnQnOlxuICAgICAgLy8gVE9ETyAtIHNwbGl0IG11bHRpcG9pbnRzXG4gICAgICBjb29yZGluYXRlcy5mb3JFYWNoKHBvaW50ID0+IHtcbiAgICAgICAgcG9pbnRGZWF0dXJlcy5wdXNoKHtnZW9tZXRyeToge2Nvb3JkaW5hdGVzOiBwb2ludH0sIHByb3BlcnRpZXMsIGZlYXR1cmV9KTtcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnTGluZVN0cmluZyc6XG4gICAgICBsaW5lRmVhdHVyZXMucHVzaChmZWF0dXJlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gICAgICAvLyBCcmVhayBtdWx0aWxpbmVzdHJpbmdzIGludG8gbXVsdGlwbGUgbGluZXMgd2l0aCBzYW1lIHByb3BlcnRpZXNcbiAgICAgIGNvb3JkaW5hdGVzLmZvckVhY2gocGF0aCA9PiB7XG4gICAgICAgIGxpbmVGZWF0dXJlcy5wdXNoKHtnZW9tZXRyeToge2Nvb3JkaW5hdGVzOiBwYXRofSwgcHJvcGVydGllcywgZmVhdHVyZX0pO1xuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdQb2x5Z29uJzpcbiAgICAgIHBvbHlnb25GZWF0dXJlcy5wdXNoKGZlYXR1cmUpO1xuICAgICAgLy8gQnJlYWsgcG9seWdvbiBpbnRvIG11bHRpcGxlIGxpbmVzIHdpdGggc2FtZSBwcm9wZXJ0aWVzXG4gICAgICBjb29yZGluYXRlcy5mb3JFYWNoKHBhdGggPT4ge1xuICAgICAgICBwb2x5Z29uT3V0bGluZUZlYXR1cmVzLnB1c2goe2dlb21ldHJ5OiB7Y29vcmRpbmF0ZXM6IHBhdGh9LCBwcm9wZXJ0aWVzLCBmZWF0dXJlfSk7XG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ011bHRpUG9seWdvbic6XG4gICAgICAvLyBCcmVhayBtdWx0aXBvbHlnb25zIGludG8gbXVsdGlwbGUgcG9seWdvbnMgd2l0aCBzYW1lIHByb3BlcnRpZXNcbiAgICAgIGNvb3JkaW5hdGVzLmZvckVhY2gocG9seWdvbiA9PiB7XG4gICAgICAgIHBvbHlnb25GZWF0dXJlcy5wdXNoKHtnZW9tZXRyeToge2Nvb3JkaW5hdGVzOiBwb2x5Z29ufSwgcHJvcGVydGllcywgZmVhdHVyZX0pO1xuICAgICAgICAvLyBCcmVhayBwb2x5Z29uIGludG8gbXVsdGlwbGUgbGluZXMgd2l0aCBzYW1lIHByb3BlcnRpZXNcbiAgICAgICAgcG9seWdvbi5mb3JFYWNoKHBhdGggPT4ge1xuICAgICAgICAgIHBvbHlnb25PdXRsaW5lRmVhdHVyZXMucHVzaCh7Z2VvbWV0cnk6IHtjb29yZGluYXRlczogcGF0aH0sIHByb3BlcnRpZXMsIGZlYXR1cmV9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgICAgLy8gTm90IHlldCBzdXBwb3J0ZWRcbiAgICBjYXNlICdHZW9tZXRyeUNvbGxlY3Rpb24nOlxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEdlb0pzb25MYXllcjogJHt0eXBlfSBub3Qgc3VwcG9ydGVkLmApO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBwb2ludEZlYXR1cmVzLFxuICAgIGxpbmVGZWF0dXJlcyxcbiAgICBwb2x5Z29uRmVhdHVyZXMsXG4gICAgcG9seWdvbk91dGxpbmVGZWF0dXJlc1xuICB9O1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGF5ZXJzL2NvcmUvZ2VvanNvbi1sYXllci9nZW9qc29uLmpzXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 58 */
/* exports provided: default */
/* exports used: default */
/*!**************************************************************************!*\
  !*** ./src/layers/core/grid-cell-layer/grid-cell-layer-fragment.glsl.js ***!
  \**************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME grid-cell-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvZ3JpZC1jZWxsLWxheWVyL2dyaWQtY2VsbC1sYXllci1mcmFnbWVudC5nbHNsLmpzP2U0NmIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuZXhwb3J0IGRlZmF1bHQgYFxcXG4jZGVmaW5lIFNIQURFUl9OQU1FIGdyaWQtY2VsbC1sYXllci1mcmFnbWVudC1zaGFkZXJcblxuI2lmZGVmIEdMX0VTXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4jZW5kaWZcblxudmFyeWluZyB2ZWM0IHZDb2xvcjtcblxudm9pZCBtYWluKHZvaWQpIHtcbiAgZ2xfRnJhZ0NvbG9yID0gdkNvbG9yO1xufVxuYDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xheWVycy9jb3JlL2dyaWQtY2VsbC1sYXllci9ncmlkLWNlbGwtbGF5ZXItZnJhZ21lbnQuZ2xzbC5qc1xuLy8gbW9kdWxlIGlkID0gNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 59 */
/* exports provided: default */
/* exports used: default */
/*!***************************************************************************!*\
  !*** ./src/layers/core/grid-cell-layer/grid-cell-layer-vertex-64.glsl.js ***!
  \***************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Inspired by screen-grid-layer vertex shader in deck.gl\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME grid-layer-vs\n\nattribute vec3 positions;\nattribute vec3 normals;\n\nattribute vec4 instancePositions;\nattribute vec2 instancePositions64xyLow;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\n// Picking uniforms\n// Set to 1.0 if rendering picking buffer, 0.0 if rendering for display\nuniform float renderPickingBuffer;\nuniform vec3 selectedPickingColor;\n\n// Custom uniforms\nuniform float extruded;\nuniform float lonOffset;\nuniform float latOffset;\nuniform float opacity;\nuniform float elevationScale;\n\n// A magic number to scale elevation so that 1 unit approximate to 1 meter\n#define ELEVATION_SCALE 0.8\n\n// Result\nvarying vec4 vColor;\n\nfloat isPicked(vec3 pickingColors, vec3 selectedColor) {\n return float(pickingColors.x == selectedColor.x\n && pickingColors.y == selectedColor.y\n && pickingColors.z == selectedColor.z);\n}\n\n\nvoid main(void) {\n  vec4 instancePositions64xy = vec4(\n    instancePositions.x + (positions.x + 1.0) * lonOffset / 2.0,\n    instancePositions64xyLow.x,\n    instancePositions.y + (positions.y + 1.0) * latOffset / 2.0,\n    instancePositions64xyLow.y);\n\n  vec2 projected_coord_xy[2];\n  project_position_fp64(instancePositions64xy, projected_coord_xy);\n\n  float elevation = 0.0;\n\n  if (extruded > 0.5) {\n    elevation = project_scale(instancePositions.w  * (positions.z + 1.0) *\n      ELEVATION_SCALE * elevationScale) + 1.0;\n  }\n\n  vec2 vertex_pos_modelspace[4];\n  vertex_pos_modelspace[0] = projected_coord_xy[0];\n  vertex_pos_modelspace[1] = projected_coord_xy[1];\n  vertex_pos_modelspace[2] = vec2(elevation, 0.0);\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\n\n  vec4 position_worldspace = vec4(\n    vertex_pos_modelspace[0].x, vertex_pos_modelspace[1].x,\n    vertex_pos_modelspace[2].x, vertex_pos_modelspace[3].x);\n\n  gl_Position = project_to_clipspace_fp64(vertex_pos_modelspace);\n\n  if (renderPickingBuffer < 0.5) {\n\n    // TODO: we should allow the user to specify the color for \"selected element\"\n    // check whether a bar is currently picked.\n    float selected = isPicked(instancePickingColors, selectedPickingColor);\n\n    float lightWeight = 1.0;\n\n    if (extruded > 0.5) {\n      lightWeight = getLightWeight(\n        position_worldspace,\n        normals\n      );\n    }\n\n    vec3 lightWeightedColor = lightWeight * instanceColors.rgb;\n    vec4 color = vec4(lightWeightedColor, instanceColors.a * opacity) / 255.0;\n    vColor = color;\n\n  } else {\n\n    vec4 pickingColor = vec4(instancePickingColors / 255.0, 1.0);\n     vColor = pickingColor;\n\n  }\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvZ3JpZC1jZWxsLWxheWVyL2dyaWQtY2VsbC1sYXllci12ZXJ0ZXgtNjQuZ2xzbC5qcz8wYjBhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbi8vIEluc3BpcmVkIGJ5IHNjcmVlbi1ncmlkLWxheWVyIHZlcnRleCBzaGFkZXIgaW4gZGVjay5nbFxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbiNkZWZpbmUgU0hBREVSX05BTUUgZ3JpZC1sYXllci12c1xuXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbnM7XG5hdHRyaWJ1dGUgdmVjMyBub3JtYWxzO1xuXG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZVBvc2l0aW9ucztcbmF0dHJpYnV0ZSB2ZWMyIGluc3RhbmNlUG9zaXRpb25zNjR4eUxvdztcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlQ29sb3JzO1xuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VQaWNraW5nQ29sb3JzO1xuXG4vLyBQaWNraW5nIHVuaWZvcm1zXG4vLyBTZXQgdG8gMS4wIGlmIHJlbmRlcmluZyBwaWNraW5nIGJ1ZmZlciwgMC4wIGlmIHJlbmRlcmluZyBmb3IgZGlzcGxheVxudW5pZm9ybSBmbG9hdCByZW5kZXJQaWNraW5nQnVmZmVyO1xudW5pZm9ybSB2ZWMzIHNlbGVjdGVkUGlja2luZ0NvbG9yO1xuXG4vLyBDdXN0b20gdW5pZm9ybXNcbnVuaWZvcm0gZmxvYXQgZXh0cnVkZWQ7XG51bmlmb3JtIGZsb2F0IGxvbk9mZnNldDtcbnVuaWZvcm0gZmxvYXQgbGF0T2Zmc2V0O1xudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xudW5pZm9ybSBmbG9hdCBlbGV2YXRpb25TY2FsZTtcblxuLy8gQSBtYWdpYyBudW1iZXIgdG8gc2NhbGUgZWxldmF0aW9uIHNvIHRoYXQgMSB1bml0IGFwcHJveGltYXRlIHRvIDEgbWV0ZXJcbiNkZWZpbmUgRUxFVkFUSU9OX1NDQUxFIDAuOFxuXG4vLyBSZXN1bHRcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XG5cbmZsb2F0IGlzUGlja2VkKHZlYzMgcGlja2luZ0NvbG9ycywgdmVjMyBzZWxlY3RlZENvbG9yKSB7XG4gcmV0dXJuIGZsb2F0KHBpY2tpbmdDb2xvcnMueCA9PSBzZWxlY3RlZENvbG9yLnhcbiAmJiBwaWNraW5nQ29sb3JzLnkgPT0gc2VsZWN0ZWRDb2xvci55XG4gJiYgcGlja2luZ0NvbG9ycy56ID09IHNlbGVjdGVkQ29sb3Iueik7XG59XG5cblxudm9pZCBtYWluKHZvaWQpIHtcbiAgdmVjNCBpbnN0YW5jZVBvc2l0aW9uczY0eHkgPSB2ZWM0KFxuICAgIGluc3RhbmNlUG9zaXRpb25zLnggKyAocG9zaXRpb25zLnggKyAxLjApICogbG9uT2Zmc2V0IC8gMi4wLFxuICAgIGluc3RhbmNlUG9zaXRpb25zNjR4eUxvdy54LFxuICAgIGluc3RhbmNlUG9zaXRpb25zLnkgKyAocG9zaXRpb25zLnkgKyAxLjApICogbGF0T2Zmc2V0IC8gMi4wLFxuICAgIGluc3RhbmNlUG9zaXRpb25zNjR4eUxvdy55KTtcblxuICB2ZWMyIHByb2plY3RlZF9jb29yZF94eVsyXTtcbiAgcHJvamVjdF9wb3NpdGlvbl9mcDY0KGluc3RhbmNlUG9zaXRpb25zNjR4eSwgcHJvamVjdGVkX2Nvb3JkX3h5KTtcblxuICBmbG9hdCBlbGV2YXRpb24gPSAwLjA7XG5cbiAgaWYgKGV4dHJ1ZGVkID4gMC41KSB7XG4gICAgZWxldmF0aW9uID0gcHJvamVjdF9zY2FsZShpbnN0YW5jZVBvc2l0aW9ucy53ICAqIChwb3NpdGlvbnMueiArIDEuMCkgKlxuICAgICAgRUxFVkFUSU9OX1NDQUxFICogZWxldmF0aW9uU2NhbGUpICsgMS4wO1xuICB9XG5cbiAgdmVjMiB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbNF07XG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVswXSA9IHByb2plY3RlZF9jb29yZF94eVswXTtcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzFdID0gcHJvamVjdGVkX2Nvb3JkX3h5WzFdO1xuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMl0gPSB2ZWMyKGVsZXZhdGlvbiwgMC4wKTtcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzNdID0gdmVjMigxLjAsIDAuMCk7XG5cbiAgdmVjNCBwb3NpdGlvbl93b3JsZHNwYWNlID0gdmVjNChcbiAgICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMF0ueCwgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzFdLngsXG4gICAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzJdLngsIHZlcnRleF9wb3NfbW9kZWxzcGFjZVszXS54KTtcblxuICBnbF9Qb3NpdGlvbiA9IHByb2plY3RfdG9fY2xpcHNwYWNlX2ZwNjQodmVydGV4X3Bvc19tb2RlbHNwYWNlKTtcblxuICBpZiAocmVuZGVyUGlja2luZ0J1ZmZlciA8IDAuNSkge1xuXG4gICAgLy8gVE9ETzogd2Ugc2hvdWxkIGFsbG93IHRoZSB1c2VyIHRvIHNwZWNpZnkgdGhlIGNvbG9yIGZvciBcInNlbGVjdGVkIGVsZW1lbnRcIlxuICAgIC8vIGNoZWNrIHdoZXRoZXIgYSBiYXIgaXMgY3VycmVudGx5IHBpY2tlZC5cbiAgICBmbG9hdCBzZWxlY3RlZCA9IGlzUGlja2VkKGluc3RhbmNlUGlja2luZ0NvbG9ycywgc2VsZWN0ZWRQaWNraW5nQ29sb3IpO1xuXG4gICAgZmxvYXQgbGlnaHRXZWlnaHQgPSAxLjA7XG5cbiAgICBpZiAoZXh0cnVkZWQgPiAwLjUpIHtcbiAgICAgIGxpZ2h0V2VpZ2h0ID0gZ2V0TGlnaHRXZWlnaHQoXG4gICAgICAgIHBvc2l0aW9uX3dvcmxkc3BhY2UsXG4gICAgICAgIG5vcm1hbHNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmVjMyBsaWdodFdlaWdodGVkQ29sb3IgPSBsaWdodFdlaWdodCAqIGluc3RhbmNlQ29sb3JzLnJnYjtcbiAgICB2ZWM0IGNvbG9yID0gdmVjNChsaWdodFdlaWdodGVkQ29sb3IsIGluc3RhbmNlQ29sb3JzLmEgKiBvcGFjaXR5KSAvIDI1NS4wO1xuICAgIHZDb2xvciA9IGNvbG9yO1xuXG4gIH0gZWxzZSB7XG5cbiAgICB2ZWM0IHBpY2tpbmdDb2xvciA9IHZlYzQoaW5zdGFuY2VQaWNraW5nQ29sb3JzIC8gMjU1LjAsIDEuMCk7XG4gICAgIHZDb2xvciA9IHBpY2tpbmdDb2xvcjtcblxuICB9XG59XG5gO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGF5ZXJzL2NvcmUvZ3JpZC1jZWxsLWxheWVyL2dyaWQtY2VsbC1sYXllci12ZXJ0ZXgtNjQuZ2xzbC5qc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 60 */
/* exports provided: default */
/* exports used: default */
/*!************************************************************************!*\
  !*** ./src/layers/core/grid-cell-layer/grid-cell-layer-vertex.glsl.js ***!
  \************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Inspired by screen-grid-layer vertex shader in deck.gl\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME grid-layer-vs\n\nattribute vec3 positions;\nattribute vec3 normals;\n\nattribute vec4 instancePositions;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\n// Picking uniforms\n// Set to 1.0 if rendering picking buffer, 0.0 if rendering for display\nuniform float renderPickingBuffer;\nuniform vec3 selectedPickingColor;\n\n// Custom uniforms\nuniform float extruded;\nuniform float lonOffset;\nuniform float latOffset;\nuniform float opacity;\nuniform float elevationScale;\n\n// A magic number to scale elevation so that 1 unit approximate to 1 meter\n#define ELEVATION_SCALE 0.8\n\n// Result\nvarying vec4 vColor;\n\n// whether is point picked\nfloat isPicked(vec3 pickingColors, vec3 selectedColor) {\n return float(pickingColors.x == selectedColor.x\n && pickingColors.y == selectedColor.y\n && pickingColors.z == selectedColor.z);\n}\n\nvoid main(void) {\n\n  // cube gemoetry vertics are between -1 to 1, scale and transform it to between 0, 1\n  vec2 ptPosition = instancePositions.xy + vec2((positions.x + 1.0 ) *\n    lonOffset / 2.0, (positions.y + 1.0) * latOffset / 2.0);\n\n  vec2 pos = project_position(ptPosition);\n\n  float elevation = 0.0;\n\n  if (extruded > 0.5) {\n    elevation = project_scale(instancePositions.w  * (positions.z + 1.0) *\n      ELEVATION_SCALE * elevationScale);\n  }\n\n  // extrude positions\n  vec3 extrudedPosition = vec3(pos.xy, elevation + 1.0);\n  vec4 position_worldspace = vec4(extrudedPosition, 1.0);\n  gl_Position = project_to_clipspace(position_worldspace);\n\n  if (renderPickingBuffer < 0.5) {\n\n    // TODO: we should allow the user to specify the color for \"selected element\"\n    // check whether a bar is currently picked.\n    float selected = isPicked(instancePickingColors, selectedPickingColor);\n\n    float lightWeight = 1.0;\n\n    if (extruded > 0.5) {\n      lightWeight = getLightWeight(\n        position_worldspace,\n        normals\n      );\n    }\n\n    vec3 lightWeightedColor = lightWeight * instanceColors.rgb;\n    vec4 color = vec4(lightWeightedColor, instanceColors.a * opacity) / 255.0;\n    vColor = color;\n\n  } else {\n\n    vec4 pickingColor = vec4(instancePickingColors / 255.0, 1.0);\n     vColor = pickingColor;\n\n  }\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvZ3JpZC1jZWxsLWxheWVyL2dyaWQtY2VsbC1sYXllci12ZXJ0ZXguZ2xzbC5qcz9kNWZkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbi8vIEluc3BpcmVkIGJ5IHNjcmVlbi1ncmlkLWxheWVyIHZlcnRleCBzaGFkZXIgaW4gZGVjay5nbFxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbiNkZWZpbmUgU0hBREVSX05BTUUgZ3JpZC1sYXllci12c1xuXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbnM7XG5hdHRyaWJ1dGUgdmVjMyBub3JtYWxzO1xuXG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZVBvc2l0aW9ucztcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlQ29sb3JzO1xuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VQaWNraW5nQ29sb3JzO1xuXG4vLyBQaWNraW5nIHVuaWZvcm1zXG4vLyBTZXQgdG8gMS4wIGlmIHJlbmRlcmluZyBwaWNraW5nIGJ1ZmZlciwgMC4wIGlmIHJlbmRlcmluZyBmb3IgZGlzcGxheVxudW5pZm9ybSBmbG9hdCByZW5kZXJQaWNraW5nQnVmZmVyO1xudW5pZm9ybSB2ZWMzIHNlbGVjdGVkUGlja2luZ0NvbG9yO1xuXG4vLyBDdXN0b20gdW5pZm9ybXNcbnVuaWZvcm0gZmxvYXQgZXh0cnVkZWQ7XG51bmlmb3JtIGZsb2F0IGxvbk9mZnNldDtcbnVuaWZvcm0gZmxvYXQgbGF0T2Zmc2V0O1xudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xudW5pZm9ybSBmbG9hdCBlbGV2YXRpb25TY2FsZTtcblxuLy8gQSBtYWdpYyBudW1iZXIgdG8gc2NhbGUgZWxldmF0aW9uIHNvIHRoYXQgMSB1bml0IGFwcHJveGltYXRlIHRvIDEgbWV0ZXJcbiNkZWZpbmUgRUxFVkFUSU9OX1NDQUxFIDAuOFxuXG4vLyBSZXN1bHRcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XG5cbi8vIHdoZXRoZXIgaXMgcG9pbnQgcGlja2VkXG5mbG9hdCBpc1BpY2tlZCh2ZWMzIHBpY2tpbmdDb2xvcnMsIHZlYzMgc2VsZWN0ZWRDb2xvcikge1xuIHJldHVybiBmbG9hdChwaWNraW5nQ29sb3JzLnggPT0gc2VsZWN0ZWRDb2xvci54XG4gJiYgcGlja2luZ0NvbG9ycy55ID09IHNlbGVjdGVkQ29sb3IueVxuICYmIHBpY2tpbmdDb2xvcnMueiA9PSBzZWxlY3RlZENvbG9yLnopO1xufVxuXG52b2lkIG1haW4odm9pZCkge1xuXG4gIC8vIGN1YmUgZ2Vtb2V0cnkgdmVydGljcyBhcmUgYmV0d2VlbiAtMSB0byAxLCBzY2FsZSBhbmQgdHJhbnNmb3JtIGl0IHRvIGJldHdlZW4gMCwgMVxuICB2ZWMyIHB0UG9zaXRpb24gPSBpbnN0YW5jZVBvc2l0aW9ucy54eSArIHZlYzIoKHBvc2l0aW9ucy54ICsgMS4wICkgKlxuICAgIGxvbk9mZnNldCAvIDIuMCwgKHBvc2l0aW9ucy55ICsgMS4wKSAqIGxhdE9mZnNldCAvIDIuMCk7XG5cbiAgdmVjMiBwb3MgPSBwcm9qZWN0X3Bvc2l0aW9uKHB0UG9zaXRpb24pO1xuXG4gIGZsb2F0IGVsZXZhdGlvbiA9IDAuMDtcblxuICBpZiAoZXh0cnVkZWQgPiAwLjUpIHtcbiAgICBlbGV2YXRpb24gPSBwcm9qZWN0X3NjYWxlKGluc3RhbmNlUG9zaXRpb25zLncgICogKHBvc2l0aW9ucy56ICsgMS4wKSAqXG4gICAgICBFTEVWQVRJT05fU0NBTEUgKiBlbGV2YXRpb25TY2FsZSk7XG4gIH1cblxuICAvLyBleHRydWRlIHBvc2l0aW9uc1xuICB2ZWMzIGV4dHJ1ZGVkUG9zaXRpb24gPSB2ZWMzKHBvcy54eSwgZWxldmF0aW9uICsgMS4wKTtcbiAgdmVjNCBwb3NpdGlvbl93b3JsZHNwYWNlID0gdmVjNChleHRydWRlZFBvc2l0aW9uLCAxLjApO1xuICBnbF9Qb3NpdGlvbiA9IHByb2plY3RfdG9fY2xpcHNwYWNlKHBvc2l0aW9uX3dvcmxkc3BhY2UpO1xuXG4gIGlmIChyZW5kZXJQaWNraW5nQnVmZmVyIDwgMC41KSB7XG5cbiAgICAvLyBUT0RPOiB3ZSBzaG91bGQgYWxsb3cgdGhlIHVzZXIgdG8gc3BlY2lmeSB0aGUgY29sb3IgZm9yIFwic2VsZWN0ZWQgZWxlbWVudFwiXG4gICAgLy8gY2hlY2sgd2hldGhlciBhIGJhciBpcyBjdXJyZW50bHkgcGlja2VkLlxuICAgIGZsb2F0IHNlbGVjdGVkID0gaXNQaWNrZWQoaW5zdGFuY2VQaWNraW5nQ29sb3JzLCBzZWxlY3RlZFBpY2tpbmdDb2xvcik7XG5cbiAgICBmbG9hdCBsaWdodFdlaWdodCA9IDEuMDtcblxuICAgIGlmIChleHRydWRlZCA+IDAuNSkge1xuICAgICAgbGlnaHRXZWlnaHQgPSBnZXRMaWdodFdlaWdodChcbiAgICAgICAgcG9zaXRpb25fd29ybGRzcGFjZSxcbiAgICAgICAgbm9ybWFsc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICB2ZWMzIGxpZ2h0V2VpZ2h0ZWRDb2xvciA9IGxpZ2h0V2VpZ2h0ICogaW5zdGFuY2VDb2xvcnMucmdiO1xuICAgIHZlYzQgY29sb3IgPSB2ZWM0KGxpZ2h0V2VpZ2h0ZWRDb2xvciwgaW5zdGFuY2VDb2xvcnMuYSAqIG9wYWNpdHkpIC8gMjU1LjA7XG4gICAgdkNvbG9yID0gY29sb3I7XG5cbiAgfSBlbHNlIHtcblxuICAgIHZlYzQgcGlja2luZ0NvbG9yID0gdmVjNChpbnN0YW5jZVBpY2tpbmdDb2xvcnMgLyAyNTUuMCwgMS4wKTtcbiAgICAgdkNvbG9yID0gcGlja2luZ0NvbG9yO1xuXG4gIH1cbn1cbmA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9sYXllcnMvY29yZS9ncmlkLWNlbGwtbGF5ZXIvZ3JpZC1jZWxsLWxheWVyLXZlcnRleC5nbHNsLmpzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 61 */
/* exports provided: pointToDensityGridData */
/* exports used: pointToDensityGridData */
/*!*******************************************************!*\
  !*** ./src/layers/core/grid-layer/grid-aggregator.js ***!
  \*******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (immutable) */ __webpack_exports__[\"a\"] = pointToDensityGridData;\nconst R_EARTH = 6378000;\n\n/**\n * Calculate density grid from an array of points\n * @param {array} points\n * @param {number} worldUnitSize - unit size in meters\n * @param {function} getPosition - position accessor\n * @returns {object} - grid data, cell dimension and count range\n */\nfunction pointToDensityGridData(points, worldUnitSize, getPosition) {\n\n  const {gridHash, gridOffset} = _pointsToGridHashing(points, worldUnitSize, getPosition);\n  const layerData = _getGridLayerDataFromGridHash(gridHash, gridOffset);\n  const countRange = _getCellCountExtent(layerData);\n\n  return {\n    gridOffset,\n    layerData,\n    countRange\n  };\n}\n\n/**\n * Project points into each cell, return a hash table of cells\n * @param {array} points\n * @param {number} worldUnitSize - unit size in meters\n * @param {function} getPosition - position accessor\n * @returns {object} - grid hash and cell dimension\n */\nfunction _pointsToGridHashing(points, worldUnitSize, getPosition) {\n\n  // find the geometric center of sample points\n  const allLat = points.map(p => getPosition(p)[1]);\n  const latMin = Math.min.apply(null, allLat);\n  const latMax = Math.max.apply(null, allLat);\n\n  const centerLat = (latMin + latMax) / 2;\n\n  const gridOffset = _calculateGridLatLonOffset(worldUnitSize, centerLat);\n\n  if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {\n    return {gridHash: {}, gridOffset};\n  }\n  // calculate count per cell\n  const gridHash = points.reduce((accu, pt) => {\n    const latIdx = Math.floor((getPosition(pt)[1] + 90) / gridOffset.yOffset);\n    const lonIdx = Math.floor((getPosition(pt)[0] + 180) / gridOffset.xOffset);\n    const key = `${latIdx}-${lonIdx}`;\n\n    accu[key] = accu[key] || {count: 0, points: []};\n    accu[key].count += 1;\n    accu[key].points.push(pt);\n\n    return accu;\n  }, {});\n\n  return {gridHash, gridOffset};\n}\n\nfunction _getGridLayerDataFromGridHash(gridHash, gridOffset) {\n  return Object.keys(gridHash).reduce((accu, key, i) => {\n    const idxs = key.split('-');\n    const latIdx = parseInt(idxs[0], 10);\n    const lonIdx = parseInt(idxs[1], 10);\n\n    accu.push(Object.assign({\n      index: i,\n      position: [\n        -180 + gridOffset.xOffset * lonIdx,\n        -90 + gridOffset.yOffset * latIdx\n      ]\n    }, gridHash[key]));\n\n    return accu;\n  }, []);\n}\n\nfunction _getCellCountExtent(data) {\n  return data.length ? [\n    Math.min.apply(null, data.map(d => d.count)),\n    Math.max.apply(null, data.map(d => d.count))\n  ] : [0, 1];\n}\n\n/**\n * calculate grid layer cell size in lat lon based on world unit size\n * and current latitude\n * @param {number} worldUnitSize\n * @param {number} latitude\n * @returns {object} - lat delta and lon delta\n */\nfunction _calculateGridLatLonOffset(worldUnitSize, latitude) {\n  const yOffset = _calculateLatOffset(worldUnitSize);\n  const xOffset = _calculateLonOffset(latitude, worldUnitSize);\n  return {yOffset, xOffset};\n}\n\n/**\n * with a given x-km change, calculate the increment of latitude\n * based on stackoverflow http://stackoverflow.com/questions/7477003\n * @param {number} dy - change in km\n * @return {number} - increment in latitude\n */\nfunction _calculateLatOffset(dy) {\n  return (dy / R_EARTH) * (180 / Math.PI);\n}\n\n/**\n * with a given x-km change, and current latitude\n * calculate the increment of longitude\n * based on stackoverflow http://stackoverflow.com/questions/7477003\n * @param {number} lat - latitude of current location (based on city)\n * @param {number} dx - change in km\n * @return {number} - increment in longitude\n */\nfunction _calculateLonOffset(lat, dx) {\n  return (dx / R_EARTH) * (180 / Math.PI) / Math.cos(lat * Math.PI / 180);\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvZ3JpZC1sYXllci9ncmlkLWFnZ3JlZ2F0b3IuanM/Mjk5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBSX0VBUlRIID0gNjM3ODAwMDtcblxuLyoqXG4gKiBDYWxjdWxhdGUgZGVuc2l0eSBncmlkIGZyb20gYW4gYXJyYXkgb2YgcG9pbnRzXG4gKiBAcGFyYW0ge2FycmF5fSBwb2ludHNcbiAqIEBwYXJhbSB7bnVtYmVyfSB3b3JsZFVuaXRTaXplIC0gdW5pdCBzaXplIGluIG1ldGVyc1xuICogQHBhcmFtIHtmdW5jdGlvbn0gZ2V0UG9zaXRpb24gLSBwb3NpdGlvbiBhY2Nlc3NvclxuICogQHJldHVybnMge29iamVjdH0gLSBncmlkIGRhdGEsIGNlbGwgZGltZW5zaW9uIGFuZCBjb3VudCByYW5nZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRUb0RlbnNpdHlHcmlkRGF0YShwb2ludHMsIHdvcmxkVW5pdFNpemUsIGdldFBvc2l0aW9uKSB7XG5cbiAgY29uc3Qge2dyaWRIYXNoLCBncmlkT2Zmc2V0fSA9IF9wb2ludHNUb0dyaWRIYXNoaW5nKHBvaW50cywgd29ybGRVbml0U2l6ZSwgZ2V0UG9zaXRpb24pO1xuICBjb25zdCBsYXllckRhdGEgPSBfZ2V0R3JpZExheWVyRGF0YUZyb21HcmlkSGFzaChncmlkSGFzaCwgZ3JpZE9mZnNldCk7XG4gIGNvbnN0IGNvdW50UmFuZ2UgPSBfZ2V0Q2VsbENvdW50RXh0ZW50KGxheWVyRGF0YSk7XG5cbiAgcmV0dXJuIHtcbiAgICBncmlkT2Zmc2V0LFxuICAgIGxheWVyRGF0YSxcbiAgICBjb3VudFJhbmdlXG4gIH07XG59XG5cbi8qKlxuICogUHJvamVjdCBwb2ludHMgaW50byBlYWNoIGNlbGwsIHJldHVybiBhIGhhc2ggdGFibGUgb2YgY2VsbHNcbiAqIEBwYXJhbSB7YXJyYXl9IHBvaW50c1xuICogQHBhcmFtIHtudW1iZXJ9IHdvcmxkVW5pdFNpemUgLSB1bml0IHNpemUgaW4gbWV0ZXJzXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBnZXRQb3NpdGlvbiAtIHBvc2l0aW9uIGFjY2Vzc29yXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAtIGdyaWQgaGFzaCBhbmQgY2VsbCBkaW1lbnNpb25cbiAqL1xuZnVuY3Rpb24gX3BvaW50c1RvR3JpZEhhc2hpbmcocG9pbnRzLCB3b3JsZFVuaXRTaXplLCBnZXRQb3NpdGlvbikge1xuXG4gIC8vIGZpbmQgdGhlIGdlb21ldHJpYyBjZW50ZXIgb2Ygc2FtcGxlIHBvaW50c1xuICBjb25zdCBhbGxMYXQgPSBwb2ludHMubWFwKHAgPT4gZ2V0UG9zaXRpb24ocClbMV0pO1xuICBjb25zdCBsYXRNaW4gPSBNYXRoLm1pbi5hcHBseShudWxsLCBhbGxMYXQpO1xuICBjb25zdCBsYXRNYXggPSBNYXRoLm1heC5hcHBseShudWxsLCBhbGxMYXQpO1xuXG4gIGNvbnN0IGNlbnRlckxhdCA9IChsYXRNaW4gKyBsYXRNYXgpIC8gMjtcblxuICBjb25zdCBncmlkT2Zmc2V0ID0gX2NhbGN1bGF0ZUdyaWRMYXRMb25PZmZzZXQod29ybGRVbml0U2l6ZSwgY2VudGVyTGF0KTtcblxuICBpZiAoZ3JpZE9mZnNldC54T2Zmc2V0IDw9IDAgfHwgZ3JpZE9mZnNldC55T2Zmc2V0IDw9IDApIHtcbiAgICByZXR1cm4ge2dyaWRIYXNoOiB7fSwgZ3JpZE9mZnNldH07XG4gIH1cbiAgLy8gY2FsY3VsYXRlIGNvdW50IHBlciBjZWxsXG4gIGNvbnN0IGdyaWRIYXNoID0gcG9pbnRzLnJlZHVjZSgoYWNjdSwgcHQpID0+IHtcbiAgICBjb25zdCBsYXRJZHggPSBNYXRoLmZsb29yKChnZXRQb3NpdGlvbihwdClbMV0gKyA5MCkgLyBncmlkT2Zmc2V0LnlPZmZzZXQpO1xuICAgIGNvbnN0IGxvbklkeCA9IE1hdGguZmxvb3IoKGdldFBvc2l0aW9uKHB0KVswXSArIDE4MCkgLyBncmlkT2Zmc2V0LnhPZmZzZXQpO1xuICAgIGNvbnN0IGtleSA9IGAke2xhdElkeH0tJHtsb25JZHh9YDtcblxuICAgIGFjY3Vba2V5XSA9IGFjY3Vba2V5XSB8fCB7Y291bnQ6IDAsIHBvaW50czogW119O1xuICAgIGFjY3Vba2V5XS5jb3VudCArPSAxO1xuICAgIGFjY3Vba2V5XS5wb2ludHMucHVzaChwdCk7XG5cbiAgICByZXR1cm4gYWNjdTtcbiAgfSwge30pO1xuXG4gIHJldHVybiB7Z3JpZEhhc2gsIGdyaWRPZmZzZXR9O1xufVxuXG5mdW5jdGlvbiBfZ2V0R3JpZExheWVyRGF0YUZyb21HcmlkSGFzaChncmlkSGFzaCwgZ3JpZE9mZnNldCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoZ3JpZEhhc2gpLnJlZHVjZSgoYWNjdSwga2V5LCBpKSA9PiB7XG4gICAgY29uc3QgaWR4cyA9IGtleS5zcGxpdCgnLScpO1xuICAgIGNvbnN0IGxhdElkeCA9IHBhcnNlSW50KGlkeHNbMF0sIDEwKTtcbiAgICBjb25zdCBsb25JZHggPSBwYXJzZUludChpZHhzWzFdLCAxMCk7XG5cbiAgICBhY2N1LnB1c2goT2JqZWN0LmFzc2lnbih7XG4gICAgICBpbmRleDogaSxcbiAgICAgIHBvc2l0aW9uOiBbXG4gICAgICAgIC0xODAgKyBncmlkT2Zmc2V0LnhPZmZzZXQgKiBsb25JZHgsXG4gICAgICAgIC05MCArIGdyaWRPZmZzZXQueU9mZnNldCAqIGxhdElkeFxuICAgICAgXVxuICAgIH0sIGdyaWRIYXNoW2tleV0pKTtcblxuICAgIHJldHVybiBhY2N1O1xuICB9LCBbXSk7XG59XG5cbmZ1bmN0aW9uIF9nZXRDZWxsQ291bnRFeHRlbnQoZGF0YSkge1xuICByZXR1cm4gZGF0YS5sZW5ndGggPyBbXG4gICAgTWF0aC5taW4uYXBwbHkobnVsbCwgZGF0YS5tYXAoZCA9PiBkLmNvdW50KSksXG4gICAgTWF0aC5tYXguYXBwbHkobnVsbCwgZGF0YS5tYXAoZCA9PiBkLmNvdW50KSlcbiAgXSA6IFswLCAxXTtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgZ3JpZCBsYXllciBjZWxsIHNpemUgaW4gbGF0IGxvbiBiYXNlZCBvbiB3b3JsZCB1bml0IHNpemVcbiAqIGFuZCBjdXJyZW50IGxhdGl0dWRlXG4gKiBAcGFyYW0ge251bWJlcn0gd29ybGRVbml0U2l6ZVxuICogQHBhcmFtIHtudW1iZXJ9IGxhdGl0dWRlXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAtIGxhdCBkZWx0YSBhbmQgbG9uIGRlbHRhXG4gKi9cbmZ1bmN0aW9uIF9jYWxjdWxhdGVHcmlkTGF0TG9uT2Zmc2V0KHdvcmxkVW5pdFNpemUsIGxhdGl0dWRlKSB7XG4gIGNvbnN0IHlPZmZzZXQgPSBfY2FsY3VsYXRlTGF0T2Zmc2V0KHdvcmxkVW5pdFNpemUpO1xuICBjb25zdCB4T2Zmc2V0ID0gX2NhbGN1bGF0ZUxvbk9mZnNldChsYXRpdHVkZSwgd29ybGRVbml0U2l6ZSk7XG4gIHJldHVybiB7eU9mZnNldCwgeE9mZnNldH07XG59XG5cbi8qKlxuICogd2l0aCBhIGdpdmVuIHgta20gY2hhbmdlLCBjYWxjdWxhdGUgdGhlIGluY3JlbWVudCBvZiBsYXRpdHVkZVxuICogYmFzZWQgb24gc3RhY2tvdmVyZmxvdyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc0NzcwMDNcbiAqIEBwYXJhbSB7bnVtYmVyfSBkeSAtIGNoYW5nZSBpbiBrbVxuICogQHJldHVybiB7bnVtYmVyfSAtIGluY3JlbWVudCBpbiBsYXRpdHVkZVxuICovXG5mdW5jdGlvbiBfY2FsY3VsYXRlTGF0T2Zmc2V0KGR5KSB7XG4gIHJldHVybiAoZHkgLyBSX0VBUlRIKSAqICgxODAgLyBNYXRoLlBJKTtcbn1cblxuLyoqXG4gKiB3aXRoIGEgZ2l2ZW4geC1rbSBjaGFuZ2UsIGFuZCBjdXJyZW50IGxhdGl0dWRlXG4gKiBjYWxjdWxhdGUgdGhlIGluY3JlbWVudCBvZiBsb25naXR1ZGVcbiAqIGJhc2VkIG9uIHN0YWNrb3ZlcmZsb3cgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83NDc3MDAzXG4gKiBAcGFyYW0ge251bWJlcn0gbGF0IC0gbGF0aXR1ZGUgb2YgY3VycmVudCBsb2NhdGlvbiAoYmFzZWQgb24gY2l0eSlcbiAqIEBwYXJhbSB7bnVtYmVyfSBkeCAtIGNoYW5nZSBpbiBrbVxuICogQHJldHVybiB7bnVtYmVyfSAtIGluY3JlbWVudCBpbiBsb25naXR1ZGVcbiAqL1xuZnVuY3Rpb24gX2NhbGN1bGF0ZUxvbk9mZnNldChsYXQsIGR4KSB7XG4gIHJldHVybiAoZHggLyBSX0VBUlRIKSAqICgxODAgLyBNYXRoLlBJKSAvIE1hdGguY29zKGxhdCAqIE1hdGguUEkgLyAxODApO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGF5ZXJzL2NvcmUvZ3JpZC1sYXllci9ncmlkLWFnZ3JlZ2F0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 62 */
/* exports provided: default */
/* exports used: default */
/*!********************************************************************************!*\
  !*** ./src/layers/core/hexagon-cell-layer/hexagon-cell-layer-fragment.glsl.js ***!
  \********************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME hexagon-cell-layer-fs\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvaGV4YWdvbi1jZWxsLWxheWVyL2hleGFnb24tY2VsbC1sYXllci1mcmFnbWVudC5nbHNsLmpzPzNhNjIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuZXhwb3J0IGRlZmF1bHQgYFxcXG4jZGVmaW5lIFNIQURFUl9OQU1FIGhleGFnb24tY2VsbC1sYXllci1mc1xuXG4jaWZkZWYgR0xfRVNcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiNlbmRpZlxuXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xuXG52b2lkIG1haW4odm9pZCkge1xuICBnbF9GcmFnQ29sb3IgPSB2Q29sb3I7XG59XG5gO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGF5ZXJzL2NvcmUvaGV4YWdvbi1jZWxsLWxheWVyL2hleGFnb24tY2VsbC1sYXllci1mcmFnbWVudC5nbHNsLmpzXG4vLyBtb2R1bGUgaWQgPSA2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 63 */
/* exports provided: default */
/* exports used: default */
/*!*********************************************************************************!*\
  !*** ./src/layers/core/hexagon-cell-layer/hexagon-cell-layer-vertex-64.glsl.js ***!
  \*********************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME hexagon-cell-layer-vs-64\n\nattribute vec3 positions;\nattribute vec3 normals;\n\nattribute vec3 instancePositions;\nattribute vec2 instancePositions64xyLow;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\n// Picking uniforms\n// Set to 1.0 if rendering picking buffer, 0.0 if rendering for display\nuniform float renderPickingBuffer;\nuniform vec3 selectedPickingColor;\n\n// Custom uniforms\nuniform float opacity;\nuniform float radius;\nuniform float angle;\nuniform float extruded;\nuniform float coverage;\nuniform float elevationScale;\n\n// Result\nvarying vec4 vColor;\n\n// A magic number to scale elevation so that 1 unit approximate to 1 meter.\n#define ELEVATION_SCALE 0.8\n\nfloat isPicked(vec3 pickingColors, vec3 selectedColor) {\n return float(pickingColors.x == selectedColor.x\n && pickingColors.y == selectedColor.y\n && pickingColors.z == selectedColor.z);\n}\n\nvoid main(void) {\n\n  // rotate primitive position and normal\n  mat2 rotationMatrix = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n\n  vec2 rPos = rotationMatrix * positions.xz;\n  vec2 rNorm = rotationMatrix * normals.xz;\n\n  vec3 rotatedPositions = vec3(rPos.x, positions.y, rPos.y);\n  vec3 rotatedNormals = vec3(rNorm.x, normals.y, rNorm.y);\n\n  // calculate elevation, if 3d not enabled set to 0\n  // cylindar gemoetry height are between -0.5 to 0.5, transform it to between 0, 1\n  float elevation = 0.0;\n\n  if (extruded > 0.5) {\n    elevation = project_scale(instancePositions.z * (positions.y + 0.5) *\n      ELEVATION_SCALE * elevationScale);\n}\n\n  float dotRadius = radius * clamp(coverage, 0.0, 1.0);\n  // // project center of hexagon\n\n  vec4 instancePositions64xy = vec4(\n    instancePositions.x, instancePositions64xyLow.x,\n    instancePositions.y, instancePositions64xyLow.y);\n\n  vec2 projected_coord_xy[2];\n  project_position_fp64(instancePositions64xy, projected_coord_xy);\n\n  vec2 vertex_pos_localspace[4];\n  vec4_fp64(vec4(rotatedPositions.xz * dotRadius, 0.0, 1.0), vertex_pos_localspace);\n\n  vec2 vertex_pos_modelspace[4];\n  vertex_pos_modelspace[0] = sum_fp64(vertex_pos_localspace[0], projected_coord_xy[0]);\n  vertex_pos_modelspace[1] = sum_fp64(vertex_pos_localspace[1], projected_coord_xy[1]);\n  vertex_pos_modelspace[2] = sum_fp64(vertex_pos_localspace[2], vec2(elevation, 0.0));\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\n\n  vec4 position_worldspace = vec4(\n    vertex_pos_modelspace[0].x, vertex_pos_modelspace[1].x,\n    vertex_pos_modelspace[2].x, vertex_pos_modelspace[3].x);\n\n  gl_Position = project_to_clipspace_fp64(vertex_pos_modelspace);\n\n  // render display\n  if (renderPickingBuffer < 0.5) {\n\n    // TODO: we should allow the user to specify the color for \"selected element\"\n    // check whether hexagon is currently picked.\n    float selected = isPicked(instancePickingColors, selectedPickingColor);\n\n    // Light calculations\n    // Worldspace is the linear space after Mercator projection\n\n    vec3 normals_worldspace = rotatedNormals;\n\n    float lightWeight = 1.0;\n\n    if (extruded > 0.5) {\n      lightWeight = getLightWeight(\n        position_worldspace,\n        normals_worldspace\n      );\n    }\n\n    vec3 lightWeightedColor = lightWeight * instanceColors.rgb;\n\n    // Color: Either opacity-multiplied instance color, or picking color\n    vec4 color = vec4(lightWeightedColor, opacity * instanceColors.a) / 255.0;\n\n    vColor = color;\n\n  } else {\n\n    vec4 pickingColor = vec4(instancePickingColors / 255.0, 1.0);\n    vColor = pickingColor;\n\n  }\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvaGV4YWdvbi1jZWxsLWxheWVyL2hleGFnb24tY2VsbC1sYXllci12ZXJ0ZXgtNjQuZ2xzbC5qcz80N2RlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmV4cG9ydCBkZWZhdWx0IGBcXFxuI2RlZmluZSBTSEFERVJfTkFNRSBoZXhhZ29uLWNlbGwtbGF5ZXItdnMtNjRcblxuYXR0cmlidXRlIHZlYzMgcG9zaXRpb25zO1xuYXR0cmlidXRlIHZlYzMgbm9ybWFscztcblxuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VQb3NpdGlvbnM7XG5hdHRyaWJ1dGUgdmVjMiBpbnN0YW5jZVBvc2l0aW9uczY0eHlMb3c7XG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZUNvbG9ycztcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUGlja2luZ0NvbG9ycztcblxuLy8gUGlja2luZyB1bmlmb3Jtc1xuLy8gU2V0IHRvIDEuMCBpZiByZW5kZXJpbmcgcGlja2luZyBidWZmZXIsIDAuMCBpZiByZW5kZXJpbmcgZm9yIGRpc3BsYXlcbnVuaWZvcm0gZmxvYXQgcmVuZGVyUGlja2luZ0J1ZmZlcjtcbnVuaWZvcm0gdmVjMyBzZWxlY3RlZFBpY2tpbmdDb2xvcjtcblxuLy8gQ3VzdG9tIHVuaWZvcm1zXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XG51bmlmb3JtIGZsb2F0IHJhZGl1cztcbnVuaWZvcm0gZmxvYXQgYW5nbGU7XG51bmlmb3JtIGZsb2F0IGV4dHJ1ZGVkO1xudW5pZm9ybSBmbG9hdCBjb3ZlcmFnZTtcbnVuaWZvcm0gZmxvYXQgZWxldmF0aW9uU2NhbGU7XG5cbi8vIFJlc3VsdFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcblxuLy8gQSBtYWdpYyBudW1iZXIgdG8gc2NhbGUgZWxldmF0aW9uIHNvIHRoYXQgMSB1bml0IGFwcHJveGltYXRlIHRvIDEgbWV0ZXIuXG4jZGVmaW5lIEVMRVZBVElPTl9TQ0FMRSAwLjhcblxuZmxvYXQgaXNQaWNrZWQodmVjMyBwaWNraW5nQ29sb3JzLCB2ZWMzIHNlbGVjdGVkQ29sb3IpIHtcbiByZXR1cm4gZmxvYXQocGlja2luZ0NvbG9ycy54ID09IHNlbGVjdGVkQ29sb3IueFxuICYmIHBpY2tpbmdDb2xvcnMueSA9PSBzZWxlY3RlZENvbG9yLnlcbiAmJiBwaWNraW5nQ29sb3JzLnogPT0gc2VsZWN0ZWRDb2xvci56KTtcbn1cblxudm9pZCBtYWluKHZvaWQpIHtcblxuICAvLyByb3RhdGUgcHJpbWl0aXZlIHBvc2l0aW9uIGFuZCBub3JtYWxcbiAgbWF0MiByb3RhdGlvbk1hdHJpeCA9IG1hdDIoY29zKGFuZ2xlKSwgLXNpbihhbmdsZSksIHNpbihhbmdsZSksIGNvcyhhbmdsZSkpO1xuXG4gIHZlYzIgclBvcyA9IHJvdGF0aW9uTWF0cml4ICogcG9zaXRpb25zLnh6O1xuICB2ZWMyIHJOb3JtID0gcm90YXRpb25NYXRyaXggKiBub3JtYWxzLnh6O1xuXG4gIHZlYzMgcm90YXRlZFBvc2l0aW9ucyA9IHZlYzMoclBvcy54LCBwb3NpdGlvbnMueSwgclBvcy55KTtcbiAgdmVjMyByb3RhdGVkTm9ybWFscyA9IHZlYzMock5vcm0ueCwgbm9ybWFscy55LCByTm9ybS55KTtcblxuICAvLyBjYWxjdWxhdGUgZWxldmF0aW9uLCBpZiAzZCBub3QgZW5hYmxlZCBzZXQgdG8gMFxuICAvLyBjeWxpbmRhciBnZW1vZXRyeSBoZWlnaHQgYXJlIGJldHdlZW4gLTAuNSB0byAwLjUsIHRyYW5zZm9ybSBpdCB0byBiZXR3ZWVuIDAsIDFcbiAgZmxvYXQgZWxldmF0aW9uID0gMC4wO1xuXG4gIGlmIChleHRydWRlZCA+IDAuNSkge1xuICAgIGVsZXZhdGlvbiA9IHByb2plY3Rfc2NhbGUoaW5zdGFuY2VQb3NpdGlvbnMueiAqIChwb3NpdGlvbnMueSArIDAuNSkgKlxuICAgICAgRUxFVkFUSU9OX1NDQUxFICogZWxldmF0aW9uU2NhbGUpO1xufVxuXG4gIGZsb2F0IGRvdFJhZGl1cyA9IHJhZGl1cyAqIGNsYW1wKGNvdmVyYWdlLCAwLjAsIDEuMCk7XG4gIC8vIC8vIHByb2plY3QgY2VudGVyIG9mIGhleGFnb25cblxuICB2ZWM0IGluc3RhbmNlUG9zaXRpb25zNjR4eSA9IHZlYzQoXG4gICAgaW5zdGFuY2VQb3NpdGlvbnMueCwgaW5zdGFuY2VQb3NpdGlvbnM2NHh5TG93LngsXG4gICAgaW5zdGFuY2VQb3NpdGlvbnMueSwgaW5zdGFuY2VQb3NpdGlvbnM2NHh5TG93LnkpO1xuXG4gIHZlYzIgcHJvamVjdGVkX2Nvb3JkX3h5WzJdO1xuICBwcm9qZWN0X3Bvc2l0aW9uX2ZwNjQoaW5zdGFuY2VQb3NpdGlvbnM2NHh5LCBwcm9qZWN0ZWRfY29vcmRfeHkpO1xuXG4gIHZlYzIgdmVydGV4X3Bvc19sb2NhbHNwYWNlWzRdO1xuICB2ZWM0X2ZwNjQodmVjNChyb3RhdGVkUG9zaXRpb25zLnh6ICogZG90UmFkaXVzLCAwLjAsIDEuMCksIHZlcnRleF9wb3NfbG9jYWxzcGFjZSk7XG5cbiAgdmVjMiB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbNF07XG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVswXSA9IHN1bV9mcDY0KHZlcnRleF9wb3NfbG9jYWxzcGFjZVswXSwgcHJvamVjdGVkX2Nvb3JkX3h5WzBdKTtcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzFdID0gc3VtX2ZwNjQodmVydGV4X3Bvc19sb2NhbHNwYWNlWzFdLCBwcm9qZWN0ZWRfY29vcmRfeHlbMV0pO1xuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMl0gPSBzdW1fZnA2NCh2ZXJ0ZXhfcG9zX2xvY2Fsc3BhY2VbMl0sIHZlYzIoZWxldmF0aW9uLCAwLjApKTtcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzNdID0gdmVjMigxLjAsIDAuMCk7XG5cbiAgdmVjNCBwb3NpdGlvbl93b3JsZHNwYWNlID0gdmVjNChcbiAgICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMF0ueCwgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzFdLngsXG4gICAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzJdLngsIHZlcnRleF9wb3NfbW9kZWxzcGFjZVszXS54KTtcblxuICBnbF9Qb3NpdGlvbiA9IHByb2plY3RfdG9fY2xpcHNwYWNlX2ZwNjQodmVydGV4X3Bvc19tb2RlbHNwYWNlKTtcblxuICAvLyByZW5kZXIgZGlzcGxheVxuICBpZiAocmVuZGVyUGlja2luZ0J1ZmZlciA8IDAuNSkge1xuXG4gICAgLy8gVE9ETzogd2Ugc2hvdWxkIGFsbG93IHRoZSB1c2VyIHRvIHNwZWNpZnkgdGhlIGNvbG9yIGZvciBcInNlbGVjdGVkIGVsZW1lbnRcIlxuICAgIC8vIGNoZWNrIHdoZXRoZXIgaGV4YWdvbiBpcyBjdXJyZW50bHkgcGlja2VkLlxuICAgIGZsb2F0IHNlbGVjdGVkID0gaXNQaWNrZWQoaW5zdGFuY2VQaWNraW5nQ29sb3JzLCBzZWxlY3RlZFBpY2tpbmdDb2xvcik7XG5cbiAgICAvLyBMaWdodCBjYWxjdWxhdGlvbnNcbiAgICAvLyBXb3JsZHNwYWNlIGlzIHRoZSBsaW5lYXIgc3BhY2UgYWZ0ZXIgTWVyY2F0b3IgcHJvamVjdGlvblxuXG4gICAgdmVjMyBub3JtYWxzX3dvcmxkc3BhY2UgPSByb3RhdGVkTm9ybWFscztcblxuICAgIGZsb2F0IGxpZ2h0V2VpZ2h0ID0gMS4wO1xuXG4gICAgaWYgKGV4dHJ1ZGVkID4gMC41KSB7XG4gICAgICBsaWdodFdlaWdodCA9IGdldExpZ2h0V2VpZ2h0KFxuICAgICAgICBwb3NpdGlvbl93b3JsZHNwYWNlLFxuICAgICAgICBub3JtYWxzX3dvcmxkc3BhY2VcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmVjMyBsaWdodFdlaWdodGVkQ29sb3IgPSBsaWdodFdlaWdodCAqIGluc3RhbmNlQ29sb3JzLnJnYjtcblxuICAgIC8vIENvbG9yOiBFaXRoZXIgb3BhY2l0eS1tdWx0aXBsaWVkIGluc3RhbmNlIGNvbG9yLCBvciBwaWNraW5nIGNvbG9yXG4gICAgdmVjNCBjb2xvciA9IHZlYzQobGlnaHRXZWlnaHRlZENvbG9yLCBvcGFjaXR5ICogaW5zdGFuY2VDb2xvcnMuYSkgLyAyNTUuMDtcblxuICAgIHZDb2xvciA9IGNvbG9yO1xuXG4gIH0gZWxzZSB7XG5cbiAgICB2ZWM0IHBpY2tpbmdDb2xvciA9IHZlYzQoaW5zdGFuY2VQaWNraW5nQ29sb3JzIC8gMjU1LjAsIDEuMCk7XG4gICAgdkNvbG9yID0gcGlja2luZ0NvbG9yO1xuXG4gIH1cbn1cbmA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9sYXllcnMvY29yZS9oZXhhZ29uLWNlbGwtbGF5ZXIvaGV4YWdvbi1jZWxsLWxheWVyLXZlcnRleC02NC5nbHNsLmpzXG4vLyBtb2R1bGUgaWQgPSA2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 64 */
/* exports provided: default */
/* exports used: default */
/*!******************************************************************************!*\
  !*** ./src/layers/core/hexagon-cell-layer/hexagon-cell-layer-vertex.glsl.js ***!
  \******************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n\n#define SHADER_NAME hexagon-cell-layer-vs\n\nattribute vec3 positions;\nattribute vec3 normals;\n\nattribute vec3 instancePositions;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\n// Picking uniforms\n// Set to 1.0 if rendering picking buffer, 0.0 if rendering for display\nuniform float renderPickingBuffer;\nuniform vec3 selectedPickingColor;\n\n// Custom uniforms\nuniform float opacity;\nuniform float radius;\nuniform float angle;\nuniform float extruded;\nuniform float coverage;\nuniform float elevationScale;\n\n// Result\nvarying vec4 vColor;\n\n// A magic number to scale elevation so that 1 unit approximate to 1 meter.\n#define ELEVATION_SCALE 0.8\n\n// whether is point picked\nfloat isPicked(vec3 pickingColors, vec3 selectedColor) {\n return float(pickingColors.x == selectedColor.x\n && pickingColors.y == selectedColor.y\n && pickingColors.z == selectedColor.z);\n}\n\nvoid main(void) {\n\n  // rotate primitive position and normal\n  mat2 rotationMatrix = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n\n  vec2 rPos = rotationMatrix * positions.xz;\n  vec2 rNorm = rotationMatrix * normals.xz;\n\n  vec3 rotatedPositions = vec3(rPos.x, positions.y, rPos.y);\n  vec3 rotatedNormals = vec3(rNorm.x, normals.y, rNorm.y);\n\n  // calculate elevation, if 3d not enabled set to 0\n  // cylindar gemoetry height are between -0.5 to 0.5, transform it to between 0, 1\n  float elevation = 0.0;\n\n  if (extruded > 0.5) {\n    elevation = project_scale(instancePositions.z * (positions.y + 0.5) *\n      ELEVATION_SCALE * elevationScale);\n  }\n\n  float dotRadius = radius * mix(coverage, 0.0, float(instanceColors.a == 0.0));\n  // // project center of hexagon\n\n  vec4 centroidPosition = vec4(project_position(instancePositions.xy), elevation, 0.0);\n\n  vec4 position_worldspace = centroidPosition + vec4(vec2(rotatedPositions.xz * dotRadius), 0., 1.);\n\n  gl_Position = project_to_clipspace(position_worldspace);\n\n  // render display\n  if (renderPickingBuffer < 0.5) {\n\n    // TODO: we should allow the user to specify the color for \"selected element\"\n    // check whether hexagon is currently picked.\n    float selected = isPicked(instancePickingColors, selectedPickingColor);\n\n    // Light calculations\n    // Worldspace is the linear space after Mercator projection\n\n    vec3 normals_worldspace = rotatedNormals;\n\n    float lightWeight = 1.0;\n\n    if (extruded > 0.5) {\n      lightWeight = getLightWeight(\n        position_worldspace,\n        normals_worldspace\n      );\n    }\n\n    vec3 lightWeightedColor = lightWeight * instanceColors.rgb;\n\n    // Color: Either opacity-multiplied instance color, or picking color\n    vec4 color = vec4(lightWeightedColor, opacity * instanceColors.a) / 255.0;\n\n    vColor = color;\n\n  } else {\n\n    vec4 pickingColor = vec4(instancePickingColors / 255.0, 1.0);\n    vColor = pickingColor;\n\n  }\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvaGV4YWdvbi1jZWxsLWxheWVyL2hleGFnb24tY2VsbC1sYXllci12ZXJ0ZXguZ2xzbC5qcz85OTBiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmV4cG9ydCBkZWZhdWx0IGBcXFxuXG4jZGVmaW5lIFNIQURFUl9OQU1FIGhleGFnb24tY2VsbC1sYXllci12c1xuXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbnM7XG5hdHRyaWJ1dGUgdmVjMyBub3JtYWxzO1xuXG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBvc2l0aW9ucztcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlQ29sb3JzO1xuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VQaWNraW5nQ29sb3JzO1xuXG4vLyBQaWNraW5nIHVuaWZvcm1zXG4vLyBTZXQgdG8gMS4wIGlmIHJlbmRlcmluZyBwaWNraW5nIGJ1ZmZlciwgMC4wIGlmIHJlbmRlcmluZyBmb3IgZGlzcGxheVxudW5pZm9ybSBmbG9hdCByZW5kZXJQaWNraW5nQnVmZmVyO1xudW5pZm9ybSB2ZWMzIHNlbGVjdGVkUGlja2luZ0NvbG9yO1xuXG4vLyBDdXN0b20gdW5pZm9ybXNcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcbnVuaWZvcm0gZmxvYXQgcmFkaXVzO1xudW5pZm9ybSBmbG9hdCBhbmdsZTtcbnVuaWZvcm0gZmxvYXQgZXh0cnVkZWQ7XG51bmlmb3JtIGZsb2F0IGNvdmVyYWdlO1xudW5pZm9ybSBmbG9hdCBlbGV2YXRpb25TY2FsZTtcblxuLy8gUmVzdWx0XG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xuXG4vLyBBIG1hZ2ljIG51bWJlciB0byBzY2FsZSBlbGV2YXRpb24gc28gdGhhdCAxIHVuaXQgYXBwcm94aW1hdGUgdG8gMSBtZXRlci5cbiNkZWZpbmUgRUxFVkFUSU9OX1NDQUxFIDAuOFxuXG4vLyB3aGV0aGVyIGlzIHBvaW50IHBpY2tlZFxuZmxvYXQgaXNQaWNrZWQodmVjMyBwaWNraW5nQ29sb3JzLCB2ZWMzIHNlbGVjdGVkQ29sb3IpIHtcbiByZXR1cm4gZmxvYXQocGlja2luZ0NvbG9ycy54ID09IHNlbGVjdGVkQ29sb3IueFxuICYmIHBpY2tpbmdDb2xvcnMueSA9PSBzZWxlY3RlZENvbG9yLnlcbiAmJiBwaWNraW5nQ29sb3JzLnogPT0gc2VsZWN0ZWRDb2xvci56KTtcbn1cblxudm9pZCBtYWluKHZvaWQpIHtcblxuICAvLyByb3RhdGUgcHJpbWl0aXZlIHBvc2l0aW9uIGFuZCBub3JtYWxcbiAgbWF0MiByb3RhdGlvbk1hdHJpeCA9IG1hdDIoY29zKGFuZ2xlKSwgLXNpbihhbmdsZSksIHNpbihhbmdsZSksIGNvcyhhbmdsZSkpO1xuXG4gIHZlYzIgclBvcyA9IHJvdGF0aW9uTWF0cml4ICogcG9zaXRpb25zLnh6O1xuICB2ZWMyIHJOb3JtID0gcm90YXRpb25NYXRyaXggKiBub3JtYWxzLnh6O1xuXG4gIHZlYzMgcm90YXRlZFBvc2l0aW9ucyA9IHZlYzMoclBvcy54LCBwb3NpdGlvbnMueSwgclBvcy55KTtcbiAgdmVjMyByb3RhdGVkTm9ybWFscyA9IHZlYzMock5vcm0ueCwgbm9ybWFscy55LCByTm9ybS55KTtcblxuICAvLyBjYWxjdWxhdGUgZWxldmF0aW9uLCBpZiAzZCBub3QgZW5hYmxlZCBzZXQgdG8gMFxuICAvLyBjeWxpbmRhciBnZW1vZXRyeSBoZWlnaHQgYXJlIGJldHdlZW4gLTAuNSB0byAwLjUsIHRyYW5zZm9ybSBpdCB0byBiZXR3ZWVuIDAsIDFcbiAgZmxvYXQgZWxldmF0aW9uID0gMC4wO1xuXG4gIGlmIChleHRydWRlZCA+IDAuNSkge1xuICAgIGVsZXZhdGlvbiA9IHByb2plY3Rfc2NhbGUoaW5zdGFuY2VQb3NpdGlvbnMueiAqIChwb3NpdGlvbnMueSArIDAuNSkgKlxuICAgICAgRUxFVkFUSU9OX1NDQUxFICogZWxldmF0aW9uU2NhbGUpO1xuICB9XG5cbiAgZmxvYXQgZG90UmFkaXVzID0gcmFkaXVzICogbWl4KGNvdmVyYWdlLCAwLjAsIGZsb2F0KGluc3RhbmNlQ29sb3JzLmEgPT0gMC4wKSk7XG4gIC8vIC8vIHByb2plY3QgY2VudGVyIG9mIGhleGFnb25cblxuICB2ZWM0IGNlbnRyb2lkUG9zaXRpb24gPSB2ZWM0KHByb2plY3RfcG9zaXRpb24oaW5zdGFuY2VQb3NpdGlvbnMueHkpLCBlbGV2YXRpb24sIDAuMCk7XG5cbiAgdmVjNCBwb3NpdGlvbl93b3JsZHNwYWNlID0gY2VudHJvaWRQb3NpdGlvbiArIHZlYzQodmVjMihyb3RhdGVkUG9zaXRpb25zLnh6ICogZG90UmFkaXVzKSwgMC4sIDEuKTtcblxuICBnbF9Qb3NpdGlvbiA9IHByb2plY3RfdG9fY2xpcHNwYWNlKHBvc2l0aW9uX3dvcmxkc3BhY2UpO1xuXG4gIC8vIHJlbmRlciBkaXNwbGF5XG4gIGlmIChyZW5kZXJQaWNraW5nQnVmZmVyIDwgMC41KSB7XG5cbiAgICAvLyBUT0RPOiB3ZSBzaG91bGQgYWxsb3cgdGhlIHVzZXIgdG8gc3BlY2lmeSB0aGUgY29sb3IgZm9yIFwic2VsZWN0ZWQgZWxlbWVudFwiXG4gICAgLy8gY2hlY2sgd2hldGhlciBoZXhhZ29uIGlzIGN1cnJlbnRseSBwaWNrZWQuXG4gICAgZmxvYXQgc2VsZWN0ZWQgPSBpc1BpY2tlZChpbnN0YW5jZVBpY2tpbmdDb2xvcnMsIHNlbGVjdGVkUGlja2luZ0NvbG9yKTtcblxuICAgIC8vIExpZ2h0IGNhbGN1bGF0aW9uc1xuICAgIC8vIFdvcmxkc3BhY2UgaXMgdGhlIGxpbmVhciBzcGFjZSBhZnRlciBNZXJjYXRvciBwcm9qZWN0aW9uXG5cbiAgICB2ZWMzIG5vcm1hbHNfd29ybGRzcGFjZSA9IHJvdGF0ZWROb3JtYWxzO1xuXG4gICAgZmxvYXQgbGlnaHRXZWlnaHQgPSAxLjA7XG5cbiAgICBpZiAoZXh0cnVkZWQgPiAwLjUpIHtcbiAgICAgIGxpZ2h0V2VpZ2h0ID0gZ2V0TGlnaHRXZWlnaHQoXG4gICAgICAgIHBvc2l0aW9uX3dvcmxkc3BhY2UsXG4gICAgICAgIG5vcm1hbHNfd29ybGRzcGFjZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2ZWMzIGxpZ2h0V2VpZ2h0ZWRDb2xvciA9IGxpZ2h0V2VpZ2h0ICogaW5zdGFuY2VDb2xvcnMucmdiO1xuXG4gICAgLy8gQ29sb3I6IEVpdGhlciBvcGFjaXR5LW11bHRpcGxpZWQgaW5zdGFuY2UgY29sb3IsIG9yIHBpY2tpbmcgY29sb3JcbiAgICB2ZWM0IGNvbG9yID0gdmVjNChsaWdodFdlaWdodGVkQ29sb3IsIG9wYWNpdHkgKiBpbnN0YW5jZUNvbG9ycy5hKSAvIDI1NS4wO1xuXG4gICAgdkNvbG9yID0gY29sb3I7XG5cbiAgfSBlbHNlIHtcblxuICAgIHZlYzQgcGlja2luZ0NvbG9yID0gdmVjNChpbnN0YW5jZVBpY2tpbmdDb2xvcnMgLyAyNTUuMCwgMS4wKTtcbiAgICB2Q29sb3IgPSBwaWNraW5nQ29sb3I7XG5cbiAgfVxufVxuYDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xheWVycy9jb3JlL2hleGFnb24tY2VsbC1sYXllci9oZXhhZ29uLWNlbGwtbGF5ZXItdmVydGV4Lmdsc2wuanNcbi8vIG1vZHVsZSBpZCA9IDY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 65 */
/* exports provided: pointToHexbin, getRadiusInPixel */
/* exports used: pointToHexbin */
/*!*************************************************************!*\
  !*** ./src/layers/core/hexagon-layer/hexagon-aggregator.js ***!
  \*************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_hexbin__ = __webpack_require__(/*! d3-hexbin */ 117);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_hexbin___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_d3_hexbin__);\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = pointToHexbin;\n/* unused harmony export getRadiusInPixel */\n\n\n/**\n * Use d3-hexbin to performs hexagonal binning from geo points to hexagons\n * @param {Array} data - array of points\n * @param {Number} radius - hexagon radius in meter\n * @param {function} getPosition - get points lon lat\n * @param {Object} viewport - current viewport object\n\n * @return {Object} - hexagons and countRange\n */\nfunction pointToHexbin({data, radius, getPosition}, viewport) {\n  // get hexagon radius in mercator world unit\n  const radiusInPixel = getRadiusInPixel(radius, viewport);\n\n  // add world space coordinates to points\n  const screenPoints = data.map(pt => Object.assign({\n    screenCoord: viewport.projectFlat(getPosition(pt))\n  }, pt));\n\n  const newHexbin = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_hexbin__[\"hexbin\"])()\n    .radius(radiusInPixel)\n    .x(d => d.screenCoord[0])\n    .y(d => d.screenCoord[1]);\n\n  const hexagonBins = newHexbin(screenPoints);\n\n  return hexagonBins.map(hex => ({\n    centroid: viewport.unprojectFlat([hex.x, hex.y]),\n    points: hex\n  }));\n}\n\n/**\n * Get radius in mercator world space coordinates from meter\n * @param {Number} radius - in meter\n * @param {Object} viewport - current viewport object\n\n * @return {Number} radius in mercator world spcae coordinates\n */\nfunction getRadiusInPixel(radius, viewport) {\n\n  const {pixelsPerMeter} = viewport.getDistanceScales();\n\n  // x, y distance should be the same\n  return radius * pixelsPerMeter[0];\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvaGV4YWdvbi1sYXllci9oZXhhZ29uLWFnZ3JlZ2F0b3IuanM/ZTI0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2hleGJpbn0gZnJvbSAnZDMtaGV4YmluJztcblxuLyoqXG4gKiBVc2UgZDMtaGV4YmluIHRvIHBlcmZvcm1zIGhleGFnb25hbCBiaW5uaW5nIGZyb20gZ2VvIHBvaW50cyB0byBoZXhhZ29uc1xuICogQHBhcmFtIHtBcnJheX0gZGF0YSAtIGFycmF5IG9mIHBvaW50c1xuICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cyAtIGhleGFnb24gcmFkaXVzIGluIG1ldGVyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBnZXRQb3NpdGlvbiAtIGdldCBwb2ludHMgbG9uIGxhdFxuICogQHBhcmFtIHtPYmplY3R9IHZpZXdwb3J0IC0gY3VycmVudCB2aWV3cG9ydCBvYmplY3RcblxuICogQHJldHVybiB7T2JqZWN0fSAtIGhleGFnb25zIGFuZCBjb3VudFJhbmdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb2ludFRvSGV4YmluKHtkYXRhLCByYWRpdXMsIGdldFBvc2l0aW9ufSwgdmlld3BvcnQpIHtcbiAgLy8gZ2V0IGhleGFnb24gcmFkaXVzIGluIG1lcmNhdG9yIHdvcmxkIHVuaXRcbiAgY29uc3QgcmFkaXVzSW5QaXhlbCA9IGdldFJhZGl1c0luUGl4ZWwocmFkaXVzLCB2aWV3cG9ydCk7XG5cbiAgLy8gYWRkIHdvcmxkIHNwYWNlIGNvb3JkaW5hdGVzIHRvIHBvaW50c1xuICBjb25zdCBzY3JlZW5Qb2ludHMgPSBkYXRhLm1hcChwdCA9PiBPYmplY3QuYXNzaWduKHtcbiAgICBzY3JlZW5Db29yZDogdmlld3BvcnQucHJvamVjdEZsYXQoZ2V0UG9zaXRpb24ocHQpKVxuICB9LCBwdCkpO1xuXG4gIGNvbnN0IG5ld0hleGJpbiA9IGhleGJpbigpXG4gICAgLnJhZGl1cyhyYWRpdXNJblBpeGVsKVxuICAgIC54KGQgPT4gZC5zY3JlZW5Db29yZFswXSlcbiAgICAueShkID0+IGQuc2NyZWVuQ29vcmRbMV0pO1xuXG4gIGNvbnN0IGhleGFnb25CaW5zID0gbmV3SGV4YmluKHNjcmVlblBvaW50cyk7XG5cbiAgcmV0dXJuIGhleGFnb25CaW5zLm1hcChoZXggPT4gKHtcbiAgICBjZW50cm9pZDogdmlld3BvcnQudW5wcm9qZWN0RmxhdChbaGV4LngsIGhleC55XSksXG4gICAgcG9pbnRzOiBoZXhcbiAgfSkpO1xufVxuXG4vKipcbiAqIEdldCByYWRpdXMgaW4gbWVyY2F0b3Igd29ybGQgc3BhY2UgY29vcmRpbmF0ZXMgZnJvbSBtZXRlclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cyAtIGluIG1ldGVyXG4gKiBAcGFyYW0ge09iamVjdH0gdmlld3BvcnQgLSBjdXJyZW50IHZpZXdwb3J0IG9iamVjdFxuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHJhZGl1cyBpbiBtZXJjYXRvciB3b3JsZCBzcGNhZSBjb29yZGluYXRlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmFkaXVzSW5QaXhlbChyYWRpdXMsIHZpZXdwb3J0KSB7XG5cbiAgY29uc3Qge3BpeGVsc1Blck1ldGVyfSA9IHZpZXdwb3J0LmdldERpc3RhbmNlU2NhbGVzKCk7XG5cbiAgLy8geCwgeSBkaXN0YW5jZSBzaG91bGQgYmUgdGhlIHNhbWVcbiAgcmV0dXJuIHJhZGl1cyAqIHBpeGVsc1Blck1ldGVyWzBdO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGF5ZXJzL2NvcmUvaGV4YWdvbi1sYXllci9oZXhhZ29uLWFnZ3JlZ2F0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 66 */
/* exports provided: default */
/* exports used: default */
/*!****************************************************************!*\
  !*** ./src/layers/core/icon-layer/icon-layer-fragment.glsl.js ***!
  \****************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME scatterplot-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform float opacity;\nuniform float renderPickingBuffer;\nuniform sampler2D iconsTexture;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\n\nconst float MIN_ALPHA = 0.05;\n\nvoid main(void) {\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\n\n  // if colorMode == 0, use pixel color from the texture\n  // if colorMode == 1 or rendering picking buffer, use texture as transparency mask\n  vec3 color = mix(texColor.rgb, vColor.rgb,\n    max(vColorMode, renderPickingBuffer)\n  );\n  float a = texColor.a * opacity * mix(1.0, vColor.a, vColorMode);\n\n  if (a < MIN_ALPHA) {\n    discard;\n  }\n\n  // if rendering to screen, use mixed alpha\n  // if rendering picking buffer, use binary alpha\n  a = mix(a, 1.0, renderPickingBuffer);\n\n  gl_FragColor = vec4(color, a);\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvaWNvbi1sYXllci9pY29uLWxheWVyLWZyYWdtZW50Lmdsc2wuanM/YmIwOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbiNkZWZpbmUgU0hBREVSX05BTUUgc2NhdHRlcnBsb3QtbGF5ZXItZnJhZ21lbnQtc2hhZGVyXG5cbiNpZmRlZiBHTF9FU1xucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuI2VuZGlmXG5cbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcbnVuaWZvcm0gZmxvYXQgcmVuZGVyUGlja2luZ0J1ZmZlcjtcbnVuaWZvcm0gc2FtcGxlcjJEIGljb25zVGV4dHVyZTtcblxudmFyeWluZyBmbG9hdCB2Q29sb3JNb2RlO1xudmFyeWluZyB2ZWM0IHZDb2xvcjtcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkcztcblxuY29uc3QgZmxvYXQgTUlOX0FMUEhBID0gMC4wNTtcblxudm9pZCBtYWluKHZvaWQpIHtcbiAgdmVjNCB0ZXhDb2xvciA9IHRleHR1cmUyRChpY29uc1RleHR1cmUsIHZUZXh0dXJlQ29vcmRzKTtcblxuICAvLyBpZiBjb2xvck1vZGUgPT0gMCwgdXNlIHBpeGVsIGNvbG9yIGZyb20gdGhlIHRleHR1cmVcbiAgLy8gaWYgY29sb3JNb2RlID09IDEgb3IgcmVuZGVyaW5nIHBpY2tpbmcgYnVmZmVyLCB1c2UgdGV4dHVyZSBhcyB0cmFuc3BhcmVuY3kgbWFza1xuICB2ZWMzIGNvbG9yID0gbWl4KHRleENvbG9yLnJnYiwgdkNvbG9yLnJnYixcbiAgICBtYXgodkNvbG9yTW9kZSwgcmVuZGVyUGlja2luZ0J1ZmZlcilcbiAgKTtcbiAgZmxvYXQgYSA9IHRleENvbG9yLmEgKiBvcGFjaXR5ICogbWl4KDEuMCwgdkNvbG9yLmEsIHZDb2xvck1vZGUpO1xuXG4gIGlmIChhIDwgTUlOX0FMUEhBKSB7XG4gICAgZGlzY2FyZDtcbiAgfVxuXG4gIC8vIGlmIHJlbmRlcmluZyB0byBzY3JlZW4sIHVzZSBtaXhlZCBhbHBoYVxuICAvLyBpZiByZW5kZXJpbmcgcGlja2luZyBidWZmZXIsIHVzZSBiaW5hcnkgYWxwaGFcbiAgYSA9IG1peChhLCAxLjAsIHJlbmRlclBpY2tpbmdCdWZmZXIpO1xuXG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIGEpO1xufVxuYDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xheWVycy9jb3JlL2ljb24tbGF5ZXIvaWNvbi1sYXllci1mcmFnbWVudC5nbHNsLmpzXG4vLyBtb2R1bGUgaWQgPSA2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 67 */
/* exports provided: default */
/* exports used: default */
/*!*****************************************************************!*\
  !*** ./src/layers/core/icon-layer/icon-layer-vertex-64.glsl.js ***!
  \*****************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME icon-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec2 instancePositions64xyLow;\nattribute float instanceSizes;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec4 instanceIconFrames;\nattribute float instanceColorModes;\nattribute vec2 instanceOffsets;\n\nuniform vec2 viewportSize;\nuniform float sizeScale;\nuniform float renderPickingBuffer;\nuniform vec2 iconsTextureDim;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\n\nvoid main(void) {\n  vec2 iconSize = instanceIconFrames.zw;\n  vec2 iconSize_clipspace = iconSize / viewportSize * 2.0;\n  // scale icon height to match instanceSize\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : instanceSizes / iconSize.y;\n\n  // The vertex variable is in clip space and should not go through project_to_clipspace call\n  vec2 vertex = (positions / 2.0 + instanceOffsets) * iconSize_clipspace *\n    sizeScale * instanceScale;\n\n  vertex.y *= -1.0;\n\n  vec4 instancePositions64xy = vec4(\n    instancePositions.x, instancePositions64xyLow.x,\n    instancePositions.y, instancePositions64xyLow.y);\n\n  vec2 projected_coord_xy[2];\n  project_position_fp64(instancePositions64xy, projected_coord_xy);\n\n  vec2 vertex_pos_modelspace[4];\n  vertex_pos_modelspace[0] = projected_coord_xy[0];\n  vertex_pos_modelspace[1] = projected_coord_xy[1];\n  vertex_pos_modelspace[2] = vec2(project_scale(instancePositions.z), 0.0);\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\n\n  gl_Position = project_to_clipspace_fp64(vertex_pos_modelspace) + vec4(vertex, 0.0, 0.0);\n\n  vTextureCoords = mix(\n    instanceIconFrames.xy,\n    instanceIconFrames.xy + iconSize,\n    (positions.xy + 1.0) / 2.0\n  ) / iconsTextureDim;\n\n  vTextureCoords.y = 1.0 - vTextureCoords.y;\n\n  vec4 color = instanceColors / 255.;\n  vec4 pickingColor = vec4(instancePickingColors / 255., 1.);\n  vColor = mix(color, pickingColor, renderPickingBuffer);\n\n  vColorMode = instanceColorModes;\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvaWNvbi1sYXllci9pY29uLWxheWVyLXZlcnRleC02NC5nbHNsLmpzPzE3MTQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuZXhwb3J0IGRlZmF1bHQgYFxcXG4jZGVmaW5lIFNIQURFUl9OQU1FIGljb24tbGF5ZXItdmVydGV4LXNoYWRlclxuXG5hdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbnM7XG5cbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUG9zaXRpb25zO1xuYXR0cmlidXRlIHZlYzIgaW5zdGFuY2VQb3NpdGlvbnM2NHh5TG93O1xuYXR0cmlidXRlIGZsb2F0IGluc3RhbmNlU2l6ZXM7XG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZUNvbG9ycztcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUGlja2luZ0NvbG9ycztcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlSWNvbkZyYW1lcztcbmF0dHJpYnV0ZSBmbG9hdCBpbnN0YW5jZUNvbG9yTW9kZXM7XG5hdHRyaWJ1dGUgdmVjMiBpbnN0YW5jZU9mZnNldHM7XG5cbnVuaWZvcm0gdmVjMiB2aWV3cG9ydFNpemU7XG51bmlmb3JtIGZsb2F0IHNpemVTY2FsZTtcbnVuaWZvcm0gZmxvYXQgcmVuZGVyUGlja2luZ0J1ZmZlcjtcbnVuaWZvcm0gdmVjMiBpY29uc1RleHR1cmVEaW07XG5cbnZhcnlpbmcgZmxvYXQgdkNvbG9yTW9kZTtcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZHM7XG5cbnZvaWQgbWFpbih2b2lkKSB7XG4gIHZlYzIgaWNvblNpemUgPSBpbnN0YW5jZUljb25GcmFtZXMuenc7XG4gIHZlYzIgaWNvblNpemVfY2xpcHNwYWNlID0gaWNvblNpemUgLyB2aWV3cG9ydFNpemUgKiAyLjA7XG4gIC8vIHNjYWxlIGljb24gaGVpZ2h0IHRvIG1hdGNoIGluc3RhbmNlU2l6ZVxuICBmbG9hdCBpbnN0YW5jZVNjYWxlID0gaWNvblNpemUueSA9PSAwLjAgPyAwLjAgOiBpbnN0YW5jZVNpemVzIC8gaWNvblNpemUueTtcblxuICAvLyBUaGUgdmVydGV4IHZhcmlhYmxlIGlzIGluIGNsaXAgc3BhY2UgYW5kIHNob3VsZCBub3QgZ28gdGhyb3VnaCBwcm9qZWN0X3RvX2NsaXBzcGFjZSBjYWxsXG4gIHZlYzIgdmVydGV4ID0gKHBvc2l0aW9ucyAvIDIuMCArIGluc3RhbmNlT2Zmc2V0cykgKiBpY29uU2l6ZV9jbGlwc3BhY2UgKlxuICAgIHNpemVTY2FsZSAqIGluc3RhbmNlU2NhbGU7XG5cbiAgdmVydGV4LnkgKj0gLTEuMDtcblxuICB2ZWM0IGluc3RhbmNlUG9zaXRpb25zNjR4eSA9IHZlYzQoXG4gICAgaW5zdGFuY2VQb3NpdGlvbnMueCwgaW5zdGFuY2VQb3NpdGlvbnM2NHh5TG93LngsXG4gICAgaW5zdGFuY2VQb3NpdGlvbnMueSwgaW5zdGFuY2VQb3NpdGlvbnM2NHh5TG93LnkpO1xuXG4gIHZlYzIgcHJvamVjdGVkX2Nvb3JkX3h5WzJdO1xuICBwcm9qZWN0X3Bvc2l0aW9uX2ZwNjQoaW5zdGFuY2VQb3NpdGlvbnM2NHh5LCBwcm9qZWN0ZWRfY29vcmRfeHkpO1xuXG4gIHZlYzIgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzRdO1xuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMF0gPSBwcm9qZWN0ZWRfY29vcmRfeHlbMF07XG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVsxXSA9IHByb2plY3RlZF9jb29yZF94eVsxXTtcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzJdID0gdmVjMihwcm9qZWN0X3NjYWxlKGluc3RhbmNlUG9zaXRpb25zLnopLCAwLjApO1xuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbM10gPSB2ZWMyKDEuMCwgMC4wKTtcblxuICBnbF9Qb3NpdGlvbiA9IHByb2plY3RfdG9fY2xpcHNwYWNlX2ZwNjQodmVydGV4X3Bvc19tb2RlbHNwYWNlKSArIHZlYzQodmVydGV4LCAwLjAsIDAuMCk7XG5cbiAgdlRleHR1cmVDb29yZHMgPSBtaXgoXG4gICAgaW5zdGFuY2VJY29uRnJhbWVzLnh5LFxuICAgIGluc3RhbmNlSWNvbkZyYW1lcy54eSArIGljb25TaXplLFxuICAgIChwb3NpdGlvbnMueHkgKyAxLjApIC8gMi4wXG4gICkgLyBpY29uc1RleHR1cmVEaW07XG5cbiAgdlRleHR1cmVDb29yZHMueSA9IDEuMCAtIHZUZXh0dXJlQ29vcmRzLnk7XG5cbiAgdmVjNCBjb2xvciA9IGluc3RhbmNlQ29sb3JzIC8gMjU1LjtcbiAgdmVjNCBwaWNraW5nQ29sb3IgPSB2ZWM0KGluc3RhbmNlUGlja2luZ0NvbG9ycyAvIDI1NS4sIDEuKTtcbiAgdkNvbG9yID0gbWl4KGNvbG9yLCBwaWNraW5nQ29sb3IsIHJlbmRlclBpY2tpbmdCdWZmZXIpO1xuXG4gIHZDb2xvck1vZGUgPSBpbnN0YW5jZUNvbG9yTW9kZXM7XG59XG5gO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGF5ZXJzL2NvcmUvaWNvbi1sYXllci9pY29uLWxheWVyLXZlcnRleC02NC5nbHNsLmpzXG4vLyBtb2R1bGUgaWQgPSA2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 68 */
/* exports provided: default */
/* exports used: default */
/*!**************************************************************!*\
  !*** ./src/layers/core/icon-layer/icon-layer-vertex.glsl.js ***!
  \**************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME icon-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute float instanceSizes;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec4 instanceIconFrames;\nattribute float instanceColorModes;\nattribute vec2 instanceOffsets;\n\nuniform vec2 viewportSize;\nuniform float sizeScale;\nuniform float renderPickingBuffer;\nuniform vec2 iconsTextureDim;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\n\nvoid main(void) {\n  vec2 iconSize = instanceIconFrames.zw;\n  vec2 iconSize_clipspace = iconSize / viewportSize * 2.0;\n  // scale icon height to match instanceSize\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : instanceSizes / iconSize.y;\n  vec3 center = project_position(instancePositions);\n  vec2 vertex = (positions / 2.0 + instanceOffsets) * iconSize_clipspace *\n    sizeScale * instanceScale;\n  vertex.y *= -1.0;\n  gl_Position = project_to_clipspace(vec4(center, 1.0)) + vec4(vertex, 0.0, 0.0);\n\n  vTextureCoords = mix(\n    instanceIconFrames.xy,\n    instanceIconFrames.xy + iconSize,\n    (positions.xy + 1.0) / 2.0\n  ) / iconsTextureDim;\n\n  vTextureCoords.y = 1.0 - vTextureCoords.y;\n\n  vec4 color = instanceColors / 255.;\n  vec4 pickingColor = vec4(instancePickingColors / 255., 1.);\n  vColor = mix(color, pickingColor, renderPickingBuffer);\n\n  vColorMode = instanceColorModes;\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvaWNvbi1sYXllci9pY29uLWxheWVyLXZlcnRleC5nbHNsLmpzPzMxN2UiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuZXhwb3J0IGRlZmF1bHQgYFxcXG4jZGVmaW5lIFNIQURFUl9OQU1FIGljb24tbGF5ZXItdmVydGV4LXNoYWRlclxuXG5hdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbnM7XG5cbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUG9zaXRpb25zO1xuYXR0cmlidXRlIGZsb2F0IGluc3RhbmNlU2l6ZXM7XG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZUNvbG9ycztcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUGlja2luZ0NvbG9ycztcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlSWNvbkZyYW1lcztcbmF0dHJpYnV0ZSBmbG9hdCBpbnN0YW5jZUNvbG9yTW9kZXM7XG5hdHRyaWJ1dGUgdmVjMiBpbnN0YW5jZU9mZnNldHM7XG5cbnVuaWZvcm0gdmVjMiB2aWV3cG9ydFNpemU7XG51bmlmb3JtIGZsb2F0IHNpemVTY2FsZTtcbnVuaWZvcm0gZmxvYXQgcmVuZGVyUGlja2luZ0J1ZmZlcjtcbnVuaWZvcm0gdmVjMiBpY29uc1RleHR1cmVEaW07XG5cbnZhcnlpbmcgZmxvYXQgdkNvbG9yTW9kZTtcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZHM7XG5cbnZvaWQgbWFpbih2b2lkKSB7XG4gIHZlYzIgaWNvblNpemUgPSBpbnN0YW5jZUljb25GcmFtZXMuenc7XG4gIHZlYzIgaWNvblNpemVfY2xpcHNwYWNlID0gaWNvblNpemUgLyB2aWV3cG9ydFNpemUgKiAyLjA7XG4gIC8vIHNjYWxlIGljb24gaGVpZ2h0IHRvIG1hdGNoIGluc3RhbmNlU2l6ZVxuICBmbG9hdCBpbnN0YW5jZVNjYWxlID0gaWNvblNpemUueSA9PSAwLjAgPyAwLjAgOiBpbnN0YW5jZVNpemVzIC8gaWNvblNpemUueTtcbiAgdmVjMyBjZW50ZXIgPSBwcm9qZWN0X3Bvc2l0aW9uKGluc3RhbmNlUG9zaXRpb25zKTtcbiAgdmVjMiB2ZXJ0ZXggPSAocG9zaXRpb25zIC8gMi4wICsgaW5zdGFuY2VPZmZzZXRzKSAqIGljb25TaXplX2NsaXBzcGFjZSAqXG4gICAgc2l6ZVNjYWxlICogaW5zdGFuY2VTY2FsZTtcbiAgdmVydGV4LnkgKj0gLTEuMDtcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0X3RvX2NsaXBzcGFjZSh2ZWM0KGNlbnRlciwgMS4wKSkgKyB2ZWM0KHZlcnRleCwgMC4wLCAwLjApO1xuXG4gIHZUZXh0dXJlQ29vcmRzID0gbWl4KFxuICAgIGluc3RhbmNlSWNvbkZyYW1lcy54eSxcbiAgICBpbnN0YW5jZUljb25GcmFtZXMueHkgKyBpY29uU2l6ZSxcbiAgICAocG9zaXRpb25zLnh5ICsgMS4wKSAvIDIuMFxuICApIC8gaWNvbnNUZXh0dXJlRGltO1xuXG4gIHZUZXh0dXJlQ29vcmRzLnkgPSAxLjAgLSB2VGV4dHVyZUNvb3Jkcy55O1xuXG4gIHZlYzQgY29sb3IgPSBpbnN0YW5jZUNvbG9ycyAvIDI1NS47XG4gIHZlYzQgcGlja2luZ0NvbG9yID0gdmVjNChpbnN0YW5jZVBpY2tpbmdDb2xvcnMgLyAyNTUuLCAxLik7XG4gIHZDb2xvciA9IG1peChjb2xvciwgcGlja2luZ0NvbG9yLCByZW5kZXJQaWNraW5nQnVmZmVyKTtcblxuICB2Q29sb3JNb2RlID0gaW5zdGFuY2VDb2xvck1vZGVzO1xufVxuYDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xheWVycy9jb3JlL2ljb24tbGF5ZXIvaWNvbi1sYXllci12ZXJ0ZXguZ2xzbC5qc1xuLy8gbW9kdWxlIGlkID0gNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 69 */
/* exports provided: default */
/* exports used: default */
/*!****************************************************************!*\
  !*** ./src/layers/core/line-layer/line-layer-fragment.glsl.js ***!
  \****************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME line-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvbGluZS1sYXllci9saW5lLWxheWVyLWZyYWdtZW50Lmdsc2wuanM/ZTE4OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbiNkZWZpbmUgU0hBREVSX05BTUUgbGluZS1sYXllci1mcmFnbWVudC1zaGFkZXJcblxuI2lmZGVmIEdMX0VTXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4jZW5kaWZcblxudmFyeWluZyB2ZWM0IHZDb2xvcjtcblxudm9pZCBtYWluKHZvaWQpIHtcbiAgZ2xfRnJhZ0NvbG9yID0gdkNvbG9yO1xufVxuYDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xheWVycy9jb3JlL2xpbmUtbGF5ZXIvbGluZS1sYXllci1mcmFnbWVudC5nbHNsLmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 70 */
/* exports provided: default */
/* exports used: default */
/*!*****************************************************************!*\
  !*** ./src/layers/core/line-layer/line-layer-vertex-64.glsl.js ***!
  \*****************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME line-layer-vertex-64-shader\n\nattribute vec3 positions;\nattribute vec3 instanceSourcePositions;\nattribute vec3 instanceTargetPositions;\nattribute vec4 instanceSourceTargetPositions64xyLow;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform vec2 viewportSize;\nuniform float strokeWidth;\nuniform float opacity;\nuniform float renderPickingBuffer;\n\nvarying vec4 vColor;\n\n// offset vector by strokeWidth pixels\n// offset_direction is -1 (left) or 1 (right)\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace * viewportSize);\n  // rotate by 90 degrees\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  vec2 offset_screenspace = dir_screenspace * offset_direction * strokeWidth / 2.0;\n  vec2 offset_clipspace = offset_screenspace / viewportSize * 2.0;\n\n  return offset_clipspace;\n}\n\nvoid main(void) {\n  // Position\n  vec4 instanceSourcePositions64 = vec4(\n    instanceSourcePositions.x, instanceSourceTargetPositions64xyLow.x,\n    instanceSourcePositions.y, instanceSourceTargetPositions64xyLow.y);\n\n  vec4 instanceTargetPositions64 = vec4(\n    instanceTargetPositions.x, instanceSourceTargetPositions64xyLow.z,\n    instanceTargetPositions.y, instanceSourceTargetPositions64xyLow.w);\n\n  vec2 projected_source_coord[2];\n  vec2 projected_target_coord[2];\n\n  project_position_fp64(instanceSourcePositions64, projected_source_coord);\n  project_position_fp64(instanceTargetPositions64, projected_target_coord);\n\n  vec2 source_pos_modelspace[4];\n  source_pos_modelspace[0] =  projected_source_coord[0];\n  source_pos_modelspace[1] =  projected_source_coord[1];\n  source_pos_modelspace[2] = vec2(project_scale(instanceSourcePositions.z), 0.0);\n  source_pos_modelspace[3] = vec2(1.0, 0.0);\n\n  vec4 source_pos_clipspace = project_to_clipspace_fp64(source_pos_modelspace);\n\n  vec2 target_pos_modelspace[4];\n  target_pos_modelspace[0] =  projected_target_coord[0];\n  target_pos_modelspace[1] =  projected_target_coord[1];\n  target_pos_modelspace[2] = vec2(project_scale(instanceTargetPositions.z), 0.0);\n  target_pos_modelspace[3] = vec2(1.0, 0.0);\n\n  vec4 target_pos_clipspace = project_to_clipspace_fp64(target_pos_modelspace);\n\n  float segmentIndex = positions.x;\n  vec4 p = mix(source_pos_clipspace, target_pos_clipspace, segmentIndex);\n\n  vec2 offset = getExtrusionOffset(target_pos_clipspace.xy - source_pos_clipspace.xy, positions.y);\n\n  gl_Position = p + vec4(offset, 0.0, 0.0);\n\n  // Color\n  vec4 color = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  vec4 pickingColor = vec4(instancePickingColors / 255., 1.);\n\n  vColor = mix(\n    color,\n    pickingColor,\n    renderPickingBuffer\n  );\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvbGluZS1sYXllci9saW5lLWxheWVyLXZlcnRleC02NC5nbHNsLmpzPzViMWUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE2IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuZXhwb3J0IGRlZmF1bHQgYFxcXG4jZGVmaW5lIFNIQURFUl9OQU1FIGxpbmUtbGF5ZXItdmVydGV4LTY0LXNoYWRlclxuXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbnM7XG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVNvdXJjZVBvc2l0aW9ucztcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlVGFyZ2V0UG9zaXRpb25zO1xuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VTb3VyY2VUYXJnZXRQb3NpdGlvbnM2NHh5TG93O1xuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VDb2xvcnM7XG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBpY2tpbmdDb2xvcnM7XG5cbnVuaWZvcm0gdmVjMiB2aWV3cG9ydFNpemU7XG51bmlmb3JtIGZsb2F0IHN0cm9rZVdpZHRoO1xudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xudW5pZm9ybSBmbG9hdCByZW5kZXJQaWNraW5nQnVmZmVyO1xuXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xuXG4vLyBvZmZzZXQgdmVjdG9yIGJ5IHN0cm9rZVdpZHRoIHBpeGVsc1xuLy8gb2Zmc2V0X2RpcmVjdGlvbiBpcyAtMSAobGVmdCkgb3IgMSAocmlnaHQpXG52ZWMyIGdldEV4dHJ1c2lvbk9mZnNldCh2ZWMyIGxpbmVfY2xpcHNwYWNlLCBmbG9hdCBvZmZzZXRfZGlyZWN0aW9uKSB7XG4gIC8vIG5vcm1hbGl6ZWQgZGlyZWN0aW9uIG9mIHRoZSBsaW5lXG4gIHZlYzIgZGlyX3NjcmVlbnNwYWNlID0gbm9ybWFsaXplKGxpbmVfY2xpcHNwYWNlICogdmlld3BvcnRTaXplKTtcbiAgLy8gcm90YXRlIGJ5IDkwIGRlZ3JlZXNcbiAgZGlyX3NjcmVlbnNwYWNlID0gdmVjMigtZGlyX3NjcmVlbnNwYWNlLnksIGRpcl9zY3JlZW5zcGFjZS54KTtcblxuICB2ZWMyIG9mZnNldF9zY3JlZW5zcGFjZSA9IGRpcl9zY3JlZW5zcGFjZSAqIG9mZnNldF9kaXJlY3Rpb24gKiBzdHJva2VXaWR0aCAvIDIuMDtcbiAgdmVjMiBvZmZzZXRfY2xpcHNwYWNlID0gb2Zmc2V0X3NjcmVlbnNwYWNlIC8gdmlld3BvcnRTaXplICogMi4wO1xuXG4gIHJldHVybiBvZmZzZXRfY2xpcHNwYWNlO1xufVxuXG52b2lkIG1haW4odm9pZCkge1xuICAvLyBQb3NpdGlvblxuICB2ZWM0IGluc3RhbmNlU291cmNlUG9zaXRpb25zNjQgPSB2ZWM0KFxuICAgIGluc3RhbmNlU291cmNlUG9zaXRpb25zLngsIGluc3RhbmNlU291cmNlVGFyZ2V0UG9zaXRpb25zNjR4eUxvdy54LFxuICAgIGluc3RhbmNlU291cmNlUG9zaXRpb25zLnksIGluc3RhbmNlU291cmNlVGFyZ2V0UG9zaXRpb25zNjR4eUxvdy55KTtcblxuICB2ZWM0IGluc3RhbmNlVGFyZ2V0UG9zaXRpb25zNjQgPSB2ZWM0KFxuICAgIGluc3RhbmNlVGFyZ2V0UG9zaXRpb25zLngsIGluc3RhbmNlU291cmNlVGFyZ2V0UG9zaXRpb25zNjR4eUxvdy56LFxuICAgIGluc3RhbmNlVGFyZ2V0UG9zaXRpb25zLnksIGluc3RhbmNlU291cmNlVGFyZ2V0UG9zaXRpb25zNjR4eUxvdy53KTtcblxuICB2ZWMyIHByb2plY3RlZF9zb3VyY2VfY29vcmRbMl07XG4gIHZlYzIgcHJvamVjdGVkX3RhcmdldF9jb29yZFsyXTtcblxuICBwcm9qZWN0X3Bvc2l0aW9uX2ZwNjQoaW5zdGFuY2VTb3VyY2VQb3NpdGlvbnM2NCwgcHJvamVjdGVkX3NvdXJjZV9jb29yZCk7XG4gIHByb2plY3RfcG9zaXRpb25fZnA2NChpbnN0YW5jZVRhcmdldFBvc2l0aW9uczY0LCBwcm9qZWN0ZWRfdGFyZ2V0X2Nvb3JkKTtcblxuICB2ZWMyIHNvdXJjZV9wb3NfbW9kZWxzcGFjZVs0XTtcbiAgc291cmNlX3Bvc19tb2RlbHNwYWNlWzBdID0gIHByb2plY3RlZF9zb3VyY2VfY29vcmRbMF07XG4gIHNvdXJjZV9wb3NfbW9kZWxzcGFjZVsxXSA9ICBwcm9qZWN0ZWRfc291cmNlX2Nvb3JkWzFdO1xuICBzb3VyY2VfcG9zX21vZGVsc3BhY2VbMl0gPSB2ZWMyKHByb2plY3Rfc2NhbGUoaW5zdGFuY2VTb3VyY2VQb3NpdGlvbnMueiksIDAuMCk7XG4gIHNvdXJjZV9wb3NfbW9kZWxzcGFjZVszXSA9IHZlYzIoMS4wLCAwLjApO1xuXG4gIHZlYzQgc291cmNlX3Bvc19jbGlwc3BhY2UgPSBwcm9qZWN0X3RvX2NsaXBzcGFjZV9mcDY0KHNvdXJjZV9wb3NfbW9kZWxzcGFjZSk7XG5cbiAgdmVjMiB0YXJnZXRfcG9zX21vZGVsc3BhY2VbNF07XG4gIHRhcmdldF9wb3NfbW9kZWxzcGFjZVswXSA9ICBwcm9qZWN0ZWRfdGFyZ2V0X2Nvb3JkWzBdO1xuICB0YXJnZXRfcG9zX21vZGVsc3BhY2VbMV0gPSAgcHJvamVjdGVkX3RhcmdldF9jb29yZFsxXTtcbiAgdGFyZ2V0X3Bvc19tb2RlbHNwYWNlWzJdID0gdmVjMihwcm9qZWN0X3NjYWxlKGluc3RhbmNlVGFyZ2V0UG9zaXRpb25zLnopLCAwLjApO1xuICB0YXJnZXRfcG9zX21vZGVsc3BhY2VbM10gPSB2ZWMyKDEuMCwgMC4wKTtcblxuICB2ZWM0IHRhcmdldF9wb3NfY2xpcHNwYWNlID0gcHJvamVjdF90b19jbGlwc3BhY2VfZnA2NCh0YXJnZXRfcG9zX21vZGVsc3BhY2UpO1xuXG4gIGZsb2F0IHNlZ21lbnRJbmRleCA9IHBvc2l0aW9ucy54O1xuICB2ZWM0IHAgPSBtaXgoc291cmNlX3Bvc19jbGlwc3BhY2UsIHRhcmdldF9wb3NfY2xpcHNwYWNlLCBzZWdtZW50SW5kZXgpO1xuXG4gIHZlYzIgb2Zmc2V0ID0gZ2V0RXh0cnVzaW9uT2Zmc2V0KHRhcmdldF9wb3NfY2xpcHNwYWNlLnh5IC0gc291cmNlX3Bvc19jbGlwc3BhY2UueHksIHBvc2l0aW9ucy55KTtcblxuICBnbF9Qb3NpdGlvbiA9IHAgKyB2ZWM0KG9mZnNldCwgMC4wLCAwLjApO1xuXG4gIC8vIENvbG9yXG4gIHZlYzQgY29sb3IgPSB2ZWM0KGluc3RhbmNlQ29sb3JzLnJnYiwgaW5zdGFuY2VDb2xvcnMuYSAqIG9wYWNpdHkpIC8gMjU1LjtcbiAgdmVjNCBwaWNraW5nQ29sb3IgPSB2ZWM0KGluc3RhbmNlUGlja2luZ0NvbG9ycyAvIDI1NS4sIDEuKTtcblxuICB2Q29sb3IgPSBtaXgoXG4gICAgY29sb3IsXG4gICAgcGlja2luZ0NvbG9yLFxuICAgIHJlbmRlclBpY2tpbmdCdWZmZXJcbiAgKTtcbn1cbmA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9sYXllcnMvY29yZS9saW5lLWxheWVyL2xpbmUtbGF5ZXItdmVydGV4LTY0Lmdsc2wuanNcbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 71 */
/* exports provided: default */
/* exports used: default */
/*!**************************************************************!*\
  !*** ./src/layers/core/line-layer/line-layer-vertex.glsl.js ***!
  \**************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME line-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 instanceSourcePositions;\nattribute vec3 instanceTargetPositions;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform vec2 viewportSize;\nuniform float strokeWidth;\nuniform float opacity;\nuniform float renderPickingBuffer;\n\nvarying vec4 vColor;\n\n// offset vector by strokeWidth pixels\n// offset_direction is -1 (left) or 1 (right)\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace * viewportSize);\n  // rotate by 90 degrees\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  vec2 offset_screenspace = dir_screenspace * offset_direction * strokeWidth / 2.0;\n  vec2 offset_clipspace = offset_screenspace / viewportSize * 2.0;\n\n  return offset_clipspace;\n}\n\nvoid main(void) {\n  // Position\n  vec3 sourcePos = project_position(instanceSourcePositions);\n  vec3 targetPos = project_position(instanceTargetPositions);\n  vec4 source = project_to_clipspace(vec4(sourcePos, 1.0));\n  vec4 target = project_to_clipspace(vec4(targetPos, 1.0));\n\n  // linear interpolation of source & target to pick right coord\n  float segmentIndex = positions.x;\n  vec4 p = mix(source, target, segmentIndex);\n\n  // extrude\n  vec2 offset = getExtrusionOffset(target.xy - source.xy, positions.y);\n  gl_Position = p + vec4(offset, 0.0, 0.0);\n\n  // Color\n  vec4 color = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  vec4 pickingColor = vec4(instancePickingColors / 255., 1.);\n  vColor = mix(\n    color,\n    pickingColor,\n    renderPickingBuffer\n  );\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvbGluZS1sYXllci9saW5lLWxheWVyLXZlcnRleC5nbHNsLmpzPzI5M2QiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuZXhwb3J0IGRlZmF1bHQgYFxcXG4jZGVmaW5lIFNIQURFUl9OQU1FIGxpbmUtbGF5ZXItdmVydGV4LXNoYWRlclxuXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbnM7XG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVNvdXJjZVBvc2l0aW9ucztcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlVGFyZ2V0UG9zaXRpb25zO1xuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VDb2xvcnM7XG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBpY2tpbmdDb2xvcnM7XG5cbnVuaWZvcm0gdmVjMiB2aWV3cG9ydFNpemU7XG51bmlmb3JtIGZsb2F0IHN0cm9rZVdpZHRoO1xudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xudW5pZm9ybSBmbG9hdCByZW5kZXJQaWNraW5nQnVmZmVyO1xuXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xuXG4vLyBvZmZzZXQgdmVjdG9yIGJ5IHN0cm9rZVdpZHRoIHBpeGVsc1xuLy8gb2Zmc2V0X2RpcmVjdGlvbiBpcyAtMSAobGVmdCkgb3IgMSAocmlnaHQpXG52ZWMyIGdldEV4dHJ1c2lvbk9mZnNldCh2ZWMyIGxpbmVfY2xpcHNwYWNlLCBmbG9hdCBvZmZzZXRfZGlyZWN0aW9uKSB7XG4gIC8vIG5vcm1hbGl6ZWQgZGlyZWN0aW9uIG9mIHRoZSBsaW5lXG4gIHZlYzIgZGlyX3NjcmVlbnNwYWNlID0gbm9ybWFsaXplKGxpbmVfY2xpcHNwYWNlICogdmlld3BvcnRTaXplKTtcbiAgLy8gcm90YXRlIGJ5IDkwIGRlZ3JlZXNcbiAgZGlyX3NjcmVlbnNwYWNlID0gdmVjMigtZGlyX3NjcmVlbnNwYWNlLnksIGRpcl9zY3JlZW5zcGFjZS54KTtcblxuICB2ZWMyIG9mZnNldF9zY3JlZW5zcGFjZSA9IGRpcl9zY3JlZW5zcGFjZSAqIG9mZnNldF9kaXJlY3Rpb24gKiBzdHJva2VXaWR0aCAvIDIuMDtcbiAgdmVjMiBvZmZzZXRfY2xpcHNwYWNlID0gb2Zmc2V0X3NjcmVlbnNwYWNlIC8gdmlld3BvcnRTaXplICogMi4wO1xuXG4gIHJldHVybiBvZmZzZXRfY2xpcHNwYWNlO1xufVxuXG52b2lkIG1haW4odm9pZCkge1xuICAvLyBQb3NpdGlvblxuICB2ZWMzIHNvdXJjZVBvcyA9IHByb2plY3RfcG9zaXRpb24oaW5zdGFuY2VTb3VyY2VQb3NpdGlvbnMpO1xuICB2ZWMzIHRhcmdldFBvcyA9IHByb2plY3RfcG9zaXRpb24oaW5zdGFuY2VUYXJnZXRQb3NpdGlvbnMpO1xuICB2ZWM0IHNvdXJjZSA9IHByb2plY3RfdG9fY2xpcHNwYWNlKHZlYzQoc291cmNlUG9zLCAxLjApKTtcbiAgdmVjNCB0YXJnZXQgPSBwcm9qZWN0X3RvX2NsaXBzcGFjZSh2ZWM0KHRhcmdldFBvcywgMS4wKSk7XG5cbiAgLy8gbGluZWFyIGludGVycG9sYXRpb24gb2Ygc291cmNlICYgdGFyZ2V0IHRvIHBpY2sgcmlnaHQgY29vcmRcbiAgZmxvYXQgc2VnbWVudEluZGV4ID0gcG9zaXRpb25zLng7XG4gIHZlYzQgcCA9IG1peChzb3VyY2UsIHRhcmdldCwgc2VnbWVudEluZGV4KTtcblxuICAvLyBleHRydWRlXG4gIHZlYzIgb2Zmc2V0ID0gZ2V0RXh0cnVzaW9uT2Zmc2V0KHRhcmdldC54eSAtIHNvdXJjZS54eSwgcG9zaXRpb25zLnkpO1xuICBnbF9Qb3NpdGlvbiA9IHAgKyB2ZWM0KG9mZnNldCwgMC4wLCAwLjApO1xuXG4gIC8vIENvbG9yXG4gIHZlYzQgY29sb3IgPSB2ZWM0KGluc3RhbmNlQ29sb3JzLnJnYiwgaW5zdGFuY2VDb2xvcnMuYSAqIG9wYWNpdHkpIC8gMjU1LjtcbiAgdmVjNCBwaWNraW5nQ29sb3IgPSB2ZWM0KGluc3RhbmNlUGlja2luZ0NvbG9ycyAvIDI1NS4sIDEuKTtcbiAgdkNvbG9yID0gbWl4KFxuICAgIGNvbG9yLFxuICAgIHBpY2tpbmdDb2xvcixcbiAgICByZW5kZXJQaWNraW5nQnVmZmVyXG4gICk7XG59XG5gO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGF5ZXJzL2NvcmUvbGluZS1sYXllci9saW5lLWxheWVyLXZlcnRleC5nbHNsLmpzXG4vLyBtb2R1bGUgaWQgPSA3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 72 */
/* exports provided: default */
/* exports used: default */
/*!****************************************************************!*\
  !*** ./src/layers/core/path-layer/path-layer-fragment.glsl.js ***!
  \****************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME path-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform float jointType;\nuniform float miterLimit;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\n\nvoid main(void) {\n  // if joint is rounded, test distance from the corner\n  if (jointType > 0.0 && vMiterLength > 0.0 && length(vCornerOffset) > 1.0) {\n    discard;\n  }\n  if (jointType == 0.0 && vMiterLength > miterLimit) {\n    discard;\n  }\n  gl_FragColor = vColor;\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvcGF0aC1sYXllci9wYXRoLWxheWVyLWZyYWdtZW50Lmdsc2wuanM/OWUxNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTYgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbiNkZWZpbmUgU0hBREVSX05BTUUgcGF0aC1sYXllci1mcmFnbWVudC1zaGFkZXJcblxuI2lmZGVmIEdMX0VTXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4jZW5kaWZcblxudW5pZm9ybSBmbG9hdCBqb2ludFR5cGU7XG51bmlmb3JtIGZsb2F0IG1pdGVyTGltaXQ7XG5cbnZhcnlpbmcgdmVjNCB2Q29sb3I7XG52YXJ5aW5nIHZlYzIgdkNvcm5lck9mZnNldDtcbnZhcnlpbmcgZmxvYXQgdk1pdGVyTGVuZ3RoO1xuXG52b2lkIG1haW4odm9pZCkge1xuICAvLyBpZiBqb2ludCBpcyByb3VuZGVkLCB0ZXN0IGRpc3RhbmNlIGZyb20gdGhlIGNvcm5lclxuICBpZiAoam9pbnRUeXBlID4gMC4wICYmIHZNaXRlckxlbmd0aCA+IDAuMCAmJiBsZW5ndGgodkNvcm5lck9mZnNldCkgPiAxLjApIHtcbiAgICBkaXNjYXJkO1xuICB9XG4gIGlmIChqb2ludFR5cGUgPT0gMC4wICYmIHZNaXRlckxlbmd0aCA+IG1pdGVyTGltaXQpIHtcbiAgICBkaXNjYXJkO1xuICB9XG4gIGdsX0ZyYWdDb2xvciA9IHZDb2xvcjtcbn1cbmA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9sYXllcnMvY29yZS9wYXRoLWxheWVyL3BhdGgtbGF5ZXItZnJhZ21lbnQuZ2xzbC5qc1xuLy8gbW9kdWxlIGlkID0gNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 73 */
/* exports provided: default */
/* exports used: default */
/*!*****************************************************************!*\
  !*** ./src/layers/core/path-layer/path-layer-vertex-64.glsl.js ***!
  \*****************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n\n#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec4 instanceStartEndPositions64xyLow;\nattribute vec3 instanceLeftDeltas;\nattribute vec3 instanceRightDeltas;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float miterLimit;\n\nuniform float opacity;\nuniform float renderPickingBuffer;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\n\nconst float EPSILON = 0.001;\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\nvec3 lineJoin(vec3 prevPoint, vec3 currPoint, vec3 nextPoint) {\n\n  float width = clamp(project_scale(instanceStrokeWidths * widthScale),\n    widthMinPixels, widthMaxPixels) / 2.0;\n\n  vec2 deltaA = currPoint.xy - prevPoint.xy;\n  vec2 deltaB = nextPoint.xy - currPoint.xy;\n\n  vec2 offsetVec;\n  float offsetScale;\n  float offsetDirection;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(1.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(1.0, 0.0);\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n\n  // tangent of the corner\n  vec2 tangent = vec2(dirA + dirB);\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  // direction of the corner\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  // width offset from current position\n  vec2 perp = mix(perpB, perpA, positions.x);\n  float L = mix(lenB, lenA, positions.x);\n\n  // cap super sharp angles\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n  bool turnsRight = dirA.x * dirB.y > dirA.y * dirB.x;\n\n  // relative position to the corner:\n  // -1: inside (smaller side of the angle)\n  // 0: center\n  // 1: outside (bigger side of the angle)\n  float cornerPosition = mix(\n    flipIfTrue(turnsRight == (positions.y > 0.0)),\n    0.0,\n    positions.z\n  );\n\n  offsetScale = 1.0 / max(sinHalfA, EPSILON);\n\n  // do not bevel if line segment is too short\n  cornerPosition *= float(cornerPosition <= 0.0 || sinHalfA < min(lenA, lenB) / width * cosHalfA);\n  // trim if inside corner extends further than the line segment\n  offsetScale = mix(\n    offsetScale,\n    min(offsetScale, L / width / max(cosHalfA, EPSILON)),\n    float(cornerPosition < 0.0)\n  );\n\n  vMiterLength = mix(\n    offsetScale * cornerPosition,\n    mix(offsetScale, 0.0, cornerPosition),\n    step(0.0, cornerPosition)\n  ) - sinHalfA * jointType;\n  offsetDirection = mix(\n    positions.y,\n    mix(\n      flipIfTrue(turnsRight),\n      positions.y * flipIfTrue(turnsRight == (positions.x == 1.)),\n      cornerPosition\n    ),\n    step(0.0, cornerPosition)\n  );\n  offsetVec = mix(miterVec, -tangent, step(0.5, cornerPosition));\n  offsetScale = mix(offsetScale, 1.0 / max(cosHalfA, 0.001), step(0.5, cornerPosition));\n\n  // special treatment for start cap and end cap\n  float isStartCap = step(0.0, -lenA);\n  float isEndCap = step(0.0, -lenB);\n  float isCap = max(isStartCap, isEndCap);\n\n  // 0: center, 1: side\n  cornerPosition = isCap * (1.0 - positions.z);\n\n  // start of path: use next - curr\n  offsetVec = mix(offsetVec, mix(dirB, perpB, cornerPosition), isStartCap);\n  // end of path: use curr - prev\n  offsetVec = mix(offsetVec, mix(dirA, perpA, cornerPosition), isEndCap);\n\n  // extend out a triangle to envelope the round cap\n  offsetScale = mix(\n    offsetScale,\n    mix(4.0 * jointType, 1.0, cornerPosition),\n    isCap\n  );\n  vMiterLength = mix(vMiterLength, 1.0 - cornerPosition, isCap);\n\n  offsetDirection = mix(\n    offsetDirection,\n    mix(flipIfTrue(isStartCap > 0.), positions.y, cornerPosition),\n    isCap\n  );\n\n  vCornerOffset = offsetVec * offsetDirection * offsetScale;\n\n  return vec3(vCornerOffset * width, 0.0);\n}\n\nvoid main() {\n  vec4 color = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  vec4 pickingColor = vec4(instancePickingColors, 255.) / 255.;\n  vColor = mix(color, pickingColor, renderPickingBuffer);\n\n  float isEnd = positions.x;\n\n  // Calculate previous position\n  vec3 prevPosition = mix(-instanceLeftDeltas, vec3(0.0), isEnd) + instanceStartPositions;\n  prevPosition = project_position(prevPosition);\n\n  // Calculate current position\n  // Only here we need to do the 64-bit calculations.\n\n  vec2 instanceStartPositions64[2];\n  instanceStartPositions64[0] = vec2(instanceStartPositions.x, instanceStartEndPositions64xyLow.x);\n  instanceStartPositions64[1] = vec2(instanceStartPositions.y, instanceStartEndPositions64xyLow.y);\n\n  vec2 instanceEndPositions64[2];\n  instanceEndPositions64[0] = vec2(instanceEndPositions.x, instanceStartEndPositions64xyLow.z);\n  instanceEndPositions64[1] = vec2(instanceEndPositions.y, instanceStartEndPositions64xyLow.w);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n\n  vec2 tempCurrPosition64[2];\n  vec2_mix_fp64(instanceStartPositions64, instanceEndPositions64, isEnd, tempCurrPosition64);\n\n  vec4 currPosition64 = vec4(tempCurrPosition64[0].xy, tempCurrPosition64[1].xy);\n\n  vec2 projected_curr_position[2];\n  project_position_fp64(currPosition64, projected_curr_position);\n  float projected_curr_position_z = project_scale(currPosition.z);\n\n  currPosition = project_position(currPosition);\n\n  // Calculate next positions\n  vec3 nextPosition = mix(vec3(0.0), instanceRightDeltas, isEnd) + instanceEndPositions;\n  nextPosition = project_position(nextPosition);\n\n  vec3 pos = lineJoin(prevPosition, currPosition, nextPosition);\n  vec2 vertex_pos_modelspace[4];\n  vertex_pos_modelspace[0] = sum_fp64(vec2(pos.x, 0.0), projected_curr_position[0]);\n  vertex_pos_modelspace[1] = sum_fp64(vec2(pos.y, 0.0), projected_curr_position[1]);\n  vertex_pos_modelspace[2] = vec2(pos.z + projected_curr_position_z, 0.0);\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\n\n  gl_Position = project_to_clipspace_fp64(vertex_pos_modelspace);\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvcGF0aC1sYXllci9wYXRoLWxheWVyLXZlcnRleC02NC5nbHNsLmpzP2Y0MDYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE2IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuZXhwb3J0IGRlZmF1bHQgYFxcXG5cbiNkZWZpbmUgU0hBREVSX05BTUUgcGF0aC1sYXllci12ZXJ0ZXgtc2hhZGVyXG5cbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9ucztcblxuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VTdGFydFBvc2l0aW9ucztcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlRW5kUG9zaXRpb25zO1xuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VTdGFydEVuZFBvc2l0aW9uczY0eHlMb3c7XG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZUxlZnREZWx0YXM7XG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVJpZ2h0RGVsdGFzO1xuYXR0cmlidXRlIGZsb2F0IGluc3RhbmNlU3Ryb2tlV2lkdGhzO1xuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VDb2xvcnM7XG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBpY2tpbmdDb2xvcnM7XG5cbnVuaWZvcm0gZmxvYXQgd2lkdGhTY2FsZTtcbnVuaWZvcm0gZmxvYXQgd2lkdGhNaW5QaXhlbHM7XG51bmlmb3JtIGZsb2F0IHdpZHRoTWF4UGl4ZWxzO1xudW5pZm9ybSBmbG9hdCBqb2ludFR5cGU7XG51bmlmb3JtIGZsb2F0IG1pdGVyTGltaXQ7XG5cbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcbnVuaWZvcm0gZmxvYXQgcmVuZGVyUGlja2luZ0J1ZmZlcjtcblxudmFyeWluZyB2ZWM0IHZDb2xvcjtcbnZhcnlpbmcgdmVjMiB2Q29ybmVyT2Zmc2V0O1xudmFyeWluZyBmbG9hdCB2TWl0ZXJMZW5ndGg7XG5cbmNvbnN0IGZsb2F0IEVQU0lMT04gPSAwLjAwMTtcblxuZmxvYXQgZmxpcElmVHJ1ZShib29sIGZsYWcpIHtcbiAgcmV0dXJuIC0oZmxvYXQoZmxhZykgKiAyLiAtIDEuKTtcbn1cbnZlYzMgbGluZUpvaW4odmVjMyBwcmV2UG9pbnQsIHZlYzMgY3VyclBvaW50LCB2ZWMzIG5leHRQb2ludCkge1xuXG4gIGZsb2F0IHdpZHRoID0gY2xhbXAocHJvamVjdF9zY2FsZShpbnN0YW5jZVN0cm9rZVdpZHRocyAqIHdpZHRoU2NhbGUpLFxuICAgIHdpZHRoTWluUGl4ZWxzLCB3aWR0aE1heFBpeGVscykgLyAyLjA7XG5cbiAgdmVjMiBkZWx0YUEgPSBjdXJyUG9pbnQueHkgLSBwcmV2UG9pbnQueHk7XG4gIHZlYzIgZGVsdGFCID0gbmV4dFBvaW50Lnh5IC0gY3VyclBvaW50Lnh5O1xuXG4gIHZlYzIgb2Zmc2V0VmVjO1xuICBmbG9hdCBvZmZzZXRTY2FsZTtcbiAgZmxvYXQgb2Zmc2V0RGlyZWN0aW9uO1xuXG4gIGZsb2F0IGxlbkEgPSBsZW5ndGgoZGVsdGFBKTtcbiAgZmxvYXQgbGVuQiA9IGxlbmd0aChkZWx0YUIpO1xuICB2ZWMyIGRpckEgPSBsZW5BID4gMC4gPyBub3JtYWxpemUoZGVsdGFBKSA6IHZlYzIoMS4wLCAwLjApO1xuICB2ZWMyIGRpckIgPSBsZW5CID4gMC4gPyBub3JtYWxpemUoZGVsdGFCKSA6IHZlYzIoMS4wLCAwLjApO1xuICB2ZWMyIHBlcnBBID0gdmVjMigtZGlyQS55LCBkaXJBLngpO1xuICB2ZWMyIHBlcnBCID0gdmVjMigtZGlyQi55LCBkaXJCLngpO1xuXG4gIC8vIHRhbmdlbnQgb2YgdGhlIGNvcm5lclxuICB2ZWMyIHRhbmdlbnQgPSB2ZWMyKGRpckEgKyBkaXJCKTtcbiAgdGFuZ2VudCA9IGxlbmd0aCh0YW5nZW50KSA+IDAuID8gbm9ybWFsaXplKHRhbmdlbnQpIDogcGVycEE7XG4gIC8vIGRpcmVjdGlvbiBvZiB0aGUgY29ybmVyXG4gIHZlYzIgbWl0ZXJWZWMgPSB2ZWMyKC10YW5nZW50LnksIHRhbmdlbnQueCk7XG4gIC8vIHdpZHRoIG9mZnNldCBmcm9tIGN1cnJlbnQgcG9zaXRpb25cbiAgdmVjMiBwZXJwID0gbWl4KHBlcnBCLCBwZXJwQSwgcG9zaXRpb25zLngpO1xuICBmbG9hdCBMID0gbWl4KGxlbkIsIGxlbkEsIHBvc2l0aW9ucy54KTtcblxuICAvLyBjYXAgc3VwZXIgc2hhcnAgYW5nbGVzXG4gIGZsb2F0IHNpbkhhbGZBID0gYWJzKGRvdChtaXRlclZlYywgcGVycCkpO1xuICBmbG9hdCBjb3NIYWxmQSA9IGFicyhkb3QoZGlyQSwgbWl0ZXJWZWMpKTtcbiAgYm9vbCB0dXJuc1JpZ2h0ID0gZGlyQS54ICogZGlyQi55ID4gZGlyQS55ICogZGlyQi54O1xuXG4gIC8vIHJlbGF0aXZlIHBvc2l0aW9uIHRvIHRoZSBjb3JuZXI6XG4gIC8vIC0xOiBpbnNpZGUgKHNtYWxsZXIgc2lkZSBvZiB0aGUgYW5nbGUpXG4gIC8vIDA6IGNlbnRlclxuICAvLyAxOiBvdXRzaWRlIChiaWdnZXIgc2lkZSBvZiB0aGUgYW5nbGUpXG4gIGZsb2F0IGNvcm5lclBvc2l0aW9uID0gbWl4KFxuICAgIGZsaXBJZlRydWUodHVybnNSaWdodCA9PSAocG9zaXRpb25zLnkgPiAwLjApKSxcbiAgICAwLjAsXG4gICAgcG9zaXRpb25zLnpcbiAgKTtcblxuICBvZmZzZXRTY2FsZSA9IDEuMCAvIG1heChzaW5IYWxmQSwgRVBTSUxPTik7XG5cbiAgLy8gZG8gbm90IGJldmVsIGlmIGxpbmUgc2VnbWVudCBpcyB0b28gc2hvcnRcbiAgY29ybmVyUG9zaXRpb24gKj0gZmxvYXQoY29ybmVyUG9zaXRpb24gPD0gMC4wIHx8IHNpbkhhbGZBIDwgbWluKGxlbkEsIGxlbkIpIC8gd2lkdGggKiBjb3NIYWxmQSk7XG4gIC8vIHRyaW0gaWYgaW5zaWRlIGNvcm5lciBleHRlbmRzIGZ1cnRoZXIgdGhhbiB0aGUgbGluZSBzZWdtZW50XG4gIG9mZnNldFNjYWxlID0gbWl4KFxuICAgIG9mZnNldFNjYWxlLFxuICAgIG1pbihvZmZzZXRTY2FsZSwgTCAvIHdpZHRoIC8gbWF4KGNvc0hhbGZBLCBFUFNJTE9OKSksXG4gICAgZmxvYXQoY29ybmVyUG9zaXRpb24gPCAwLjApXG4gICk7XG5cbiAgdk1pdGVyTGVuZ3RoID0gbWl4KFxuICAgIG9mZnNldFNjYWxlICogY29ybmVyUG9zaXRpb24sXG4gICAgbWl4KG9mZnNldFNjYWxlLCAwLjAsIGNvcm5lclBvc2l0aW9uKSxcbiAgICBzdGVwKDAuMCwgY29ybmVyUG9zaXRpb24pXG4gICkgLSBzaW5IYWxmQSAqIGpvaW50VHlwZTtcbiAgb2Zmc2V0RGlyZWN0aW9uID0gbWl4KFxuICAgIHBvc2l0aW9ucy55LFxuICAgIG1peChcbiAgICAgIGZsaXBJZlRydWUodHVybnNSaWdodCksXG4gICAgICBwb3NpdGlvbnMueSAqIGZsaXBJZlRydWUodHVybnNSaWdodCA9PSAocG9zaXRpb25zLnggPT0gMS4pKSxcbiAgICAgIGNvcm5lclBvc2l0aW9uXG4gICAgKSxcbiAgICBzdGVwKDAuMCwgY29ybmVyUG9zaXRpb24pXG4gICk7XG4gIG9mZnNldFZlYyA9IG1peChtaXRlclZlYywgLXRhbmdlbnQsIHN0ZXAoMC41LCBjb3JuZXJQb3NpdGlvbikpO1xuICBvZmZzZXRTY2FsZSA9IG1peChvZmZzZXRTY2FsZSwgMS4wIC8gbWF4KGNvc0hhbGZBLCAwLjAwMSksIHN0ZXAoMC41LCBjb3JuZXJQb3NpdGlvbikpO1xuXG4gIC8vIHNwZWNpYWwgdHJlYXRtZW50IGZvciBzdGFydCBjYXAgYW5kIGVuZCBjYXBcbiAgZmxvYXQgaXNTdGFydENhcCA9IHN0ZXAoMC4wLCAtbGVuQSk7XG4gIGZsb2F0IGlzRW5kQ2FwID0gc3RlcCgwLjAsIC1sZW5CKTtcbiAgZmxvYXQgaXNDYXAgPSBtYXgoaXNTdGFydENhcCwgaXNFbmRDYXApO1xuXG4gIC8vIDA6IGNlbnRlciwgMTogc2lkZVxuICBjb3JuZXJQb3NpdGlvbiA9IGlzQ2FwICogKDEuMCAtIHBvc2l0aW9ucy56KTtcblxuICAvLyBzdGFydCBvZiBwYXRoOiB1c2UgbmV4dCAtIGN1cnJcbiAgb2Zmc2V0VmVjID0gbWl4KG9mZnNldFZlYywgbWl4KGRpckIsIHBlcnBCLCBjb3JuZXJQb3NpdGlvbiksIGlzU3RhcnRDYXApO1xuICAvLyBlbmQgb2YgcGF0aDogdXNlIGN1cnIgLSBwcmV2XG4gIG9mZnNldFZlYyA9IG1peChvZmZzZXRWZWMsIG1peChkaXJBLCBwZXJwQSwgY29ybmVyUG9zaXRpb24pLCBpc0VuZENhcCk7XG5cbiAgLy8gZXh0ZW5kIG91dCBhIHRyaWFuZ2xlIHRvIGVudmVsb3BlIHRoZSByb3VuZCBjYXBcbiAgb2Zmc2V0U2NhbGUgPSBtaXgoXG4gICAgb2Zmc2V0U2NhbGUsXG4gICAgbWl4KDQuMCAqIGpvaW50VHlwZSwgMS4wLCBjb3JuZXJQb3NpdGlvbiksXG4gICAgaXNDYXBcbiAgKTtcbiAgdk1pdGVyTGVuZ3RoID0gbWl4KHZNaXRlckxlbmd0aCwgMS4wIC0gY29ybmVyUG9zaXRpb24sIGlzQ2FwKTtcblxuICBvZmZzZXREaXJlY3Rpb24gPSBtaXgoXG4gICAgb2Zmc2V0RGlyZWN0aW9uLFxuICAgIG1peChmbGlwSWZUcnVlKGlzU3RhcnRDYXAgPiAwLiksIHBvc2l0aW9ucy55LCBjb3JuZXJQb3NpdGlvbiksXG4gICAgaXNDYXBcbiAgKTtcblxuICB2Q29ybmVyT2Zmc2V0ID0gb2Zmc2V0VmVjICogb2Zmc2V0RGlyZWN0aW9uICogb2Zmc2V0U2NhbGU7XG5cbiAgcmV0dXJuIHZlYzModkNvcm5lck9mZnNldCAqIHdpZHRoLCAwLjApO1xufVxuXG52b2lkIG1haW4oKSB7XG4gIHZlYzQgY29sb3IgPSB2ZWM0KGluc3RhbmNlQ29sb3JzLnJnYiwgaW5zdGFuY2VDb2xvcnMuYSAqIG9wYWNpdHkpIC8gMjU1LjtcbiAgdmVjNCBwaWNraW5nQ29sb3IgPSB2ZWM0KGluc3RhbmNlUGlja2luZ0NvbG9ycywgMjU1LikgLyAyNTUuO1xuICB2Q29sb3IgPSBtaXgoY29sb3IsIHBpY2tpbmdDb2xvciwgcmVuZGVyUGlja2luZ0J1ZmZlcik7XG5cbiAgZmxvYXQgaXNFbmQgPSBwb3NpdGlvbnMueDtcblxuICAvLyBDYWxjdWxhdGUgcHJldmlvdXMgcG9zaXRpb25cbiAgdmVjMyBwcmV2UG9zaXRpb24gPSBtaXgoLWluc3RhbmNlTGVmdERlbHRhcywgdmVjMygwLjApLCBpc0VuZCkgKyBpbnN0YW5jZVN0YXJ0UG9zaXRpb25zO1xuICBwcmV2UG9zaXRpb24gPSBwcm9qZWN0X3Bvc2l0aW9uKHByZXZQb3NpdGlvbik7XG5cbiAgLy8gQ2FsY3VsYXRlIGN1cnJlbnQgcG9zaXRpb25cbiAgLy8gT25seSBoZXJlIHdlIG5lZWQgdG8gZG8gdGhlIDY0LWJpdCBjYWxjdWxhdGlvbnMuXG5cbiAgdmVjMiBpbnN0YW5jZVN0YXJ0UG9zaXRpb25zNjRbMl07XG4gIGluc3RhbmNlU3RhcnRQb3NpdGlvbnM2NFswXSA9IHZlYzIoaW5zdGFuY2VTdGFydFBvc2l0aW9ucy54LCBpbnN0YW5jZVN0YXJ0RW5kUG9zaXRpb25zNjR4eUxvdy54KTtcbiAgaW5zdGFuY2VTdGFydFBvc2l0aW9uczY0WzFdID0gdmVjMihpbnN0YW5jZVN0YXJ0UG9zaXRpb25zLnksIGluc3RhbmNlU3RhcnRFbmRQb3NpdGlvbnM2NHh5TG93LnkpO1xuXG4gIHZlYzIgaW5zdGFuY2VFbmRQb3NpdGlvbnM2NFsyXTtcbiAgaW5zdGFuY2VFbmRQb3NpdGlvbnM2NFswXSA9IHZlYzIoaW5zdGFuY2VFbmRQb3NpdGlvbnMueCwgaW5zdGFuY2VTdGFydEVuZFBvc2l0aW9uczY0eHlMb3cueik7XG4gIGluc3RhbmNlRW5kUG9zaXRpb25zNjRbMV0gPSB2ZWMyKGluc3RhbmNlRW5kUG9zaXRpb25zLnksIGluc3RhbmNlU3RhcnRFbmRQb3NpdGlvbnM2NHh5TG93LncpO1xuXG4gIHZlYzMgY3VyclBvc2l0aW9uID0gbWl4KGluc3RhbmNlU3RhcnRQb3NpdGlvbnMsIGluc3RhbmNlRW5kUG9zaXRpb25zLCBpc0VuZCk7XG5cbiAgdmVjMiB0ZW1wQ3VyclBvc2l0aW9uNjRbMl07XG4gIHZlYzJfbWl4X2ZwNjQoaW5zdGFuY2VTdGFydFBvc2l0aW9uczY0LCBpbnN0YW5jZUVuZFBvc2l0aW9uczY0LCBpc0VuZCwgdGVtcEN1cnJQb3NpdGlvbjY0KTtcblxuICB2ZWM0IGN1cnJQb3NpdGlvbjY0ID0gdmVjNCh0ZW1wQ3VyclBvc2l0aW9uNjRbMF0ueHksIHRlbXBDdXJyUG9zaXRpb242NFsxXS54eSk7XG5cbiAgdmVjMiBwcm9qZWN0ZWRfY3Vycl9wb3NpdGlvblsyXTtcbiAgcHJvamVjdF9wb3NpdGlvbl9mcDY0KGN1cnJQb3NpdGlvbjY0LCBwcm9qZWN0ZWRfY3Vycl9wb3NpdGlvbik7XG4gIGZsb2F0IHByb2plY3RlZF9jdXJyX3Bvc2l0aW9uX3ogPSBwcm9qZWN0X3NjYWxlKGN1cnJQb3NpdGlvbi56KTtcblxuICBjdXJyUG9zaXRpb24gPSBwcm9qZWN0X3Bvc2l0aW9uKGN1cnJQb3NpdGlvbik7XG5cbiAgLy8gQ2FsY3VsYXRlIG5leHQgcG9zaXRpb25zXG4gIHZlYzMgbmV4dFBvc2l0aW9uID0gbWl4KHZlYzMoMC4wKSwgaW5zdGFuY2VSaWdodERlbHRhcywgaXNFbmQpICsgaW5zdGFuY2VFbmRQb3NpdGlvbnM7XG4gIG5leHRQb3NpdGlvbiA9IHByb2plY3RfcG9zaXRpb24obmV4dFBvc2l0aW9uKTtcblxuICB2ZWMzIHBvcyA9IGxpbmVKb2luKHByZXZQb3NpdGlvbiwgY3VyclBvc2l0aW9uLCBuZXh0UG9zaXRpb24pO1xuICB2ZWMyIHZlcnRleF9wb3NfbW9kZWxzcGFjZVs0XTtcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzBdID0gc3VtX2ZwNjQodmVjMihwb3MueCwgMC4wKSwgcHJvamVjdGVkX2N1cnJfcG9zaXRpb25bMF0pO1xuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMV0gPSBzdW1fZnA2NCh2ZWMyKHBvcy55LCAwLjApLCBwcm9qZWN0ZWRfY3Vycl9wb3NpdGlvblsxXSk7XG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVsyXSA9IHZlYzIocG9zLnogKyBwcm9qZWN0ZWRfY3Vycl9wb3NpdGlvbl96LCAwLjApO1xuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbM10gPSB2ZWMyKDEuMCwgMC4wKTtcblxuICBnbF9Qb3NpdGlvbiA9IHByb2plY3RfdG9fY2xpcHNwYWNlX2ZwNjQodmVydGV4X3Bvc19tb2RlbHNwYWNlKTtcbn1cbmA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9sYXllcnMvY29yZS9wYXRoLWxheWVyL3BhdGgtbGF5ZXItdmVydGV4LTY0Lmdsc2wuanNcbi8vIG1vZHVsZSBpZCA9IDczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 74 */
/* exports provided: default */
/* exports used: default */
/*!**************************************************************!*\
  !*** ./src/layers/core/path-layer/path-layer-vertex.glsl.js ***!
  \**************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec3 instanceLeftDeltas;\nattribute vec3 instanceRightDeltas;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float miterLimit;\n\nuniform float opacity;\nuniform float renderPickingBuffer;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\n\nconst float EPSILON = 0.001;\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\n\n// calculate line join positions\nvec3 lineJoin(vec3 prevPoint, vec3 currPoint, vec3 nextPoint) {\n\n  float width = clamp(project_scale(instanceStrokeWidths * widthScale),\n    widthMinPixels, widthMaxPixels) / 2.0;\n\n  vec2 deltaA = currPoint.xy - prevPoint.xy;\n  vec2 deltaB = nextPoint.xy - currPoint.xy;\n\n  vec2 offsetVec;\n  float offsetScale;\n  float offsetDirection;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(1.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(1.0, 0.0);\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n\n  // tangent of the corner\n  vec2 tangent = vec2(dirA + dirB);\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  // direction of the corner\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  // width offset from current position\n  vec2 perp = mix(perpB, perpA, positions.x);\n  float L = mix(lenB, lenA, positions.x);\n\n  // cap super sharp angles\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n  bool turnsRight = dirA.x * dirB.y > dirA.y * dirB.x;\n\n  // relative position to the corner:\n  // -1: inside (smaller side of the angle)\n  // 0: center\n  // 1: outside (bigger side of the angle)\n  float cornerPosition = mix(\n    flipIfTrue(turnsRight == (positions.y > 0.0)),\n    0.0,\n    positions.z\n  );\n\n  offsetScale = 1.0 / max(sinHalfA, EPSILON);\n\n  // do not bevel if line segment is too short\n  cornerPosition *= float(cornerPosition <= 0.0 || sinHalfA < min(lenA, lenB) / width * cosHalfA);\n  // trim if inside corner extends further than the line segment\n  offsetScale = mix(\n    offsetScale,\n    min(offsetScale, L / width / max(cosHalfA, EPSILON)),\n    float(cornerPosition < 0.0)\n  );\n\n  vMiterLength = mix(\n    offsetScale * cornerPosition,\n    mix(offsetScale, 0.0, cornerPosition),\n    step(0.0, cornerPosition)\n  ) - sinHalfA * jointType;\n  offsetDirection = mix(\n    positions.y,\n    mix(\n      flipIfTrue(turnsRight),\n      positions.y * flipIfTrue(turnsRight == (positions.x == 1.)),\n      cornerPosition\n    ),\n    step(0.0, cornerPosition)\n  );\n  offsetVec = mix(miterVec, -tangent, step(0.5, cornerPosition));\n  offsetScale = mix(offsetScale, 1.0 / max(cosHalfA, 0.001), step(0.5, cornerPosition));\n\n  // special treatment for start cap and end cap\n  float isStartCap = step(0.0, -lenA);\n  float isEndCap = step(0.0, -lenB);\n  float isCap = max(isStartCap, isEndCap);\n\n  // 0: center, 1: side\n  cornerPosition = isCap * (1.0 - positions.z);\n\n  // start of path: use next - curr\n  offsetVec = mix(offsetVec, mix(dirB, perpB, cornerPosition), isStartCap);\n  // end of path: use curr - prev\n  offsetVec = mix(offsetVec, mix(dirA, perpA, cornerPosition), isEndCap);\n\n  // extend out a triangle to envelope the round cap\n  offsetScale = mix(\n    offsetScale,\n    mix(4.0 * jointType, 1.0, cornerPosition),\n    isCap\n  );\n  vMiterLength = mix(vMiterLength, 1.0 - cornerPosition, isCap);\n\n  offsetDirection = mix(\n    offsetDirection,\n    mix(flipIfTrue(isStartCap > 0.), positions.y, cornerPosition),\n    isCap\n  );\n\n  vCornerOffset = offsetVec * offsetDirection * offsetScale;\n\n  return currPoint + vec3(vCornerOffset * width, 0.0);\n}\n\nvoid main() {\n  vec4 color = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  vec4 pickingColor = vec4(instancePickingColors, 255.) / 255.;\n  vColor = mix(color, pickingColor, renderPickingBuffer);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(-instanceLeftDeltas, vec3(0.0), isEnd) + instanceStartPositions;\n  prevPosition = project_position(prevPosition);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  currPosition = project_position(currPosition);\n\n  vec3 nextPosition = mix(vec3(0.0), instanceRightDeltas, isEnd) + instanceEndPositions;\n  nextPosition = project_position(nextPosition);\n\n  vec3 pos;\n\n  pos = lineJoin(prevPosition, currPosition, nextPosition);\n\n  gl_Position = project_to_clipspace(vec4(pos, 1.0));\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvcGF0aC1sYXllci9wYXRoLWxheWVyLXZlcnRleC5nbHNsLmpzPzY0MjkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE2IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuZXhwb3J0IGRlZmF1bHQgYFxcXG4jZGVmaW5lIFNIQURFUl9OQU1FIHBhdGgtbGF5ZXItdmVydGV4LXNoYWRlclxuXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbnM7XG5cbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlU3RhcnRQb3NpdGlvbnM7XG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZUVuZFBvc2l0aW9ucztcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlTGVmdERlbHRhcztcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUmlnaHREZWx0YXM7XG5hdHRyaWJ1dGUgZmxvYXQgaW5zdGFuY2VTdHJva2VXaWR0aHM7XG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZUNvbG9ycztcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUGlja2luZ0NvbG9ycztcblxudW5pZm9ybSBmbG9hdCB3aWR0aFNjYWxlO1xudW5pZm9ybSBmbG9hdCB3aWR0aE1pblBpeGVscztcbnVuaWZvcm0gZmxvYXQgd2lkdGhNYXhQaXhlbHM7XG51bmlmb3JtIGZsb2F0IGpvaW50VHlwZTtcbnVuaWZvcm0gZmxvYXQgbWl0ZXJMaW1pdDtcblxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xudW5pZm9ybSBmbG9hdCByZW5kZXJQaWNraW5nQnVmZmVyO1xuXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xudmFyeWluZyB2ZWMyIHZDb3JuZXJPZmZzZXQ7XG52YXJ5aW5nIGZsb2F0IHZNaXRlckxlbmd0aDtcblxuY29uc3QgZmxvYXQgRVBTSUxPTiA9IDAuMDAxO1xuXG5mbG9hdCBmbGlwSWZUcnVlKGJvb2wgZmxhZykge1xuICByZXR1cm4gLShmbG9hdChmbGFnKSAqIDIuIC0gMS4pO1xufVxuXG4vLyBjYWxjdWxhdGUgbGluZSBqb2luIHBvc2l0aW9uc1xudmVjMyBsaW5lSm9pbih2ZWMzIHByZXZQb2ludCwgdmVjMyBjdXJyUG9pbnQsIHZlYzMgbmV4dFBvaW50KSB7XG5cbiAgZmxvYXQgd2lkdGggPSBjbGFtcChwcm9qZWN0X3NjYWxlKGluc3RhbmNlU3Ryb2tlV2lkdGhzICogd2lkdGhTY2FsZSksXG4gICAgd2lkdGhNaW5QaXhlbHMsIHdpZHRoTWF4UGl4ZWxzKSAvIDIuMDtcblxuICB2ZWMyIGRlbHRhQSA9IGN1cnJQb2ludC54eSAtIHByZXZQb2ludC54eTtcbiAgdmVjMiBkZWx0YUIgPSBuZXh0UG9pbnQueHkgLSBjdXJyUG9pbnQueHk7XG5cbiAgdmVjMiBvZmZzZXRWZWM7XG4gIGZsb2F0IG9mZnNldFNjYWxlO1xuICBmbG9hdCBvZmZzZXREaXJlY3Rpb247XG5cbiAgZmxvYXQgbGVuQSA9IGxlbmd0aChkZWx0YUEpO1xuICBmbG9hdCBsZW5CID0gbGVuZ3RoKGRlbHRhQik7XG4gIHZlYzIgZGlyQSA9IGxlbkEgPiAwLiA/IG5vcm1hbGl6ZShkZWx0YUEpIDogdmVjMigxLjAsIDAuMCk7XG4gIHZlYzIgZGlyQiA9IGxlbkIgPiAwLiA/IG5vcm1hbGl6ZShkZWx0YUIpIDogdmVjMigxLjAsIDAuMCk7XG4gIHZlYzIgcGVycEEgPSB2ZWMyKC1kaXJBLnksIGRpckEueCk7XG4gIHZlYzIgcGVycEIgPSB2ZWMyKC1kaXJCLnksIGRpckIueCk7XG5cbiAgLy8gdGFuZ2VudCBvZiB0aGUgY29ybmVyXG4gIHZlYzIgdGFuZ2VudCA9IHZlYzIoZGlyQSArIGRpckIpO1xuICB0YW5nZW50ID0gbGVuZ3RoKHRhbmdlbnQpID4gMC4gPyBub3JtYWxpemUodGFuZ2VudCkgOiBwZXJwQTtcbiAgLy8gZGlyZWN0aW9uIG9mIHRoZSBjb3JuZXJcbiAgdmVjMiBtaXRlclZlYyA9IHZlYzIoLXRhbmdlbnQueSwgdGFuZ2VudC54KTtcbiAgLy8gd2lkdGggb2Zmc2V0IGZyb20gY3VycmVudCBwb3NpdGlvblxuICB2ZWMyIHBlcnAgPSBtaXgocGVycEIsIHBlcnBBLCBwb3NpdGlvbnMueCk7XG4gIGZsb2F0IEwgPSBtaXgobGVuQiwgbGVuQSwgcG9zaXRpb25zLngpO1xuXG4gIC8vIGNhcCBzdXBlciBzaGFycCBhbmdsZXNcbiAgZmxvYXQgc2luSGFsZkEgPSBhYnMoZG90KG1pdGVyVmVjLCBwZXJwKSk7XG4gIGZsb2F0IGNvc0hhbGZBID0gYWJzKGRvdChkaXJBLCBtaXRlclZlYykpO1xuICBib29sIHR1cm5zUmlnaHQgPSBkaXJBLnggKiBkaXJCLnkgPiBkaXJBLnkgKiBkaXJCLng7XG5cbiAgLy8gcmVsYXRpdmUgcG9zaXRpb24gdG8gdGhlIGNvcm5lcjpcbiAgLy8gLTE6IGluc2lkZSAoc21hbGxlciBzaWRlIG9mIHRoZSBhbmdsZSlcbiAgLy8gMDogY2VudGVyXG4gIC8vIDE6IG91dHNpZGUgKGJpZ2dlciBzaWRlIG9mIHRoZSBhbmdsZSlcbiAgZmxvYXQgY29ybmVyUG9zaXRpb24gPSBtaXgoXG4gICAgZmxpcElmVHJ1ZSh0dXJuc1JpZ2h0ID09IChwb3NpdGlvbnMueSA+IDAuMCkpLFxuICAgIDAuMCxcbiAgICBwb3NpdGlvbnMuelxuICApO1xuXG4gIG9mZnNldFNjYWxlID0gMS4wIC8gbWF4KHNpbkhhbGZBLCBFUFNJTE9OKTtcblxuICAvLyBkbyBub3QgYmV2ZWwgaWYgbGluZSBzZWdtZW50IGlzIHRvbyBzaG9ydFxuICBjb3JuZXJQb3NpdGlvbiAqPSBmbG9hdChjb3JuZXJQb3NpdGlvbiA8PSAwLjAgfHwgc2luSGFsZkEgPCBtaW4obGVuQSwgbGVuQikgLyB3aWR0aCAqIGNvc0hhbGZBKTtcbiAgLy8gdHJpbSBpZiBpbnNpZGUgY29ybmVyIGV4dGVuZHMgZnVydGhlciB0aGFuIHRoZSBsaW5lIHNlZ21lbnRcbiAgb2Zmc2V0U2NhbGUgPSBtaXgoXG4gICAgb2Zmc2V0U2NhbGUsXG4gICAgbWluKG9mZnNldFNjYWxlLCBMIC8gd2lkdGggLyBtYXgoY29zSGFsZkEsIEVQU0lMT04pKSxcbiAgICBmbG9hdChjb3JuZXJQb3NpdGlvbiA8IDAuMClcbiAgKTtcblxuICB2TWl0ZXJMZW5ndGggPSBtaXgoXG4gICAgb2Zmc2V0U2NhbGUgKiBjb3JuZXJQb3NpdGlvbixcbiAgICBtaXgob2Zmc2V0U2NhbGUsIDAuMCwgY29ybmVyUG9zaXRpb24pLFxuICAgIHN0ZXAoMC4wLCBjb3JuZXJQb3NpdGlvbilcbiAgKSAtIHNpbkhhbGZBICogam9pbnRUeXBlO1xuICBvZmZzZXREaXJlY3Rpb24gPSBtaXgoXG4gICAgcG9zaXRpb25zLnksXG4gICAgbWl4KFxuICAgICAgZmxpcElmVHJ1ZSh0dXJuc1JpZ2h0KSxcbiAgICAgIHBvc2l0aW9ucy55ICogZmxpcElmVHJ1ZSh0dXJuc1JpZ2h0ID09IChwb3NpdGlvbnMueCA9PSAxLikpLFxuICAgICAgY29ybmVyUG9zaXRpb25cbiAgICApLFxuICAgIHN0ZXAoMC4wLCBjb3JuZXJQb3NpdGlvbilcbiAgKTtcbiAgb2Zmc2V0VmVjID0gbWl4KG1pdGVyVmVjLCAtdGFuZ2VudCwgc3RlcCgwLjUsIGNvcm5lclBvc2l0aW9uKSk7XG4gIG9mZnNldFNjYWxlID0gbWl4KG9mZnNldFNjYWxlLCAxLjAgLyBtYXgoY29zSGFsZkEsIDAuMDAxKSwgc3RlcCgwLjUsIGNvcm5lclBvc2l0aW9uKSk7XG5cbiAgLy8gc3BlY2lhbCB0cmVhdG1lbnQgZm9yIHN0YXJ0IGNhcCBhbmQgZW5kIGNhcFxuICBmbG9hdCBpc1N0YXJ0Q2FwID0gc3RlcCgwLjAsIC1sZW5BKTtcbiAgZmxvYXQgaXNFbmRDYXAgPSBzdGVwKDAuMCwgLWxlbkIpO1xuICBmbG9hdCBpc0NhcCA9IG1heChpc1N0YXJ0Q2FwLCBpc0VuZENhcCk7XG5cbiAgLy8gMDogY2VudGVyLCAxOiBzaWRlXG4gIGNvcm5lclBvc2l0aW9uID0gaXNDYXAgKiAoMS4wIC0gcG9zaXRpb25zLnopO1xuXG4gIC8vIHN0YXJ0IG9mIHBhdGg6IHVzZSBuZXh0IC0gY3VyclxuICBvZmZzZXRWZWMgPSBtaXgob2Zmc2V0VmVjLCBtaXgoZGlyQiwgcGVycEIsIGNvcm5lclBvc2l0aW9uKSwgaXNTdGFydENhcCk7XG4gIC8vIGVuZCBvZiBwYXRoOiB1c2UgY3VyciAtIHByZXZcbiAgb2Zmc2V0VmVjID0gbWl4KG9mZnNldFZlYywgbWl4KGRpckEsIHBlcnBBLCBjb3JuZXJQb3NpdGlvbiksIGlzRW5kQ2FwKTtcblxuICAvLyBleHRlbmQgb3V0IGEgdHJpYW5nbGUgdG8gZW52ZWxvcGUgdGhlIHJvdW5kIGNhcFxuICBvZmZzZXRTY2FsZSA9IG1peChcbiAgICBvZmZzZXRTY2FsZSxcbiAgICBtaXgoNC4wICogam9pbnRUeXBlLCAxLjAsIGNvcm5lclBvc2l0aW9uKSxcbiAgICBpc0NhcFxuICApO1xuICB2TWl0ZXJMZW5ndGggPSBtaXgodk1pdGVyTGVuZ3RoLCAxLjAgLSBjb3JuZXJQb3NpdGlvbiwgaXNDYXApO1xuXG4gIG9mZnNldERpcmVjdGlvbiA9IG1peChcbiAgICBvZmZzZXREaXJlY3Rpb24sXG4gICAgbWl4KGZsaXBJZlRydWUoaXNTdGFydENhcCA+IDAuKSwgcG9zaXRpb25zLnksIGNvcm5lclBvc2l0aW9uKSxcbiAgICBpc0NhcFxuICApO1xuXG4gIHZDb3JuZXJPZmZzZXQgPSBvZmZzZXRWZWMgKiBvZmZzZXREaXJlY3Rpb24gKiBvZmZzZXRTY2FsZTtcblxuICByZXR1cm4gY3VyclBvaW50ICsgdmVjMyh2Q29ybmVyT2Zmc2V0ICogd2lkdGgsIDAuMCk7XG59XG5cbnZvaWQgbWFpbigpIHtcbiAgdmVjNCBjb2xvciA9IHZlYzQoaW5zdGFuY2VDb2xvcnMucmdiLCBpbnN0YW5jZUNvbG9ycy5hICogb3BhY2l0eSkgLyAyNTUuO1xuICB2ZWM0IHBpY2tpbmdDb2xvciA9IHZlYzQoaW5zdGFuY2VQaWNraW5nQ29sb3JzLCAyNTUuKSAvIDI1NS47XG4gIHZDb2xvciA9IG1peChjb2xvciwgcGlja2luZ0NvbG9yLCByZW5kZXJQaWNraW5nQnVmZmVyKTtcblxuICBmbG9hdCBpc0VuZCA9IHBvc2l0aW9ucy54O1xuXG4gIHZlYzMgcHJldlBvc2l0aW9uID0gbWl4KC1pbnN0YW5jZUxlZnREZWx0YXMsIHZlYzMoMC4wKSwgaXNFbmQpICsgaW5zdGFuY2VTdGFydFBvc2l0aW9ucztcbiAgcHJldlBvc2l0aW9uID0gcHJvamVjdF9wb3NpdGlvbihwcmV2UG9zaXRpb24pO1xuXG4gIHZlYzMgY3VyclBvc2l0aW9uID0gbWl4KGluc3RhbmNlU3RhcnRQb3NpdGlvbnMsIGluc3RhbmNlRW5kUG9zaXRpb25zLCBpc0VuZCk7XG4gIGN1cnJQb3NpdGlvbiA9IHByb2plY3RfcG9zaXRpb24oY3VyclBvc2l0aW9uKTtcblxuICB2ZWMzIG5leHRQb3NpdGlvbiA9IG1peCh2ZWMzKDAuMCksIGluc3RhbmNlUmlnaHREZWx0YXMsIGlzRW5kKSArIGluc3RhbmNlRW5kUG9zaXRpb25zO1xuICBuZXh0UG9zaXRpb24gPSBwcm9qZWN0X3Bvc2l0aW9uKG5leHRQb3NpdGlvbik7XG5cbiAgdmVjMyBwb3M7XG5cbiAgcG9zID0gbGluZUpvaW4ocHJldlBvc2l0aW9uLCBjdXJyUG9zaXRpb24sIG5leHRQb3NpdGlvbik7XG5cbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0X3RvX2NsaXBzcGFjZSh2ZWM0KHBvcywgMS4wKSk7XG59XG5gO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGF5ZXJzL2NvcmUvcGF0aC1sYXllci9wYXRoLWxheWVyLXZlcnRleC5nbHNsLmpzXG4vLyBtb2R1bGUgaWQgPSA3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 75 */
/* exports provided: default */
/* exports used: default */
/*!******************************************************************************!*\
  !*** ./src/layers/core/point-cloud-layer/point-cloud-layer-fragment.glsl.js ***!
  \******************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME point-cloud-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n\n  float distToCenter = length(unitPosition);\n\n  if (distToCenter <= 1.0) {\n    gl_FragColor = vColor;\n  } else {\n    discard;\n  }\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvcG9pbnQtY2xvdWQtbGF5ZXIvcG9pbnQtY2xvdWQtbGF5ZXItZnJhZ21lbnQuZ2xzbC5qcz83OWMzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmV4cG9ydCBkZWZhdWx0IGBcXFxuI2RlZmluZSBTSEFERVJfTkFNRSBwb2ludC1jbG91ZC1sYXllci1mcmFnbWVudC1zaGFkZXJcblxuI2lmZGVmIEdMX0VTXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4jZW5kaWZcblxudmFyeWluZyB2ZWM0IHZDb2xvcjtcbnZhcnlpbmcgdmVjMiB1bml0UG9zaXRpb247XG5cbnZvaWQgbWFpbih2b2lkKSB7XG5cbiAgZmxvYXQgZGlzdFRvQ2VudGVyID0gbGVuZ3RoKHVuaXRQb3NpdGlvbik7XG5cbiAgaWYgKGRpc3RUb0NlbnRlciA8PSAxLjApIHtcbiAgICBnbF9GcmFnQ29sb3IgPSB2Q29sb3I7XG4gIH0gZWxzZSB7XG4gICAgZGlzY2FyZDtcbiAgfVxufVxuYDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xheWVycy9jb3JlL3BvaW50LWNsb3VkLWxheWVyL3BvaW50LWNsb3VkLWxheWVyLWZyYWdtZW50Lmdsc2wuanNcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 76 */
/* exports provided: default */
/* exports used: default */
/*!*******************************************************************************!*\
  !*** ./src/layers/core/point-cloud-layer/point-cloud-layer-vertex-64.glsl.js ***!
  \*******************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME point-cloud-layer-vertex-64-shader\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute vec2 instancePositions64xyLow;\nattribute vec3 instanceNormals;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float renderPickingBuffer;\nuniform float opacity;\nuniform float radius;\nuniform vec2 screenSize;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n  // position on the containing square in [-1, 1] space\n  unitPosition = positions.xy;\n\n  vec4 instancePositions64xy = vec4(\n    instancePositions.x, instancePositions64xyLow.x,\n    instancePositions.y, instancePositions64xyLow.y);\n\n  vec2 projected_coord_xy[2];\n  project_position_fp64(instancePositions64xy, projected_coord_xy);\n\n  vec2 vertex_pos_localspace[4];\n  vec4_fp64(vec4(positions.xy * radius / screenSize * 2.0, 0.0, 0.0), vertex_pos_localspace);\n\n  vec2 vertex_pos_modelspace[4];\n  vertex_pos_modelspace[0] = sum_fp64(vertex_pos_localspace[0], projected_coord_xy[0]);\n  vertex_pos_modelspace[1] = sum_fp64(vertex_pos_localspace[1], projected_coord_xy[1]);\n  vertex_pos_modelspace[2] = sum_fp64(vertex_pos_localspace[2],\n    vec2(project_scale(instancePositions.z), 0.0));\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\n\n  gl_Position = project_to_clipspace_fp64(vertex_pos_modelspace);\n\n  vec4 position_worldspace = vec4(\n    projected_coord_xy[0].x, projected_coord_xy[1].x,\n    project_scale(instancePositions.z), 1.0);\n\n  // Find the center of the point and add the current vertex\n  // vec4 position_worldspace = vec4(project_position(instancePositions), 1.0);\n  // vec2 vertex = positions.xy * radius / screenSize * 2.0;\n  // gl_Position = project_to_clipspace(position_worldspace) + vec4(vertex, 0.0, 0.0);\n\n  if (renderPickingBuffer > 0.5) {\n    vColor = vec4(instancePickingColors / 255., 1.);\n  } else {\n    // Apply lighting\n    float lightWeight = getLightWeight(position_worldspace, instanceNormals);\n\n    // Apply opacity to instance color, or return instance picking color\n    vColor = vec4(lightWeight * instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  }\n\n  // // Apply lighting\n  // float lightWeight = getLightWeight(position_worldspace, instanceNormals);\n\n  // // Apply opacity to instance color, or return instance picking color\n  // vec4 color = vec4(lightWeight * instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  // vec4 pickingColor = vec4(instancePickingColors / 255., 1.);\n  // vColor = mix(color, pickingColor, renderPickingBuffer);\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvcG9pbnQtY2xvdWQtbGF5ZXIvcG9pbnQtY2xvdWQtbGF5ZXItdmVydGV4LTY0Lmdsc2wuanM/NGZkNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbiNkZWZpbmUgU0hBREVSX05BTUUgcG9pbnQtY2xvdWQtbGF5ZXItdmVydGV4LTY0LXNoYWRlclxuXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbnM7XG5cbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUG9zaXRpb25zO1xuYXR0cmlidXRlIHZlYzIgaW5zdGFuY2VQb3NpdGlvbnM2NHh5TG93O1xuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VOb3JtYWxzO1xuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VDb2xvcnM7XG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBpY2tpbmdDb2xvcnM7XG5cbnVuaWZvcm0gZmxvYXQgcmVuZGVyUGlja2luZ0J1ZmZlcjtcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcbnVuaWZvcm0gZmxvYXQgcmFkaXVzO1xudW5pZm9ybSB2ZWMyIHNjcmVlblNpemU7XG5cbnZhcnlpbmcgdmVjNCB2Q29sb3I7XG52YXJ5aW5nIHZlYzIgdW5pdFBvc2l0aW9uO1xuXG52b2lkIG1haW4odm9pZCkge1xuICAvLyBwb3NpdGlvbiBvbiB0aGUgY29udGFpbmluZyBzcXVhcmUgaW4gWy0xLCAxXSBzcGFjZVxuICB1bml0UG9zaXRpb24gPSBwb3NpdGlvbnMueHk7XG5cbiAgdmVjNCBpbnN0YW5jZVBvc2l0aW9uczY0eHkgPSB2ZWM0KFxuICAgIGluc3RhbmNlUG9zaXRpb25zLngsIGluc3RhbmNlUG9zaXRpb25zNjR4eUxvdy54LFxuICAgIGluc3RhbmNlUG9zaXRpb25zLnksIGluc3RhbmNlUG9zaXRpb25zNjR4eUxvdy55KTtcblxuICB2ZWMyIHByb2plY3RlZF9jb29yZF94eVsyXTtcbiAgcHJvamVjdF9wb3NpdGlvbl9mcDY0KGluc3RhbmNlUG9zaXRpb25zNjR4eSwgcHJvamVjdGVkX2Nvb3JkX3h5KTtcblxuICB2ZWMyIHZlcnRleF9wb3NfbG9jYWxzcGFjZVs0XTtcbiAgdmVjNF9mcDY0KHZlYzQocG9zaXRpb25zLnh5ICogcmFkaXVzIC8gc2NyZWVuU2l6ZSAqIDIuMCwgMC4wLCAwLjApLCB2ZXJ0ZXhfcG9zX2xvY2Fsc3BhY2UpO1xuXG4gIHZlYzIgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzRdO1xuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMF0gPSBzdW1fZnA2NCh2ZXJ0ZXhfcG9zX2xvY2Fsc3BhY2VbMF0sIHByb2plY3RlZF9jb29yZF94eVswXSk7XG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVsxXSA9IHN1bV9mcDY0KHZlcnRleF9wb3NfbG9jYWxzcGFjZVsxXSwgcHJvamVjdGVkX2Nvb3JkX3h5WzFdKTtcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzJdID0gc3VtX2ZwNjQodmVydGV4X3Bvc19sb2NhbHNwYWNlWzJdLFxuICAgIHZlYzIocHJvamVjdF9zY2FsZShpbnN0YW5jZVBvc2l0aW9ucy56KSwgMC4wKSk7XG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVszXSA9IHZlYzIoMS4wLCAwLjApO1xuXG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdF90b19jbGlwc3BhY2VfZnA2NCh2ZXJ0ZXhfcG9zX21vZGVsc3BhY2UpO1xuXG4gIHZlYzQgcG9zaXRpb25fd29ybGRzcGFjZSA9IHZlYzQoXG4gICAgcHJvamVjdGVkX2Nvb3JkX3h5WzBdLngsIHByb2plY3RlZF9jb29yZF94eVsxXS54LFxuICAgIHByb2plY3Rfc2NhbGUoaW5zdGFuY2VQb3NpdGlvbnMueiksIDEuMCk7XG5cbiAgLy8gRmluZCB0aGUgY2VudGVyIG9mIHRoZSBwb2ludCBhbmQgYWRkIHRoZSBjdXJyZW50IHZlcnRleFxuICAvLyB2ZWM0IHBvc2l0aW9uX3dvcmxkc3BhY2UgPSB2ZWM0KHByb2plY3RfcG9zaXRpb24oaW5zdGFuY2VQb3NpdGlvbnMpLCAxLjApO1xuICAvLyB2ZWMyIHZlcnRleCA9IHBvc2l0aW9ucy54eSAqIHJhZGl1cyAvIHNjcmVlblNpemUgKiAyLjA7XG4gIC8vIGdsX1Bvc2l0aW9uID0gcHJvamVjdF90b19jbGlwc3BhY2UocG9zaXRpb25fd29ybGRzcGFjZSkgKyB2ZWM0KHZlcnRleCwgMC4wLCAwLjApO1xuXG4gIGlmIChyZW5kZXJQaWNraW5nQnVmZmVyID4gMC41KSB7XG4gICAgdkNvbG9yID0gdmVjNChpbnN0YW5jZVBpY2tpbmdDb2xvcnMgLyAyNTUuLCAxLik7XG4gIH0gZWxzZSB7XG4gICAgLy8gQXBwbHkgbGlnaHRpbmdcbiAgICBmbG9hdCBsaWdodFdlaWdodCA9IGdldExpZ2h0V2VpZ2h0KHBvc2l0aW9uX3dvcmxkc3BhY2UsIGluc3RhbmNlTm9ybWFscyk7XG5cbiAgICAvLyBBcHBseSBvcGFjaXR5IHRvIGluc3RhbmNlIGNvbG9yLCBvciByZXR1cm4gaW5zdGFuY2UgcGlja2luZyBjb2xvclxuICAgIHZDb2xvciA9IHZlYzQobGlnaHRXZWlnaHQgKiBpbnN0YW5jZUNvbG9ycy5yZ2IsIGluc3RhbmNlQ29sb3JzLmEgKiBvcGFjaXR5KSAvIDI1NS47XG4gIH1cblxuICAvLyAvLyBBcHBseSBsaWdodGluZ1xuICAvLyBmbG9hdCBsaWdodFdlaWdodCA9IGdldExpZ2h0V2VpZ2h0KHBvc2l0aW9uX3dvcmxkc3BhY2UsIGluc3RhbmNlTm9ybWFscyk7XG5cbiAgLy8gLy8gQXBwbHkgb3BhY2l0eSB0byBpbnN0YW5jZSBjb2xvciwgb3IgcmV0dXJuIGluc3RhbmNlIHBpY2tpbmcgY29sb3JcbiAgLy8gdmVjNCBjb2xvciA9IHZlYzQobGlnaHRXZWlnaHQgKiBpbnN0YW5jZUNvbG9ycy5yZ2IsIGluc3RhbmNlQ29sb3JzLmEgKiBvcGFjaXR5KSAvIDI1NS47XG4gIC8vIHZlYzQgcGlja2luZ0NvbG9yID0gdmVjNChpbnN0YW5jZVBpY2tpbmdDb2xvcnMgLyAyNTUuLCAxLik7XG4gIC8vIHZDb2xvciA9IG1peChjb2xvciwgcGlja2luZ0NvbG9yLCByZW5kZXJQaWNraW5nQnVmZmVyKTtcbn1cbmA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9sYXllcnMvY29yZS9wb2ludC1jbG91ZC1sYXllci9wb2ludC1jbG91ZC1sYXllci12ZXJ0ZXgtNjQuZ2xzbC5qc1xuLy8gbW9kdWxlIGlkID0gNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 77 */
/* exports provided: default */
/* exports used: default */
/*!****************************************************************************!*\
  !*** ./src/layers/core/point-cloud-layer/point-cloud-layer-vertex.glsl.js ***!
  \****************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME point-cloud-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instanceNormals;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float renderPickingBuffer;\nuniform float opacity;\nuniform float radius;\nuniform vec2 viewportSize;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n  // position on the containing square in [-1, 1] space\n  unitPosition = positions.xy;\n\n  // Find the center of the point and add the current vertex\n  vec4 position_worldspace = vec4(project_position(instancePositions), 1.0);\n  vec2 vertex = positions.xy * radius / viewportSize * 2.0;\n  gl_Position = project_to_clipspace(position_worldspace) + vec4(vertex, 0.0, 0.0);\n\n  // Apply lighting\n  float lightWeight = getLightWeight(position_worldspace, instanceNormals);\n\n  // Apply opacity to instance color, or return instance picking color\n  vec4 color = vec4(lightWeight * instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  vec4 pickingColor = vec4(instancePickingColors / 255., 1.);\n  vColor = mix(color, pickingColor, renderPickingBuffer);\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvcG9pbnQtY2xvdWQtbGF5ZXIvcG9pbnQtY2xvdWQtbGF5ZXItdmVydGV4Lmdsc2wuanM/NWRhYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbiNkZWZpbmUgU0hBREVSX05BTUUgcG9pbnQtY2xvdWQtbGF5ZXItdmVydGV4LXNoYWRlclxuXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbnM7XG5cbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUG9zaXRpb25zO1xuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VOb3JtYWxzO1xuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VDb2xvcnM7XG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBpY2tpbmdDb2xvcnM7XG5cbnVuaWZvcm0gZmxvYXQgcmVuZGVyUGlja2luZ0J1ZmZlcjtcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcbnVuaWZvcm0gZmxvYXQgcmFkaXVzO1xudW5pZm9ybSB2ZWMyIHZpZXdwb3J0U2l6ZTtcblxudmFyeWluZyB2ZWM0IHZDb2xvcjtcbnZhcnlpbmcgdmVjMiB1bml0UG9zaXRpb247XG5cbnZvaWQgbWFpbih2b2lkKSB7XG4gIC8vIHBvc2l0aW9uIG9uIHRoZSBjb250YWluaW5nIHNxdWFyZSBpbiBbLTEsIDFdIHNwYWNlXG4gIHVuaXRQb3NpdGlvbiA9IHBvc2l0aW9ucy54eTtcblxuICAvLyBGaW5kIHRoZSBjZW50ZXIgb2YgdGhlIHBvaW50IGFuZCBhZGQgdGhlIGN1cnJlbnQgdmVydGV4XG4gIHZlYzQgcG9zaXRpb25fd29ybGRzcGFjZSA9IHZlYzQocHJvamVjdF9wb3NpdGlvbihpbnN0YW5jZVBvc2l0aW9ucyksIDEuMCk7XG4gIHZlYzIgdmVydGV4ID0gcG9zaXRpb25zLnh5ICogcmFkaXVzIC8gdmlld3BvcnRTaXplICogMi4wO1xuICBnbF9Qb3NpdGlvbiA9IHByb2plY3RfdG9fY2xpcHNwYWNlKHBvc2l0aW9uX3dvcmxkc3BhY2UpICsgdmVjNCh2ZXJ0ZXgsIDAuMCwgMC4wKTtcblxuICAvLyBBcHBseSBsaWdodGluZ1xuICBmbG9hdCBsaWdodFdlaWdodCA9IGdldExpZ2h0V2VpZ2h0KHBvc2l0aW9uX3dvcmxkc3BhY2UsIGluc3RhbmNlTm9ybWFscyk7XG5cbiAgLy8gQXBwbHkgb3BhY2l0eSB0byBpbnN0YW5jZSBjb2xvciwgb3IgcmV0dXJuIGluc3RhbmNlIHBpY2tpbmcgY29sb3JcbiAgdmVjNCBjb2xvciA9IHZlYzQobGlnaHRXZWlnaHQgKiBpbnN0YW5jZUNvbG9ycy5yZ2IsIGluc3RhbmNlQ29sb3JzLmEgKiBvcGFjaXR5KSAvIDI1NS47XG4gIHZlYzQgcGlja2luZ0NvbG9yID0gdmVjNChpbnN0YW5jZVBpY2tpbmdDb2xvcnMgLyAyNTUuLCAxLik7XG4gIHZDb2xvciA9IG1peChjb2xvciwgcGlja2luZ0NvbG9yLCByZW5kZXJQaWNraW5nQnVmZmVyKTtcbn1cbmA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9sYXllcnMvY29yZS9wb2ludC1jbG91ZC1sYXllci9wb2ludC1jbG91ZC1sYXllci12ZXJ0ZXguZ2xzbC5qc1xuLy8gbW9kdWxlIGlkID0gNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 78 */
/* exports provided: default */
/* exports used: default */
/*!******************************************************************************!*\
  !*** ./src/layers/core/scatterplot-layer/scatterplot-layer-fragment.glsl.js ***!
  \******************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME scatterplot-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\n\nvoid main(void) {\n\n  float distToCenter = length(unitPosition);\n\n  if (distToCenter <= 1.0 && distToCenter >= innerUnitRadius) {\n    gl_FragColor = vColor;\n  } else {\n    discard;\n  }\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvc2NhdHRlcnBsb3QtbGF5ZXIvc2NhdHRlcnBsb3QtbGF5ZXItZnJhZ21lbnQuZ2xzbC5qcz9mMDk4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmV4cG9ydCBkZWZhdWx0IGBcXFxuI2RlZmluZSBTSEFERVJfTkFNRSBzY2F0dGVycGxvdC1sYXllci1mcmFnbWVudC1zaGFkZXJcblxuI2lmZGVmIEdMX0VTXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4jZW5kaWZcblxudmFyeWluZyB2ZWM0IHZDb2xvcjtcbnZhcnlpbmcgdmVjMiB1bml0UG9zaXRpb247XG52YXJ5aW5nIGZsb2F0IGlubmVyVW5pdFJhZGl1cztcblxudm9pZCBtYWluKHZvaWQpIHtcblxuICBmbG9hdCBkaXN0VG9DZW50ZXIgPSBsZW5ndGgodW5pdFBvc2l0aW9uKTtcblxuICBpZiAoZGlzdFRvQ2VudGVyIDw9IDEuMCAmJiBkaXN0VG9DZW50ZXIgPj0gaW5uZXJVbml0UmFkaXVzKSB7XG4gICAgZ2xfRnJhZ0NvbG9yID0gdkNvbG9yO1xuICB9IGVsc2Uge1xuICAgIGRpc2NhcmQ7XG4gIH1cbn1cbmA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9sYXllcnMvY29yZS9zY2F0dGVycGxvdC1sYXllci9zY2F0dGVycGxvdC1sYXllci1mcmFnbWVudC5nbHNsLmpzXG4vLyBtb2R1bGUgaWQgPSA3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 79 */
/* exports provided: default */
/* exports used: default */
/*!*******************************************************************************!*\
  !*** ./src/layers/core/scatterplot-layer/scatterplot-layer-vertex-64.glsl.js ***!
  \*******************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME scatterplot-layer-vertex-64-shader\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute vec2 instancePositions64xyLow;\nattribute float instanceRadius;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\n// Only one-dimensional arrays may be declared in GLSL ES 1.0. specs p.24\nuniform float opacity;\nuniform float radiusScale;\nuniform float radiusMinPixels;\nuniform float radiusMaxPixels;\nuniform float renderPickingBuffer;\nuniform float outline;\nuniform float strokeWidth;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\n\nvoid main(void) {\n  // Multiply out radius and clamp to limits\n  float outerRadiusPixels = clamp(\n    project_scale(radiusScale * instanceRadius),\n    radiusMinPixels, radiusMaxPixels\n  );\n\n  // outline is centered at the radius\n  // outer radius needs to offset by half stroke width\n  outerRadiusPixels += outline * strokeWidth / 2.0;\n\n  // position on the containing square in [-1, 1] space\n  unitPosition = positions.xy;\n  // 0 - solid circle, 1 - stroke with lineWidth=0\n  innerUnitRadius = outline * (1.0 - strokeWidth / outerRadiusPixels);\n\n  vec4 instancePositions64xy = vec4(\n    instancePositions.x, instancePositions64xyLow.x,\n    instancePositions.y, instancePositions64xyLow.y);\n\n  vec2 projected_coord_xy[2];\n  project_position_fp64(instancePositions64xy, projected_coord_xy);\n\n  vec2 vertex_pos_localspace[4];\n  vec4_fp64(vec4(positions * outerRadiusPixels, 0.0), vertex_pos_localspace);\n\n  vec2 vertex_pos_modelspace[4];\n  vertex_pos_modelspace[0] = sum_fp64(vertex_pos_localspace[0], projected_coord_xy[0]);\n  vertex_pos_modelspace[1] = sum_fp64(vertex_pos_localspace[1], projected_coord_xy[1]);\n  vertex_pos_modelspace[2] = sum_fp64(vertex_pos_localspace[2],\n    vec2(project_scale(instancePositions.z), 0.0));\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\n\n  gl_Position = project_to_clipspace_fp64(vertex_pos_modelspace);\n\n  if (renderPickingBuffer > 0.5) {\n    vColor = vec4(instancePickingColors / 255., 1.);\n  } else {\n    vColor = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  }\n  // // Apply opacity to instance color, or return instance picking color\n  // vec4 color = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  // vec4 pickingColor = vec4(instancePickingColors / 255., 1.);\n  // vColor = mix(color, pickingColor, renderPickingBuffer);\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvc2NhdHRlcnBsb3QtbGF5ZXIvc2NhdHRlcnBsb3QtbGF5ZXItdmVydGV4LTY0Lmdsc2wuanM/ODgzYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTYgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbiNkZWZpbmUgU0hBREVSX05BTUUgc2NhdHRlcnBsb3QtbGF5ZXItdmVydGV4LTY0LXNoYWRlclxuXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbnM7XG5cbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUG9zaXRpb25zO1xuYXR0cmlidXRlIHZlYzIgaW5zdGFuY2VQb3NpdGlvbnM2NHh5TG93O1xuYXR0cmlidXRlIGZsb2F0IGluc3RhbmNlUmFkaXVzO1xuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VDb2xvcnM7XG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBpY2tpbmdDb2xvcnM7XG5cbi8vIE9ubHkgb25lLWRpbWVuc2lvbmFsIGFycmF5cyBtYXkgYmUgZGVjbGFyZWQgaW4gR0xTTCBFUyAxLjAuIHNwZWNzIHAuMjRcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcbnVuaWZvcm0gZmxvYXQgcmFkaXVzU2NhbGU7XG51bmlmb3JtIGZsb2F0IHJhZGl1c01pblBpeGVscztcbnVuaWZvcm0gZmxvYXQgcmFkaXVzTWF4UGl4ZWxzO1xudW5pZm9ybSBmbG9hdCByZW5kZXJQaWNraW5nQnVmZmVyO1xudW5pZm9ybSBmbG9hdCBvdXRsaW5lO1xudW5pZm9ybSBmbG9hdCBzdHJva2VXaWR0aDtcblxudmFyeWluZyB2ZWM0IHZDb2xvcjtcbnZhcnlpbmcgdmVjMiB1bml0UG9zaXRpb247XG52YXJ5aW5nIGZsb2F0IGlubmVyVW5pdFJhZGl1cztcblxudm9pZCBtYWluKHZvaWQpIHtcbiAgLy8gTXVsdGlwbHkgb3V0IHJhZGl1cyBhbmQgY2xhbXAgdG8gbGltaXRzXG4gIGZsb2F0IG91dGVyUmFkaXVzUGl4ZWxzID0gY2xhbXAoXG4gICAgcHJvamVjdF9zY2FsZShyYWRpdXNTY2FsZSAqIGluc3RhbmNlUmFkaXVzKSxcbiAgICByYWRpdXNNaW5QaXhlbHMsIHJhZGl1c01heFBpeGVsc1xuICApO1xuXG4gIC8vIG91dGxpbmUgaXMgY2VudGVyZWQgYXQgdGhlIHJhZGl1c1xuICAvLyBvdXRlciByYWRpdXMgbmVlZHMgdG8gb2Zmc2V0IGJ5IGhhbGYgc3Ryb2tlIHdpZHRoXG4gIG91dGVyUmFkaXVzUGl4ZWxzICs9IG91dGxpbmUgKiBzdHJva2VXaWR0aCAvIDIuMDtcblxuICAvLyBwb3NpdGlvbiBvbiB0aGUgY29udGFpbmluZyBzcXVhcmUgaW4gWy0xLCAxXSBzcGFjZVxuICB1bml0UG9zaXRpb24gPSBwb3NpdGlvbnMueHk7XG4gIC8vIDAgLSBzb2xpZCBjaXJjbGUsIDEgLSBzdHJva2Ugd2l0aCBsaW5lV2lkdGg9MFxuICBpbm5lclVuaXRSYWRpdXMgPSBvdXRsaW5lICogKDEuMCAtIHN0cm9rZVdpZHRoIC8gb3V0ZXJSYWRpdXNQaXhlbHMpO1xuXG4gIHZlYzQgaW5zdGFuY2VQb3NpdGlvbnM2NHh5ID0gdmVjNChcbiAgICBpbnN0YW5jZVBvc2l0aW9ucy54LCBpbnN0YW5jZVBvc2l0aW9uczY0eHlMb3cueCxcbiAgICBpbnN0YW5jZVBvc2l0aW9ucy55LCBpbnN0YW5jZVBvc2l0aW9uczY0eHlMb3cueSk7XG5cbiAgdmVjMiBwcm9qZWN0ZWRfY29vcmRfeHlbMl07XG4gIHByb2plY3RfcG9zaXRpb25fZnA2NChpbnN0YW5jZVBvc2l0aW9uczY0eHksIHByb2plY3RlZF9jb29yZF94eSk7XG5cbiAgdmVjMiB2ZXJ0ZXhfcG9zX2xvY2Fsc3BhY2VbNF07XG4gIHZlYzRfZnA2NCh2ZWM0KHBvc2l0aW9ucyAqIG91dGVyUmFkaXVzUGl4ZWxzLCAwLjApLCB2ZXJ0ZXhfcG9zX2xvY2Fsc3BhY2UpO1xuXG4gIHZlYzIgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzRdO1xuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMF0gPSBzdW1fZnA2NCh2ZXJ0ZXhfcG9zX2xvY2Fsc3BhY2VbMF0sIHByb2plY3RlZF9jb29yZF94eVswXSk7XG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVsxXSA9IHN1bV9mcDY0KHZlcnRleF9wb3NfbG9jYWxzcGFjZVsxXSwgcHJvamVjdGVkX2Nvb3JkX3h5WzFdKTtcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzJdID0gc3VtX2ZwNjQodmVydGV4X3Bvc19sb2NhbHNwYWNlWzJdLFxuICAgIHZlYzIocHJvamVjdF9zY2FsZShpbnN0YW5jZVBvc2l0aW9ucy56KSwgMC4wKSk7XG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVszXSA9IHZlYzIoMS4wLCAwLjApO1xuXG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdF90b19jbGlwc3BhY2VfZnA2NCh2ZXJ0ZXhfcG9zX21vZGVsc3BhY2UpO1xuXG4gIGlmIChyZW5kZXJQaWNraW5nQnVmZmVyID4gMC41KSB7XG4gICAgdkNvbG9yID0gdmVjNChpbnN0YW5jZVBpY2tpbmdDb2xvcnMgLyAyNTUuLCAxLik7XG4gIH0gZWxzZSB7XG4gICAgdkNvbG9yID0gdmVjNChpbnN0YW5jZUNvbG9ycy5yZ2IsIGluc3RhbmNlQ29sb3JzLmEgKiBvcGFjaXR5KSAvIDI1NS47XG4gIH1cbiAgLy8gLy8gQXBwbHkgb3BhY2l0eSB0byBpbnN0YW5jZSBjb2xvciwgb3IgcmV0dXJuIGluc3RhbmNlIHBpY2tpbmcgY29sb3JcbiAgLy8gdmVjNCBjb2xvciA9IHZlYzQoaW5zdGFuY2VDb2xvcnMucmdiLCBpbnN0YW5jZUNvbG9ycy5hICogb3BhY2l0eSkgLyAyNTUuO1xuICAvLyB2ZWM0IHBpY2tpbmdDb2xvciA9IHZlYzQoaW5zdGFuY2VQaWNraW5nQ29sb3JzIC8gMjU1LiwgMS4pO1xuICAvLyB2Q29sb3IgPSBtaXgoY29sb3IsIHBpY2tpbmdDb2xvciwgcmVuZGVyUGlja2luZ0J1ZmZlcik7XG59XG5gO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGF5ZXJzL2NvcmUvc2NhdHRlcnBsb3QtbGF5ZXIvc2NhdHRlcnBsb3QtbGF5ZXItdmVydGV4LTY0Lmdsc2wuanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 80 */
/* exports provided: default */
/* exports used: default */
/*!****************************************************************************!*\
  !*** ./src/layers/core/scatterplot-layer/scatterplot-layer-vertex.glsl.js ***!
  \****************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME scatterplot-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute float instanceRadius;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusScale;\nuniform float radiusMinPixels;\nuniform float radiusMaxPixels;\nuniform float renderPickingBuffer;\nuniform float outline;\nuniform float strokeWidth;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\n\nvoid main(void) {\n  // Multiply out radius and clamp to limits\n  float outerRadiusPixels = clamp(\n    project_scale(radiusScale * instanceRadius),\n    radiusMinPixels, radiusMaxPixels\n  );\n  // outline is centered at the radius\n  // outer radius needs to offset by half stroke width\n  outerRadiusPixels += outline * strokeWidth / 2.0;\n\n  // position on the containing square in [-1, 1] space\n  unitPosition = positions.xy;\n  // 0 - solid circle, 1 - stroke with lineWidth=0\n  innerUnitRadius = outline * (1.0 - strokeWidth / outerRadiusPixels);\n\n  // Find the center of the point and add the current vertex\n  vec3 center = project_position(instancePositions);\n  vec3 vertex = positions * outerRadiusPixels;\n  gl_Position = project_to_clipspace(vec4(center + vertex, 1.0));\n\n  // Apply opacity to instance color, or return instance picking color\n  vec4 color = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  vec4 pickingColor = vec4(instancePickingColors / 255., 1.);\n  vColor = mix(color, pickingColor, renderPickingBuffer);\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvc2NhdHRlcnBsb3QtbGF5ZXIvc2NhdHRlcnBsb3QtbGF5ZXItdmVydGV4Lmdsc2wuanM/ODA5YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbiNkZWZpbmUgU0hBREVSX05BTUUgc2NhdHRlcnBsb3QtbGF5ZXItdmVydGV4LXNoYWRlclxuXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbnM7XG5cbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUG9zaXRpb25zO1xuYXR0cmlidXRlIGZsb2F0IGluc3RhbmNlUmFkaXVzO1xuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VDb2xvcnM7XG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBpY2tpbmdDb2xvcnM7XG5cbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcbnVuaWZvcm0gZmxvYXQgcmFkaXVzU2NhbGU7XG51bmlmb3JtIGZsb2F0IHJhZGl1c01pblBpeGVscztcbnVuaWZvcm0gZmxvYXQgcmFkaXVzTWF4UGl4ZWxzO1xudW5pZm9ybSBmbG9hdCByZW5kZXJQaWNraW5nQnVmZmVyO1xudW5pZm9ybSBmbG9hdCBvdXRsaW5lO1xudW5pZm9ybSBmbG9hdCBzdHJva2VXaWR0aDtcblxudmFyeWluZyB2ZWM0IHZDb2xvcjtcbnZhcnlpbmcgdmVjMiB1bml0UG9zaXRpb247XG52YXJ5aW5nIGZsb2F0IGlubmVyVW5pdFJhZGl1cztcblxudm9pZCBtYWluKHZvaWQpIHtcbiAgLy8gTXVsdGlwbHkgb3V0IHJhZGl1cyBhbmQgY2xhbXAgdG8gbGltaXRzXG4gIGZsb2F0IG91dGVyUmFkaXVzUGl4ZWxzID0gY2xhbXAoXG4gICAgcHJvamVjdF9zY2FsZShyYWRpdXNTY2FsZSAqIGluc3RhbmNlUmFkaXVzKSxcbiAgICByYWRpdXNNaW5QaXhlbHMsIHJhZGl1c01heFBpeGVsc1xuICApO1xuICAvLyBvdXRsaW5lIGlzIGNlbnRlcmVkIGF0IHRoZSByYWRpdXNcbiAgLy8gb3V0ZXIgcmFkaXVzIG5lZWRzIHRvIG9mZnNldCBieSBoYWxmIHN0cm9rZSB3aWR0aFxuICBvdXRlclJhZGl1c1BpeGVscyArPSBvdXRsaW5lICogc3Ryb2tlV2lkdGggLyAyLjA7XG5cbiAgLy8gcG9zaXRpb24gb24gdGhlIGNvbnRhaW5pbmcgc3F1YXJlIGluIFstMSwgMV0gc3BhY2VcbiAgdW5pdFBvc2l0aW9uID0gcG9zaXRpb25zLnh5O1xuICAvLyAwIC0gc29saWQgY2lyY2xlLCAxIC0gc3Ryb2tlIHdpdGggbGluZVdpZHRoPTBcbiAgaW5uZXJVbml0UmFkaXVzID0gb3V0bGluZSAqICgxLjAgLSBzdHJva2VXaWR0aCAvIG91dGVyUmFkaXVzUGl4ZWxzKTtcblxuICAvLyBGaW5kIHRoZSBjZW50ZXIgb2YgdGhlIHBvaW50IGFuZCBhZGQgdGhlIGN1cnJlbnQgdmVydGV4XG4gIHZlYzMgY2VudGVyID0gcHJvamVjdF9wb3NpdGlvbihpbnN0YW5jZVBvc2l0aW9ucyk7XG4gIHZlYzMgdmVydGV4ID0gcG9zaXRpb25zICogb3V0ZXJSYWRpdXNQaXhlbHM7XG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdF90b19jbGlwc3BhY2UodmVjNChjZW50ZXIgKyB2ZXJ0ZXgsIDEuMCkpO1xuXG4gIC8vIEFwcGx5IG9wYWNpdHkgdG8gaW5zdGFuY2UgY29sb3IsIG9yIHJldHVybiBpbnN0YW5jZSBwaWNraW5nIGNvbG9yXG4gIHZlYzQgY29sb3IgPSB2ZWM0KGluc3RhbmNlQ29sb3JzLnJnYiwgaW5zdGFuY2VDb2xvcnMuYSAqIG9wYWNpdHkpIC8gMjU1LjtcbiAgdmVjNCBwaWNraW5nQ29sb3IgPSB2ZWM0KGluc3RhbmNlUGlja2luZ0NvbG9ycyAvIDI1NS4sIDEuKTtcbiAgdkNvbG9yID0gbWl4KGNvbG9yLCBwaWNraW5nQ29sb3IsIHJlbmRlclBpY2tpbmdCdWZmZXIpO1xufVxuYDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xheWVycy9jb3JlL3NjYXR0ZXJwbG90LWxheWVyL3NjYXR0ZXJwbG90LWxheWVyLXZlcnRleC5nbHNsLmpzXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 81 */
/* exports provided: default */
/* exports used: default */
/*!******************************************************************************!*\
  !*** ./src/layers/core/screen-grid-layer/screen-grid-layer-fragment.glsl.js ***!
  \******************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* fragment shader for the grid-layer */\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME grid-layer-fs\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvc2NyZWVuLWdyaWQtbGF5ZXIvc2NyZWVuLWdyaWQtbGF5ZXItZnJhZ21lbnQuZ2xzbC5qcz83ZmU3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbi8qIGZyYWdtZW50IHNoYWRlciBmb3IgdGhlIGdyaWQtbGF5ZXIgKi9cbmV4cG9ydCBkZWZhdWx0IGBcXFxuI2RlZmluZSBTSEFERVJfTkFNRSBncmlkLWxheWVyLWZzXG5cbiNpZmRlZiBHTF9FU1xucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuI2VuZGlmXG5cbnZhcnlpbmcgdmVjNCB2Q29sb3I7XG5cbnZvaWQgbWFpbih2b2lkKSB7XG4gIGdsX0ZyYWdDb2xvciA9IHZDb2xvcjtcbn1cbmA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9sYXllcnMvY29yZS9zY3JlZW4tZ3JpZC1sYXllci9zY3JlZW4tZ3JpZC1sYXllci1mcmFnbWVudC5nbHNsLmpzXG4vLyBtb2R1bGUgaWQgPSA4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 82 */
/* exports provided: default */
/* exports used: default */
/*!****************************************************************************!*\
  !*** ./src/layers/core/screen-grid-layer/screen-grid-layer-vertex.glsl.js ***!
  \****************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME grid-layer-vs\n\nattribute vec3 vertices;\nattribute vec3 instancePositions;\nattribute float instanceCount;\nattribute vec3 instancePickingColors;\n\nuniform float maxCount;\nuniform float opacity;\nuniform vec4 minColor;\nuniform vec4 maxColor;\nuniform float renderPickingBuffer;\nuniform vec3 cellScale;\nuniform vec3 selectedPickingColor;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  vec4 color = mix(minColor, maxColor, instanceCount / maxCount) / 255.;\n\n  vColor = mix(\n    vec4(color.rgb, color.a * opacity),\n    vec4(instancePickingColors / 255., 1.),\n    renderPickingBuffer\n  );\n\n  gl_Position = vec4(instancePositions + vertices * cellScale, 1.);\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvc2NyZWVuLWdyaWQtbGF5ZXIvc2NyZWVuLWdyaWQtbGF5ZXItdmVydGV4Lmdsc2wuanM/ZWMxNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbiNkZWZpbmUgU0hBREVSX05BTUUgZ3JpZC1sYXllci12c1xuXG5hdHRyaWJ1dGUgdmVjMyB2ZXJ0aWNlcztcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUG9zaXRpb25zO1xuYXR0cmlidXRlIGZsb2F0IGluc3RhbmNlQ291bnQ7XG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBpY2tpbmdDb2xvcnM7XG5cbnVuaWZvcm0gZmxvYXQgbWF4Q291bnQ7XG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XG51bmlmb3JtIHZlYzQgbWluQ29sb3I7XG51bmlmb3JtIHZlYzQgbWF4Q29sb3I7XG51bmlmb3JtIGZsb2F0IHJlbmRlclBpY2tpbmdCdWZmZXI7XG51bmlmb3JtIHZlYzMgY2VsbFNjYWxlO1xudW5pZm9ybSB2ZWMzIHNlbGVjdGVkUGlja2luZ0NvbG9yO1xuXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xuXG52b2lkIG1haW4odm9pZCkge1xuICB2ZWM0IGNvbG9yID0gbWl4KG1pbkNvbG9yLCBtYXhDb2xvciwgaW5zdGFuY2VDb3VudCAvIG1heENvdW50KSAvIDI1NS47XG5cbiAgdkNvbG9yID0gbWl4KFxuICAgIHZlYzQoY29sb3IucmdiLCBjb2xvci5hICogb3BhY2l0eSksXG4gICAgdmVjNChpbnN0YW5jZVBpY2tpbmdDb2xvcnMgLyAyNTUuLCAxLiksXG4gICAgcmVuZGVyUGlja2luZ0J1ZmZlclxuICApO1xuXG4gIGdsX1Bvc2l0aW9uID0gdmVjNChpbnN0YW5jZVBvc2l0aW9ucyArIHZlcnRpY2VzICogY2VsbFNjYWxlLCAxLik7XG59XG5gO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGF5ZXJzL2NvcmUvc2NyZWVuLWdyaWQtbGF5ZXIvc2NyZWVuLWdyaWQtbGF5ZXItdmVydGV4Lmdsc2wuanNcbi8vIG1vZHVsZSBpZCA9IDgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 83 */
/* exports provided: PolygonTesselatorExtruded */
/* exports used: PolygonTesselatorExtruded */
/*!****************************************************************************!*\
  !*** ./src/layers/core/solid-polygon-layer/polygon-tesselator-extruded.js ***!
  \****************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polygon__ = __webpack_require__(/*! ./polygon */ 13);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_gl_matrix__ = __webpack_require__(/*! gl-matrix */ 7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_gl_matrix___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_gl_matrix__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__ = __webpack_require__(/*! ../../../lib/utils/fp64 */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_utils__ = __webpack_require__(/*! ../../../lib/utils */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_earcut__ = __webpack_require__(/*! earcut */ 8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_earcut___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_earcut__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash_flattendeep__ = __webpack_require__(/*! lodash.flattendeep */ 33);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash_flattendeep___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash_flattendeep__);\n\n\n\n\n\n\n\nfunction getPickingColor(index) {\n  return [\n    (index + 1) % 256,\n    Math.floor((index + 1) / 256) % 256,\n    Math.floor((index + 1) / 256 / 256) % 256\n  ];\n}\n\nfunction parseColor(color) {\n  if (!Array.isArray(color)) {\n    color = [__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils__[\"d\" /* get */])(color, 0), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils__[\"d\" /* get */])(color, 1), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils__[\"d\" /* get */])(color, 2), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils__[\"d\" /* get */])(color, 3)];\n  }\n  color[3] = Number.isFinite(color[3]) ? color[3] : 255;\n  return color;\n}\n\nconst DEFAULT_COLOR = [0, 0, 0, 255]; // Black\n\nclass PolygonTesselatorExtruded {\n\n  constructor({\n    polygons,\n    getHeight = x => 1000,\n    getColor = x => [0, 0, 0, 255],\n    wireframe = false,\n    fp64 = false\n  }) {\n    this.fp64 = fp64;\n\n    // Expensive operation, convert all polygons to arrays\n    polygons = polygons.map((complexPolygon, polygonIndex) => {\n      const height = getHeight(polygonIndex) || 0;\n      return __WEBPACK_IMPORTED_MODULE_0__polygon__[\"a\" /* normalize */](complexPolygon).map(\n        polygon => polygon.map(coord => [__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils__[\"d\" /* get */])(coord, 0), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils__[\"d\" /* get */])(coord, 1), height])\n      );\n    });\n\n    const groupedVertices = polygons;\n    this.groupedVertices = polygons;\n    this.wireframe = wireframe;\n\n    this.attributes = {};\n\n    const positionsJS = calculatePositionsJS({groupedVertices, wireframe});\n    Object.assign(this.attributes, {\n      positions: calculatePositions(positionsJS, this.fp64),\n      indices: calculateIndices({groupedVertices, wireframe}),\n      normals: calculateNormals({groupedVertices, wireframe}),\n      // colors: calculateColors({groupedVertices, wireframe, getColor}),\n      pickingColors: calculatePickingColors({groupedVertices, wireframe})\n    });\n  }\n\n  indices() {\n    return this.attributes.indices;\n  }\n\n  positions() {\n    return this.attributes.positions;\n  }\n\n  normals() {\n    return this.attributes.normals;\n  }\n\n  colors({getColor = x => DEFAULT_COLOR} = {}) {\n    const {groupedVertices, wireframe} = this;\n    return calculateColors({groupedVertices, wireframe, getColor});\n  }\n\n  pickingColors() {\n    return this.attributes.pickingColors;\n  }\n\n  // updateTriggers: {\n  //   positions: ['getHeight'],\n  //   colors: ['getColors']\n  //   pickingColors: 'none'\n  // }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = PolygonTesselatorExtruded;\n\n\nfunction countVertices(vertices) {\n  return vertices.reduce((vertexCount, polygon) => vertexCount + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils__[\"e\" /* count */])(polygon), 0);\n}\n\nfunction calculateIndices({groupedVertices, wireframe = false}) {\n  // adjust index offset for multiple polygons\n  const multiplier = wireframe ? 2 : 5;\n  const offsets = groupedVertices.reduce(\n    (acc, vertices) =>\n      [...acc, acc[acc.length - 1] + countVertices(vertices) * multiplier],\n    [0]\n  );\n\n  const indices = groupedVertices.map((vertices, polygonIndex) =>\n    wireframe ?\n      // 1. get sequentially ordered indices of each polygons wireframe\n      // 2. offset them by the number of indices in previous polygons\n      calculateContourIndices(vertices, offsets[polygonIndex]) :\n      // 1. get triangulated indices for the internal areas\n      // 2. offset them by the number of indices in previous polygons\n      calculateSurfaceIndices(vertices, offsets[polygonIndex])\n  );\n\n  return new Uint32Array(__WEBPACK_IMPORTED_MODULE_5_lodash_flattendeep___default()(indices));\n}\n\n// Calculate a flat position array in JS - can be mapped to 32 or 64 bit typed arrays\n// Remarks:\n// * each top vertex is on 3 surfaces\n// * each bottom vertex is on 2 surfaces\nfunction calculatePositionsJS({groupedVertices, wireframe = false}) {\n  const positions = groupedVertices.map(complexPolygon =>\n    complexPolygon.map(vertices => {\n      const topVertices = [].concat(vertices);\n      const baseVertices = topVertices.map(v => [__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils__[\"d\" /* get */])(v, 0), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils__[\"d\" /* get */])(v, 1), 0]);\n      return wireframe ?\n        [topVertices, baseVertices] :\n        [topVertices, topVertices, topVertices, baseVertices, baseVertices];\n    })\n  );\n  return __WEBPACK_IMPORTED_MODULE_5_lodash_flattendeep___default()(positions);\n}\n\nfunction calculatePositions(positionsJS, fp64) {\n  let positionLow;\n  if (fp64) {\n    // We only need x, y component\n    positionLow = new Float32Array(positionsJS.length / 3 * 2);\n    for (let i = 0; i < positionsJS.length / 3; i++) {\n      positionLow[i * 2 + 0] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__[\"a\" /* fp64ify */])(positionsJS[i * 3 + 0])[1];\n      positionLow[i * 2 + 1] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__[\"a\" /* fp64ify */])(positionsJS[i * 3 + 1])[1];\n    }\n\n  }\n  return {positions: new Float32Array(positionsJS), positions64xyLow: positionLow};\n}\n\nfunction calculateNormals({groupedVertices, wireframe}) {\n  const up = [0, 1, 0];\n\n  const normals = groupedVertices.map((vertices, polygonIndex) => {\n    const topNormals = new Array(countVertices(vertices)).fill(up);\n    const sideNormals = vertices.map(polygon => calculateSideNormals(polygon));\n    const sideNormalsForward = sideNormals.map(n => n[0]);\n    const sideNormalsBackward = sideNormals.map(n => n[1]);\n\n    return wireframe ?\n    [topNormals, topNormals] :\n    [topNormals, sideNormalsForward, sideNormalsBackward, sideNormalsForward, sideNormalsBackward];\n  });\n\n  return new Float32Array(__WEBPACK_IMPORTED_MODULE_5_lodash_flattendeep___default()(normals));\n}\n\nfunction calculateSideNormals(vertices) {\n  const normals = [];\n\n  let lastVertice = null;\n  for (const vertice of vertices) {\n    if (lastVertice) {\n      // vertex[i-1], vertex[i]\n      const n = getNormal(lastVertice, vertice);\n      normals.push(n);\n    }\n    lastVertice = vertice;\n  }\n\n  return [[...normals, normals[0]], [normals[0], ...normals]];\n}\n\nfunction calculateColors({groupedVertices, getColor, wireframe = false}) {\n  const colors = groupedVertices.map((complexPolygon, polygonIndex) => {\n    let color = getColor(polygonIndex);\n    color = parseColor(color);\n\n    const numVertices = countVertices(complexPolygon);\n    const topColors = new Array(numVertices).fill(color);\n    const baseColors = new Array(numVertices).fill(color);\n    return wireframe ?\n      [topColors, baseColors] :\n      [topColors, topColors, topColors, baseColors, baseColors];\n  });\n  return new Uint8ClampedArray(__WEBPACK_IMPORTED_MODULE_5_lodash_flattendeep___default()(colors));\n}\n\nfunction calculatePickingColors({groupedVertices, wireframe = false}) {\n  const colors = groupedVertices.map((vertices, polygonIndex) => {\n    const numVertices = countVertices(vertices);\n    const color = getPickingColor(polygonIndex);\n    const topColors = new Array(numVertices).fill(color);\n    const baseColors = new Array(numVertices).fill(color);\n    return wireframe ?\n      [topColors, baseColors] :\n      [topColors, topColors, topColors, baseColors, baseColors];\n  });\n  return new Uint8ClampedArray(__WEBPACK_IMPORTED_MODULE_5_lodash_flattendeep___default()(colors));\n}\n\nfunction calculateContourIndices(vertices, offset) {\n  const stride = countVertices(vertices);\n\n  return vertices.map(polygon => {\n    const indices = [offset];\n    const numVertices = polygon.length;\n\n    // polygon top\n    // use vertex pairs for GL.LINES => [0, 1, 1, 2, 2, ..., n-1, n-1, 0]\n    for (let i = 1; i < numVertices - 1; i++) {\n      indices.push(i + offset, i + offset);\n    }\n    indices.push(offset);\n\n    // polygon sides\n    for (let i = 0; i < numVertices - 1; i++) {\n      indices.push(i + offset, i + stride + offset);\n    }\n\n    offset += numVertices;\n    return indices;\n  });\n}\n\nfunction calculateSurfaceIndices(vertices, offset) {\n  const stride = countVertices(vertices);\n  const quad = [\n    [0, 1], [0, 3], [1, 2],\n    [1, 2], [0, 3], [1, 4]\n  ];\n\n  function drawRectangle(i) {\n    return quad.map(v => i + v[0] + stride * v[1] + offset);\n  }\n\n  let holes = null;\n\n  if (vertices.length > 1) {\n    holes = vertices.reduce(\n      (acc, polygon) => [...acc, acc[acc.length - 1] + polygon.length],\n      [0]\n    ).slice(1, vertices.length);\n  }\n\n  const topIndices = __WEBPACK_IMPORTED_MODULE_4_earcut___default()(__WEBPACK_IMPORTED_MODULE_5_lodash_flattendeep___default()(vertices), holes, 3).map(index => index + offset);\n\n  const sideIndices = vertices.map(polygon => {\n    const numVertices = polygon.length;\n    // polygon top\n    const indices = [];\n\n    // polygon sides\n    for (let i = 0; i < numVertices - 1; i++) {\n      indices.push(...drawRectangle(i));\n    }\n\n    offset += numVertices;\n    return indices;\n  });\n\n  return [topIndices, sideIndices];\n}\n\n// helpers\n\n// get normal vector of line segment\nfunction getNormal(p1, p2) {\n  const p1x = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils__[\"d\" /* get */])(p1, 0);\n  const p1y = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils__[\"d\" /* get */])(p1, 1);\n  const p2x = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils__[\"d\" /* get */])(p2, 0);\n  const p2y = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils__[\"d\" /* get */])(p2, 1);\n\n  if (p1x === p2x && p1y === p2y) {\n    return [1, 0, 0];\n  }\n\n  const degrees2radians = Math.PI / 180;\n  const lon1 = degrees2radians * p1x;\n  const lon2 = degrees2radians * p2x;\n  const lat1 = degrees2radians * p1y;\n  const lat2 = degrees2radians * p2y;\n  const a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n  const b = Math.cos(lat1) * Math.sin(lat2) -\n    Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n  return __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"vec3\"].normalize([], [b, 0, -a]);\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvc29saWQtcG9seWdvbi1sYXllci9wb2x5Z29uLXRlc3NlbGF0b3ItZXh0cnVkZWQuanM/ZjAxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBQb2x5Z29uIGZyb20gJy4vcG9seWdvbic7XG5pbXBvcnQge3ZlYzN9IGZyb20gJ2dsLW1hdHJpeCc7XG5pbXBvcnQge2ZwNjRpZnl9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscy9mcDY0JztcbmltcG9ydCB7Z2V0LCBjb3VudH0gZnJvbSAnLi4vLi4vLi4vbGliL3V0aWxzJztcbmltcG9ydCBlYXJjdXQgZnJvbSAnZWFyY3V0JztcbmltcG9ydCBmbGF0dGVuRGVlcCBmcm9tICdsb2Rhc2guZmxhdHRlbmRlZXAnO1xuXG5mdW5jdGlvbiBnZXRQaWNraW5nQ29sb3IoaW5kZXgpIHtcbiAgcmV0dXJuIFtcbiAgICAoaW5kZXggKyAxKSAlIDI1NixcbiAgICBNYXRoLmZsb29yKChpbmRleCArIDEpIC8gMjU2KSAlIDI1NixcbiAgICBNYXRoLmZsb29yKChpbmRleCArIDEpIC8gMjU2IC8gMjU2KSAlIDI1NlxuICBdO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNvbG9yKGNvbG9yKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShjb2xvcikpIHtcbiAgICBjb2xvciA9IFtnZXQoY29sb3IsIDApLCBnZXQoY29sb3IsIDEpLCBnZXQoY29sb3IsIDIpLCBnZXQoY29sb3IsIDMpXTtcbiAgfVxuICBjb2xvclszXSA9IE51bWJlci5pc0Zpbml0ZShjb2xvclszXSkgPyBjb2xvclszXSA6IDI1NTtcbiAgcmV0dXJuIGNvbG9yO1xufVxuXG5jb25zdCBERUZBVUxUX0NPTE9SID0gWzAsIDAsIDAsIDI1NV07IC8vIEJsYWNrXG5cbmV4cG9ydCBjbGFzcyBQb2x5Z29uVGVzc2VsYXRvckV4dHJ1ZGVkIHtcblxuICBjb25zdHJ1Y3Rvcih7XG4gICAgcG9seWdvbnMsXG4gICAgZ2V0SGVpZ2h0ID0geCA9PiAxMDAwLFxuICAgIGdldENvbG9yID0geCA9PiBbMCwgMCwgMCwgMjU1XSxcbiAgICB3aXJlZnJhbWUgPSBmYWxzZSxcbiAgICBmcDY0ID0gZmFsc2VcbiAgfSkge1xuICAgIHRoaXMuZnA2NCA9IGZwNjQ7XG5cbiAgICAvLyBFeHBlbnNpdmUgb3BlcmF0aW9uLCBjb252ZXJ0IGFsbCBwb2x5Z29ucyB0byBhcnJheXNcbiAgICBwb2x5Z29ucyA9IHBvbHlnb25zLm1hcCgoY29tcGxleFBvbHlnb24sIHBvbHlnb25JbmRleCkgPT4ge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gZ2V0SGVpZ2h0KHBvbHlnb25JbmRleCkgfHwgMDtcbiAgICAgIHJldHVybiBQb2x5Z29uLm5vcm1hbGl6ZShjb21wbGV4UG9seWdvbikubWFwKFxuICAgICAgICBwb2x5Z29uID0+IHBvbHlnb24ubWFwKGNvb3JkID0+IFtnZXQoY29vcmQsIDApLCBnZXQoY29vcmQsIDEpLCBoZWlnaHRdKVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGdyb3VwZWRWZXJ0aWNlcyA9IHBvbHlnb25zO1xuICAgIHRoaXMuZ3JvdXBlZFZlcnRpY2VzID0gcG9seWdvbnM7XG4gICAgdGhpcy53aXJlZnJhbWUgPSB3aXJlZnJhbWU7XG5cbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcblxuICAgIGNvbnN0IHBvc2l0aW9uc0pTID0gY2FsY3VsYXRlUG9zaXRpb25zSlMoe2dyb3VwZWRWZXJ0aWNlcywgd2lyZWZyYW1lfSk7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLmF0dHJpYnV0ZXMsIHtcbiAgICAgIHBvc2l0aW9uczogY2FsY3VsYXRlUG9zaXRpb25zKHBvc2l0aW9uc0pTLCB0aGlzLmZwNjQpLFxuICAgICAgaW5kaWNlczogY2FsY3VsYXRlSW5kaWNlcyh7Z3JvdXBlZFZlcnRpY2VzLCB3aXJlZnJhbWV9KSxcbiAgICAgIG5vcm1hbHM6IGNhbGN1bGF0ZU5vcm1hbHMoe2dyb3VwZWRWZXJ0aWNlcywgd2lyZWZyYW1lfSksXG4gICAgICAvLyBjb2xvcnM6IGNhbGN1bGF0ZUNvbG9ycyh7Z3JvdXBlZFZlcnRpY2VzLCB3aXJlZnJhbWUsIGdldENvbG9yfSksXG4gICAgICBwaWNraW5nQ29sb3JzOiBjYWxjdWxhdGVQaWNraW5nQ29sb3JzKHtncm91cGVkVmVydGljZXMsIHdpcmVmcmFtZX0pXG4gICAgfSk7XG4gIH1cblxuICBpbmRpY2VzKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXMuaW5kaWNlcztcbiAgfVxuXG4gIHBvc2l0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9ucztcbiAgfVxuXG4gIG5vcm1hbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcy5ub3JtYWxzO1xuICB9XG5cbiAgY29sb3JzKHtnZXRDb2xvciA9IHggPT4gREVGQVVMVF9DT0xPUn0gPSB7fSkge1xuICAgIGNvbnN0IHtncm91cGVkVmVydGljZXMsIHdpcmVmcmFtZX0gPSB0aGlzO1xuICAgIHJldHVybiBjYWxjdWxhdGVDb2xvcnMoe2dyb3VwZWRWZXJ0aWNlcywgd2lyZWZyYW1lLCBnZXRDb2xvcn0pO1xuICB9XG5cbiAgcGlja2luZ0NvbG9ycygpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnBpY2tpbmdDb2xvcnM7XG4gIH1cblxuICAvLyB1cGRhdGVUcmlnZ2Vyczoge1xuICAvLyAgIHBvc2l0aW9uczogWydnZXRIZWlnaHQnXSxcbiAgLy8gICBjb2xvcnM6IFsnZ2V0Q29sb3JzJ11cbiAgLy8gICBwaWNraW5nQ29sb3JzOiAnbm9uZSdcbiAgLy8gfVxufVxuXG5mdW5jdGlvbiBjb3VudFZlcnRpY2VzKHZlcnRpY2VzKSB7XG4gIHJldHVybiB2ZXJ0aWNlcy5yZWR1Y2UoKHZlcnRleENvdW50LCBwb2x5Z29uKSA9PiB2ZXJ0ZXhDb3VudCArIGNvdW50KHBvbHlnb24pLCAwKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlSW5kaWNlcyh7Z3JvdXBlZFZlcnRpY2VzLCB3aXJlZnJhbWUgPSBmYWxzZX0pIHtcbiAgLy8gYWRqdXN0IGluZGV4IG9mZnNldCBmb3IgbXVsdGlwbGUgcG9seWdvbnNcbiAgY29uc3QgbXVsdGlwbGllciA9IHdpcmVmcmFtZSA/IDIgOiA1O1xuICBjb25zdCBvZmZzZXRzID0gZ3JvdXBlZFZlcnRpY2VzLnJlZHVjZShcbiAgICAoYWNjLCB2ZXJ0aWNlcykgPT5cbiAgICAgIFsuLi5hY2MsIGFjY1thY2MubGVuZ3RoIC0gMV0gKyBjb3VudFZlcnRpY2VzKHZlcnRpY2VzKSAqIG11bHRpcGxpZXJdLFxuICAgIFswXVxuICApO1xuXG4gIGNvbnN0IGluZGljZXMgPSBncm91cGVkVmVydGljZXMubWFwKCh2ZXJ0aWNlcywgcG9seWdvbkluZGV4KSA9PlxuICAgIHdpcmVmcmFtZSA/XG4gICAgICAvLyAxLiBnZXQgc2VxdWVudGlhbGx5IG9yZGVyZWQgaW5kaWNlcyBvZiBlYWNoIHBvbHlnb25zIHdpcmVmcmFtZVxuICAgICAgLy8gMi4gb2Zmc2V0IHRoZW0gYnkgdGhlIG51bWJlciBvZiBpbmRpY2VzIGluIHByZXZpb3VzIHBvbHlnb25zXG4gICAgICBjYWxjdWxhdGVDb250b3VySW5kaWNlcyh2ZXJ0aWNlcywgb2Zmc2V0c1twb2x5Z29uSW5kZXhdKSA6XG4gICAgICAvLyAxLiBnZXQgdHJpYW5ndWxhdGVkIGluZGljZXMgZm9yIHRoZSBpbnRlcm5hbCBhcmVhc1xuICAgICAgLy8gMi4gb2Zmc2V0IHRoZW0gYnkgdGhlIG51bWJlciBvZiBpbmRpY2VzIGluIHByZXZpb3VzIHBvbHlnb25zXG4gICAgICBjYWxjdWxhdGVTdXJmYWNlSW5kaWNlcyh2ZXJ0aWNlcywgb2Zmc2V0c1twb2x5Z29uSW5kZXhdKVxuICApO1xuXG4gIHJldHVybiBuZXcgVWludDMyQXJyYXkoZmxhdHRlbkRlZXAoaW5kaWNlcykpO1xufVxuXG4vLyBDYWxjdWxhdGUgYSBmbGF0IHBvc2l0aW9uIGFycmF5IGluIEpTIC0gY2FuIGJlIG1hcHBlZCB0byAzMiBvciA2NCBiaXQgdHlwZWQgYXJyYXlzXG4vLyBSZW1hcmtzOlxuLy8gKiBlYWNoIHRvcCB2ZXJ0ZXggaXMgb24gMyBzdXJmYWNlc1xuLy8gKiBlYWNoIGJvdHRvbSB2ZXJ0ZXggaXMgb24gMiBzdXJmYWNlc1xuZnVuY3Rpb24gY2FsY3VsYXRlUG9zaXRpb25zSlMoe2dyb3VwZWRWZXJ0aWNlcywgd2lyZWZyYW1lID0gZmFsc2V9KSB7XG4gIGNvbnN0IHBvc2l0aW9ucyA9IGdyb3VwZWRWZXJ0aWNlcy5tYXAoY29tcGxleFBvbHlnb24gPT5cbiAgICBjb21wbGV4UG9seWdvbi5tYXAodmVydGljZXMgPT4ge1xuICAgICAgY29uc3QgdG9wVmVydGljZXMgPSBbXS5jb25jYXQodmVydGljZXMpO1xuICAgICAgY29uc3QgYmFzZVZlcnRpY2VzID0gdG9wVmVydGljZXMubWFwKHYgPT4gW2dldCh2LCAwKSwgZ2V0KHYsIDEpLCAwXSk7XG4gICAgICByZXR1cm4gd2lyZWZyYW1lID9cbiAgICAgICAgW3RvcFZlcnRpY2VzLCBiYXNlVmVydGljZXNdIDpcbiAgICAgICAgW3RvcFZlcnRpY2VzLCB0b3BWZXJ0aWNlcywgdG9wVmVydGljZXMsIGJhc2VWZXJ0aWNlcywgYmFzZVZlcnRpY2VzXTtcbiAgICB9KVxuICApO1xuICByZXR1cm4gZmxhdHRlbkRlZXAocG9zaXRpb25zKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUG9zaXRpb25zKHBvc2l0aW9uc0pTLCBmcDY0KSB7XG4gIGxldCBwb3NpdGlvbkxvdztcbiAgaWYgKGZwNjQpIHtcbiAgICAvLyBXZSBvbmx5IG5lZWQgeCwgeSBjb21wb25lbnRcbiAgICBwb3NpdGlvbkxvdyA9IG5ldyBGbG9hdDMyQXJyYXkocG9zaXRpb25zSlMubGVuZ3RoIC8gMyAqIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb25zSlMubGVuZ3RoIC8gMzsgaSsrKSB7XG4gICAgICBwb3NpdGlvbkxvd1tpICogMiArIDBdID0gZnA2NGlmeShwb3NpdGlvbnNKU1tpICogMyArIDBdKVsxXTtcbiAgICAgIHBvc2l0aW9uTG93W2kgKiAyICsgMV0gPSBmcDY0aWZ5KHBvc2l0aW9uc0pTW2kgKiAzICsgMV0pWzFdO1xuICAgIH1cblxuICB9XG4gIHJldHVybiB7cG9zaXRpb25zOiBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9uc0pTKSwgcG9zaXRpb25zNjR4eUxvdzogcG9zaXRpb25Mb3d9O1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVOb3JtYWxzKHtncm91cGVkVmVydGljZXMsIHdpcmVmcmFtZX0pIHtcbiAgY29uc3QgdXAgPSBbMCwgMSwgMF07XG5cbiAgY29uc3Qgbm9ybWFscyA9IGdyb3VwZWRWZXJ0aWNlcy5tYXAoKHZlcnRpY2VzLCBwb2x5Z29uSW5kZXgpID0+IHtcbiAgICBjb25zdCB0b3BOb3JtYWxzID0gbmV3IEFycmF5KGNvdW50VmVydGljZXModmVydGljZXMpKS5maWxsKHVwKTtcbiAgICBjb25zdCBzaWRlTm9ybWFscyA9IHZlcnRpY2VzLm1hcChwb2x5Z29uID0+IGNhbGN1bGF0ZVNpZGVOb3JtYWxzKHBvbHlnb24pKTtcbiAgICBjb25zdCBzaWRlTm9ybWFsc0ZvcndhcmQgPSBzaWRlTm9ybWFscy5tYXAobiA9PiBuWzBdKTtcbiAgICBjb25zdCBzaWRlTm9ybWFsc0JhY2t3YXJkID0gc2lkZU5vcm1hbHMubWFwKG4gPT4gblsxXSk7XG5cbiAgICByZXR1cm4gd2lyZWZyYW1lID9cbiAgICBbdG9wTm9ybWFscywgdG9wTm9ybWFsc10gOlxuICAgIFt0b3BOb3JtYWxzLCBzaWRlTm9ybWFsc0ZvcndhcmQsIHNpZGVOb3JtYWxzQmFja3dhcmQsIHNpZGVOb3JtYWxzRm9yd2FyZCwgc2lkZU5vcm1hbHNCYWNrd2FyZF07XG4gIH0pO1xuXG4gIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGZsYXR0ZW5EZWVwKG5vcm1hbHMpKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlU2lkZU5vcm1hbHModmVydGljZXMpIHtcbiAgY29uc3Qgbm9ybWFscyA9IFtdO1xuXG4gIGxldCBsYXN0VmVydGljZSA9IG51bGw7XG4gIGZvciAoY29uc3QgdmVydGljZSBvZiB2ZXJ0aWNlcykge1xuICAgIGlmIChsYXN0VmVydGljZSkge1xuICAgICAgLy8gdmVydGV4W2ktMV0sIHZlcnRleFtpXVxuICAgICAgY29uc3QgbiA9IGdldE5vcm1hbChsYXN0VmVydGljZSwgdmVydGljZSk7XG4gICAgICBub3JtYWxzLnB1c2gobik7XG4gICAgfVxuICAgIGxhc3RWZXJ0aWNlID0gdmVydGljZTtcbiAgfVxuXG4gIHJldHVybiBbWy4uLm5vcm1hbHMsIG5vcm1hbHNbMF1dLCBbbm9ybWFsc1swXSwgLi4ubm9ybWFsc11dO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVDb2xvcnMoe2dyb3VwZWRWZXJ0aWNlcywgZ2V0Q29sb3IsIHdpcmVmcmFtZSA9IGZhbHNlfSkge1xuICBjb25zdCBjb2xvcnMgPSBncm91cGVkVmVydGljZXMubWFwKChjb21wbGV4UG9seWdvbiwgcG9seWdvbkluZGV4KSA9PiB7XG4gICAgbGV0IGNvbG9yID0gZ2V0Q29sb3IocG9seWdvbkluZGV4KTtcbiAgICBjb2xvciA9IHBhcnNlQ29sb3IoY29sb3IpO1xuXG4gICAgY29uc3QgbnVtVmVydGljZXMgPSBjb3VudFZlcnRpY2VzKGNvbXBsZXhQb2x5Z29uKTtcbiAgICBjb25zdCB0b3BDb2xvcnMgPSBuZXcgQXJyYXkobnVtVmVydGljZXMpLmZpbGwoY29sb3IpO1xuICAgIGNvbnN0IGJhc2VDb2xvcnMgPSBuZXcgQXJyYXkobnVtVmVydGljZXMpLmZpbGwoY29sb3IpO1xuICAgIHJldHVybiB3aXJlZnJhbWUgP1xuICAgICAgW3RvcENvbG9ycywgYmFzZUNvbG9yc10gOlxuICAgICAgW3RvcENvbG9ycywgdG9wQ29sb3JzLCB0b3BDb2xvcnMsIGJhc2VDb2xvcnMsIGJhc2VDb2xvcnNdO1xuICB9KTtcbiAgcmV0dXJuIG5ldyBVaW50OENsYW1wZWRBcnJheShmbGF0dGVuRGVlcChjb2xvcnMpKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUGlja2luZ0NvbG9ycyh7Z3JvdXBlZFZlcnRpY2VzLCB3aXJlZnJhbWUgPSBmYWxzZX0pIHtcbiAgY29uc3QgY29sb3JzID0gZ3JvdXBlZFZlcnRpY2VzLm1hcCgodmVydGljZXMsIHBvbHlnb25JbmRleCkgPT4ge1xuICAgIGNvbnN0IG51bVZlcnRpY2VzID0gY291bnRWZXJ0aWNlcyh2ZXJ0aWNlcyk7XG4gICAgY29uc3QgY29sb3IgPSBnZXRQaWNraW5nQ29sb3IocG9seWdvbkluZGV4KTtcbiAgICBjb25zdCB0b3BDb2xvcnMgPSBuZXcgQXJyYXkobnVtVmVydGljZXMpLmZpbGwoY29sb3IpO1xuICAgIGNvbnN0IGJhc2VDb2xvcnMgPSBuZXcgQXJyYXkobnVtVmVydGljZXMpLmZpbGwoY29sb3IpO1xuICAgIHJldHVybiB3aXJlZnJhbWUgP1xuICAgICAgW3RvcENvbG9ycywgYmFzZUNvbG9yc10gOlxuICAgICAgW3RvcENvbG9ycywgdG9wQ29sb3JzLCB0b3BDb2xvcnMsIGJhc2VDb2xvcnMsIGJhc2VDb2xvcnNdO1xuICB9KTtcbiAgcmV0dXJuIG5ldyBVaW50OENsYW1wZWRBcnJheShmbGF0dGVuRGVlcChjb2xvcnMpKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlQ29udG91ckluZGljZXModmVydGljZXMsIG9mZnNldCkge1xuICBjb25zdCBzdHJpZGUgPSBjb3VudFZlcnRpY2VzKHZlcnRpY2VzKTtcblxuICByZXR1cm4gdmVydGljZXMubWFwKHBvbHlnb24gPT4ge1xuICAgIGNvbnN0IGluZGljZXMgPSBbb2Zmc2V0XTtcbiAgICBjb25zdCBudW1WZXJ0aWNlcyA9IHBvbHlnb24ubGVuZ3RoO1xuXG4gICAgLy8gcG9seWdvbiB0b3BcbiAgICAvLyB1c2UgdmVydGV4IHBhaXJzIGZvciBHTC5MSU5FUyA9PiBbMCwgMSwgMSwgMiwgMiwgLi4uLCBuLTEsIG4tMSwgMF1cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG51bVZlcnRpY2VzIC0gMTsgaSsrKSB7XG4gICAgICBpbmRpY2VzLnB1c2goaSArIG9mZnNldCwgaSArIG9mZnNldCk7XG4gICAgfVxuICAgIGluZGljZXMucHVzaChvZmZzZXQpO1xuXG4gICAgLy8gcG9seWdvbiBzaWRlc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVmVydGljZXMgLSAxOyBpKyspIHtcbiAgICAgIGluZGljZXMucHVzaChpICsgb2Zmc2V0LCBpICsgc3RyaWRlICsgb2Zmc2V0KTtcbiAgICB9XG5cbiAgICBvZmZzZXQgKz0gbnVtVmVydGljZXM7XG4gICAgcmV0dXJuIGluZGljZXM7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVTdXJmYWNlSW5kaWNlcyh2ZXJ0aWNlcywgb2Zmc2V0KSB7XG4gIGNvbnN0IHN0cmlkZSA9IGNvdW50VmVydGljZXModmVydGljZXMpO1xuICBjb25zdCBxdWFkID0gW1xuICAgIFswLCAxXSwgWzAsIDNdLCBbMSwgMl0sXG4gICAgWzEsIDJdLCBbMCwgM10sIFsxLCA0XVxuICBdO1xuXG4gIGZ1bmN0aW9uIGRyYXdSZWN0YW5nbGUoaSkge1xuICAgIHJldHVybiBxdWFkLm1hcCh2ID0+IGkgKyB2WzBdICsgc3RyaWRlICogdlsxXSArIG9mZnNldCk7XG4gIH1cblxuICBsZXQgaG9sZXMgPSBudWxsO1xuXG4gIGlmICh2ZXJ0aWNlcy5sZW5ndGggPiAxKSB7XG4gICAgaG9sZXMgPSB2ZXJ0aWNlcy5yZWR1Y2UoXG4gICAgICAoYWNjLCBwb2x5Z29uKSA9PiBbLi4uYWNjLCBhY2NbYWNjLmxlbmd0aCAtIDFdICsgcG9seWdvbi5sZW5ndGhdLFxuICAgICAgWzBdXG4gICAgKS5zbGljZSgxLCB2ZXJ0aWNlcy5sZW5ndGgpO1xuICB9XG5cbiAgY29uc3QgdG9wSW5kaWNlcyA9IGVhcmN1dChmbGF0dGVuRGVlcCh2ZXJ0aWNlcyksIGhvbGVzLCAzKS5tYXAoaW5kZXggPT4gaW5kZXggKyBvZmZzZXQpO1xuXG4gIGNvbnN0IHNpZGVJbmRpY2VzID0gdmVydGljZXMubWFwKHBvbHlnb24gPT4ge1xuICAgIGNvbnN0IG51bVZlcnRpY2VzID0gcG9seWdvbi5sZW5ndGg7XG4gICAgLy8gcG9seWdvbiB0b3BcbiAgICBjb25zdCBpbmRpY2VzID0gW107XG5cbiAgICAvLyBwb2x5Z29uIHNpZGVzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1WZXJ0aWNlcyAtIDE7IGkrKykge1xuICAgICAgaW5kaWNlcy5wdXNoKC4uLmRyYXdSZWN0YW5nbGUoaSkpO1xuICAgIH1cblxuICAgIG9mZnNldCArPSBudW1WZXJ0aWNlcztcbiAgICByZXR1cm4gaW5kaWNlcztcbiAgfSk7XG5cbiAgcmV0dXJuIFt0b3BJbmRpY2VzLCBzaWRlSW5kaWNlc107XG59XG5cbi8vIGhlbHBlcnNcblxuLy8gZ2V0IG5vcm1hbCB2ZWN0b3Igb2YgbGluZSBzZWdtZW50XG5mdW5jdGlvbiBnZXROb3JtYWwocDEsIHAyKSB7XG4gIGNvbnN0IHAxeCA9IGdldChwMSwgMCk7XG4gIGNvbnN0IHAxeSA9IGdldChwMSwgMSk7XG4gIGNvbnN0IHAyeCA9IGdldChwMiwgMCk7XG4gIGNvbnN0IHAyeSA9IGdldChwMiwgMSk7XG5cbiAgaWYgKHAxeCA9PT0gcDJ4ICYmIHAxeSA9PT0gcDJ5KSB7XG4gICAgcmV0dXJuIFsxLCAwLCAwXTtcbiAgfVxuXG4gIGNvbnN0IGRlZ3JlZXMycmFkaWFucyA9IE1hdGguUEkgLyAxODA7XG4gIGNvbnN0IGxvbjEgPSBkZWdyZWVzMnJhZGlhbnMgKiBwMXg7XG4gIGNvbnN0IGxvbjIgPSBkZWdyZWVzMnJhZGlhbnMgKiBwMng7XG4gIGNvbnN0IGxhdDEgPSBkZWdyZWVzMnJhZGlhbnMgKiBwMXk7XG4gIGNvbnN0IGxhdDIgPSBkZWdyZWVzMnJhZGlhbnMgKiBwMnk7XG4gIGNvbnN0IGEgPSBNYXRoLnNpbihsb24yIC0gbG9uMSkgKiBNYXRoLmNvcyhsYXQyKTtcbiAgY29uc3QgYiA9IE1hdGguY29zKGxhdDEpICogTWF0aC5zaW4obGF0MikgLVxuICAgIE1hdGguc2luKGxhdDEpICogTWF0aC5jb3MobGF0MikgKiBNYXRoLmNvcyhsb24yIC0gbG9uMSk7XG4gIHJldHVybiB2ZWMzLm5vcm1hbGl6ZShbXSwgW2IsIDAsIC1hXSk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9sYXllcnMvY29yZS9zb2xpZC1wb2x5Z29uLWxheWVyL3BvbHlnb24tdGVzc2VsYXRvci1leHRydWRlZC5qc1xuLy8gbW9kdWxlIGlkID0gODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 84 */
/* exports provided: PolygonTesselator, flattenVertices2 */
/* exports used: PolygonTesselator */
/*!*******************************************************************!*\
  !*** ./src/layers/core/solid-polygon-layer/polygon-tesselator.js ***!
  \*******************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polygon__ = __webpack_require__(/*! ./polygon */ 13);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_earcut__ = __webpack_require__(/*! earcut */ 8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_earcut___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_earcut__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_utils__ = __webpack_require__(/*! ../../../lib/utils */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__ = __webpack_require__(/*! ../../../lib/utils/fp64 */ 4);\n/* unused harmony export flattenVertices2 */\n// Handles tesselation of polygons with holes\n// - 2D surfaces\n// - 2D outlines\n// - 3D surfaces (top and sides only)\n// - 3D wireframes (not yet)\n\n\n\n\n\n// Maybe deck.gl or luma.gl needs to export this\nfunction getPickingColor(index) {\n  return [\n    (index + 1) % 256,\n    Math.floor((index + 1) / 256) % 256,\n    Math.floor((index + 1) / 256 / 256) % 256\n  ];\n}\n\nfunction parseColor(color) {\n  if (!Array.isArray(color)) {\n    color = [__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"d\" /* get */])(color, 0), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"d\" /* get */])(color, 1), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"d\" /* get */])(color, 2), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"d\" /* get */])(color, 3)];\n  }\n  color[3] = Number.isFinite(color[3]) ? color[3] : 255;\n  return color;\n}\n\nconst DEFAULT_COLOR = [0, 0, 0, 255]; // Black\n\n// This class is set up to allow querying one attribute at a time\n// the way the AttributeManager expects it\nclass PolygonTesselator {\n  constructor({polygons, fp64 = false}) {\n    // Normalize all polygons\n    this.polygons = polygons.map(polygon => __WEBPACK_IMPORTED_MODULE_0__polygon__[\"a\" /* normalize */](polygon));\n    // Count all polygon vertices\n    this.pointCount = getPointCount(this.polygons);\n    this.fp64 = fp64;\n  }\n\n  indices() {\n    const {polygons, indexCount} = this;\n    return calculateIndices({polygons, indexCount});\n  }\n\n  positions() {\n    const {polygons, pointCount} = this;\n    return calculatePositions({polygons, pointCount, fp64: this.fp64});\n  }\n\n  normals() {\n    const {polygons, pointCount} = this;\n    return calculateNormals({polygons, pointCount});\n  }\n\n  colors({getColor = x => DEFAULT_COLOR} = {}) {\n    const {polygons, pointCount} = this;\n    return calculateColors({polygons, pointCount, getColor});\n  }\n\n  pickingColors() {\n    const {polygons, pointCount} = this;\n    return calculatePickingColors({polygons, pointCount});\n  }\n\n  // getAttribute({size, accessor}) {\n  //   const {polygons, pointCount} = this;\n  //   return calculateAttribute({polygons, pointCount, size, accessor});\n  // }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = PolygonTesselator;\n\n\n// Count number of points in a list of complex polygons\nfunction getPointCount(polygons) {\n  return polygons.reduce((points, polygon) => points + __WEBPACK_IMPORTED_MODULE_0__polygon__[\"b\" /* getVertexCount */](polygon), 0);\n}\n\n// COunt number of triangles in a list of complex polygons\nfunction getTriangleCount(polygons) {\n  return polygons.reduce((triangles, polygon) => triangles + __WEBPACK_IMPORTED_MODULE_0__polygon__[\"c\" /* getTriangleCount */](polygon), 0);\n}\n\n// Returns the offsets of each complex polygon in the combined array of all polygons\nfunction getPolygonOffsets(polygons) {\n  const offsets = new Array(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"e\" /* count */])(polygons) + 1);\n  offsets[0] = 0;\n  let offset = 0;\n  polygons.forEach((polygon, i) => {\n    offset += __WEBPACK_IMPORTED_MODULE_0__polygon__[\"b\" /* getVertexCount */](polygon);\n    offsets[i + 1] = offset;\n  });\n  return offsets;\n}\n\n// Returns the offset of each hole polygon in the flattened array for that polygon\nfunction getHoleIndices(complexPolygon) {\n  let holeIndices = null;\n  if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"e\" /* count */])(complexPolygon) > 1) {\n    let polygonStartIndex = 0;\n    holeIndices = [];\n    complexPolygon.forEach(polygon => {\n      polygonStartIndex += __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"e\" /* count */])(polygon);\n      holeIndices.push(polygonStartIndex);\n    });\n    // Last element points to end of the flat array, remove it\n    holeIndices.pop();\n  }\n  return holeIndices;\n}\n\nfunction calculateIndices({polygons, IndexType = Uint32Array}) {\n  // Calculate length of index array (3 * number of triangles)\n  const indexCount = 3 * getTriangleCount(polygons);\n  const offsets = getPolygonOffsets(polygons);\n\n  // Allocate the attribute\n  // TODO it's not the index count but the vertex count that must be checked\n  if (IndexType === Uint16Array && indexCount > 65535) {\n    throw new Error('Vertex count exceeds browser\\'s limit');\n  }\n  const attribute = new IndexType(indexCount);\n\n  // 1. get triangulated indices for the internal areas\n  // 2. offset them by the number of indices in previous polygons\n  let i = 0;\n  polygons.forEach((polygon, polygonIndex) => {\n    for (const index of calculateSurfaceIndices(polygon)) {\n      attribute[i++] = index + offsets[polygonIndex];\n    }\n  });\n\n  return attribute;\n}\n\n/*\n * Get vertex indices for drawing complexPolygon mesh\n * @private\n * @param {[Number,Number,Number][][]} complexPolygon\n * @returns {[Number]} indices\n */\nfunction calculateSurfaceIndices(complexPolygon) {\n  // Prepare an array of hole indices as expected by earcut\n  const holeIndices = getHoleIndices(complexPolygon);\n  // Flatten the polygon as expected by earcut\n  const verts = flattenVertices2(complexPolygon);\n  // Let earcut triangulate the polygon\n  return __WEBPACK_IMPORTED_MODULE_1_earcut___default()(verts, holeIndices, 3);\n}\n\n// TODO - refactor\nfunction isContainer(value) {\n  return Array.isArray(value) || ArrayBuffer.isView(value) ||\n    value !== null && typeof value === 'object';\n}\n\n// TODO - refactor, this file should not need a separate flatten func\n// Flattens nested array of vertices, padding third coordinate as needed\nfunction flattenVertices2(nestedArray, {result = [], dimensions = 3} = {}) {\n  let index = -1;\n  let vertexLength = 0;\n  const length = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"e\" /* count */])(nestedArray);\n  while (++index < length) {\n    const value = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"d\" /* get */])(nestedArray, index);\n    if (isContainer(value)) {\n      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"f\" /* flattenVertices */])(value, {result, dimensions});\n    } else {\n      if (vertexLength < dimensions) { // eslint-disable-line\n        result.push(value);\n        vertexLength++;\n      }\n    }\n  }\n  // Add a third coordinate if needed\n  if (vertexLength > 0 && vertexLength < dimensions) {\n    result.push(0);\n  }\n  return result;\n}\n\nfunction calculatePositions({polygons, pointCount, fp64}) {\n  // Flatten out all the vertices of all the sub subPolygons\n  const attribute = new Float32Array(pointCount * 3);\n  let attributeLow;\n  if (fp64) {\n    // We only need x, y component\n    attributeLow = new Float32Array(pointCount * 2);\n  }\n  let i = 0;\n  let j = 0;\n  for (const polygon of polygons) {\n    __WEBPACK_IMPORTED_MODULE_0__polygon__[\"d\" /* forEachVertex */](polygon, vertex => { // eslint-disable-line\n      const x = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"d\" /* get */])(vertex, 0);\n      const y = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"d\" /* get */])(vertex, 1);\n      const z = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"d\" /* get */])(vertex, 2) || 0;\n      attribute[i++] = x;\n      attribute[i++] = y;\n      attribute[i++] = z;\n      if (fp64) {\n        attributeLow[j++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__[\"a\" /* fp64ify */])(x)[1];\n        attributeLow[j++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__[\"a\" /* fp64ify */])(y)[1];\n      }\n    });\n  }\n  return {positions: attribute, positions64xyLow: attributeLow};\n}\n\nfunction calculateNormals({polygons, pointCount}) {\n  // TODO - use generic vertex attribute?\n  const attribute = new Float32Array(pointCount * 3);\n  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"g\" /* fillArray */])({target: attribute, source: [0, 1, 0], start: 0, pointCount});\n  return attribute;\n}\n\nfunction calculateColors({polygons, pointCount, getColor}) {\n  const attribute = new Uint8Array(pointCount * 4);\n  let i = 0;\n  polygons.forEach((complexPolygon, polygonIndex) => {\n    // Calculate polygon color\n    let color = getColor(polygonIndex);\n    color = parseColor(color);\n\n    const vertexCount = __WEBPACK_IMPORTED_MODULE_0__polygon__[\"b\" /* getVertexCount */](complexPolygon);\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"g\" /* fillArray */])({target: attribute, source: color, start: i, count: vertexCount});\n    i += color.length * vertexCount;\n  });\n  return attribute;\n}\n\nfunction calculatePickingColors({polygons, pointCount}) {\n  const attribute = new Uint8Array(pointCount * 3);\n  let i = 0;\n  polygons.forEach((complexPolygon, polygonIndex) => {\n    const color = getPickingColor(polygonIndex);\n    const vertexCount = __WEBPACK_IMPORTED_MODULE_0__polygon__[\"b\" /* getVertexCount */](complexPolygon);\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"g\" /* fillArray */])({target: attribute, source: color, start: i, count: vertexCount});\n    i += color.length * vertexCount;\n  });\n  return attribute;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvc29saWQtcG9seWdvbi1sYXllci9wb2x5Z29uLXRlc3NlbGF0b3IuanM/YTg2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBIYW5kbGVzIHRlc3NlbGF0aW9uIG9mIHBvbHlnb25zIHdpdGggaG9sZXNcbi8vIC0gMkQgc3VyZmFjZXNcbi8vIC0gMkQgb3V0bGluZXNcbi8vIC0gM0Qgc3VyZmFjZXMgKHRvcCBhbmQgc2lkZXMgb25seSlcbi8vIC0gM0Qgd2lyZWZyYW1lcyAobm90IHlldClcbmltcG9ydCAqIGFzIFBvbHlnb24gZnJvbSAnLi9wb2x5Z29uJztcbmltcG9ydCBlYXJjdXQgZnJvbSAnZWFyY3V0JztcbmltcG9ydCB7Z2V0LCBjb3VudCwgZmxhdHRlblZlcnRpY2VzLCBmaWxsQXJyYXl9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscyc7XG5pbXBvcnQge2ZwNjRpZnl9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscy9mcDY0JztcblxuLy8gTWF5YmUgZGVjay5nbCBvciBsdW1hLmdsIG5lZWRzIHRvIGV4cG9ydCB0aGlzXG5mdW5jdGlvbiBnZXRQaWNraW5nQ29sb3IoaW5kZXgpIHtcbiAgcmV0dXJuIFtcbiAgICAoaW5kZXggKyAxKSAlIDI1NixcbiAgICBNYXRoLmZsb29yKChpbmRleCArIDEpIC8gMjU2KSAlIDI1NixcbiAgICBNYXRoLmZsb29yKChpbmRleCArIDEpIC8gMjU2IC8gMjU2KSAlIDI1NlxuICBdO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNvbG9yKGNvbG9yKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShjb2xvcikpIHtcbiAgICBjb2xvciA9IFtnZXQoY29sb3IsIDApLCBnZXQoY29sb3IsIDEpLCBnZXQoY29sb3IsIDIpLCBnZXQoY29sb3IsIDMpXTtcbiAgfVxuICBjb2xvclszXSA9IE51bWJlci5pc0Zpbml0ZShjb2xvclszXSkgPyBjb2xvclszXSA6IDI1NTtcbiAgcmV0dXJuIGNvbG9yO1xufVxuXG5jb25zdCBERUZBVUxUX0NPTE9SID0gWzAsIDAsIDAsIDI1NV07IC8vIEJsYWNrXG5cbi8vIFRoaXMgY2xhc3MgaXMgc2V0IHVwIHRvIGFsbG93IHF1ZXJ5aW5nIG9uZSBhdHRyaWJ1dGUgYXQgYSB0aW1lXG4vLyB0aGUgd2F5IHRoZSBBdHRyaWJ1dGVNYW5hZ2VyIGV4cGVjdHMgaXRcbmV4cG9ydCBjbGFzcyBQb2x5Z29uVGVzc2VsYXRvciB7XG4gIGNvbnN0cnVjdG9yKHtwb2x5Z29ucywgZnA2NCA9IGZhbHNlfSkge1xuICAgIC8vIE5vcm1hbGl6ZSBhbGwgcG9seWdvbnNcbiAgICB0aGlzLnBvbHlnb25zID0gcG9seWdvbnMubWFwKHBvbHlnb24gPT4gUG9seWdvbi5ub3JtYWxpemUocG9seWdvbikpO1xuICAgIC8vIENvdW50IGFsbCBwb2x5Z29uIHZlcnRpY2VzXG4gICAgdGhpcy5wb2ludENvdW50ID0gZ2V0UG9pbnRDb3VudCh0aGlzLnBvbHlnb25zKTtcbiAgICB0aGlzLmZwNjQgPSBmcDY0O1xuICB9XG5cbiAgaW5kaWNlcygpIHtcbiAgICBjb25zdCB7cG9seWdvbnMsIGluZGV4Q291bnR9ID0gdGhpcztcbiAgICByZXR1cm4gY2FsY3VsYXRlSW5kaWNlcyh7cG9seWdvbnMsIGluZGV4Q291bnR9KTtcbiAgfVxuXG4gIHBvc2l0aW9ucygpIHtcbiAgICBjb25zdCB7cG9seWdvbnMsIHBvaW50Q291bnR9ID0gdGhpcztcbiAgICByZXR1cm4gY2FsY3VsYXRlUG9zaXRpb25zKHtwb2x5Z29ucywgcG9pbnRDb3VudCwgZnA2NDogdGhpcy5mcDY0fSk7XG4gIH1cblxuICBub3JtYWxzKCkge1xuICAgIGNvbnN0IHtwb2x5Z29ucywgcG9pbnRDb3VudH0gPSB0aGlzO1xuICAgIHJldHVybiBjYWxjdWxhdGVOb3JtYWxzKHtwb2x5Z29ucywgcG9pbnRDb3VudH0pO1xuICB9XG5cbiAgY29sb3JzKHtnZXRDb2xvciA9IHggPT4gREVGQVVMVF9DT0xPUn0gPSB7fSkge1xuICAgIGNvbnN0IHtwb2x5Z29ucywgcG9pbnRDb3VudH0gPSB0aGlzO1xuICAgIHJldHVybiBjYWxjdWxhdGVDb2xvcnMoe3BvbHlnb25zLCBwb2ludENvdW50LCBnZXRDb2xvcn0pO1xuICB9XG5cbiAgcGlja2luZ0NvbG9ycygpIHtcbiAgICBjb25zdCB7cG9seWdvbnMsIHBvaW50Q291bnR9ID0gdGhpcztcbiAgICByZXR1cm4gY2FsY3VsYXRlUGlja2luZ0NvbG9ycyh7cG9seWdvbnMsIHBvaW50Q291bnR9KTtcbiAgfVxuXG4gIC8vIGdldEF0dHJpYnV0ZSh7c2l6ZSwgYWNjZXNzb3J9KSB7XG4gIC8vICAgY29uc3Qge3BvbHlnb25zLCBwb2ludENvdW50fSA9IHRoaXM7XG4gIC8vICAgcmV0dXJuIGNhbGN1bGF0ZUF0dHJpYnV0ZSh7cG9seWdvbnMsIHBvaW50Q291bnQsIHNpemUsIGFjY2Vzc29yfSk7XG4gIC8vIH1cbn1cblxuLy8gQ291bnQgbnVtYmVyIG9mIHBvaW50cyBpbiBhIGxpc3Qgb2YgY29tcGxleCBwb2x5Z29uc1xuZnVuY3Rpb24gZ2V0UG9pbnRDb3VudChwb2x5Z29ucykge1xuICByZXR1cm4gcG9seWdvbnMucmVkdWNlKChwb2ludHMsIHBvbHlnb24pID0+IHBvaW50cyArIFBvbHlnb24uZ2V0VmVydGV4Q291bnQocG9seWdvbiksIDApO1xufVxuXG4vLyBDT3VudCBudW1iZXIgb2YgdHJpYW5nbGVzIGluIGEgbGlzdCBvZiBjb21wbGV4IHBvbHlnb25zXG5mdW5jdGlvbiBnZXRUcmlhbmdsZUNvdW50KHBvbHlnb25zKSB7XG4gIHJldHVybiBwb2x5Z29ucy5yZWR1Y2UoKHRyaWFuZ2xlcywgcG9seWdvbikgPT4gdHJpYW5nbGVzICsgUG9seWdvbi5nZXRUcmlhbmdsZUNvdW50KHBvbHlnb24pLCAwKTtcbn1cblxuLy8gUmV0dXJucyB0aGUgb2Zmc2V0cyBvZiBlYWNoIGNvbXBsZXggcG9seWdvbiBpbiB0aGUgY29tYmluZWQgYXJyYXkgb2YgYWxsIHBvbHlnb25zXG5mdW5jdGlvbiBnZXRQb2x5Z29uT2Zmc2V0cyhwb2x5Z29ucykge1xuICBjb25zdCBvZmZzZXRzID0gbmV3IEFycmF5KGNvdW50KHBvbHlnb25zKSArIDEpO1xuICBvZmZzZXRzWzBdID0gMDtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIHBvbHlnb25zLmZvckVhY2goKHBvbHlnb24sIGkpID0+IHtcbiAgICBvZmZzZXQgKz0gUG9seWdvbi5nZXRWZXJ0ZXhDb3VudChwb2x5Z29uKTtcbiAgICBvZmZzZXRzW2kgKyAxXSA9IG9mZnNldDtcbiAgfSk7XG4gIHJldHVybiBvZmZzZXRzO1xufVxuXG4vLyBSZXR1cm5zIHRoZSBvZmZzZXQgb2YgZWFjaCBob2xlIHBvbHlnb24gaW4gdGhlIGZsYXR0ZW5lZCBhcnJheSBmb3IgdGhhdCBwb2x5Z29uXG5mdW5jdGlvbiBnZXRIb2xlSW5kaWNlcyhjb21wbGV4UG9seWdvbikge1xuICBsZXQgaG9sZUluZGljZXMgPSBudWxsO1xuICBpZiAoY291bnQoY29tcGxleFBvbHlnb24pID4gMSkge1xuICAgIGxldCBwb2x5Z29uU3RhcnRJbmRleCA9IDA7XG4gICAgaG9sZUluZGljZXMgPSBbXTtcbiAgICBjb21wbGV4UG9seWdvbi5mb3JFYWNoKHBvbHlnb24gPT4ge1xuICAgICAgcG9seWdvblN0YXJ0SW5kZXggKz0gY291bnQocG9seWdvbik7XG4gICAgICBob2xlSW5kaWNlcy5wdXNoKHBvbHlnb25TdGFydEluZGV4KTtcbiAgICB9KTtcbiAgICAvLyBMYXN0IGVsZW1lbnQgcG9pbnRzIHRvIGVuZCBvZiB0aGUgZmxhdCBhcnJheSwgcmVtb3ZlIGl0XG4gICAgaG9sZUluZGljZXMucG9wKCk7XG4gIH1cbiAgcmV0dXJuIGhvbGVJbmRpY2VzO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVJbmRpY2VzKHtwb2x5Z29ucywgSW5kZXhUeXBlID0gVWludDMyQXJyYXl9KSB7XG4gIC8vIENhbGN1bGF0ZSBsZW5ndGggb2YgaW5kZXggYXJyYXkgKDMgKiBudW1iZXIgb2YgdHJpYW5nbGVzKVxuICBjb25zdCBpbmRleENvdW50ID0gMyAqIGdldFRyaWFuZ2xlQ291bnQocG9seWdvbnMpO1xuICBjb25zdCBvZmZzZXRzID0gZ2V0UG9seWdvbk9mZnNldHMocG9seWdvbnMpO1xuXG4gIC8vIEFsbG9jYXRlIHRoZSBhdHRyaWJ1dGVcbiAgLy8gVE9ETyBpdCdzIG5vdCB0aGUgaW5kZXggY291bnQgYnV0IHRoZSB2ZXJ0ZXggY291bnQgdGhhdCBtdXN0IGJlIGNoZWNrZWRcbiAgaWYgKEluZGV4VHlwZSA9PT0gVWludDE2QXJyYXkgJiYgaW5kZXhDb3VudCA+IDY1NTM1KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdWZXJ0ZXggY291bnQgZXhjZWVkcyBicm93c2VyXFwncyBsaW1pdCcpO1xuICB9XG4gIGNvbnN0IGF0dHJpYnV0ZSA9IG5ldyBJbmRleFR5cGUoaW5kZXhDb3VudCk7XG5cbiAgLy8gMS4gZ2V0IHRyaWFuZ3VsYXRlZCBpbmRpY2VzIGZvciB0aGUgaW50ZXJuYWwgYXJlYXNcbiAgLy8gMi4gb2Zmc2V0IHRoZW0gYnkgdGhlIG51bWJlciBvZiBpbmRpY2VzIGluIHByZXZpb3VzIHBvbHlnb25zXG4gIGxldCBpID0gMDtcbiAgcG9seWdvbnMuZm9yRWFjaCgocG9seWdvbiwgcG9seWdvbkluZGV4KSA9PiB7XG4gICAgZm9yIChjb25zdCBpbmRleCBvZiBjYWxjdWxhdGVTdXJmYWNlSW5kaWNlcyhwb2x5Z29uKSkge1xuICAgICAgYXR0cmlidXRlW2krK10gPSBpbmRleCArIG9mZnNldHNbcG9seWdvbkluZGV4XTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBhdHRyaWJ1dGU7XG59XG5cbi8qXG4gKiBHZXQgdmVydGV4IGluZGljZXMgZm9yIGRyYXdpbmcgY29tcGxleFBvbHlnb24gbWVzaFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7W051bWJlcixOdW1iZXIsTnVtYmVyXVtdW119IGNvbXBsZXhQb2x5Z29uXG4gKiBAcmV0dXJucyB7W051bWJlcl19IGluZGljZXNcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlU3VyZmFjZUluZGljZXMoY29tcGxleFBvbHlnb24pIHtcbiAgLy8gUHJlcGFyZSBhbiBhcnJheSBvZiBob2xlIGluZGljZXMgYXMgZXhwZWN0ZWQgYnkgZWFyY3V0XG4gIGNvbnN0IGhvbGVJbmRpY2VzID0gZ2V0SG9sZUluZGljZXMoY29tcGxleFBvbHlnb24pO1xuICAvLyBGbGF0dGVuIHRoZSBwb2x5Z29uIGFzIGV4cGVjdGVkIGJ5IGVhcmN1dFxuICBjb25zdCB2ZXJ0cyA9IGZsYXR0ZW5WZXJ0aWNlczIoY29tcGxleFBvbHlnb24pO1xuICAvLyBMZXQgZWFyY3V0IHRyaWFuZ3VsYXRlIHRoZSBwb2x5Z29uXG4gIHJldHVybiBlYXJjdXQodmVydHMsIGhvbGVJbmRpY2VzLCAzKTtcbn1cblxuLy8gVE9ETyAtIHJlZmFjdG9yXG5mdW5jdGlvbiBpc0NvbnRhaW5lcih2YWx1ZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSB8fFxuICAgIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XG59XG5cbi8vIFRPRE8gLSByZWZhY3RvciwgdGhpcyBmaWxlIHNob3VsZCBub3QgbmVlZCBhIHNlcGFyYXRlIGZsYXR0ZW4gZnVuY1xuLy8gRmxhdHRlbnMgbmVzdGVkIGFycmF5IG9mIHZlcnRpY2VzLCBwYWRkaW5nIHRoaXJkIGNvb3JkaW5hdGUgYXMgbmVlZGVkXG5leHBvcnQgZnVuY3Rpb24gZmxhdHRlblZlcnRpY2VzMihuZXN0ZWRBcnJheSwge3Jlc3VsdCA9IFtdLCBkaW1lbnNpb25zID0gM30gPSB7fSkge1xuICBsZXQgaW5kZXggPSAtMTtcbiAgbGV0IHZlcnRleExlbmd0aCA9IDA7XG4gIGNvbnN0IGxlbmd0aCA9IGNvdW50KG5lc3RlZEFycmF5KTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldChuZXN0ZWRBcnJheSwgaW5kZXgpO1xuICAgIGlmIChpc0NvbnRhaW5lcih2YWx1ZSkpIHtcbiAgICAgIGZsYXR0ZW5WZXJ0aWNlcyh2YWx1ZSwge3Jlc3VsdCwgZGltZW5zaW9uc30pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmVydGV4TGVuZ3RoIDwgZGltZW5zaW9ucykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgdmVydGV4TGVuZ3RoKys7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIEFkZCBhIHRoaXJkIGNvb3JkaW5hdGUgaWYgbmVlZGVkXG4gIGlmICh2ZXJ0ZXhMZW5ndGggPiAwICYmIHZlcnRleExlbmd0aCA8IGRpbWVuc2lvbnMpIHtcbiAgICByZXN1bHQucHVzaCgwKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVQb3NpdGlvbnMoe3BvbHlnb25zLCBwb2ludENvdW50LCBmcDY0fSkge1xuICAvLyBGbGF0dGVuIG91dCBhbGwgdGhlIHZlcnRpY2VzIG9mIGFsbCB0aGUgc3ViIHN1YlBvbHlnb25zXG4gIGNvbnN0IGF0dHJpYnV0ZSA9IG5ldyBGbG9hdDMyQXJyYXkocG9pbnRDb3VudCAqIDMpO1xuICBsZXQgYXR0cmlidXRlTG93O1xuICBpZiAoZnA2NCkge1xuICAgIC8vIFdlIG9ubHkgbmVlZCB4LCB5IGNvbXBvbmVudFxuICAgIGF0dHJpYnV0ZUxvdyA9IG5ldyBGbG9hdDMyQXJyYXkocG9pbnRDb3VudCAqIDIpO1xuICB9XG4gIGxldCBpID0gMDtcbiAgbGV0IGogPSAwO1xuICBmb3IgKGNvbnN0IHBvbHlnb24gb2YgcG9seWdvbnMpIHtcbiAgICBQb2x5Z29uLmZvckVhY2hWZXJ0ZXgocG9seWdvbiwgdmVydGV4ID0+IHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgY29uc3QgeCA9IGdldCh2ZXJ0ZXgsIDApO1xuICAgICAgY29uc3QgeSA9IGdldCh2ZXJ0ZXgsIDEpO1xuICAgICAgY29uc3QgeiA9IGdldCh2ZXJ0ZXgsIDIpIHx8IDA7XG4gICAgICBhdHRyaWJ1dGVbaSsrXSA9IHg7XG4gICAgICBhdHRyaWJ1dGVbaSsrXSA9IHk7XG4gICAgICBhdHRyaWJ1dGVbaSsrXSA9IHo7XG4gICAgICBpZiAoZnA2NCkge1xuICAgICAgICBhdHRyaWJ1dGVMb3dbaisrXSA9IGZwNjRpZnkoeClbMV07XG4gICAgICAgIGF0dHJpYnV0ZUxvd1tqKytdID0gZnA2NGlmeSh5KVsxXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge3Bvc2l0aW9uczogYXR0cmlidXRlLCBwb3NpdGlvbnM2NHh5TG93OiBhdHRyaWJ1dGVMb3d9O1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVOb3JtYWxzKHtwb2x5Z29ucywgcG9pbnRDb3VudH0pIHtcbiAgLy8gVE9ETyAtIHVzZSBnZW5lcmljIHZlcnRleCBhdHRyaWJ1dGU/XG4gIGNvbnN0IGF0dHJpYnV0ZSA9IG5ldyBGbG9hdDMyQXJyYXkocG9pbnRDb3VudCAqIDMpO1xuICBmaWxsQXJyYXkoe3RhcmdldDogYXR0cmlidXRlLCBzb3VyY2U6IFswLCAxLCAwXSwgc3RhcnQ6IDAsIHBvaW50Q291bnR9KTtcbiAgcmV0dXJuIGF0dHJpYnV0ZTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlQ29sb3JzKHtwb2x5Z29ucywgcG9pbnRDb3VudCwgZ2V0Q29sb3J9KSB7XG4gIGNvbnN0IGF0dHJpYnV0ZSA9IG5ldyBVaW50OEFycmF5KHBvaW50Q291bnQgKiA0KTtcbiAgbGV0IGkgPSAwO1xuICBwb2x5Z29ucy5mb3JFYWNoKChjb21wbGV4UG9seWdvbiwgcG9seWdvbkluZGV4KSA9PiB7XG4gICAgLy8gQ2FsY3VsYXRlIHBvbHlnb24gY29sb3JcbiAgICBsZXQgY29sb3IgPSBnZXRDb2xvcihwb2x5Z29uSW5kZXgpO1xuICAgIGNvbG9yID0gcGFyc2VDb2xvcihjb2xvcik7XG5cbiAgICBjb25zdCB2ZXJ0ZXhDb3VudCA9IFBvbHlnb24uZ2V0VmVydGV4Q291bnQoY29tcGxleFBvbHlnb24pO1xuICAgIGZpbGxBcnJheSh7dGFyZ2V0OiBhdHRyaWJ1dGUsIHNvdXJjZTogY29sb3IsIHN0YXJ0OiBpLCBjb3VudDogdmVydGV4Q291bnR9KTtcbiAgICBpICs9IGNvbG9yLmxlbmd0aCAqIHZlcnRleENvdW50O1xuICB9KTtcbiAgcmV0dXJuIGF0dHJpYnV0ZTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUGlja2luZ0NvbG9ycyh7cG9seWdvbnMsIHBvaW50Q291bnR9KSB7XG4gIGNvbnN0IGF0dHJpYnV0ZSA9IG5ldyBVaW50OEFycmF5KHBvaW50Q291bnQgKiAzKTtcbiAgbGV0IGkgPSAwO1xuICBwb2x5Z29ucy5mb3JFYWNoKChjb21wbGV4UG9seWdvbiwgcG9seWdvbkluZGV4KSA9PiB7XG4gICAgY29uc3QgY29sb3IgPSBnZXRQaWNraW5nQ29sb3IocG9seWdvbkluZGV4KTtcbiAgICBjb25zdCB2ZXJ0ZXhDb3VudCA9IFBvbHlnb24uZ2V0VmVydGV4Q291bnQoY29tcGxleFBvbHlnb24pO1xuICAgIGZpbGxBcnJheSh7dGFyZ2V0OiBhdHRyaWJ1dGUsIHNvdXJjZTogY29sb3IsIHN0YXJ0OiBpLCBjb3VudDogdmVydGV4Q291bnR9KTtcbiAgICBpICs9IGNvbG9yLmxlbmd0aCAqIHZlcnRleENvdW50O1xuICB9KTtcbiAgcmV0dXJuIGF0dHJpYnV0ZTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xheWVycy9jb3JlL3NvbGlkLXBvbHlnb24tbGF5ZXIvcG9seWdvbi10ZXNzZWxhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 85 */
/* exports provided: default */
/* exports used: default */
/*!**********************************************************************************!*\
  !*** ./src/layers/core/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js ***!
  \**********************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME polygon-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n// PICKING\n// uniform bool pickingEnabled;\nvarying vec4 vPickingColor;\nvec4 picking_getColor() {\n  return vPickingColor;\n}\n// PICKING\n\nvoid main(void) {\n  gl_FragColor = picking_getColor();\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvc29saWQtcG9seWdvbi1sYXllci9zb2xpZC1wb2x5Z29uLWxheWVyLWZyYWdtZW50Lmdsc2wuanM/YjM1MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTYgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbiNkZWZpbmUgU0hBREVSX05BTUUgcG9seWdvbi1sYXllci1mcmFnbWVudC1zaGFkZXJcblxuI2lmZGVmIEdMX0VTXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4jZW5kaWZcblxuLy8gUElDS0lOR1xuLy8gdW5pZm9ybSBib29sIHBpY2tpbmdFbmFibGVkO1xudmFyeWluZyB2ZWM0IHZQaWNraW5nQ29sb3I7XG52ZWM0IHBpY2tpbmdfZ2V0Q29sb3IoKSB7XG4gIHJldHVybiB2UGlja2luZ0NvbG9yO1xufVxuLy8gUElDS0lOR1xuXG52b2lkIG1haW4odm9pZCkge1xuICBnbF9GcmFnQ29sb3IgPSBwaWNraW5nX2dldENvbG9yKCk7XG59XG5gO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGF5ZXJzL2NvcmUvc29saWQtcG9seWdvbi1sYXllci9zb2xpZC1wb2x5Z29uLWxheWVyLWZyYWdtZW50Lmdsc2wuanNcbi8vIG1vZHVsZSBpZCA9IDg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 86 */
/* exports provided: default */
/* exports used: default */
/*!***********************************************************************************!*\
  !*** ./src/layers/core/solid-polygon-layer/solid-polygon-layer-vertex-64.glsl.js ***!
  \***********************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME polygon-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec2 positions64xyLow;\nattribute vec3 normals;\nattribute vec4 colors;\nattribute vec3 pickingColors;\n\nuniform float extruded;\nuniform float opacity;\n\nuniform float renderPickingBuffer;\nuniform vec3 selectedPickingColor;\n\n// PICKING\nuniform float pickingEnabled;\nvarying vec4 vPickingColor;\n\nvoid main(void) {\n  vec4 positions64xy = vec4(positions.x, positions64xyLow.x, positions.y, positions64xyLow.y);\n\n  vec2 projected_coord_xy[2];\n  project_position_fp64(positions64xy, projected_coord_xy);\n\n  vec2 vertex_pos_modelspace[4];\n  vertex_pos_modelspace[0] = projected_coord_xy[0];\n  vertex_pos_modelspace[1] = projected_coord_xy[1];\n  vertex_pos_modelspace[2] = vec2(project_scale(positions.z), 0.0);\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\n\n  gl_Position = project_to_clipspace_fp64(vertex_pos_modelspace);\n\n  vec4 position_worldspace = vec4(\n    vertex_pos_modelspace[0].x, vertex_pos_modelspace[1].x,\n    vertex_pos_modelspace[2].x, vertex_pos_modelspace[3].x);\n\n  if (pickingEnabled < 0.5) {\n    float lightWeight = 1.0;\n\n    if (extruded > 0.5) {\n      lightWeight = getLightWeight(\n        position_worldspace,\n        normals\n      );\n    }\n\n    vec3 lightWeightedColor = lightWeight * colors.rgb;\n    vec4 color = vec4(lightWeightedColor, colors.a * opacity) / 255.0;\n\n    vPickingColor = color;\n\n  } else {\n    vPickingColor = vec4(pickingColors.rgb / 255.0, 1.0);\n  }\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvc29saWQtcG9seWdvbi1sYXllci9zb2xpZC1wb2x5Z29uLWxheWVyLXZlcnRleC02NC5nbHNsLmpzP2Q0ZjIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE2IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuZXhwb3J0IGRlZmF1bHQgYFxcXG4jZGVmaW5lIFNIQURFUl9OQU1FIHBvbHlnb24tbGF5ZXItdmVydGV4LXNoYWRlclxuXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbnM7XG5hdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbnM2NHh5TG93O1xuYXR0cmlidXRlIHZlYzMgbm9ybWFscztcbmF0dHJpYnV0ZSB2ZWM0IGNvbG9ycztcbmF0dHJpYnV0ZSB2ZWMzIHBpY2tpbmdDb2xvcnM7XG5cbnVuaWZvcm0gZmxvYXQgZXh0cnVkZWQ7XG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XG5cbnVuaWZvcm0gZmxvYXQgcmVuZGVyUGlja2luZ0J1ZmZlcjtcbnVuaWZvcm0gdmVjMyBzZWxlY3RlZFBpY2tpbmdDb2xvcjtcblxuLy8gUElDS0lOR1xudW5pZm9ybSBmbG9hdCBwaWNraW5nRW5hYmxlZDtcbnZhcnlpbmcgdmVjNCB2UGlja2luZ0NvbG9yO1xuXG52b2lkIG1haW4odm9pZCkge1xuICB2ZWM0IHBvc2l0aW9uczY0eHkgPSB2ZWM0KHBvc2l0aW9ucy54LCBwb3NpdGlvbnM2NHh5TG93LngsIHBvc2l0aW9ucy55LCBwb3NpdGlvbnM2NHh5TG93LnkpO1xuXG4gIHZlYzIgcHJvamVjdGVkX2Nvb3JkX3h5WzJdO1xuICBwcm9qZWN0X3Bvc2l0aW9uX2ZwNjQocG9zaXRpb25zNjR4eSwgcHJvamVjdGVkX2Nvb3JkX3h5KTtcblxuICB2ZWMyIHZlcnRleF9wb3NfbW9kZWxzcGFjZVs0XTtcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzBdID0gcHJvamVjdGVkX2Nvb3JkX3h5WzBdO1xuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMV0gPSBwcm9qZWN0ZWRfY29vcmRfeHlbMV07XG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVsyXSA9IHZlYzIocHJvamVjdF9zY2FsZShwb3NpdGlvbnMueiksIDAuMCk7XG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVszXSA9IHZlYzIoMS4wLCAwLjApO1xuXG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdF90b19jbGlwc3BhY2VfZnA2NCh2ZXJ0ZXhfcG9zX21vZGVsc3BhY2UpO1xuXG4gIHZlYzQgcG9zaXRpb25fd29ybGRzcGFjZSA9IHZlYzQoXG4gICAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzBdLngsIHZlcnRleF9wb3NfbW9kZWxzcGFjZVsxXS54LFxuICAgIHZlcnRleF9wb3NfbW9kZWxzcGFjZVsyXS54LCB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbM10ueCk7XG5cbiAgaWYgKHBpY2tpbmdFbmFibGVkIDwgMC41KSB7XG4gICAgZmxvYXQgbGlnaHRXZWlnaHQgPSAxLjA7XG5cbiAgICBpZiAoZXh0cnVkZWQgPiAwLjUpIHtcbiAgICAgIGxpZ2h0V2VpZ2h0ID0gZ2V0TGlnaHRXZWlnaHQoXG4gICAgICAgIHBvc2l0aW9uX3dvcmxkc3BhY2UsXG4gICAgICAgIG5vcm1hbHNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmVjMyBsaWdodFdlaWdodGVkQ29sb3IgPSBsaWdodFdlaWdodCAqIGNvbG9ycy5yZ2I7XG4gICAgdmVjNCBjb2xvciA9IHZlYzQobGlnaHRXZWlnaHRlZENvbG9yLCBjb2xvcnMuYSAqIG9wYWNpdHkpIC8gMjU1LjA7XG5cbiAgICB2UGlja2luZ0NvbG9yID0gY29sb3I7XG5cbiAgfSBlbHNlIHtcbiAgICB2UGlja2luZ0NvbG9yID0gdmVjNChwaWNraW5nQ29sb3JzLnJnYiAvIDI1NS4wLCAxLjApO1xuICB9XG59XG5gO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGF5ZXJzL2NvcmUvc29saWQtcG9seWdvbi1sYXllci9zb2xpZC1wb2x5Z29uLWxheWVyLXZlcnRleC02NC5nbHNsLmpzXG4vLyBtb2R1bGUgaWQgPSA4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 87 */
/* exports provided: default */
/* exports used: default */
/*!********************************************************************************!*\
  !*** ./src/layers/core/solid-polygon-layer/solid-polygon-layer-vertex.glsl.js ***!
  \********************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME polygon-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 normals;\nattribute vec4 colors;\nattribute vec3 pickingColors;\n\nuniform float extruded;\nuniform float opacity;\n\nuniform float renderPickingBuffer;\nuniform vec3 selectedPickingColor;\n\n// PICKING\nuniform float pickingEnabled;\nvarying vec4 vPickingColor;\n\nvoid main(void) {\n  vec4 position_worldspace = vec4(project_position(positions), 1.0);\n  gl_Position = project_to_clipspace(position_worldspace);\n\n  if (pickingEnabled < 0.5) {\n    float lightWeight = 1.0;\n\n    if (extruded > 0.5) {\n      lightWeight = getLightWeight(\n        position_worldspace,\n        normals\n      );\n    }\n\n    vec3 lightWeightedColor = lightWeight * colors.rgb;\n    vec4 color = vec4(lightWeightedColor, colors.a * opacity) / 255.0;\n\n    vPickingColor = color;\n\n  } else {\n    vPickingColor = vec4(pickingColors.rgb / 255.0, 1.0);\n  }\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvc29saWQtcG9seWdvbi1sYXllci9zb2xpZC1wb2x5Z29uLWxheWVyLXZlcnRleC5nbHNsLmpzP2Q0MTMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE2IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuZXhwb3J0IGRlZmF1bHQgYFxcXG4jZGVmaW5lIFNIQURFUl9OQU1FIHBvbHlnb24tbGF5ZXItdmVydGV4LXNoYWRlclxuXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbnM7XG5hdHRyaWJ1dGUgdmVjMyBub3JtYWxzO1xuYXR0cmlidXRlIHZlYzQgY29sb3JzO1xuYXR0cmlidXRlIHZlYzMgcGlja2luZ0NvbG9ycztcblxudW5pZm9ybSBmbG9hdCBleHRydWRlZDtcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcblxudW5pZm9ybSBmbG9hdCByZW5kZXJQaWNraW5nQnVmZmVyO1xudW5pZm9ybSB2ZWMzIHNlbGVjdGVkUGlja2luZ0NvbG9yO1xuXG4vLyBQSUNLSU5HXG51bmlmb3JtIGZsb2F0IHBpY2tpbmdFbmFibGVkO1xudmFyeWluZyB2ZWM0IHZQaWNraW5nQ29sb3I7XG5cbnZvaWQgbWFpbih2b2lkKSB7XG4gIHZlYzQgcG9zaXRpb25fd29ybGRzcGFjZSA9IHZlYzQocHJvamVjdF9wb3NpdGlvbihwb3NpdGlvbnMpLCAxLjApO1xuICBnbF9Qb3NpdGlvbiA9IHByb2plY3RfdG9fY2xpcHNwYWNlKHBvc2l0aW9uX3dvcmxkc3BhY2UpO1xuXG4gIGlmIChwaWNraW5nRW5hYmxlZCA8IDAuNSkge1xuICAgIGZsb2F0IGxpZ2h0V2VpZ2h0ID0gMS4wO1xuXG4gICAgaWYgKGV4dHJ1ZGVkID4gMC41KSB7XG4gICAgICBsaWdodFdlaWdodCA9IGdldExpZ2h0V2VpZ2h0KFxuICAgICAgICBwb3NpdGlvbl93b3JsZHNwYWNlLFxuICAgICAgICBub3JtYWxzXG4gICAgICApO1xuICAgIH1cblxuICAgIHZlYzMgbGlnaHRXZWlnaHRlZENvbG9yID0gbGlnaHRXZWlnaHQgKiBjb2xvcnMucmdiO1xuICAgIHZlYzQgY29sb3IgPSB2ZWM0KGxpZ2h0V2VpZ2h0ZWRDb2xvciwgY29sb3JzLmEgKiBvcGFjaXR5KSAvIDI1NS4wO1xuXG4gICAgdlBpY2tpbmdDb2xvciA9IGNvbG9yO1xuXG4gIH0gZWxzZSB7XG4gICAgdlBpY2tpbmdDb2xvciA9IHZlYzQocGlja2luZ0NvbG9ycy5yZ2IgLyAyNTUuMCwgMS4wKTtcbiAgfVxufVxuYDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xheWVycy9jb3JlL3NvbGlkLXBvbHlnb24tbGF5ZXIvc29saWQtcG9seWdvbi1sYXllci12ZXJ0ZXguZ2xzbC5qc1xuLy8gbW9kdWxlIGlkID0gODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 88 */
/* exports provided: default */
/* exports used: default */
/*!**************************************************************************************!*\
  !*** ./src/layers/deprecated/choropleth-layer-64/choropleth-layer-vertex-64.glsl.js ***!
  \**************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME choropleth-layer-vertex-64-shader\n\nattribute vec4 positions64;\nattribute vec2 heights64;\nattribute vec4 colors;\nattribute vec3 pickingColors;\n\nuniform float opacity;\nuniform float renderPickingBuffer;\nuniform vec3 selectedPickingColor;\n\nuniform float pickingEnabled;\nvarying vec4 vPickingColor;\nvoid picking_setPickColor(vec3 pickingColor) {\n  vPickingColor = vec4(pickingColor,  1.);\n}\nvec4 picking_setNormalAndPickColors(vec4 color, vec3 pickingColor) {\n  vec4 pickingColor4 = vec4(pickingColor.rgb, 1.);\n  vPickingColor = mix(color, pickingColor4, pickingEnabled);\n  return vPickingColor;\n}\n\nvoid main(void) {\n  // For some reason, need to add one to elevation to show up in untilted mode\n  vec2 projectedCoord[2];\n  project_position_fp64(positions64, projectedCoord);\n\n  vec2 vertex_pos_modelspace[4];\n\n  vertex_pos_modelspace[0] = projectedCoord[0];\n  vertex_pos_modelspace[1] = projectedCoord[1];\n  vertex_pos_modelspace[2] = heights64;\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\n\n  gl_Position = project_to_clipspace_fp64(vertex_pos_modelspace);\n\n  vec4 color = vec4(colors.rgb, colors.a * opacity) / 255.;\n\n  picking_setNormalAndPickColors(\n    color,\n    pickingColors / 255.\n  );\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2RlcHJlY2F0ZWQvY2hvcm9wbGV0aC1sYXllci02NC9jaG9yb3BsZXRoLWxheWVyLXZlcnRleC02NC5nbHNsLmpzPzk5NmQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE2IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuZXhwb3J0IGRlZmF1bHQgYFxcXG4jZGVmaW5lIFNIQURFUl9OQU1FIGNob3JvcGxldGgtbGF5ZXItdmVydGV4LTY0LXNoYWRlclxuXG5hdHRyaWJ1dGUgdmVjNCBwb3NpdGlvbnM2NDtcbmF0dHJpYnV0ZSB2ZWMyIGhlaWdodHM2NDtcbmF0dHJpYnV0ZSB2ZWM0IGNvbG9ycztcbmF0dHJpYnV0ZSB2ZWMzIHBpY2tpbmdDb2xvcnM7XG5cbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcbnVuaWZvcm0gZmxvYXQgcmVuZGVyUGlja2luZ0J1ZmZlcjtcbnVuaWZvcm0gdmVjMyBzZWxlY3RlZFBpY2tpbmdDb2xvcjtcblxudW5pZm9ybSBmbG9hdCBwaWNraW5nRW5hYmxlZDtcbnZhcnlpbmcgdmVjNCB2UGlja2luZ0NvbG9yO1xudm9pZCBwaWNraW5nX3NldFBpY2tDb2xvcih2ZWMzIHBpY2tpbmdDb2xvcikge1xuICB2UGlja2luZ0NvbG9yID0gdmVjNChwaWNraW5nQ29sb3IsICAxLik7XG59XG52ZWM0IHBpY2tpbmdfc2V0Tm9ybWFsQW5kUGlja0NvbG9ycyh2ZWM0IGNvbG9yLCB2ZWMzIHBpY2tpbmdDb2xvcikge1xuICB2ZWM0IHBpY2tpbmdDb2xvcjQgPSB2ZWM0KHBpY2tpbmdDb2xvci5yZ2IsIDEuKTtcbiAgdlBpY2tpbmdDb2xvciA9IG1peChjb2xvciwgcGlja2luZ0NvbG9yNCwgcGlja2luZ0VuYWJsZWQpO1xuICByZXR1cm4gdlBpY2tpbmdDb2xvcjtcbn1cblxudm9pZCBtYWluKHZvaWQpIHtcbiAgLy8gRm9yIHNvbWUgcmVhc29uLCBuZWVkIHRvIGFkZCBvbmUgdG8gZWxldmF0aW9uIHRvIHNob3cgdXAgaW4gdW50aWx0ZWQgbW9kZVxuICB2ZWMyIHByb2plY3RlZENvb3JkWzJdO1xuICBwcm9qZWN0X3Bvc2l0aW9uX2ZwNjQocG9zaXRpb25zNjQsIHByb2plY3RlZENvb3JkKTtcblxuICB2ZWMyIHZlcnRleF9wb3NfbW9kZWxzcGFjZVs0XTtcblxuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMF0gPSBwcm9qZWN0ZWRDb29yZFswXTtcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzFdID0gcHJvamVjdGVkQ29vcmRbMV07XG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVsyXSA9IGhlaWdodHM2NDtcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzNdID0gdmVjMigxLjAsIDAuMCk7XG5cbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0X3RvX2NsaXBzcGFjZV9mcDY0KHZlcnRleF9wb3NfbW9kZWxzcGFjZSk7XG5cbiAgdmVjNCBjb2xvciA9IHZlYzQoY29sb3JzLnJnYiwgY29sb3JzLmEgKiBvcGFjaXR5KSAvIDI1NS47XG5cbiAgcGlja2luZ19zZXROb3JtYWxBbmRQaWNrQ29sb3JzKFxuICAgIGNvbG9yLFxuICAgIHBpY2tpbmdDb2xvcnMgLyAyNTUuXG4gICk7XG59XG5gO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGF5ZXJzL2RlcHJlY2F0ZWQvY2hvcm9wbGV0aC1sYXllci02NC9jaG9yb3BsZXRoLWxheWVyLXZlcnRleC02NC5nbHNsLmpzXG4vLyBtb2R1bGUgaWQgPSA4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 89 */
/* exports provided: default */
/* exports used: default */
/*!**********************************************************************************!*\
  !*** ./src/layers/deprecated/choropleth-layer/choropleth-layer-fragment.glsl.js ***!
  \**********************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME choropleth-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n// PICKING\n// uniform bool pickingEnabled;\nvarying vec4 vPickingColor;\nvec4 picking_getColor() {\n  return vPickingColor;\n}\n// PICKING\n\nvoid main(void) {\n  gl_FragColor = picking_getColor();\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2RlcHJlY2F0ZWQvY2hvcm9wbGV0aC1sYXllci9jaG9yb3BsZXRoLWxheWVyLWZyYWdtZW50Lmdsc2wuanM/YzBiNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcbiNkZWZpbmUgU0hBREVSX05BTUUgY2hvcm9wbGV0aC1sYXllci1mcmFnbWVudC1zaGFkZXJcblxuI2lmZGVmIEdMX0VTXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4jZW5kaWZcblxuLy8gUElDS0lOR1xuLy8gdW5pZm9ybSBib29sIHBpY2tpbmdFbmFibGVkO1xudmFyeWluZyB2ZWM0IHZQaWNraW5nQ29sb3I7XG52ZWM0IHBpY2tpbmdfZ2V0Q29sb3IoKSB7XG4gIHJldHVybiB2UGlja2luZ0NvbG9yO1xufVxuLy8gUElDS0lOR1xuXG52b2lkIG1haW4odm9pZCkge1xuICBnbF9GcmFnQ29sb3IgPSBwaWNraW5nX2dldENvbG9yKCk7XG59XG5gO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGF5ZXJzL2RlcHJlY2F0ZWQvY2hvcm9wbGV0aC1sYXllci9jaG9yb3BsZXRoLWxheWVyLWZyYWdtZW50Lmdsc2wuanNcbi8vIG1vZHVsZSBpZCA9IDg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 90 */
/* exports provided: default */
/* exports used: default */
/*!********************************************************************************!*\
  !*** ./src/layers/deprecated/choropleth-layer/choropleth-layer-vertex.glsl.js ***!
  \********************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME choropleth-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec4 colors;\nattribute vec3 pickingColors;\n\nuniform float opacity;\nuniform float renderPickingBuffer;\nuniform vec3 selectedPickingColor;\n\n// PICKING\nuniform float pickingEnabled;\nvarying vec4 vPickingColor;\nvoid picking_setPickColor(vec3 pickingColor) {\n  vPickingColor = vec4(pickingColor,  1.);\n}\nvec4 picking_setNormalAndPickColors(vec4 color, vec3 pickingColor) {\n  vec4 pickingColor4 = vec4(pickingColor.rgb, 1.);\n  vPickingColor = mix(color, pickingColor4, pickingEnabled);\n  return vPickingColor;\n}\n\n// PICKING\n// vec4 getColor(vec4 color, float opacity, vec3 pickingColor, float renderPickingBuffer) {\n//   vec4 color4 = vec4(color.xyz / 255., color.w / 255. * opacity);\n//   vec4 pickingColor4 = vec4(pickingColor / 255., 1.);\n//   return mix(color4, pickingColor4, renderPickingBuffer);\n// }\n\nvoid main(void) {\n\n  vec4 color = vec4(colors.rgb, colors.a * opacity) / 255.;\n\n  picking_setNormalAndPickColors(\n    color,\n    pickingColors / 255.\n  );\n\n  vec3 p = project_position(positions);\n  gl_Position = project_to_clipspace(vec4(p, 1.));\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2RlcHJlY2F0ZWQvY2hvcm9wbGV0aC1sYXllci9jaG9yb3BsZXRoLWxheWVyLXZlcnRleC5nbHNsLmpzPzBkYTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuZXhwb3J0IGRlZmF1bHQgYFxcXG4jZGVmaW5lIFNIQURFUl9OQU1FIGNob3JvcGxldGgtbGF5ZXItdmVydGV4LXNoYWRlclxuXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbnM7XG5hdHRyaWJ1dGUgdmVjNCBjb2xvcnM7XG5hdHRyaWJ1dGUgdmVjMyBwaWNraW5nQ29sb3JzO1xuXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XG51bmlmb3JtIGZsb2F0IHJlbmRlclBpY2tpbmdCdWZmZXI7XG51bmlmb3JtIHZlYzMgc2VsZWN0ZWRQaWNraW5nQ29sb3I7XG5cbi8vIFBJQ0tJTkdcbnVuaWZvcm0gZmxvYXQgcGlja2luZ0VuYWJsZWQ7XG52YXJ5aW5nIHZlYzQgdlBpY2tpbmdDb2xvcjtcbnZvaWQgcGlja2luZ19zZXRQaWNrQ29sb3IodmVjMyBwaWNraW5nQ29sb3IpIHtcbiAgdlBpY2tpbmdDb2xvciA9IHZlYzQocGlja2luZ0NvbG9yLCAgMS4pO1xufVxudmVjNCBwaWNraW5nX3NldE5vcm1hbEFuZFBpY2tDb2xvcnModmVjNCBjb2xvciwgdmVjMyBwaWNraW5nQ29sb3IpIHtcbiAgdmVjNCBwaWNraW5nQ29sb3I0ID0gdmVjNChwaWNraW5nQ29sb3IucmdiLCAxLik7XG4gIHZQaWNraW5nQ29sb3IgPSBtaXgoY29sb3IsIHBpY2tpbmdDb2xvcjQsIHBpY2tpbmdFbmFibGVkKTtcbiAgcmV0dXJuIHZQaWNraW5nQ29sb3I7XG59XG5cbi8vIFBJQ0tJTkdcbi8vIHZlYzQgZ2V0Q29sb3IodmVjNCBjb2xvciwgZmxvYXQgb3BhY2l0eSwgdmVjMyBwaWNraW5nQ29sb3IsIGZsb2F0IHJlbmRlclBpY2tpbmdCdWZmZXIpIHtcbi8vICAgdmVjNCBjb2xvcjQgPSB2ZWM0KGNvbG9yLnh5eiAvIDI1NS4sIGNvbG9yLncgLyAyNTUuICogb3BhY2l0eSk7XG4vLyAgIHZlYzQgcGlja2luZ0NvbG9yNCA9IHZlYzQocGlja2luZ0NvbG9yIC8gMjU1LiwgMS4pO1xuLy8gICByZXR1cm4gbWl4KGNvbG9yNCwgcGlja2luZ0NvbG9yNCwgcmVuZGVyUGlja2luZ0J1ZmZlcik7XG4vLyB9XG5cbnZvaWQgbWFpbih2b2lkKSB7XG5cbiAgdmVjNCBjb2xvciA9IHZlYzQoY29sb3JzLnJnYiwgY29sb3JzLmEgKiBvcGFjaXR5KSAvIDI1NS47XG5cbiAgcGlja2luZ19zZXROb3JtYWxBbmRQaWNrQ29sb3JzKFxuICAgIGNvbG9yLFxuICAgIHBpY2tpbmdDb2xvcnMgLyAyNTUuXG4gICk7XG5cbiAgdmVjMyBwID0gcHJvamVjdF9wb3NpdGlvbihwb3NpdGlvbnMpO1xuICBnbF9Qb3NpdGlvbiA9IHByb2plY3RfdG9fY2xpcHNwYWNlKHZlYzQocCwgMS4pKTtcbn1cbmA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9sYXllcnMvZGVwcmVjYXRlZC9jaG9yb3BsZXRoLWxheWVyL2Nob3JvcGxldGgtbGF5ZXItdmVydGV4Lmdsc2wuanNcbi8vIG1vZHVsZSBpZCA9IDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 91 */
/* exports provided: getGeojsonFeatures, featureToPolygons, extractPolygons, normalizeGeojson */
/* exports used: extractPolygons */
/*!***********************************************************!*\
  !*** ./src/layers/deprecated/choropleth-layer/geojson.js ***!
  \***********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib_utils__ = __webpack_require__(/*! ../../../lib/utils */ 2);\n/* unused harmony export getGeojsonFeatures */\n/* unused harmony export featureToPolygons */\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = extractPolygons;\n/* unused harmony export normalizeGeojson */\n\n\n/**\n * \"Normalizes\" complete or partial GeoJSON data into iterable list of features\n * Can accept GeoJSON geometry or \"Feature\", \"FeatureCollection\" in addition\n * to plain arrays and iterables.\n * Works by extracting the feature array or wrapping single objects in an array,\n * so that subsequent code can simply iterate over features.\n *\n * @param {object} geojson - geojson data\n * @param {Object|Array} data - geojson object (FeatureCollection, Feature or\n *  Geometry) or array of features\n * @return {Array|\"iteratable\"} - iterable list of features\n */\nfunction getGeojsonFeatures(geojson) {\n  // If array, assume this is a list of features\n  if (Array.isArray(geojson)) {\n    return geojson;\n  }\n\n  const type = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"d\" /* get */])(geojson, 'type');\n  switch (type) {\n  case 'Point':\n  case 'MultiPoint':\n  case 'LineString':\n  case 'MultiLineString':\n  case 'Polygon':\n  case 'MultiPolygon':\n  case 'GeometryCollection':\n    // Wrap the geometry object in a 'Feature' object and wrap in an array\n    return [\n      {type: 'Feature', properties: {}, geometry: geojson}\n    ];\n  case 'Feature':\n    // Wrap the feature in a 'Features' array\n    return [geojson];\n  case 'FeatureCollection':\n    // Just return the 'Features' array from the collection\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"d\" /* get */])(geojson, 'features');\n  default:\n    throw new Error('Unknown geojson type');\n  }\n}\n\n/*\n * converts a GeoJSON \"Feature\" object to a list of GeoJSON polygon-style coordinates\n * @param {Object | Array} data - geojson object or array of feature\n * @returns {[Number,Number,Number][][][]} array of choropleths\n */\nfunction featureToPolygons(feature) {\n  const geometry = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"d\" /* get */])(feature, 'geometry');\n  // If no geometry field, assume that \"feature\" is the polygon list\n  if (geometry === undefined) {\n    return feature;\n  }\n\n  const type = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"d\" /* get */])(geometry, 'type');\n  const coordinates = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"d\" /* get */])(geometry, 'coordinates');\n\n  let polygons;\n  switch (type) {\n  case 'MultiPolygon':\n    polygons = coordinates;\n    break;\n  case 'Polygon':\n    polygons = [coordinates];\n    break;\n  case 'LineString':\n    // TODO - should lines really be handled in this switch?\n    polygons = [[coordinates]];\n    break;\n  case 'MultiLineString':\n    // TODO - should lines really be handled in this switch?\n    polygons = coordinates.map(coords => [coords]);\n    break;\n  default:\n    polygons = [];\n  }\n  return polygons;\n}\n\n// DEPRECATED - USED BY OLD CHOROPLETH LAYERS\n\n/*\n * converts list of features from a GeoJSON object to a list of GeoJSON\n * polygon-style coordinates\n * @param {Object} data - geojson object\n * @returns {[Number,Number,Number][][][]} array of choropleths\n */\nfunction extractPolygons(data) {\n  const normalizedGeojson = normalizeGeojson(data);\n  const features = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"d\" /* get */])(normalizedGeojson, 'features');\n\n  const result = [];\n  features.forEach((feature, featureIndex) => {\n    let choropleths = featureToPolygons(feature);\n\n    /* eslint-disable max-nested-callbacks */\n    choropleths = choropleths.map(\n      choropleth => choropleth.map(\n        polygon => polygon.map(\n          coord => [\n            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"d\" /* get */])(coord, 0),\n            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"d\" /* get */])(coord, 1),\n            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"d\" /* get */])(coord, 2) || 0\n          ]\n        )\n      )\n    );\n    /* eslint-enable max-nested-callbacks */\n\n    for (const choropleth of choropleths) {\n      choropleth.featureIndex = featureIndex;\n    }\n    result.push(...choropleths);\n  });\n  return result;\n}\n\n/**\n * \"Normalizes\" a GeoJSON geometry or \"Feature\" into a \"FeatureCollection\",\n * by wrapping it in an extra object/array.\n *\n * @param {object} geojson - geojson data\n * @return {object} - normalized geojson data\n */\nfunction normalizeGeojson(geojson) {\n  const type = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"d\" /* get */])(geojson, 'type');\n  switch (type) {\n  case 'Point':\n  case 'MultiPoint':\n  case 'LineString':\n  case 'MultiLineString':\n  case 'Polygon':\n  case 'MultiPolygon':\n  case 'GeometryCollection':\n    // Wrap the geometry object in a \"Feature\" and add the feature to a \"FeatureCollection\"\n    return {\n      type: 'FeatureCollection',\n      features: [\n        {type: 'Feature', properties: {}, geometry: geojson}\n      ]\n    };\n  case 'Feature':\n    // Add the feature to a \"FeatureCollection\"\n    return {\n      type: 'FeatureCollection',\n      features: [geojson]\n    };\n  case 'FeatureCollection':\n    // Just return the feature collection\n    return geojson;\n  default:\n    throw new Error('Unknown geojson type');\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2RlcHJlY2F0ZWQvY2hvcm9wbGV0aC1sYXllci9nZW9qc29uLmpzP2Y0ZmUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtnZXR9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscyc7XG5cbi8qKlxuICogXCJOb3JtYWxpemVzXCIgY29tcGxldGUgb3IgcGFydGlhbCBHZW9KU09OIGRhdGEgaW50byBpdGVyYWJsZSBsaXN0IG9mIGZlYXR1cmVzXG4gKiBDYW4gYWNjZXB0IEdlb0pTT04gZ2VvbWV0cnkgb3IgXCJGZWF0dXJlXCIsIFwiRmVhdHVyZUNvbGxlY3Rpb25cIiBpbiBhZGRpdGlvblxuICogdG8gcGxhaW4gYXJyYXlzIGFuZCBpdGVyYWJsZXMuXG4gKiBXb3JrcyBieSBleHRyYWN0aW5nIHRoZSBmZWF0dXJlIGFycmF5IG9yIHdyYXBwaW5nIHNpbmdsZSBvYmplY3RzIGluIGFuIGFycmF5LFxuICogc28gdGhhdCBzdWJzZXF1ZW50IGNvZGUgY2FuIHNpbXBseSBpdGVyYXRlIG92ZXIgZmVhdHVyZXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGdlb2pzb24gLSBnZW9qc29uIGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBkYXRhIC0gZ2VvanNvbiBvYmplY3QgKEZlYXR1cmVDb2xsZWN0aW9uLCBGZWF0dXJlIG9yXG4gKiAgR2VvbWV0cnkpIG9yIGFycmF5IG9mIGZlYXR1cmVzXG4gKiBAcmV0dXJuIHtBcnJheXxcIml0ZXJhdGFibGVcIn0gLSBpdGVyYWJsZSBsaXN0IG9mIGZlYXR1cmVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRHZW9qc29uRmVhdHVyZXMoZ2VvanNvbikge1xuICAvLyBJZiBhcnJheSwgYXNzdW1lIHRoaXMgaXMgYSBsaXN0IG9mIGZlYXR1cmVzXG4gIGlmIChBcnJheS5pc0FycmF5KGdlb2pzb24pKSB7XG4gICAgcmV0dXJuIGdlb2pzb247XG4gIH1cblxuICBjb25zdCB0eXBlID0gZ2V0KGdlb2pzb24sICd0eXBlJyk7XG4gIHN3aXRjaCAodHlwZSkge1xuICBjYXNlICdQb2ludCc6XG4gIGNhc2UgJ011bHRpUG9pbnQnOlxuICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgY2FzZSAnUG9seWdvbic6XG4gIGNhc2UgJ011bHRpUG9seWdvbic6XG4gIGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XG4gICAgLy8gV3JhcCB0aGUgZ2VvbWV0cnkgb2JqZWN0IGluIGEgJ0ZlYXR1cmUnIG9iamVjdCBhbmQgd3JhcCBpbiBhbiBhcnJheVxuICAgIHJldHVybiBbXG4gICAgICB7dHlwZTogJ0ZlYXR1cmUnLCBwcm9wZXJ0aWVzOiB7fSwgZ2VvbWV0cnk6IGdlb2pzb259XG4gICAgXTtcbiAgY2FzZSAnRmVhdHVyZSc6XG4gICAgLy8gV3JhcCB0aGUgZmVhdHVyZSBpbiBhICdGZWF0dXJlcycgYXJyYXlcbiAgICByZXR1cm4gW2dlb2pzb25dO1xuICBjYXNlICdGZWF0dXJlQ29sbGVjdGlvbic6XG4gICAgLy8gSnVzdCByZXR1cm4gdGhlICdGZWF0dXJlcycgYXJyYXkgZnJvbSB0aGUgY29sbGVjdGlvblxuICAgIHJldHVybiBnZXQoZ2VvanNvbiwgJ2ZlYXR1cmVzJyk7XG4gIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGdlb2pzb24gdHlwZScpO1xuICB9XG59XG5cbi8qXG4gKiBjb252ZXJ0cyBhIEdlb0pTT04gXCJGZWF0dXJlXCIgb2JqZWN0IHRvIGEgbGlzdCBvZiBHZW9KU09OIHBvbHlnb24tc3R5bGUgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7T2JqZWN0IHwgQXJyYXl9IGRhdGEgLSBnZW9qc29uIG9iamVjdCBvciBhcnJheSBvZiBmZWF0dXJlXG4gKiBAcmV0dXJucyB7W051bWJlcixOdW1iZXIsTnVtYmVyXVtdW11bXX0gYXJyYXkgb2YgY2hvcm9wbGV0aHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZlYXR1cmVUb1BvbHlnb25zKGZlYXR1cmUpIHtcbiAgY29uc3QgZ2VvbWV0cnkgPSBnZXQoZmVhdHVyZSwgJ2dlb21ldHJ5Jyk7XG4gIC8vIElmIG5vIGdlb21ldHJ5IGZpZWxkLCBhc3N1bWUgdGhhdCBcImZlYXR1cmVcIiBpcyB0aGUgcG9seWdvbiBsaXN0XG4gIGlmIChnZW9tZXRyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZlYXR1cmU7XG4gIH1cblxuICBjb25zdCB0eXBlID0gZ2V0KGdlb21ldHJ5LCAndHlwZScpO1xuICBjb25zdCBjb29yZGluYXRlcyA9IGdldChnZW9tZXRyeSwgJ2Nvb3JkaW5hdGVzJyk7XG5cbiAgbGV0IHBvbHlnb25zO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgY2FzZSAnTXVsdGlQb2x5Z29uJzpcbiAgICBwb2x5Z29ucyA9IGNvb3JkaW5hdGVzO1xuICAgIGJyZWFrO1xuICBjYXNlICdQb2x5Z29uJzpcbiAgICBwb2x5Z29ucyA9IFtjb29yZGluYXRlc107XG4gICAgYnJlYWs7XG4gIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgIC8vIFRPRE8gLSBzaG91bGQgbGluZXMgcmVhbGx5IGJlIGhhbmRsZWQgaW4gdGhpcyBzd2l0Y2g/XG4gICAgcG9seWdvbnMgPSBbW2Nvb3JkaW5hdGVzXV07XG4gICAgYnJlYWs7XG4gIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gICAgLy8gVE9ETyAtIHNob3VsZCBsaW5lcyByZWFsbHkgYmUgaGFuZGxlZCBpbiB0aGlzIHN3aXRjaD9cbiAgICBwb2x5Z29ucyA9IGNvb3JkaW5hdGVzLm1hcChjb29yZHMgPT4gW2Nvb3Jkc10pO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHBvbHlnb25zID0gW107XG4gIH1cbiAgcmV0dXJuIHBvbHlnb25zO1xufVxuXG4vLyBERVBSRUNBVEVEIC0gVVNFRCBCWSBPTEQgQ0hPUk9QTEVUSCBMQVlFUlNcblxuLypcbiAqIGNvbnZlcnRzIGxpc3Qgb2YgZmVhdHVyZXMgZnJvbSBhIEdlb0pTT04gb2JqZWN0IHRvIGEgbGlzdCBvZiBHZW9KU09OXG4gKiBwb2x5Z29uLXN0eWxlIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIGdlb2pzb24gb2JqZWN0XG4gKiBAcmV0dXJucyB7W051bWJlcixOdW1iZXIsTnVtYmVyXVtdW11bXX0gYXJyYXkgb2YgY2hvcm9wbGV0aHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RQb2x5Z29ucyhkYXRhKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRHZW9qc29uID0gbm9ybWFsaXplR2VvanNvbihkYXRhKTtcbiAgY29uc3QgZmVhdHVyZXMgPSBnZXQobm9ybWFsaXplZEdlb2pzb24sICdmZWF0dXJlcycpO1xuXG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmZWF0dXJlcy5mb3JFYWNoKChmZWF0dXJlLCBmZWF0dXJlSW5kZXgpID0+IHtcbiAgICBsZXQgY2hvcm9wbGV0aHMgPSBmZWF0dXJlVG9Qb2x5Z29ucyhmZWF0dXJlKTtcblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1uZXN0ZWQtY2FsbGJhY2tzICovXG4gICAgY2hvcm9wbGV0aHMgPSBjaG9yb3BsZXRocy5tYXAoXG4gICAgICBjaG9yb3BsZXRoID0+IGNob3JvcGxldGgubWFwKFxuICAgICAgICBwb2x5Z29uID0+IHBvbHlnb24ubWFwKFxuICAgICAgICAgIGNvb3JkID0+IFtcbiAgICAgICAgICAgIGdldChjb29yZCwgMCksXG4gICAgICAgICAgICBnZXQoY29vcmQsIDEpLFxuICAgICAgICAgICAgZ2V0KGNvb3JkLCAyKSB8fCAwXG4gICAgICAgICAgXVxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG1heC1uZXN0ZWQtY2FsbGJhY2tzICovXG5cbiAgICBmb3IgKGNvbnN0IGNob3JvcGxldGggb2YgY2hvcm9wbGV0aHMpIHtcbiAgICAgIGNob3JvcGxldGguZmVhdHVyZUluZGV4ID0gZmVhdHVyZUluZGV4O1xuICAgIH1cbiAgICByZXN1bHQucHVzaCguLi5jaG9yb3BsZXRocyk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFwiTm9ybWFsaXplc1wiIGEgR2VvSlNPTiBnZW9tZXRyeSBvciBcIkZlYXR1cmVcIiBpbnRvIGEgXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogYnkgd3JhcHBpbmcgaXQgaW4gYW4gZXh0cmEgb2JqZWN0L2FycmF5LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBnZW9qc29uIC0gZ2VvanNvbiBkYXRhXG4gKiBAcmV0dXJuIHtvYmplY3R9IC0gbm9ybWFsaXplZCBnZW9qc29uIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUdlb2pzb24oZ2VvanNvbikge1xuICBjb25zdCB0eXBlID0gZ2V0KGdlb2pzb24sICd0eXBlJyk7XG4gIHN3aXRjaCAodHlwZSkge1xuICBjYXNlICdQb2ludCc6XG4gIGNhc2UgJ011bHRpUG9pbnQnOlxuICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgY2FzZSAnUG9seWdvbic6XG4gIGNhc2UgJ011bHRpUG9seWdvbic6XG4gIGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XG4gICAgLy8gV3JhcCB0aGUgZ2VvbWV0cnkgb2JqZWN0IGluIGEgXCJGZWF0dXJlXCIgYW5kIGFkZCB0aGUgZmVhdHVyZSB0byBhIFwiRmVhdHVyZUNvbGxlY3Rpb25cIlxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxuICAgICAgZmVhdHVyZXM6IFtcbiAgICAgICAge3R5cGU6ICdGZWF0dXJlJywgcHJvcGVydGllczoge30sIGdlb21ldHJ5OiBnZW9qc29ufVxuICAgICAgXVxuICAgIH07XG4gIGNhc2UgJ0ZlYXR1cmUnOlxuICAgIC8vIEFkZCB0aGUgZmVhdHVyZSB0byBhIFwiRmVhdHVyZUNvbGxlY3Rpb25cIlxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxuICAgICAgZmVhdHVyZXM6IFtnZW9qc29uXVxuICAgIH07XG4gIGNhc2UgJ0ZlYXR1cmVDb2xsZWN0aW9uJzpcbiAgICAvLyBKdXN0IHJldHVybiB0aGUgZmVhdHVyZSBjb2xsZWN0aW9uXG4gICAgcmV0dXJuIGdlb2pzb247XG4gIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGdlb2pzb24gdHlwZScpO1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9sYXllcnMvZGVwcmVjYXRlZC9jaG9yb3BsZXRoLWxheWVyL2dlb2pzb24uanNcbi8vIG1vZHVsZSBpZCA9IDkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 92 */
/* exports provided: default */
/* exports used: default */
/*!*******************************************************************************************************!*\
  !*** ./src/layers/deprecated/extruded-choropleth-layer-64/extruded-choropleth-layer-fragment.glsl.js ***!
  \*******************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* fragment shader for the building-layer */\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME building-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2RlcHJlY2F0ZWQvZXh0cnVkZWQtY2hvcm9wbGV0aC1sYXllci02NC9leHRydWRlZC1jaG9yb3BsZXRoLWxheWVyLWZyYWdtZW50Lmdsc2wuanM/Yzk5YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vKiBmcmFnbWVudCBzaGFkZXIgZm9yIHRoZSBidWlsZGluZy1sYXllciAqL1xuZXhwb3J0IGRlZmF1bHQgYFxcXG4jZGVmaW5lIFNIQURFUl9OQU1FIGJ1aWxkaW5nLWxheWVyLWZyYWdtZW50LXNoYWRlclxuXG4jaWZkZWYgR0xfRVNcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiNlbmRpZlxuXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xuXG52b2lkIG1haW4odm9pZCkge1xuICBnbF9GcmFnQ29sb3IgPSB2Q29sb3I7XG59XG5gO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGF5ZXJzL2RlcHJlY2F0ZWQvZXh0cnVkZWQtY2hvcm9wbGV0aC1sYXllci02NC9leHRydWRlZC1jaG9yb3BsZXRoLWxheWVyLWZyYWdtZW50Lmdsc2wuanNcbi8vIG1vZHVsZSBpZCA9IDkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 93 */
/* exports provided: default */
/* exports used: default */
/*!*****************************************************************************************************!*\
  !*** ./src/layers/deprecated/extruded-choropleth-layer-64/extruded-choropleth-layer-vertex.glsl.js ***!
  \*****************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define SHADER_NAME extruded-choropleths-layer-vertex-shader\n\nattribute vec4 positions;\nattribute vec2 heights;\nattribute vec3 normals;\nuniform vec3 colors;\n\nuniform float opacity;\nuniform float elevation;\n\nuniform vec3 uAmbientColor;\nuniform float uPointLightAmbientCoefficient;\nuniform vec3 uPointLightLocation;\nuniform vec3 uPointLightColor;\nuniform float uPointLightAttenuation;\n\nuniform vec3 uMaterialSpecularColor;\nuniform float uMaterialShininess;\n\nvarying vec4 vColor;\n\nvec3 applyLighting(vec3 position_modelspace, vec3 normal_modelspace, vec3 color) {\n\n  vec3 pointLightLocation_modelspace = vec3(project_position(uPointLightLocation));\n  vec3 lightDirection = normalize(pointLightLocation_modelspace - position_modelspace);\n\n  vec3 ambient = uPointLightAmbientCoefficient * color / 255.0 * uAmbientColor / 255.0;\n\n  float diffuseCoefficient = max(dot(normal_modelspace, lightDirection), 0.0);\n  vec3 diffuse = diffuseCoefficient * uPointLightColor / 255. * color / 255.;\n\n  return ambient + uPointLightAttenuation * diffuse;\n}\n\nvoid main(void) {\n  vec2 projected_xy[2];\n  project_position_fp64(positions, projected_xy);\n  vec2 scaled_height = mul_fp64(heights, vec2(projectionPixelsPerUnit.x * elevation, 0.0));\n\n  vec2 vertex_pos_modelspace[4];\n  vertex_pos_modelspace[0] = projected_xy[0];\n  vertex_pos_modelspace[1] = projected_xy[1];\n  vertex_pos_modelspace[2] = sum_fp64(scaled_height, vec2(1.0, 0.0));\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\n\n  gl_Position = project_to_clipspace_fp64(vertex_pos_modelspace);\n\n  vec3 color = applyLighting(\n  \tvec3(\n  \t  vertex_pos_modelspace[0].x,\n  \t  vertex_pos_modelspace[1].x,\n  \t  vertex_pos_modelspace[2].x),\n  \tnormals,\n  \tcolors\n  );\n  vColor = vec4(color, opacity);\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2RlcHJlY2F0ZWQvZXh0cnVkZWQtY2hvcm9wbGV0aC1sYXllci02NC9leHRydWRlZC1jaG9yb3BsZXRoLWxheWVyLXZlcnRleC5nbHNsLmpzPzQ1NWUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuZXhwb3J0IGRlZmF1bHQgYFxcXG4jZGVmaW5lIFNIQURFUl9OQU1FIGV4dHJ1ZGVkLWNob3JvcGxldGhzLWxheWVyLXZlcnRleC1zaGFkZXJcblxuYXR0cmlidXRlIHZlYzQgcG9zaXRpb25zO1xuYXR0cmlidXRlIHZlYzIgaGVpZ2h0cztcbmF0dHJpYnV0ZSB2ZWMzIG5vcm1hbHM7XG51bmlmb3JtIHZlYzMgY29sb3JzO1xuXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XG51bmlmb3JtIGZsb2F0IGVsZXZhdGlvbjtcblxudW5pZm9ybSB2ZWMzIHVBbWJpZW50Q29sb3I7XG51bmlmb3JtIGZsb2F0IHVQb2ludExpZ2h0QW1iaWVudENvZWZmaWNpZW50O1xudW5pZm9ybSB2ZWMzIHVQb2ludExpZ2h0TG9jYXRpb247XG51bmlmb3JtIHZlYzMgdVBvaW50TGlnaHRDb2xvcjtcbnVuaWZvcm0gZmxvYXQgdVBvaW50TGlnaHRBdHRlbnVhdGlvbjtcblxudW5pZm9ybSB2ZWMzIHVNYXRlcmlhbFNwZWN1bGFyQ29sb3I7XG51bmlmb3JtIGZsb2F0IHVNYXRlcmlhbFNoaW5pbmVzcztcblxudmFyeWluZyB2ZWM0IHZDb2xvcjtcblxudmVjMyBhcHBseUxpZ2h0aW5nKHZlYzMgcG9zaXRpb25fbW9kZWxzcGFjZSwgdmVjMyBub3JtYWxfbW9kZWxzcGFjZSwgdmVjMyBjb2xvcikge1xuXG4gIHZlYzMgcG9pbnRMaWdodExvY2F0aW9uX21vZGVsc3BhY2UgPSB2ZWMzKHByb2plY3RfcG9zaXRpb24odVBvaW50TGlnaHRMb2NhdGlvbikpO1xuICB2ZWMzIGxpZ2h0RGlyZWN0aW9uID0gbm9ybWFsaXplKHBvaW50TGlnaHRMb2NhdGlvbl9tb2RlbHNwYWNlIC0gcG9zaXRpb25fbW9kZWxzcGFjZSk7XG5cbiAgdmVjMyBhbWJpZW50ID0gdVBvaW50TGlnaHRBbWJpZW50Q29lZmZpY2llbnQgKiBjb2xvciAvIDI1NS4wICogdUFtYmllbnRDb2xvciAvIDI1NS4wO1xuXG4gIGZsb2F0IGRpZmZ1c2VDb2VmZmljaWVudCA9IG1heChkb3Qobm9ybWFsX21vZGVsc3BhY2UsIGxpZ2h0RGlyZWN0aW9uKSwgMC4wKTtcbiAgdmVjMyBkaWZmdXNlID0gZGlmZnVzZUNvZWZmaWNpZW50ICogdVBvaW50TGlnaHRDb2xvciAvIDI1NS4gKiBjb2xvciAvIDI1NS47XG5cbiAgcmV0dXJuIGFtYmllbnQgKyB1UG9pbnRMaWdodEF0dGVudWF0aW9uICogZGlmZnVzZTtcbn1cblxudm9pZCBtYWluKHZvaWQpIHtcbiAgdmVjMiBwcm9qZWN0ZWRfeHlbMl07XG4gIHByb2plY3RfcG9zaXRpb25fZnA2NChwb3NpdGlvbnMsIHByb2plY3RlZF94eSk7XG4gIHZlYzIgc2NhbGVkX2hlaWdodCA9IG11bF9mcDY0KGhlaWdodHMsIHZlYzIocHJvamVjdGlvblBpeGVsc1BlclVuaXQueCAqIGVsZXZhdGlvbiwgMC4wKSk7XG5cbiAgdmVjMiB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbNF07XG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVswXSA9IHByb2plY3RlZF94eVswXTtcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzFdID0gcHJvamVjdGVkX3h5WzFdO1xuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMl0gPSBzdW1fZnA2NChzY2FsZWRfaGVpZ2h0LCB2ZWMyKDEuMCwgMC4wKSk7XG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVszXSA9IHZlYzIoMS4wLCAwLjApO1xuXG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdF90b19jbGlwc3BhY2VfZnA2NCh2ZXJ0ZXhfcG9zX21vZGVsc3BhY2UpO1xuXG4gIHZlYzMgY29sb3IgPSBhcHBseUxpZ2h0aW5nKFxuICBcdHZlYzMoXG4gIFx0ICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMF0ueCxcbiAgXHQgIHZlcnRleF9wb3NfbW9kZWxzcGFjZVsxXS54LFxuICBcdCAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzJdLngpLFxuICBcdG5vcm1hbHMsXG4gIFx0Y29sb3JzXG4gICk7XG4gIHZDb2xvciA9IHZlYzQoY29sb3IsIG9wYWNpdHkpO1xufVxuYDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xheWVycy9kZXByZWNhdGVkL2V4dHJ1ZGVkLWNob3JvcGxldGgtbGF5ZXItNjQvZXh0cnVkZWQtY2hvcm9wbGV0aC1sYXllci12ZXJ0ZXguZ2xzbC5qc1xuLy8gbW9kdWxlIGlkID0gOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 94 */
/* exports provided: default */
/* exports used: default */
/*!************************************!*\
  !*** ./src/lib/composite-layer.js ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__layer__ = __webpack_require__(/*! ./layer */ 15);\n\n\nclass CompositeLayer extends __WEBPACK_IMPORTED_MODULE_0__layer__[\"a\" /* default */] {\n  constructor(props) {\n    super(props);\n  }\n\n  // initializeState is usually not needed for composite layers\n  // Provide empty definition to disable check for missing definition\n  initializeState() {\n  }\n\n  // No-op for the invalidateAttribute function as the composite\n  // layer has no AttributeManager\n  invalidateAttribute() {\n  }\n\n  getPickingInfo(opts) {\n    // do not call onHover/onClick on the container\n    return null;\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = CompositeLayer;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL2NvbXBvc2l0ZS1sYXllci5qcz85NTY2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBMYXllciBmcm9tICcuL2xheWVyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29tcG9zaXRlTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICB9XG5cbiAgLy8gaW5pdGlhbGl6ZVN0YXRlIGlzIHVzdWFsbHkgbm90IG5lZWRlZCBmb3IgY29tcG9zaXRlIGxheWVyc1xuICAvLyBQcm92aWRlIGVtcHR5IGRlZmluaXRpb24gdG8gZGlzYWJsZSBjaGVjayBmb3IgbWlzc2luZyBkZWZpbml0aW9uXG4gIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgfVxuXG4gIC8vIE5vLW9wIGZvciB0aGUgaW52YWxpZGF0ZUF0dHJpYnV0ZSBmdW5jdGlvbiBhcyB0aGUgY29tcG9zaXRlXG4gIC8vIGxheWVyIGhhcyBubyBBdHRyaWJ1dGVNYW5hZ2VyXG4gIGludmFsaWRhdGVBdHRyaWJ1dGUoKSB7XG4gIH1cblxuICBnZXRQaWNraW5nSW5mbyhvcHRzKSB7XG4gICAgLy8gZG8gbm90IGNhbGwgb25Ib3Zlci9vbkNsaWNrIG9uIHRoZSBjb250YWluZXJcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGliL2NvbXBvc2l0ZS1sYXllci5qc1xuLy8gbW9kdWxlIGlkID0gOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 95 */
/* exports provided: drawLayers, pickLayers */
/* exports used: drawLayers, pickLayers */
/*!**********************************!*\
  !*** ./src/lib/draw-and-pick.js ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl__ = __webpack_require__(/*! luma.gl */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__viewport_uniforms__ = __webpack_require__(/*! ./viewport-uniforms */ 104);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils__ = __webpack_require__(/*! ./utils */ 2);\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = drawLayers;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = pickLayers;\n/* global window */\n\n\n\n\nconst EMPTY_PIXEL = new Uint8Array(4);\nlet renderCount = 0;\n\nfunction drawLayers({layers, pass}) {\n  __WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* log */].log(2, `DRAWING ${layers.length} layers`);\n\n  // render layers in normal colors\n  let visibleCount = 0;\n  // render layers in normal colors\n  layers.forEach((layer, layerIndex) => {\n    if (layer.props.visible) {\n      layer.drawLayer({\n        uniforms: Object.assign(\n          {renderPickingBuffer: 0, pickingEnabled: 0},\n          layer.context.uniforms,\n          __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__viewport_uniforms__[\"a\" /* getUniformsFromViewport */])(layer.context.viewport, layer.props),\n          {layerIndex}\n        )\n      });\n      visibleCount++;\n    }\n  });\n\n  __WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* log */].log(1, `RENDER PASS ${pass}: ${renderCount++}\n    ${visibleCount} visible, ${layers.length} total`);\n}\n\n/* eslint-disable max-depth, max-statements */\nfunction pickLayers(gl, {\n  layers,\n  pickingFBO,\n  uniforms = {},\n  x,\n  y,\n  viewport,\n  mode,\n  lastPickedInfo\n}) {\n  // Convert from canvas top-left to WebGL bottom-left coordinates\n  // And compensate for pixelRatio\n  const pixelRatio = typeof window !== 'undefined' ?\n    window.devicePixelRatio : 1;\n  const deviceX = x * pixelRatio;\n  const deviceY = gl.canvas.height - y * pixelRatio;\n\n  // TODO - just return glContextWithState once luma updates\n  const unhandledPickInfos = [];\n\n  // Make sure we clear scissor test and fbo bindings in case of exceptions\n  // We are only interested in one pixel, no need to render anything else\n  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"glContextWithState\"])(gl, {\n    frameBuffer: pickingFBO,\n    framebuffer: pickingFBO,\n    scissorTest: {x: deviceX, y: deviceY, w: 1, h: 1}\n  }, () => {\n\n    // Picking process start\n    // Clear the frame buffer\n    gl.clear(__WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].COLOR_BUFFER_BIT | __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].DEPTH_BUFFER_BIT);\n    // Save current blend settings\n    const oldBlendMode = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"h\" /* getBlendMode */])(gl);\n    // Set blend mode for picking\n    // always overwrite existing pixel with [r,g,b,layerIndex]\n    gl.enable(gl.BLEND);\n    gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.CONSTANT_ALPHA, gl.ZERO);\n    gl.blendEquation(gl.FUNC_ADD);\n\n    // Render all pickable layers in picking colors\n    layers.forEach((layer, layerIndex) => {\n      if (layer.props.visible && layer.props.pickable) {\n\n        // Encode layerIndex with alpha\n        gl.blendColor(0, 0, 0, (layerIndex + 1) / 255);\n\n        layer.drawLayer({\n          uniforms: Object.assign(\n            {renderPickingBuffer: 1, pickingEnabled: 1},\n            layer.context.uniforms,\n            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__viewport_uniforms__[\"a\" /* getUniformsFromViewport */])(layer.context.viewport, layer.props),\n            {layerIndex}\n          )\n        });\n      }\n    });\n\n    // Read color in the central pixel, to be mapped with picking colors\n    const pickedColor = new Uint8Array(4);\n    gl.readPixels(deviceX, deviceY, 1, 1, __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].RGBA, __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].UNSIGNED_BYTE, pickedColor);\n\n    // restore blend mode\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"i\" /* setBlendMode */])(gl, oldBlendMode);\n    // Picking process end\n\n    // Process picked info start\n    // Decode picked color\n    const pickedLayerIndex = pickedColor[3] - 1;\n    const pickedLayer = pickedLayerIndex >= 0 ? layers[pickedLayerIndex] : null;\n    const pickedObjectIndex = pickedLayer ? pickedLayer.decodePickingColor(pickedColor) : -1;\n    const pickedLayerId = pickedLayer && pickedLayer.props.id;\n    const affectedLayers = pickedLayer ? [pickedLayer] : [];\n\n    if (mode === 'hover') {\n      // only invoke onHover events if picked object has changed\n      const lastPickedObjectIndex = lastPickedInfo.index;\n      const lastPickedLayerId = lastPickedInfo.layerId;\n\n      if (pickedLayerId === lastPickedLayerId && pickedObjectIndex === lastPickedObjectIndex) {\n        // picked object did not change, no need to proceed\n        return;\n      }\n\n      if (pickedLayerId !== lastPickedLayerId) {\n        // We cannot store a ref to lastPickedLayer in the context because\n        // the state of an outdated layer is no longer valid\n        // and the props may have changed\n        const lastPickedLayer = layers.find(l => l.props.id === lastPickedLayerId);\n        if (lastPickedLayer) {\n          // Let leave event fire before enter event\n          affectedLayers.unshift(lastPickedLayer);\n        }\n      }\n\n      // Update layer manager context\n      lastPickedInfo.layerId = pickedLayerId;\n      lastPickedInfo.index = pickedObjectIndex;\n    }\n\n    const baseInfo = createInfo([x, y], viewport);\n    baseInfo.devicePixel = [deviceX, deviceY];\n    baseInfo.pixelRatio = pixelRatio;\n\n    affectedLayers.forEach(layer => {\n      let info = Object.assign({}, baseInfo);\n      info.layer = layer;\n\n      if (layer === pickedLayer) {\n        info.color = pickedColor;\n        info.index = pickedObjectIndex;\n        info.picked = true;\n      }\n\n      // Let layers populate its own info object\n      info = layer.pickLayer({info, mode});\n\n      // If layer.getPickingInfo() returns null, do not proceed\n      if (info) {\n        let handled = false;\n\n        // Calling callbacks can have async interactions with React\n        // which nullifies layer.state.\n        switch (mode) {\n        case 'click': handled = layer.props.onClick(info); break;\n        case 'hover': handled = layer.props.onHover(info); break;\n        default: throw new Error('unknown pick type');\n        }\n\n        if (!handled) {\n          unhandledPickInfos.push(info);\n        }\n      }\n    });\n  });\n\n  return unhandledPickInfos;\n}\n/* eslint-enable max-depth, max-statements */\n\nfunction createInfo(pixel, viewport) {\n  // Assign a number of potentially useful props to the \"info\" object\n  return {\n    color: EMPTY_PIXEL,\n    index: -1,\n    picked: false,\n    x: pixel[0],\n    y: pixel[1],\n    pixel,\n    lngLat: viewport.unproject(pixel)\n  };\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL2RyYXctYW5kLXBpY2suanM/ODQyYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQge0dMLCBnbENvbnRleHRXaXRoU3RhdGV9IGZyb20gJ2x1bWEuZ2wnO1xuaW1wb3J0IHtnZXRVbmlmb3Jtc0Zyb21WaWV3cG9ydH0gZnJvbSAnLi92aWV3cG9ydC11bmlmb3Jtcyc7XG5pbXBvcnQge2xvZywgZ2V0QmxlbmRNb2RlLCBzZXRCbGVuZE1vZGV9IGZyb20gJy4vdXRpbHMnO1xuXG5jb25zdCBFTVBUWV9QSVhFTCA9IG5ldyBVaW50OEFycmF5KDQpO1xubGV0IHJlbmRlckNvdW50ID0gMDtcblxuZXhwb3J0IGZ1bmN0aW9uIGRyYXdMYXllcnMoe2xheWVycywgcGFzc30pIHtcbiAgbG9nLmxvZygyLCBgRFJBV0lORyAke2xheWVycy5sZW5ndGh9IGxheWVyc2ApO1xuXG4gIC8vIHJlbmRlciBsYXllcnMgaW4gbm9ybWFsIGNvbG9yc1xuICBsZXQgdmlzaWJsZUNvdW50ID0gMDtcbiAgLy8gcmVuZGVyIGxheWVycyBpbiBub3JtYWwgY29sb3JzXG4gIGxheWVycy5mb3JFYWNoKChsYXllciwgbGF5ZXJJbmRleCkgPT4ge1xuICAgIGlmIChsYXllci5wcm9wcy52aXNpYmxlKSB7XG4gICAgICBsYXllci5kcmF3TGF5ZXIoe1xuICAgICAgICB1bmlmb3JtczogT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7cmVuZGVyUGlja2luZ0J1ZmZlcjogMCwgcGlja2luZ0VuYWJsZWQ6IDB9LFxuICAgICAgICAgIGxheWVyLmNvbnRleHQudW5pZm9ybXMsXG4gICAgICAgICAgZ2V0VW5pZm9ybXNGcm9tVmlld3BvcnQobGF5ZXIuY29udGV4dC52aWV3cG9ydCwgbGF5ZXIucHJvcHMpLFxuICAgICAgICAgIHtsYXllckluZGV4fVxuICAgICAgICApXG4gICAgICB9KTtcbiAgICAgIHZpc2libGVDb3VudCsrO1xuICAgIH1cbiAgfSk7XG5cbiAgbG9nLmxvZygxLCBgUkVOREVSIFBBU1MgJHtwYXNzfTogJHtyZW5kZXJDb3VudCsrfVxuICAgICR7dmlzaWJsZUNvdW50fSB2aXNpYmxlLCAke2xheWVycy5sZW5ndGh9IHRvdGFsYCk7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1kZXB0aCwgbWF4LXN0YXRlbWVudHMgKi9cbmV4cG9ydCBmdW5jdGlvbiBwaWNrTGF5ZXJzKGdsLCB7XG4gIGxheWVycyxcbiAgcGlja2luZ0ZCTyxcbiAgdW5pZm9ybXMgPSB7fSxcbiAgeCxcbiAgeSxcbiAgdmlld3BvcnQsXG4gIG1vZGUsXG4gIGxhc3RQaWNrZWRJbmZvXG59KSB7XG4gIC8vIENvbnZlcnQgZnJvbSBjYW52YXMgdG9wLWxlZnQgdG8gV2ViR0wgYm90dG9tLWxlZnQgY29vcmRpbmF0ZXNcbiAgLy8gQW5kIGNvbXBlbnNhdGUgZm9yIHBpeGVsUmF0aW9cbiAgY29uc3QgcGl4ZWxSYXRpbyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID9cbiAgICB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6IDE7XG4gIGNvbnN0IGRldmljZVggPSB4ICogcGl4ZWxSYXRpbztcbiAgY29uc3QgZGV2aWNlWSA9IGdsLmNhbnZhcy5oZWlnaHQgLSB5ICogcGl4ZWxSYXRpbztcblxuICAvLyBUT0RPIC0ganVzdCByZXR1cm4gZ2xDb250ZXh0V2l0aFN0YXRlIG9uY2UgbHVtYSB1cGRhdGVzXG4gIGNvbnN0IHVuaGFuZGxlZFBpY2tJbmZvcyA9IFtdO1xuXG4gIC8vIE1ha2Ugc3VyZSB3ZSBjbGVhciBzY2lzc29yIHRlc3QgYW5kIGZibyBiaW5kaW5ncyBpbiBjYXNlIG9mIGV4Y2VwdGlvbnNcbiAgLy8gV2UgYXJlIG9ubHkgaW50ZXJlc3RlZCBpbiBvbmUgcGl4ZWwsIG5vIG5lZWQgdG8gcmVuZGVyIGFueXRoaW5nIGVsc2VcbiAgZ2xDb250ZXh0V2l0aFN0YXRlKGdsLCB7XG4gICAgZnJhbWVCdWZmZXI6IHBpY2tpbmdGQk8sXG4gICAgZnJhbWVidWZmZXI6IHBpY2tpbmdGQk8sXG4gICAgc2Npc3NvclRlc3Q6IHt4OiBkZXZpY2VYLCB5OiBkZXZpY2VZLCB3OiAxLCBoOiAxfVxuICB9LCAoKSA9PiB7XG5cbiAgICAvLyBQaWNraW5nIHByb2Nlc3Mgc3RhcnRcbiAgICAvLyBDbGVhciB0aGUgZnJhbWUgYnVmZmVyXG4gICAgZ2wuY2xlYXIoR0wuQ09MT1JfQlVGRkVSX0JJVCB8IEdMLkRFUFRIX0JVRkZFUl9CSVQpO1xuICAgIC8vIFNhdmUgY3VycmVudCBibGVuZCBzZXR0aW5nc1xuICAgIGNvbnN0IG9sZEJsZW5kTW9kZSA9IGdldEJsZW5kTW9kZShnbCk7XG4gICAgLy8gU2V0IGJsZW5kIG1vZGUgZm9yIHBpY2tpbmdcbiAgICAvLyBhbHdheXMgb3ZlcndyaXRlIGV4aXN0aW5nIHBpeGVsIHdpdGggW3IsZyxiLGxheWVySW5kZXhdXG4gICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShnbC5PTkUsIGdsLlpFUk8sIGdsLkNPTlNUQU5UX0FMUEhBLCBnbC5aRVJPKTtcbiAgICBnbC5ibGVuZEVxdWF0aW9uKGdsLkZVTkNfQUREKTtcblxuICAgIC8vIFJlbmRlciBhbGwgcGlja2FibGUgbGF5ZXJzIGluIHBpY2tpbmcgY29sb3JzXG4gICAgbGF5ZXJzLmZvckVhY2goKGxheWVyLCBsYXllckluZGV4KSA9PiB7XG4gICAgICBpZiAobGF5ZXIucHJvcHMudmlzaWJsZSAmJiBsYXllci5wcm9wcy5waWNrYWJsZSkge1xuXG4gICAgICAgIC8vIEVuY29kZSBsYXllckluZGV4IHdpdGggYWxwaGFcbiAgICAgICAgZ2wuYmxlbmRDb2xvcigwLCAwLCAwLCAobGF5ZXJJbmRleCArIDEpIC8gMjU1KTtcblxuICAgICAgICBsYXllci5kcmF3TGF5ZXIoe1xuICAgICAgICAgIHVuaWZvcm1zOiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAge3JlbmRlclBpY2tpbmdCdWZmZXI6IDEsIHBpY2tpbmdFbmFibGVkOiAxfSxcbiAgICAgICAgICAgIGxheWVyLmNvbnRleHQudW5pZm9ybXMsXG4gICAgICAgICAgICBnZXRVbmlmb3Jtc0Zyb21WaWV3cG9ydChsYXllci5jb250ZXh0LnZpZXdwb3J0LCBsYXllci5wcm9wcyksXG4gICAgICAgICAgICB7bGF5ZXJJbmRleH1cbiAgICAgICAgICApXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gUmVhZCBjb2xvciBpbiB0aGUgY2VudHJhbCBwaXhlbCwgdG8gYmUgbWFwcGVkIHdpdGggcGlja2luZyBjb2xvcnNcbiAgICBjb25zdCBwaWNrZWRDb2xvciA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGdsLnJlYWRQaXhlbHMoZGV2aWNlWCwgZGV2aWNlWSwgMSwgMSwgR0wuUkdCQSwgR0wuVU5TSUdORURfQllURSwgcGlja2VkQ29sb3IpO1xuXG4gICAgLy8gcmVzdG9yZSBibGVuZCBtb2RlXG4gICAgc2V0QmxlbmRNb2RlKGdsLCBvbGRCbGVuZE1vZGUpO1xuICAgIC8vIFBpY2tpbmcgcHJvY2VzcyBlbmRcblxuICAgIC8vIFByb2Nlc3MgcGlja2VkIGluZm8gc3RhcnRcbiAgICAvLyBEZWNvZGUgcGlja2VkIGNvbG9yXG4gICAgY29uc3QgcGlja2VkTGF5ZXJJbmRleCA9IHBpY2tlZENvbG9yWzNdIC0gMTtcbiAgICBjb25zdCBwaWNrZWRMYXllciA9IHBpY2tlZExheWVySW5kZXggPj0gMCA/IGxheWVyc1twaWNrZWRMYXllckluZGV4XSA6IG51bGw7XG4gICAgY29uc3QgcGlja2VkT2JqZWN0SW5kZXggPSBwaWNrZWRMYXllciA/IHBpY2tlZExheWVyLmRlY29kZVBpY2tpbmdDb2xvcihwaWNrZWRDb2xvcikgOiAtMTtcbiAgICBjb25zdCBwaWNrZWRMYXllcklkID0gcGlja2VkTGF5ZXIgJiYgcGlja2VkTGF5ZXIucHJvcHMuaWQ7XG4gICAgY29uc3QgYWZmZWN0ZWRMYXllcnMgPSBwaWNrZWRMYXllciA/IFtwaWNrZWRMYXllcl0gOiBbXTtcblxuICAgIGlmIChtb2RlID09PSAnaG92ZXInKSB7XG4gICAgICAvLyBvbmx5IGludm9rZSBvbkhvdmVyIGV2ZW50cyBpZiBwaWNrZWQgb2JqZWN0IGhhcyBjaGFuZ2VkXG4gICAgICBjb25zdCBsYXN0UGlja2VkT2JqZWN0SW5kZXggPSBsYXN0UGlja2VkSW5mby5pbmRleDtcbiAgICAgIGNvbnN0IGxhc3RQaWNrZWRMYXllcklkID0gbGFzdFBpY2tlZEluZm8ubGF5ZXJJZDtcblxuICAgICAgaWYgKHBpY2tlZExheWVySWQgPT09IGxhc3RQaWNrZWRMYXllcklkICYmIHBpY2tlZE9iamVjdEluZGV4ID09PSBsYXN0UGlja2VkT2JqZWN0SW5kZXgpIHtcbiAgICAgICAgLy8gcGlja2VkIG9iamVjdCBkaWQgbm90IGNoYW5nZSwgbm8gbmVlZCB0byBwcm9jZWVkXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBpY2tlZExheWVySWQgIT09IGxhc3RQaWNrZWRMYXllcklkKSB7XG4gICAgICAgIC8vIFdlIGNhbm5vdCBzdG9yZSBhIHJlZiB0byBsYXN0UGlja2VkTGF5ZXIgaW4gdGhlIGNvbnRleHQgYmVjYXVzZVxuICAgICAgICAvLyB0aGUgc3RhdGUgb2YgYW4gb3V0ZGF0ZWQgbGF5ZXIgaXMgbm8gbG9uZ2VyIHZhbGlkXG4gICAgICAgIC8vIGFuZCB0aGUgcHJvcHMgbWF5IGhhdmUgY2hhbmdlZFxuICAgICAgICBjb25zdCBsYXN0UGlja2VkTGF5ZXIgPSBsYXllcnMuZmluZChsID0+IGwucHJvcHMuaWQgPT09IGxhc3RQaWNrZWRMYXllcklkKTtcbiAgICAgICAgaWYgKGxhc3RQaWNrZWRMYXllcikge1xuICAgICAgICAgIC8vIExldCBsZWF2ZSBldmVudCBmaXJlIGJlZm9yZSBlbnRlciBldmVudFxuICAgICAgICAgIGFmZmVjdGVkTGF5ZXJzLnVuc2hpZnQobGFzdFBpY2tlZExheWVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgbGF5ZXIgbWFuYWdlciBjb250ZXh0XG4gICAgICBsYXN0UGlja2VkSW5mby5sYXllcklkID0gcGlja2VkTGF5ZXJJZDtcbiAgICAgIGxhc3RQaWNrZWRJbmZvLmluZGV4ID0gcGlja2VkT2JqZWN0SW5kZXg7XG4gICAgfVxuXG4gICAgY29uc3QgYmFzZUluZm8gPSBjcmVhdGVJbmZvKFt4LCB5XSwgdmlld3BvcnQpO1xuICAgIGJhc2VJbmZvLmRldmljZVBpeGVsID0gW2RldmljZVgsIGRldmljZVldO1xuICAgIGJhc2VJbmZvLnBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuXG4gICAgYWZmZWN0ZWRMYXllcnMuZm9yRWFjaChsYXllciA9PiB7XG4gICAgICBsZXQgaW5mbyA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VJbmZvKTtcbiAgICAgIGluZm8ubGF5ZXIgPSBsYXllcjtcblxuICAgICAgaWYgKGxheWVyID09PSBwaWNrZWRMYXllcikge1xuICAgICAgICBpbmZvLmNvbG9yID0gcGlja2VkQ29sb3I7XG4gICAgICAgIGluZm8uaW5kZXggPSBwaWNrZWRPYmplY3RJbmRleDtcbiAgICAgICAgaW5mby5waWNrZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBMZXQgbGF5ZXJzIHBvcHVsYXRlIGl0cyBvd24gaW5mbyBvYmplY3RcbiAgICAgIGluZm8gPSBsYXllci5waWNrTGF5ZXIoe2luZm8sIG1vZGV9KTtcblxuICAgICAgLy8gSWYgbGF5ZXIuZ2V0UGlja2luZ0luZm8oKSByZXR1cm5zIG51bGwsIGRvIG5vdCBwcm9jZWVkXG4gICAgICBpZiAoaW5mbykge1xuICAgICAgICBsZXQgaGFuZGxlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIENhbGxpbmcgY2FsbGJhY2tzIGNhbiBoYXZlIGFzeW5jIGludGVyYWN0aW9ucyB3aXRoIFJlYWN0XG4gICAgICAgIC8vIHdoaWNoIG51bGxpZmllcyBsYXllci5zdGF0ZS5cbiAgICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgIGNhc2UgJ2NsaWNrJzogaGFuZGxlZCA9IGxheWVyLnByb3BzLm9uQ2xpY2soaW5mbyk7IGJyZWFrO1xuICAgICAgICBjYXNlICdob3Zlcic6IGhhbmRsZWQgPSBsYXllci5wcm9wcy5vbkhvdmVyKGluZm8pOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHBpY2sgdHlwZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFoYW5kbGVkKSB7XG4gICAgICAgICAgdW5oYW5kbGVkUGlja0luZm9zLnB1c2goaW5mbyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHVuaGFuZGxlZFBpY2tJbmZvcztcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWRlcHRoLCBtYXgtc3RhdGVtZW50cyAqL1xuXG5mdW5jdGlvbiBjcmVhdGVJbmZvKHBpeGVsLCB2aWV3cG9ydCkge1xuICAvLyBBc3NpZ24gYSBudW1iZXIgb2YgcG90ZW50aWFsbHkgdXNlZnVsIHByb3BzIHRvIHRoZSBcImluZm9cIiBvYmplY3RcbiAgcmV0dXJuIHtcbiAgICBjb2xvcjogRU1QVFlfUElYRUwsXG4gICAgaW5kZXg6IC0xLFxuICAgIHBpY2tlZDogZmFsc2UsXG4gICAgeDogcGl4ZWxbMF0sXG4gICAgeTogcGl4ZWxbMV0sXG4gICAgcGl4ZWwsXG4gICAgbG5nTGF0OiB2aWV3cG9ydC51bnByb2plY3QocGl4ZWwpXG4gIH07XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9saWIvZHJhdy1hbmQtcGljay5qc1xuLy8gbW9kdWxlIGlkID0gOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 96 */
/* unknown exports provided */
/*!*************************!*\
  !*** ./src/lib/init.js ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_globals__ = __webpack_require__(/*! ./utils/globals */ 103);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_globals___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils_globals__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_log__ = __webpack_require__(/*! ./utils/log */ 28);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__package_json__ = __webpack_require__(/*! ../../package.json */ 47);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__package_json___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__package_json__);\n\n\n\n// Version detection\n// TODO - this imports a rather large JSON file, we only need one field\n\n\nconst STARTUP_MESSAGE = 'set deck.log.priority=2 to trace attribute updates';\n\nif (__WEBPACK_IMPORTED_MODULE_0__utils_globals__[\"global\"].deck && __WEBPACK_IMPORTED_MODULE_0__utils_globals__[\"global\"].deck.VERSION !== __WEBPACK_IMPORTED_MODULE_2__package_json__[\"version\"]) {\n  throw new Error(`deck.gl - multiple versions detected: ${__WEBPACK_IMPORTED_MODULE_0__utils_globals__[\"global\"].deck.VERSION} vs ${__WEBPACK_IMPORTED_MODULE_2__package_json__[\"version\"]}`);\n}\n\nif (!__WEBPACK_IMPORTED_MODULE_0__utils_globals__[\"global\"].deck) {\n  /* global console */\n  /* eslint-disable no-console */\n  console.log(`deck.gl ${__WEBPACK_IMPORTED_MODULE_2__package_json__[\"version\"]} - ${STARTUP_MESSAGE}`);\n\n  __WEBPACK_IMPORTED_MODULE_0__utils_globals__[\"global\"].deck = __WEBPACK_IMPORTED_MODULE_0__utils_globals__[\"global\"].deck || {\n    VERSION: __WEBPACK_IMPORTED_MODULE_2__package_json__[\"version\"],\n    log: __WEBPACK_IMPORTED_MODULE_1__utils_log__[\"a\" /* default */]\n  };\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL2luaXQuanM/ZDNkMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2dsb2JhbH0gZnJvbSAnLi91dGlscy9nbG9iYWxzJztcbmltcG9ydCBsb2cgZnJvbSAnLi91dGlscy9sb2cnO1xuXG4vLyBWZXJzaW9uIGRldGVjdGlvblxuLy8gVE9ETyAtIHRoaXMgaW1wb3J0cyBhIHJhdGhlciBsYXJnZSBKU09OIGZpbGUsIHdlIG9ubHkgbmVlZCBvbmUgZmllbGRcbmltcG9ydCB7dmVyc2lvbn0gZnJvbSAnLi4vLi4vcGFja2FnZS5qc29uJztcblxuY29uc3QgU1RBUlRVUF9NRVNTQUdFID0gJ3NldCBkZWNrLmxvZy5wcmlvcml0eT0yIHRvIHRyYWNlIGF0dHJpYnV0ZSB1cGRhdGVzJztcblxuaWYgKGdsb2JhbC5kZWNrICYmIGdsb2JhbC5kZWNrLlZFUlNJT04gIT09IHZlcnNpb24pIHtcbiAgdGhyb3cgbmV3IEVycm9yKGBkZWNrLmdsIC0gbXVsdGlwbGUgdmVyc2lvbnMgZGV0ZWN0ZWQ6ICR7Z2xvYmFsLmRlY2suVkVSU0lPTn0gdnMgJHt2ZXJzaW9ufWApO1xufVxuXG5pZiAoIWdsb2JhbC5kZWNrKSB7XG4gIC8qIGdsb2JhbCBjb25zb2xlICovXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgY29uc29sZS5sb2coYGRlY2suZ2wgJHt2ZXJzaW9ufSAtICR7U1RBUlRVUF9NRVNTQUdFfWApO1xuXG4gIGdsb2JhbC5kZWNrID0gZ2xvYmFsLmRlY2sgfHwge1xuICAgIFZFUlNJT046IHZlcnNpb24sXG4gICAgbG9nXG4gIH07XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9saWIvaW5pdC5qc1xuLy8gbW9kdWxlIGlkID0gOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 97 */
/* exports provided: default */
/* exports used: default */
/*!**********************************!*\
  !*** ./src/lib/layer-manager.js ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__layer__ = __webpack_require__(/*! ./layer */ 15);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(/*! ./utils */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assert__ = __webpack_require__(/*! assert */ 6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_assert__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__draw_and_pick__ = __webpack_require__(/*! ./draw-and-pick */ 95);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__viewports__ = __webpack_require__(/*! ./viewports */ 16);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_luma_gl__ = __webpack_require__(/*! luma.gl */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_luma_gl__);\n\n// IMLEMENTATION NOTES: Why new layers are created on every render\n//\n// The key here is to understand the declarative / functional\n// programming nature of \"reactive\" applications.\n//\n// - In a reactive application, the entire \"UI tree\"\n//   is re-rendered every time something in the application changes.\n//\n// - The UI framework (such as React or deck.gl) then diffs the rendered\n//   tree of UI elements (React Elements or deck.gl Layers) against the\n//   previously tree and makes optimized changes (to the DOM or to WebGL state).\n//\n// - Deck.gl layers are not based on React.\n//   But it should be possible to wrap deck.gl layers in React components to\n//   enable use of JSX.\n//\n// The deck.gl model that for the app creates a new set of on layers on every\n// render.\n// Internally, the new layers are efficiently matched against existing layers\n// using layer ids.\n//\n// All calculated state (programs, attributes etc) are stored in a state object\n// and this state object is moved forward to the match layer on every render\n// cycle.  The new layer ends up with the state of the old layer (and the\n// props of the new layer), while the old layer is simply discarded for\n// garbage collecion.\n//\n/* eslint-disable no-try-catch */\n\n\n\n\n\n\n\n\nclass LayerManager {\n  constructor({gl}) {\n    this.prevLayers = [];\n    this.layers = [];\n    // Tracks if any layers were drawn last update\n    // Needed to ensure that screen is cleared when no layers are shown\n    this.screenCleared = false;\n    this.oldContext = {};\n    this.context = {\n      gl,\n      uniforms: {},\n      viewport: null,\n      viewportChanged: true,\n      pickingFBO: null,\n      lastPickedInfo: {\n        index: -1,\n        layerId: null\n      }\n    };\n    Object.seal(this.context);\n  }\n\n  setViewport(viewport) {\n    __WEBPACK_IMPORTED_MODULE_2_assert___default()(viewport instanceof __WEBPACK_IMPORTED_MODULE_4__viewports__[\"b\" /* Viewport */], 'Invalid viewport');\n\n    // TODO - viewport change detection breaks METER_OFFSETS mode\n    // const oldViewport = this.context.viewport;\n    // const viewportChanged = !oldViewport || !viewport.equals(oldViewport);\n\n    const viewportChanged = true;\n\n    if (viewportChanged) {\n      Object.assign(this.oldContext, this.context);\n      this.context.viewport = viewport;\n      this.context.viewportChanged = true;\n      this.context.uniforms = {};\n      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */])(4, viewport);\n    }\n\n    return this;\n  }\n\n  updateLayers({newLayers}) {\n    /* eslint-disable */\n    __WEBPACK_IMPORTED_MODULE_2_assert___default()(this.context.viewport,\n      'LayerManager.updateLayers: viewport not set');\n\n    // Filter out any null layers\n    newLayers = newLayers.filter(newLayer => newLayer !== null);\n\n    for (const layer of newLayers) {\n      layer.context = this.context;\n    }\n\n    this.prevLayers = this.layers;\n    const {error, generatedLayers} = this._updateLayers({\n      oldLayers: this.prevLayers,\n      newLayers\n    });\n\n    this.layers = generatedLayers;\n    // Throw first error found, if any\n    if (error) {\n      throw error;\n    }\n    return this;\n  }\n\n  drawLayers({pass}) {\n    __WEBPACK_IMPORTED_MODULE_2_assert___default()(this.context.viewport, 'LayerManager.drawLayers: viewport not set');\n\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__draw_and_pick__[\"a\" /* drawLayers */])({layers: this.layers, pass});\n\n    return this;\n  }\n\n  pickLayer({x, y, mode}) {\n    const {gl, uniforms} = this.context;\n\n    // Set up a frame buffer if needed\n    if (this.context.pickingFBO === null ||\n      gl.canvas.width !== this.context.pickingFBO.width ||\n      gl.canvas.height !== this.context.pickingFBO.height) {\n      this.context.pickingFBO = new __WEBPACK_IMPORTED_MODULE_5_luma_gl__[\"FramebufferObject\"](gl, {\n        width: gl.canvas.width,\n        height: gl.canvas.height\n      });\n    }\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__draw_and_pick__[\"b\" /* pickLayers */])(gl, {\n      x,\n      y,\n      uniforms: {\n        renderPickingBuffer: true,\n        picking_uEnable: true\n      },\n      layers: this.layers,\n      mode,\n      viewport: this.context.viewport,\n      pickingFBO: this.context.pickingFBO,\n      lastPickedInfo: this.context.lastPickedInfo\n    });\n  }\n\n  needsRedraw({clearRedrawFlags = false} = {}) {\n    if (!this.context.viewport) {\n      return false;\n    }\n\n    let redraw = false;\n\n    // Make sure that buffer is cleared once when layer list becomes empty\n    if (this.layers.length === 0) {\n      if (this.screenCleared === false) {\n        redraw = true;\n        this.screenCleared = true;\n        return true;\n      }\n    } else {\n      if (this.screenCleared === true) {\n        this.screenCleared = false;\n      }\n    }\n\n    for (const layer of this.layers) {\n      redraw = redraw || layer.getNeedsRedraw({clearRedrawFlags});\n    }\n    return redraw;\n  }\n\n  // PRIVATE METHODS\n\n  // Match all layers, checking for caught errors\n  // To avoid having an exception in one layer disrupt other layers\n  _updateLayers({oldLayers, newLayers}) {\n    // Create old layer map\n    const oldLayerMap = {};\n    for (const oldLayer of oldLayers) {\n      if (oldLayerMap[oldLayer.id]) {\n        __WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */].once(0, `Multipe old layers with same id ${layerName(oldLayer)}`);\n      } else {\n        oldLayerMap[oldLayer.id] = oldLayer;\n      }\n    }\n\n    // Allocate array for generated layers\n    const generatedLayers = [];\n\n    // Match sublayers\n    const error = this._matchSublayers({\n      newLayers, oldLayerMap, generatedLayers\n    });\n\n    const error2 = this._finalizeOldLayers(oldLayers);\n    const firstError = error || error2;\n    return {error: firstError, generatedLayers};\n  }\n\n  /* eslint-disable max-statements */\n  _matchSublayers({newLayers, oldLayerMap, generatedLayers}) {\n    // Filter out any null layers\n    newLayers = newLayers.filter(newLayer => newLayer !== null);\n\n    let error = null;\n    for (const newLayer of newLayers) {\n      newLayer.context = this.context;\n\n      try {\n        // 1. given a new coming layer, find its matching layer\n        const oldLayer = oldLayerMap[newLayer.id];\n        oldLayerMap[newLayer.id] = null;\n\n        if (oldLayer === null) {\n          __WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */].once(0, `Multipe new layers with same id ${layerName(newLayer)}`);\n        }\n\n\n        // Only transfer state at this stage. We must not generate exceptions\n        // until all layers' state have been transferred\n        if (oldLayer) {\n          __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */])(3, `matched ${layerName(newLayer)}`, oldLayer, '=>', newLayer);\n          this._transferLayerState(oldLayer, newLayer);\n          this._updateLayer(newLayer);\n        } else {\n          this._initializeNewLayer(newLayer);\n        }\n        generatedLayers.push(newLayer);\n\n        // Call layer lifecycle method: render sublayers\n        let sublayers = newLayer.renderLayers();\n        // End layer lifecycle method: render sublayers\n\n        if (sublayers) {\n          sublayers = Array.isArray(sublayers) ? sublayers : [sublayers];\n          this._matchSublayers({\n            newLayers: sublayers,\n            oldLayerMap,\n            generatedLayers\n          });\n        }\n      } catch (err) {\n        __WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */].once(0,\n          `deck.gl error during matching of ${layerName(newLayer)} ${err}`, err);\n        // Save first error\n        error = error || err;\n      }\n    }\n    return error;\n  }\n\n  _transferLayerState(oldLayer, newLayer) {\n    const {state, props} = oldLayer;\n\n    // sanity check\n    __WEBPACK_IMPORTED_MODULE_2_assert___default()(state, 'deck.gl sanity check - Matching layer has no state');\n    __WEBPACK_IMPORTED_MODULE_2_assert___default()(oldLayer !== newLayer, 'deck.gl sanity check - Matching layer is same');\n\n    // Move state\n    newLayer.state = state;\n    state.layer = newLayer;\n\n    // Update model layer reference\n    if (state.model) {\n      state.model.userData.layer = newLayer;\n    }\n    // Keep a temporary ref to the old props, for prop comparison\n    newLayer.oldProps = props;\n    oldLayer.state = null;\n  }\n\n  // Update the old layers that were not matched\n  _finalizeOldLayers(oldLayers) {\n    let error = null;\n    // Unmatched layers still have state, it will be discarded\n    for (const layer of oldLayers) {\n      if (layer.state) {\n        error = error || this._finalizeLayer(layer);\n      }\n    }\n    return error;\n  }\n\n  // Initializes a single layer, calling layer methods\n  _initializeNewLayer(layer) {\n    let error = null;\n    // Check if new layer, and initialize it's state\n    if (!layer.state) {\n      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */])(1, `initializing ${layerName(layer)}`);\n      try {\n        layer.initializeLayer({\n          oldProps: {},\n          props: layer.props,\n          oldContext: this.oldContext,\n          context: this.context,\n          changeFlags: layer.diffProps({}, layer.props, this.context)\n        });\n      } catch (err) {\n        __WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */].once(0, `deck.gl error during initialization of ${layerName(layer)} ${err}`, err);\n        // Save first error\n        error = error || err;\n      }\n      // Set back pointer (used in picking)\n      if (layer.state) {\n        layer.state.layer = layer;\n        // Save layer on model for picking purposes\n        // TODO - store on model.userData rather than directly on model\n      }\n      if (layer.state && layer.state.model) {\n        layer.state.model.userData.layer = layer;\n      }\n    }\n    return error;\n  }\n\n  // Updates a single layer, calling layer methods\n  _updateLayer(layer) {\n    const {oldProps, props} = layer;\n    let error = null;\n    if (oldProps) {\n      try {\n        layer.updateLayer({\n          oldProps,\n          props,\n          context: this.context,\n          oldContext: this.oldContext,\n          changeFlags: layer.diffProps(oldProps, layer.props, this.context)\n        });\n      } catch (err) {\n        __WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */].once(0, `deck.gl error during update of ${layerName(layer)}`, err);\n        // Save first error\n        error = err;\n      }\n      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */])(2, `updating ${layerName(layer)}`);\n    }\n    return error;\n  }\n\n  // Finalizes a single layer\n  _finalizeLayer(layer) {\n    let error = null;\n    const {state} = layer;\n    if (state) {\n      try {\n        layer.finalizeLayer();\n      } catch (err) {\n        __WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */].once(0,\n          `deck.gl error during finalization of ${layerName(layer)}`, err);\n        // Save first error\n        error = err;\n      }\n      layer.state = null;\n      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */])(1, `finalizing ${layerName(layer)}`);\n    }\n    return error;\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = LayerManager;\n\n\nfunction layerName(layer) {\n  if (layer instanceof __WEBPACK_IMPORTED_MODULE_0__layer__[\"a\" /* default */]) {\n    return `${layer}`;\n  }\n  return !layer ? 'null layer' : 'invalid layer';\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL2xheWVyLW1hbmFnZXIuanM/OTJhZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8vIElNTEVNRU5UQVRJT04gTk9URVM6IFdoeSBuZXcgbGF5ZXJzIGFyZSBjcmVhdGVkIG9uIGV2ZXJ5IHJlbmRlclxuLy9cbi8vIFRoZSBrZXkgaGVyZSBpcyB0byB1bmRlcnN0YW5kIHRoZSBkZWNsYXJhdGl2ZSAvIGZ1bmN0aW9uYWxcbi8vIHByb2dyYW1taW5nIG5hdHVyZSBvZiBcInJlYWN0aXZlXCIgYXBwbGljYXRpb25zLlxuLy9cbi8vIC0gSW4gYSByZWFjdGl2ZSBhcHBsaWNhdGlvbiwgdGhlIGVudGlyZSBcIlVJIHRyZWVcIlxuLy8gICBpcyByZS1yZW5kZXJlZCBldmVyeSB0aW1lIHNvbWV0aGluZyBpbiB0aGUgYXBwbGljYXRpb24gY2hhbmdlcy5cbi8vXG4vLyAtIFRoZSBVSSBmcmFtZXdvcmsgKHN1Y2ggYXMgUmVhY3Qgb3IgZGVjay5nbCkgdGhlbiBkaWZmcyB0aGUgcmVuZGVyZWRcbi8vICAgdHJlZSBvZiBVSSBlbGVtZW50cyAoUmVhY3QgRWxlbWVudHMgb3IgZGVjay5nbCBMYXllcnMpIGFnYWluc3QgdGhlXG4vLyAgIHByZXZpb3VzbHkgdHJlZSBhbmQgbWFrZXMgb3B0aW1pemVkIGNoYW5nZXMgKHRvIHRoZSBET00gb3IgdG8gV2ViR0wgc3RhdGUpLlxuLy9cbi8vIC0gRGVjay5nbCBsYXllcnMgYXJlIG5vdCBiYXNlZCBvbiBSZWFjdC5cbi8vICAgQnV0IGl0IHNob3VsZCBiZSBwb3NzaWJsZSB0byB3cmFwIGRlY2suZ2wgbGF5ZXJzIGluIFJlYWN0IGNvbXBvbmVudHMgdG9cbi8vICAgZW5hYmxlIHVzZSBvZiBKU1guXG4vL1xuLy8gVGhlIGRlY2suZ2wgbW9kZWwgdGhhdCBmb3IgdGhlIGFwcCBjcmVhdGVzIGEgbmV3IHNldCBvZiBvbiBsYXllcnMgb24gZXZlcnlcbi8vIHJlbmRlci5cbi8vIEludGVybmFsbHksIHRoZSBuZXcgbGF5ZXJzIGFyZSBlZmZpY2llbnRseSBtYXRjaGVkIGFnYWluc3QgZXhpc3RpbmcgbGF5ZXJzXG4vLyB1c2luZyBsYXllciBpZHMuXG4vL1xuLy8gQWxsIGNhbGN1bGF0ZWQgc3RhdGUgKHByb2dyYW1zLCBhdHRyaWJ1dGVzIGV0YykgYXJlIHN0b3JlZCBpbiBhIHN0YXRlIG9iamVjdFxuLy8gYW5kIHRoaXMgc3RhdGUgb2JqZWN0IGlzIG1vdmVkIGZvcndhcmQgdG8gdGhlIG1hdGNoIGxheWVyIG9uIGV2ZXJ5IHJlbmRlclxuLy8gY3ljbGUuICBUaGUgbmV3IGxheWVyIGVuZHMgdXAgd2l0aCB0aGUgc3RhdGUgb2YgdGhlIG9sZCBsYXllciAoYW5kIHRoZVxuLy8gcHJvcHMgb2YgdGhlIG5ldyBsYXllciksIHdoaWxlIHRoZSBvbGQgbGF5ZXIgaXMgc2ltcGx5IGRpc2NhcmRlZCBmb3Jcbi8vIGdhcmJhZ2UgY29sbGVjaW9uLlxuLy9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXRyeS1jYXRjaCAqL1xuaW1wb3J0IExheWVyIGZyb20gJy4vbGF5ZXInO1xuaW1wb3J0IHtsb2d9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IHtkcmF3TGF5ZXJzLCBwaWNrTGF5ZXJzfSBmcm9tICcuL2RyYXctYW5kLXBpY2snO1xuaW1wb3J0IHtWaWV3cG9ydH0gZnJvbSAnLi92aWV3cG9ydHMnO1xuXG5pbXBvcnQge0ZyYW1lYnVmZmVyT2JqZWN0fSBmcm9tICdsdW1hLmdsJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGF5ZXJNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3Ioe2dsfSkge1xuICAgIHRoaXMucHJldkxheWVycyA9IFtdO1xuICAgIHRoaXMubGF5ZXJzID0gW107XG4gICAgLy8gVHJhY2tzIGlmIGFueSBsYXllcnMgd2VyZSBkcmF3biBsYXN0IHVwZGF0ZVxuICAgIC8vIE5lZWRlZCB0byBlbnN1cmUgdGhhdCBzY3JlZW4gaXMgY2xlYXJlZCB3aGVuIG5vIGxheWVycyBhcmUgc2hvd25cbiAgICB0aGlzLnNjcmVlbkNsZWFyZWQgPSBmYWxzZTtcbiAgICB0aGlzLm9sZENvbnRleHQgPSB7fTtcbiAgICB0aGlzLmNvbnRleHQgPSB7XG4gICAgICBnbCxcbiAgICAgIHVuaWZvcm1zOiB7fSxcbiAgICAgIHZpZXdwb3J0OiBudWxsLFxuICAgICAgdmlld3BvcnRDaGFuZ2VkOiB0cnVlLFxuICAgICAgcGlja2luZ0ZCTzogbnVsbCxcbiAgICAgIGxhc3RQaWNrZWRJbmZvOiB7XG4gICAgICAgIGluZGV4OiAtMSxcbiAgICAgICAgbGF5ZXJJZDogbnVsbFxuICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LnNlYWwodGhpcy5jb250ZXh0KTtcbiAgfVxuXG4gIHNldFZpZXdwb3J0KHZpZXdwb3J0KSB7XG4gICAgYXNzZXJ0KHZpZXdwb3J0IGluc3RhbmNlb2YgVmlld3BvcnQsICdJbnZhbGlkIHZpZXdwb3J0Jyk7XG5cbiAgICAvLyBUT0RPIC0gdmlld3BvcnQgY2hhbmdlIGRldGVjdGlvbiBicmVha3MgTUVURVJfT0ZGU0VUUyBtb2RlXG4gICAgLy8gY29uc3Qgb2xkVmlld3BvcnQgPSB0aGlzLmNvbnRleHQudmlld3BvcnQ7XG4gICAgLy8gY29uc3Qgdmlld3BvcnRDaGFuZ2VkID0gIW9sZFZpZXdwb3J0IHx8ICF2aWV3cG9ydC5lcXVhbHMob2xkVmlld3BvcnQpO1xuXG4gICAgY29uc3Qgdmlld3BvcnRDaGFuZ2VkID0gdHJ1ZTtcblxuICAgIGlmICh2aWV3cG9ydENoYW5nZWQpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5vbGRDb250ZXh0LCB0aGlzLmNvbnRleHQpO1xuICAgICAgdGhpcy5jb250ZXh0LnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICB0aGlzLmNvbnRleHQudmlld3BvcnRDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMuY29udGV4dC51bmlmb3JtcyA9IHt9O1xuICAgICAgbG9nKDQsIHZpZXdwb3J0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHVwZGF0ZUxheWVycyh7bmV3TGF5ZXJzfSkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlICovXG4gICAgYXNzZXJ0KHRoaXMuY29udGV4dC52aWV3cG9ydCxcbiAgICAgICdMYXllck1hbmFnZXIudXBkYXRlTGF5ZXJzOiB2aWV3cG9ydCBub3Qgc2V0Jyk7XG5cbiAgICAvLyBGaWx0ZXIgb3V0IGFueSBudWxsIGxheWVyc1xuICAgIG5ld0xheWVycyA9IG5ld0xheWVycy5maWx0ZXIobmV3TGF5ZXIgPT4gbmV3TGF5ZXIgIT09IG51bGwpO1xuXG4gICAgZm9yIChjb25zdCBsYXllciBvZiBuZXdMYXllcnMpIHtcbiAgICAgIGxheWVyLmNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgfVxuXG4gICAgdGhpcy5wcmV2TGF5ZXJzID0gdGhpcy5sYXllcnM7XG4gICAgY29uc3Qge2Vycm9yLCBnZW5lcmF0ZWRMYXllcnN9ID0gdGhpcy5fdXBkYXRlTGF5ZXJzKHtcbiAgICAgIG9sZExheWVyczogdGhpcy5wcmV2TGF5ZXJzLFxuICAgICAgbmV3TGF5ZXJzXG4gICAgfSk7XG5cbiAgICB0aGlzLmxheWVycyA9IGdlbmVyYXRlZExheWVycztcbiAgICAvLyBUaHJvdyBmaXJzdCBlcnJvciBmb3VuZCwgaWYgYW55XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBkcmF3TGF5ZXJzKHtwYXNzfSkge1xuICAgIGFzc2VydCh0aGlzLmNvbnRleHQudmlld3BvcnQsICdMYXllck1hbmFnZXIuZHJhd0xheWVyczogdmlld3BvcnQgbm90IHNldCcpO1xuXG4gICAgZHJhd0xheWVycyh7bGF5ZXJzOiB0aGlzLmxheWVycywgcGFzc30pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBwaWNrTGF5ZXIoe3gsIHksIG1vZGV9KSB7XG4gICAgY29uc3Qge2dsLCB1bmlmb3Jtc30gPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAvLyBTZXQgdXAgYSBmcmFtZSBidWZmZXIgaWYgbmVlZGVkXG4gICAgaWYgKHRoaXMuY29udGV4dC5waWNraW5nRkJPID09PSBudWxsIHx8XG4gICAgICBnbC5jYW52YXMud2lkdGggIT09IHRoaXMuY29udGV4dC5waWNraW5nRkJPLndpZHRoIHx8XG4gICAgICBnbC5jYW52YXMuaGVpZ2h0ICE9PSB0aGlzLmNvbnRleHQucGlja2luZ0ZCTy5oZWlnaHQpIHtcbiAgICAgIHRoaXMuY29udGV4dC5waWNraW5nRkJPID0gbmV3IEZyYW1lYnVmZmVyT2JqZWN0KGdsLCB7XG4gICAgICAgIHdpZHRoOiBnbC5jYW52YXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogZ2wuY2FudmFzLmhlaWdodFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwaWNrTGF5ZXJzKGdsLCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIHJlbmRlclBpY2tpbmdCdWZmZXI6IHRydWUsXG4gICAgICAgIHBpY2tpbmdfdUVuYWJsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGxheWVyczogdGhpcy5sYXllcnMsXG4gICAgICBtb2RlLFxuICAgICAgdmlld3BvcnQ6IHRoaXMuY29udGV4dC52aWV3cG9ydCxcbiAgICAgIHBpY2tpbmdGQk86IHRoaXMuY29udGV4dC5waWNraW5nRkJPLFxuICAgICAgbGFzdFBpY2tlZEluZm86IHRoaXMuY29udGV4dC5sYXN0UGlja2VkSW5mb1xuICAgIH0pO1xuICB9XG5cbiAgbmVlZHNSZWRyYXcoe2NsZWFyUmVkcmF3RmxhZ3MgPSBmYWxzZX0gPSB7fSkge1xuICAgIGlmICghdGhpcy5jb250ZXh0LnZpZXdwb3J0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHJlZHJhdyA9IGZhbHNlO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzIGNsZWFyZWQgb25jZSB3aGVuIGxheWVyIGxpc3QgYmVjb21lcyBlbXB0eVxuICAgIGlmICh0aGlzLmxheWVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmICh0aGlzLnNjcmVlbkNsZWFyZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHJlZHJhdyA9IHRydWU7XG4gICAgICAgIHRoaXMuc2NyZWVuQ2xlYXJlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5zY3JlZW5DbGVhcmVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc2NyZWVuQ2xlYXJlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy5sYXllcnMpIHtcbiAgICAgIHJlZHJhdyA9IHJlZHJhdyB8fCBsYXllci5nZXROZWVkc1JlZHJhdyh7Y2xlYXJSZWRyYXdGbGFnc30pO1xuICAgIH1cbiAgICByZXR1cm4gcmVkcmF3O1xuICB9XG5cbiAgLy8gUFJJVkFURSBNRVRIT0RTXG5cbiAgLy8gTWF0Y2ggYWxsIGxheWVycywgY2hlY2tpbmcgZm9yIGNhdWdodCBlcnJvcnNcbiAgLy8gVG8gYXZvaWQgaGF2aW5nIGFuIGV4Y2VwdGlvbiBpbiBvbmUgbGF5ZXIgZGlzcnVwdCBvdGhlciBsYXllcnNcbiAgX3VwZGF0ZUxheWVycyh7b2xkTGF5ZXJzLCBuZXdMYXllcnN9KSB7XG4gICAgLy8gQ3JlYXRlIG9sZCBsYXllciBtYXBcbiAgICBjb25zdCBvbGRMYXllck1hcCA9IHt9O1xuICAgIGZvciAoY29uc3Qgb2xkTGF5ZXIgb2Ygb2xkTGF5ZXJzKSB7XG4gICAgICBpZiAob2xkTGF5ZXJNYXBbb2xkTGF5ZXIuaWRdKSB7XG4gICAgICAgIGxvZy5vbmNlKDAsIGBNdWx0aXBlIG9sZCBsYXllcnMgd2l0aCBzYW1lIGlkICR7bGF5ZXJOYW1lKG9sZExheWVyKX1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9sZExheWVyTWFwW29sZExheWVyLmlkXSA9IG9sZExheWVyO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFsbG9jYXRlIGFycmF5IGZvciBnZW5lcmF0ZWQgbGF5ZXJzXG4gICAgY29uc3QgZ2VuZXJhdGVkTGF5ZXJzID0gW107XG5cbiAgICAvLyBNYXRjaCBzdWJsYXllcnNcbiAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoU3VibGF5ZXJzKHtcbiAgICAgIG5ld0xheWVycywgb2xkTGF5ZXJNYXAsIGdlbmVyYXRlZExheWVyc1xuICAgIH0pO1xuXG4gICAgY29uc3QgZXJyb3IyID0gdGhpcy5fZmluYWxpemVPbGRMYXllcnMob2xkTGF5ZXJzKTtcbiAgICBjb25zdCBmaXJzdEVycm9yID0gZXJyb3IgfHwgZXJyb3IyO1xuICAgIHJldHVybiB7ZXJyb3I6IGZpcnN0RXJyb3IsIGdlbmVyYXRlZExheWVyc307XG4gIH1cblxuICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuICBfbWF0Y2hTdWJsYXllcnMoe25ld0xheWVycywgb2xkTGF5ZXJNYXAsIGdlbmVyYXRlZExheWVyc30pIHtcbiAgICAvLyBGaWx0ZXIgb3V0IGFueSBudWxsIGxheWVyc1xuICAgIG5ld0xheWVycyA9IG5ld0xheWVycy5maWx0ZXIobmV3TGF5ZXIgPT4gbmV3TGF5ZXIgIT09IG51bGwpO1xuXG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IG5ld0xheWVyIG9mIG5ld0xheWVycykge1xuICAgICAgbmV3TGF5ZXIuY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gMS4gZ2l2ZW4gYSBuZXcgY29taW5nIGxheWVyLCBmaW5kIGl0cyBtYXRjaGluZyBsYXllclxuICAgICAgICBjb25zdCBvbGRMYXllciA9IG9sZExheWVyTWFwW25ld0xheWVyLmlkXTtcbiAgICAgICAgb2xkTGF5ZXJNYXBbbmV3TGF5ZXIuaWRdID0gbnVsbDtcblxuICAgICAgICBpZiAob2xkTGF5ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBsb2cub25jZSgwLCBgTXVsdGlwZSBuZXcgbGF5ZXJzIHdpdGggc2FtZSBpZCAke2xheWVyTmFtZShuZXdMYXllcil9YCk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIE9ubHkgdHJhbnNmZXIgc3RhdGUgYXQgdGhpcyBzdGFnZS4gV2UgbXVzdCBub3QgZ2VuZXJhdGUgZXhjZXB0aW9uc1xuICAgICAgICAvLyB1bnRpbCBhbGwgbGF5ZXJzJyBzdGF0ZSBoYXZlIGJlZW4gdHJhbnNmZXJyZWRcbiAgICAgICAgaWYgKG9sZExheWVyKSB7XG4gICAgICAgICAgbG9nKDMsIGBtYXRjaGVkICR7bGF5ZXJOYW1lKG5ld0xheWVyKX1gLCBvbGRMYXllciwgJz0+JywgbmV3TGF5ZXIpO1xuICAgICAgICAgIHRoaXMuX3RyYW5zZmVyTGF5ZXJTdGF0ZShvbGRMYXllciwgbmV3TGF5ZXIpO1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZUxheWVyKG5ld0xheWVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9pbml0aWFsaXplTmV3TGF5ZXIobmV3TGF5ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGdlbmVyYXRlZExheWVycy5wdXNoKG5ld0xheWVyKTtcblxuICAgICAgICAvLyBDYWxsIGxheWVyIGxpZmVjeWNsZSBtZXRob2Q6IHJlbmRlciBzdWJsYXllcnNcbiAgICAgICAgbGV0IHN1YmxheWVycyA9IG5ld0xheWVyLnJlbmRlckxheWVycygpO1xuICAgICAgICAvLyBFbmQgbGF5ZXIgbGlmZWN5Y2xlIG1ldGhvZDogcmVuZGVyIHN1YmxheWVyc1xuXG4gICAgICAgIGlmIChzdWJsYXllcnMpIHtcbiAgICAgICAgICBzdWJsYXllcnMgPSBBcnJheS5pc0FycmF5KHN1YmxheWVycykgPyBzdWJsYXllcnMgOiBbc3VibGF5ZXJzXTtcbiAgICAgICAgICB0aGlzLl9tYXRjaFN1YmxheWVycyh7XG4gICAgICAgICAgICBuZXdMYXllcnM6IHN1YmxheWVycyxcbiAgICAgICAgICAgIG9sZExheWVyTWFwLFxuICAgICAgICAgICAgZ2VuZXJhdGVkTGF5ZXJzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2cub25jZSgwLFxuICAgICAgICAgIGBkZWNrLmdsIGVycm9yIGR1cmluZyBtYXRjaGluZyBvZiAke2xheWVyTmFtZShuZXdMYXllcil9ICR7ZXJyfWAsIGVycik7XG4gICAgICAgIC8vIFNhdmUgZmlyc3QgZXJyb3JcbiAgICAgICAgZXJyb3IgPSBlcnJvciB8fCBlcnI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuXG4gIF90cmFuc2ZlckxheWVyU3RhdGUob2xkTGF5ZXIsIG5ld0xheWVyKSB7XG4gICAgY29uc3Qge3N0YXRlLCBwcm9wc30gPSBvbGRMYXllcjtcblxuICAgIC8vIHNhbml0eSBjaGVja1xuICAgIGFzc2VydChzdGF0ZSwgJ2RlY2suZ2wgc2FuaXR5IGNoZWNrIC0gTWF0Y2hpbmcgbGF5ZXIgaGFzIG5vIHN0YXRlJyk7XG4gICAgYXNzZXJ0KG9sZExheWVyICE9PSBuZXdMYXllciwgJ2RlY2suZ2wgc2FuaXR5IGNoZWNrIC0gTWF0Y2hpbmcgbGF5ZXIgaXMgc2FtZScpO1xuXG4gICAgLy8gTW92ZSBzdGF0ZVxuICAgIG5ld0xheWVyLnN0YXRlID0gc3RhdGU7XG4gICAgc3RhdGUubGF5ZXIgPSBuZXdMYXllcjtcblxuICAgIC8vIFVwZGF0ZSBtb2RlbCBsYXllciByZWZlcmVuY2VcbiAgICBpZiAoc3RhdGUubW9kZWwpIHtcbiAgICAgIHN0YXRlLm1vZGVsLnVzZXJEYXRhLmxheWVyID0gbmV3TGF5ZXI7XG4gICAgfVxuICAgIC8vIEtlZXAgYSB0ZW1wb3JhcnkgcmVmIHRvIHRoZSBvbGQgcHJvcHMsIGZvciBwcm9wIGNvbXBhcmlzb25cbiAgICBuZXdMYXllci5vbGRQcm9wcyA9IHByb3BzO1xuICAgIG9sZExheWVyLnN0YXRlID0gbnVsbDtcbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgb2xkIGxheWVycyB0aGF0IHdlcmUgbm90IG1hdGNoZWRcbiAgX2ZpbmFsaXplT2xkTGF5ZXJzKG9sZExheWVycykge1xuICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgLy8gVW5tYXRjaGVkIGxheWVycyBzdGlsbCBoYXZlIHN0YXRlLCBpdCB3aWxsIGJlIGRpc2NhcmRlZFxuICAgIGZvciAoY29uc3QgbGF5ZXIgb2Ygb2xkTGF5ZXJzKSB7XG4gICAgICBpZiAobGF5ZXIuc3RhdGUpIHtcbiAgICAgICAgZXJyb3IgPSBlcnJvciB8fCB0aGlzLl9maW5hbGl6ZUxheWVyKGxheWVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZXMgYSBzaW5nbGUgbGF5ZXIsIGNhbGxpbmcgbGF5ZXIgbWV0aG9kc1xuICBfaW5pdGlhbGl6ZU5ld0xheWVyKGxheWVyKSB7XG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICAvLyBDaGVjayBpZiBuZXcgbGF5ZXIsIGFuZCBpbml0aWFsaXplIGl0J3Mgc3RhdGVcbiAgICBpZiAoIWxheWVyLnN0YXRlKSB7XG4gICAgICBsb2coMSwgYGluaXRpYWxpemluZyAke2xheWVyTmFtZShsYXllcil9YCk7XG4gICAgICB0cnkge1xuICAgICAgICBsYXllci5pbml0aWFsaXplTGF5ZXIoe1xuICAgICAgICAgIG9sZFByb3BzOiB7fSxcbiAgICAgICAgICBwcm9wczogbGF5ZXIucHJvcHMsXG4gICAgICAgICAgb2xkQ29udGV4dDogdGhpcy5vbGRDb250ZXh0LFxuICAgICAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgICAgICBjaGFuZ2VGbGFnczogbGF5ZXIuZGlmZlByb3BzKHt9LCBsYXllci5wcm9wcywgdGhpcy5jb250ZXh0KVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2cub25jZSgwLCBgZGVjay5nbCBlcnJvciBkdXJpbmcgaW5pdGlhbGl6YXRpb24gb2YgJHtsYXllck5hbWUobGF5ZXIpfSAke2Vycn1gLCBlcnIpO1xuICAgICAgICAvLyBTYXZlIGZpcnN0IGVycm9yXG4gICAgICAgIGVycm9yID0gZXJyb3IgfHwgZXJyO1xuICAgICAgfVxuICAgICAgLy8gU2V0IGJhY2sgcG9pbnRlciAodXNlZCBpbiBwaWNraW5nKVxuICAgICAgaWYgKGxheWVyLnN0YXRlKSB7XG4gICAgICAgIGxheWVyLnN0YXRlLmxheWVyID0gbGF5ZXI7XG4gICAgICAgIC8vIFNhdmUgbGF5ZXIgb24gbW9kZWwgZm9yIHBpY2tpbmcgcHVycG9zZXNcbiAgICAgICAgLy8gVE9ETyAtIHN0b3JlIG9uIG1vZGVsLnVzZXJEYXRhIHJhdGhlciB0aGFuIGRpcmVjdGx5IG9uIG1vZGVsXG4gICAgICB9XG4gICAgICBpZiAobGF5ZXIuc3RhdGUgJiYgbGF5ZXIuc3RhdGUubW9kZWwpIHtcbiAgICAgICAgbGF5ZXIuc3RhdGUubW9kZWwudXNlckRhdGEubGF5ZXIgPSBsYXllcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgLy8gVXBkYXRlcyBhIHNpbmdsZSBsYXllciwgY2FsbGluZyBsYXllciBtZXRob2RzXG4gIF91cGRhdGVMYXllcihsYXllcikge1xuICAgIGNvbnN0IHtvbGRQcm9wcywgcHJvcHN9ID0gbGF5ZXI7XG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICBpZiAob2xkUHJvcHMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxheWVyLnVwZGF0ZUxheWVyKHtcbiAgICAgICAgICBvbGRQcm9wcyxcbiAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHQsXG4gICAgICAgICAgb2xkQ29udGV4dDogdGhpcy5vbGRDb250ZXh0LFxuICAgICAgICAgIGNoYW5nZUZsYWdzOiBsYXllci5kaWZmUHJvcHMob2xkUHJvcHMsIGxheWVyLnByb3BzLCB0aGlzLmNvbnRleHQpXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZy5vbmNlKDAsIGBkZWNrLmdsIGVycm9yIGR1cmluZyB1cGRhdGUgb2YgJHtsYXllck5hbWUobGF5ZXIpfWAsIGVycik7XG4gICAgICAgIC8vIFNhdmUgZmlyc3QgZXJyb3JcbiAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICB9XG4gICAgICBsb2coMiwgYHVwZGF0aW5nICR7bGF5ZXJOYW1lKGxheWVyKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgLy8gRmluYWxpemVzIGEgc2luZ2xlIGxheWVyXG4gIF9maW5hbGl6ZUxheWVyKGxheWVyKSB7XG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICBjb25zdCB7c3RhdGV9ID0gbGF5ZXI7XG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsYXllci5maW5hbGl6ZUxheWVyKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nLm9uY2UoMCxcbiAgICAgICAgICBgZGVjay5nbCBlcnJvciBkdXJpbmcgZmluYWxpemF0aW9uIG9mICR7bGF5ZXJOYW1lKGxheWVyKX1gLCBlcnIpO1xuICAgICAgICAvLyBTYXZlIGZpcnN0IGVycm9yXG4gICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgfVxuICAgICAgbGF5ZXIuc3RhdGUgPSBudWxsO1xuICAgICAgbG9nKDEsIGBmaW5hbGl6aW5nICR7bGF5ZXJOYW1lKGxheWVyKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxheWVyTmFtZShsYXllcikge1xuICBpZiAobGF5ZXIgaW5zdGFuY2VvZiBMYXllcikge1xuICAgIHJldHVybiBgJHtsYXllcn1gO1xuICB9XG4gIHJldHVybiAhbGF5ZXIgPyAnbnVsbCBsYXllcicgOiAnaW52YWxpZCBsYXllcic7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9saWIvbGF5ZXItbWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 98 */
/* exports provided: getBlendMode, setBlendMode */
/* exports used: getBlendMode, setBlendMode */
/*!********************************!*\
  !*** ./src/lib/utils/blend.js ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (immutable) */ __webpack_exports__[\"a\"] = getBlendMode;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = setBlendMode;\n// get current blending settings\nfunction getBlendMode(gl) {\n  return {\n    enabled: gl.getParameter(gl.BLEND),\n    equationRGB: gl.getParameter(gl.BLEND_EQUATION_RGB),\n    equationAlpha: gl.getParameter(gl.BLEND_EQUATION_ALPHA),\n    srcRGB: gl.getParameter(gl.BLEND_SRC_RGB),\n    dstRGB: gl.getParameter(gl.BLEND_DST_RGB),\n    srcAlpha: gl.getParameter(gl.BLEND_SRC_ALPHA),\n    dstAlpha: gl.getParameter(gl.BLEND_DST_ALPHA)\n  };\n}\n\n// apply blending settings\nfunction setBlendMode(gl, settings) {\n  if (settings.enabled) {\n    gl.enable(gl.BLEND);\n  } else {\n    gl.disable(gl.BLEND);\n  }\n  gl.blendEquationSeparate(settings.equationRGB, settings.equationAlpha);\n  gl.blendFuncSeparate(settings.srcRGB, settings.dstRGB, settings.srcAlpha, settings.dstAlpha);\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL3V0aWxzL2JsZW5kLmpzPzQ1YzUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZ2V0IGN1cnJlbnQgYmxlbmRpbmcgc2V0dGluZ3NcbmV4cG9ydCBmdW5jdGlvbiBnZXRCbGVuZE1vZGUoZ2wpIHtcbiAgcmV0dXJuIHtcbiAgICBlbmFibGVkOiBnbC5nZXRQYXJhbWV0ZXIoZ2wuQkxFTkQpLFxuICAgIGVxdWF0aW9uUkdCOiBnbC5nZXRQYXJhbWV0ZXIoZ2wuQkxFTkRfRVFVQVRJT05fUkdCKSxcbiAgICBlcXVhdGlvbkFscGhhOiBnbC5nZXRQYXJhbWV0ZXIoZ2wuQkxFTkRfRVFVQVRJT05fQUxQSEEpLFxuICAgIHNyY1JHQjogZ2wuZ2V0UGFyYW1ldGVyKGdsLkJMRU5EX1NSQ19SR0IpLFxuICAgIGRzdFJHQjogZ2wuZ2V0UGFyYW1ldGVyKGdsLkJMRU5EX0RTVF9SR0IpLFxuICAgIHNyY0FscGhhOiBnbC5nZXRQYXJhbWV0ZXIoZ2wuQkxFTkRfU1JDX0FMUEhBKSxcbiAgICBkc3RBbHBoYTogZ2wuZ2V0UGFyYW1ldGVyKGdsLkJMRU5EX0RTVF9BTFBIQSlcbiAgfTtcbn1cblxuLy8gYXBwbHkgYmxlbmRpbmcgc2V0dGluZ3NcbmV4cG9ydCBmdW5jdGlvbiBzZXRCbGVuZE1vZGUoZ2wsIHNldHRpbmdzKSB7XG4gIGlmIChzZXR0aW5ncy5lbmFibGVkKSB7XG4gICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgfSBlbHNlIHtcbiAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcbiAgfVxuICBnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoc2V0dGluZ3MuZXF1YXRpb25SR0IsIHNldHRpbmdzLmVxdWF0aW9uQWxwaGEpO1xuICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShzZXR0aW5ncy5zcmNSR0IsIHNldHRpbmdzLmRzdFJHQiwgc2V0dGluZ3Muc3JjQWxwaGEsIHNldHRpbmdzLmRzdEFscGhhKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xpYi91dGlscy9ibGVuZC5qc1xuLy8gbW9kdWxlIGlkID0gOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 99 */
/* exports provided: parseColor, parseHexColor, setOpacity, applyOpacity */
/*!********************************!*\
  !*** ./src/lib/utils/color.js ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* unused harmony export parseColor */\n/* unused harmony export parseHexColor */\n/* unused harmony export setOpacity */\n/* unused harmony export applyOpacity */\n\n// Parse array or string color\nfunction parseColor(color) {\n  if (Array.isArray(color)) {\n    if (color.length === 3) {\n      return [color[0], color[1], color[2], 255];\n    }\n    return color;\n  }\n  if (typeof color === 'string') {\n    return parseHexColor(color);\n  }\n  return null;\n}\n\n// Parse a hex color\nfunction parseHexColor(color) {\n  const array = new Uint8ClampedArray(4);\n  if (color.length === 7) {\n    const value = parseInt(color.substring(1), 16);\n    array[0] = value / 65536;\n    array[1] = (value / 256) % 256;\n    array[2] = value % 256;\n    array[3] = 255;\n  } else if (color.length === 9) {\n    const value = parseInt(color.substring(1), 16);\n    array[0] = value / 16777216;\n    array[1] = (value / 65536) % 256;\n    array[2] = (value / 256) % 256;\n    array[3] = value % 256;\n  }\n  return array;\n}\n\nfunction setOpacity(color, opacity = 127) {\n  return [color[0], color[1], color[2], opacity];\n}\n\nfunction applyOpacity(color, opacity = 127) {\n  return [color[0], color[1], color[2], opacity];\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL3V0aWxzL2NvbG9yLmpzP2U4MmIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vLyBQYXJzZSBhcnJheSBvciBzdHJpbmcgY29sb3JcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNvbG9yKGNvbG9yKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbG9yKSkge1xuICAgIGlmIChjb2xvci5sZW5ndGggPT09IDMpIHtcbiAgICAgIHJldHVybiBbY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgMjU1XTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG4gIGlmICh0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlSGV4Q29sb3IoY29sb3IpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBQYXJzZSBhIGhleCBjb2xvclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSGV4Q29sb3IoY29sb3IpIHtcbiAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoNCk7XG4gIGlmIChjb2xvci5sZW5ndGggPT09IDcpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHBhcnNlSW50KGNvbG9yLnN1YnN0cmluZygxKSwgMTYpO1xuICAgIGFycmF5WzBdID0gdmFsdWUgLyA2NTUzNjtcbiAgICBhcnJheVsxXSA9ICh2YWx1ZSAvIDI1NikgJSAyNTY7XG4gICAgYXJyYXlbMl0gPSB2YWx1ZSAlIDI1NjtcbiAgICBhcnJheVszXSA9IDI1NTtcbiAgfSBlbHNlIGlmIChjb2xvci5sZW5ndGggPT09IDkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHBhcnNlSW50KGNvbG9yLnN1YnN0cmluZygxKSwgMTYpO1xuICAgIGFycmF5WzBdID0gdmFsdWUgLyAxNjc3NzIxNjtcbiAgICBhcnJheVsxXSA9ICh2YWx1ZSAvIDY1NTM2KSAlIDI1NjtcbiAgICBhcnJheVsyXSA9ICh2YWx1ZSAvIDI1NikgJSAyNTY7XG4gICAgYXJyYXlbM10gPSB2YWx1ZSAlIDI1NjtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRPcGFjaXR5KGNvbG9yLCBvcGFjaXR5ID0gMTI3KSB7XG4gIHJldHVybiBbY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgb3BhY2l0eV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseU9wYWNpdHkoY29sb3IsIG9wYWNpdHkgPSAxMjcpIHtcbiAgcmV0dXJuIFtjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5XTtcbn1cblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGliL3V0aWxzL2NvbG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 100 */
/* exports provided: compareArrays, checkArray */
/*!*****************************************!*\
  !*** ./src/lib/utils/compare-arrays.js ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* unused harmony export compareArrays */\n/* unused harmony export checkArray */\nfunction compareArrays(array1, array2) {\n\n  const length = Math.min(array1.length, array2.length);\n  for (let i = 0; i < length; ++i) {\n    if (array1[i] !== array2[i]) {\n      return `Arrays are different in element ${i}: ${array1[i]} vs ${array2[i]}`;\n    }\n  }\n\n  if (array1.length !== array2.length) {\n    return `Arrays have different length ${array1.length} vs ${array2.length}`;\n  }\n\n  return null;\n}\n\nfunction checkArray(array) {\n  for (let i = 0; i < array.length; ++i) {\n    if (!Number.isFinite(array[i])) {\n      throw new Error(`Array has invalid element ${i}: ${array[i]}`);\n    }\n  }\n  return null;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi91dGlscy9jb21wYXJlLWFycmF5cy5qcz9hMDE4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBjb21wYXJlQXJyYXlzKGFycmF5MSwgYXJyYXkyKSB7XG5cbiAgY29uc3QgbGVuZ3RoID0gTWF0aC5taW4oYXJyYXkxLmxlbmd0aCwgYXJyYXkyLmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pIHtcbiAgICAgIHJldHVybiBgQXJyYXlzIGFyZSBkaWZmZXJlbnQgaW4gZWxlbWVudCAke2l9OiAke2FycmF5MVtpXX0gdnMgJHthcnJheTJbaV19YDtcbiAgICB9XG4gIH1cblxuICBpZiAoYXJyYXkxLmxlbmd0aCAhPT0gYXJyYXkyLmxlbmd0aCkge1xuICAgIHJldHVybiBgQXJyYXlzIGhhdmUgZGlmZmVyZW50IGxlbmd0aCAke2FycmF5MS5sZW5ndGh9IHZzICR7YXJyYXkyLmxlbmd0aH1gO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0FycmF5KGFycmF5KSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShhcnJheVtpXSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXJyYXkgaGFzIGludmFsaWQgZWxlbWVudCAke2l9OiAke2FycmF5W2ldfWApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xpYi91dGlscy9jb21wYXJlLWFycmF5cy5qc1xuLy8gbW9kdWxlIGlkID0gMTAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 101 */
/* exports provided: compareProps, areEqualShallow */
/* exports used: compareProps */
/*!******************************************!*\
  !*** ./src/lib/utils/compare-objects.js ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_assert__ = __webpack_require__(/*! assert */ 6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_assert__);\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = compareProps;\n/* unused harmony export areEqualShallow */\n\n\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * @param {Object} opt.oldProps - object with old key/value pairs\n * @param {Object} opt.newProps - object with new key/value pairs\n * @param {Object} opt.ignoreProps={} - object, keys that should not be compared\n * @returns {null|String} - null when values of all keys are strictly equal.\n *   if unequal, returns a string explaining what changed.\n */\n/* eslint-disable max-statements, complexity */\nfunction compareProps({oldProps, newProps, ignoreProps = {}} = {}) {\n  __WEBPACK_IMPORTED_MODULE_0_assert___default()(oldProps !== undefined && newProps !== undefined, 'compareProps args');\n\n  if (oldProps === newProps) {\n    return null;\n  }\n\n  if (typeof oldProps !== 'object' || oldProps === null) {\n    return 'old props is not an object';\n  }\n  if (typeof newProps !== 'object' || newProps === null) {\n    return 'new props is not an object';\n  }\n\n  // Test if new props different from old props\n  for (const key in oldProps) {\n    if (!(key in ignoreProps)) {\n      if (!newProps.hasOwnProperty(key)) {\n        return `prop ${key} dropped: ${oldProps[key]} -> (undefined)`;\n      } else if (oldProps[key] !== newProps[key]) {\n        return `prop ${key} changed: ${oldProps[key]} -> ${newProps[key]}`;\n      }\n    }\n  }\n\n  // Test if any new props have been added\n  for (const key in newProps) {\n    if (!(key in ignoreProps)) {\n      if (!oldProps.hasOwnProperty(key)) {\n        return `prop ${key} added: (undefined) -> ${newProps[key]}`;\n      }\n    }\n  }\n\n  return null;\n}\n/* eslint-enable max-statements, complexity */\n\n// Shallow compare\n/* eslint-disable complexity */\nfunction areEqualShallow(a, b, {ignore = {}} = {}) {\n\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== 'object' || a === null ||\n    typeof b !== 'object' || b === null) {\n    return false;\n  }\n\n  if (Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n\n  for (const key in a) {\n    if (!(key in ignore) && (!(key in b) || a[key] !== b[key])) {\n      return false;\n    }\n  }\n  for (const key in b) {\n    if (!(key in ignore) && (!(key in a))) {\n      return false;\n    }\n  }\n  return true;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi91dGlscy9jb21wYXJlLW9iamVjdHMuanM/ZDNiMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbi8qKlxuICogUGVyZm9ybXMgZXF1YWxpdHkgYnkgaXRlcmF0aW5nIHRocm91Z2gga2V5cyBvbiBhbiBvYmplY3QgYW5kIHJldHVybmluZyBmYWxzZVxuICogd2hlbiBhbnkga2V5IGhhcyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBzdHJpY3RseSBlcXVhbCBiZXR3ZWVuIHRoZSBhcmd1bWVudHMuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0Lm9sZFByb3BzIC0gb2JqZWN0IHdpdGggb2xkIGtleS92YWx1ZSBwYWlyc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdC5uZXdQcm9wcyAtIG9iamVjdCB3aXRoIG5ldyBrZXkvdmFsdWUgcGFpcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHQuaWdub3JlUHJvcHM9e30gLSBvYmplY3QsIGtleXMgdGhhdCBzaG91bGQgbm90IGJlIGNvbXBhcmVkXG4gKiBAcmV0dXJucyB7bnVsbHxTdHJpbmd9IC0gbnVsbCB3aGVuIHZhbHVlcyBvZiBhbGwga2V5cyBhcmUgc3RyaWN0bHkgZXF1YWwuXG4gKiAgIGlmIHVuZXF1YWwsIHJldHVybnMgYSBzdHJpbmcgZXhwbGFpbmluZyB3aGF0IGNoYW5nZWQuXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1zdGF0ZW1lbnRzLCBjb21wbGV4aXR5ICovXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZVByb3BzKHtvbGRQcm9wcywgbmV3UHJvcHMsIGlnbm9yZVByb3BzID0ge319ID0ge30pIHtcbiAgYXNzZXJ0KG9sZFByb3BzICE9PSB1bmRlZmluZWQgJiYgbmV3UHJvcHMgIT09IHVuZGVmaW5lZCwgJ2NvbXBhcmVQcm9wcyBhcmdzJyk7XG5cbiAgaWYgKG9sZFByb3BzID09PSBuZXdQcm9wcykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvbGRQcm9wcyAhPT0gJ29iamVjdCcgfHwgb2xkUHJvcHMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ29sZCBwcm9wcyBpcyBub3QgYW4gb2JqZWN0JztcbiAgfVxuICBpZiAodHlwZW9mIG5ld1Byb3BzICE9PSAnb2JqZWN0JyB8fCBuZXdQcm9wcyA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnbmV3IHByb3BzIGlzIG5vdCBhbiBvYmplY3QnO1xuICB9XG5cbiAgLy8gVGVzdCBpZiBuZXcgcHJvcHMgZGlmZmVyZW50IGZyb20gb2xkIHByb3BzXG4gIGZvciAoY29uc3Qga2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKCEoa2V5IGluIGlnbm9yZVByb3BzKSkge1xuICAgICAgaWYgKCFuZXdQcm9wcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHJldHVybiBgcHJvcCAke2tleX0gZHJvcHBlZDogJHtvbGRQcm9wc1trZXldfSAtPiAodW5kZWZpbmVkKWA7XG4gICAgICB9IGVsc2UgaWYgKG9sZFByb3BzW2tleV0gIT09IG5ld1Byb3BzW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIGBwcm9wICR7a2V5fSBjaGFuZ2VkOiAke29sZFByb3BzW2tleV19IC0+ICR7bmV3UHJvcHNba2V5XX1gO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFRlc3QgaWYgYW55IG5ldyBwcm9wcyBoYXZlIGJlZW4gYWRkZWRcbiAgZm9yIChjb25zdCBrZXkgaW4gbmV3UHJvcHMpIHtcbiAgICBpZiAoIShrZXkgaW4gaWdub3JlUHJvcHMpKSB7XG4gICAgICBpZiAoIW9sZFByb3BzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGBwcm9wICR7a2V5fSBhZGRlZDogKHVuZGVmaW5lZCkgLT4gJHtuZXdQcm9wc1trZXldfWA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1zdGF0ZW1lbnRzLCBjb21wbGV4aXR5ICovXG5cbi8vIFNoYWxsb3cgY29tcGFyZVxuLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFyZUVxdWFsU2hhbGxvdyhhLCBiLCB7aWdub3JlID0ge319ID0ge30pIHtcblxuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhICE9PSAnb2JqZWN0JyB8fCBhID09PSBudWxsIHx8XG4gICAgdHlwZW9mIGIgIT09ICdvYmplY3QnIHx8IGIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXMoYSkubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGNvbnN0IGtleSBpbiBhKSB7XG4gICAgaWYgKCEoa2V5IGluIGlnbm9yZSkgJiYgKCEoa2V5IGluIGIpIHx8IGFba2V5XSAhPT0gYltrZXldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBiKSB7XG4gICAgaWYgKCEoa2V5IGluIGlnbm9yZSkgJiYgKCEoa2V5IGluIGEpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xpYi91dGlscy9jb21wYXJlLW9iamVjdHMuanNcbi8vIG1vZHVsZSBpZCA9IDEwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 102 */
/* exports provided: flatten, countVertices, flattenVertices, fillArray */
/* exports used: flatten, flattenVertices, fillArray */
/*!**********************************!*\
  !*** ./src/lib/utils/flatten.js ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (immutable) */ __webpack_exports__[\"a\"] = flatten;\n/* unused harmony export countVertices */\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = flattenVertices;\n/* harmony export (immutable) */ __webpack_exports__[\"c\"] = fillArray;\n/**\n * Flattens a nested array into a single level array\n * @example flatten([[1, [2]], [3], 4]) => [1, 2, 3, 4]\n * @param {Array} array The array to flatten.\n * @return {Array} Returns the new flattened array.\n */\nfunction flatten(array, result = []) {\n  let index = -1;\n  while (++index < array.length) {\n    const value = array[index];\n    if (Array.isArray(value)) {\n      flatten(value, result);\n    } else {\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nfunction countVertices(nestedArray) {\n  let count = 0;\n  let index = -1;\n  while (++index < nestedArray.length) {\n    const value = nestedArray[index];\n    if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n      count += countVertices(value);\n    } else {\n      count++;\n    }\n  }\n  return count;\n}\n\n// Flattens nested array of vertices, padding third coordinate as needed\nfunction flattenVertices(nestedArray, {result = [], dimensions = 3} = {}) {\n  let index = -1;\n  let vertexLength = 0;\n  while (++index < nestedArray.length) {\n    const value = nestedArray[index];\n    if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n      flattenVertices(value, {result, dimensions});\n    } else {\n      if (vertexLength < dimensions) { // eslint-disable-line\n        result.push(value);\n        vertexLength++;\n      }\n    }\n  }\n  // Add a third coordinate if needed\n  if (vertexLength > 0 && vertexLength < dimensions) {\n    result.push(0);\n  }\n  return result;\n}\n\n// Uses copyWithin to significantly speed up typed array value filling\nfunction fillArray({target, source, start = 0, count = 1}) {\n  const total = count * source.length;\n  let copied = 0;\n  for (let i = 0; i < source.length; ++i) {\n    target[start + copied++] = source[i];\n  }\n\n  while (copied < total) {\n    // If we have copied less than half, copy everything we got\n    // else copy remaining in one operation\n    if (copied < total - copied) {\n      target.copyWithin(start + copied, start, start + copied);\n      copied *= 2;\n    } else {\n      target.copyWithin(start + copied, start, start + total - copied);\n      copied = total;\n    }\n  }\n\n  return target;\n}\n\n// Flattens nested array of vertices, padding third coordinate as needed\n/*\nexport function flattenTypedVertices(nestedArray, {\n  result = [],\n  Type = Float32Array,\n  start = 0,\n  dimensions = 3\n} = {}) {\n  let index = -1;\n  let vertexLength = 0;\n  while (++index < nestedArray.length) {\n    const value = nestedArray[index];\n    if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n      start = flattenTypedVertices(value, {result, start, dimensions});\n    } else {\n      if (vertexLength < dimensions) { // eslint-disable-line\n        result[start++] = value;\n        vertexLength++;\n      }\n    }\n  }\n  // Add a third coordinate if needed\n  if (vertexLength > 0 && vertexLength < dimensions) {\n    result[start++] = 0;\n  }\n  return start;\n}\n*/\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi91dGlscy9mbGF0dGVuLmpzPzliZDkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBGbGF0dGVucyBhIG5lc3RlZCBhcnJheSBpbnRvIGEgc2luZ2xlIGxldmVsIGFycmF5XG4gKiBAZXhhbXBsZSBmbGF0dGVuKFtbMSwgWzJdXSwgWzNdLCA0XSkgPT4gWzEsIDIsIDMsIDRdXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmxhdHRlbihhcnJheSwgcmVzdWx0ID0gW10pIHtcbiAgbGV0IGluZGV4ID0gLTE7XG4gIHdoaWxlICgrK2luZGV4IDwgYXJyYXkubGVuZ3RoKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBmbGF0dGVuKHZhbHVlLCByZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3VudFZlcnRpY2VzKG5lc3RlZEFycmF5KSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGxldCBpbmRleCA9IC0xO1xuICB3aGlsZSAoKytpbmRleCA8IG5lc3RlZEFycmF5Lmxlbmd0aCkge1xuICAgIGNvbnN0IHZhbHVlID0gbmVzdGVkQXJyYXlbaW5kZXhdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgICBjb3VudCArPSBjb3VudFZlcnRpY2VzKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufVxuXG4vLyBGbGF0dGVucyBuZXN0ZWQgYXJyYXkgb2YgdmVydGljZXMsIHBhZGRpbmcgdGhpcmQgY29vcmRpbmF0ZSBhcyBuZWVkZWRcbmV4cG9ydCBmdW5jdGlvbiBmbGF0dGVuVmVydGljZXMobmVzdGVkQXJyYXksIHtyZXN1bHQgPSBbXSwgZGltZW5zaW9ucyA9IDN9ID0ge30pIHtcbiAgbGV0IGluZGV4ID0gLTE7XG4gIGxldCB2ZXJ0ZXhMZW5ndGggPSAwO1xuICB3aGlsZSAoKytpbmRleCA8IG5lc3RlZEFycmF5Lmxlbmd0aCkge1xuICAgIGNvbnN0IHZhbHVlID0gbmVzdGVkQXJyYXlbaW5kZXhdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgICBmbGF0dGVuVmVydGljZXModmFsdWUsIHtyZXN1bHQsIGRpbWVuc2lvbnN9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZlcnRleExlbmd0aCA8IGRpbWVuc2lvbnMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIHZlcnRleExlbmd0aCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBBZGQgYSB0aGlyZCBjb29yZGluYXRlIGlmIG5lZWRlZFxuICBpZiAodmVydGV4TGVuZ3RoID4gMCAmJiB2ZXJ0ZXhMZW5ndGggPCBkaW1lbnNpb25zKSB7XG4gICAgcmVzdWx0LnB1c2goMCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gVXNlcyBjb3B5V2l0aGluIHRvIHNpZ25pZmljYW50bHkgc3BlZWQgdXAgdHlwZWQgYXJyYXkgdmFsdWUgZmlsbGluZ1xuZXhwb3J0IGZ1bmN0aW9uIGZpbGxBcnJheSh7dGFyZ2V0LCBzb3VyY2UsIHN0YXJ0ID0gMCwgY291bnQgPSAxfSkge1xuICBjb25zdCB0b3RhbCA9IGNvdW50ICogc291cmNlLmxlbmd0aDtcbiAgbGV0IGNvcGllZCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgKytpKSB7XG4gICAgdGFyZ2V0W3N0YXJ0ICsgY29waWVkKytdID0gc291cmNlW2ldO1xuICB9XG5cbiAgd2hpbGUgKGNvcGllZCA8IHRvdGFsKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBjb3BpZWQgbGVzcyB0aGFuIGhhbGYsIGNvcHkgZXZlcnl0aGluZyB3ZSBnb3RcbiAgICAvLyBlbHNlIGNvcHkgcmVtYWluaW5nIGluIG9uZSBvcGVyYXRpb25cbiAgICBpZiAoY29waWVkIDwgdG90YWwgLSBjb3BpZWQpIHtcbiAgICAgIHRhcmdldC5jb3B5V2l0aGluKHN0YXJ0ICsgY29waWVkLCBzdGFydCwgc3RhcnQgKyBjb3BpZWQpO1xuICAgICAgY29waWVkICo9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldC5jb3B5V2l0aGluKHN0YXJ0ICsgY29waWVkLCBzdGFydCwgc3RhcnQgKyB0b3RhbCAtIGNvcGllZCk7XG4gICAgICBjb3BpZWQgPSB0b3RhbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vLyBGbGF0dGVucyBuZXN0ZWQgYXJyYXkgb2YgdmVydGljZXMsIHBhZGRpbmcgdGhpcmQgY29vcmRpbmF0ZSBhcyBuZWVkZWRcbi8qXG5leHBvcnQgZnVuY3Rpb24gZmxhdHRlblR5cGVkVmVydGljZXMobmVzdGVkQXJyYXksIHtcbiAgcmVzdWx0ID0gW10sXG4gIFR5cGUgPSBGbG9hdDMyQXJyYXksXG4gIHN0YXJ0ID0gMCxcbiAgZGltZW5zaW9ucyA9IDNcbn0gPSB7fSkge1xuICBsZXQgaW5kZXggPSAtMTtcbiAgbGV0IHZlcnRleExlbmd0aCA9IDA7XG4gIHdoaWxlICgrK2luZGV4IDwgbmVzdGVkQXJyYXkubGVuZ3RoKSB7XG4gICAgY29uc3QgdmFsdWUgPSBuZXN0ZWRBcnJheVtpbmRleF07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICAgIHN0YXJ0ID0gZmxhdHRlblR5cGVkVmVydGljZXModmFsdWUsIHtyZXN1bHQsIHN0YXJ0LCBkaW1lbnNpb25zfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2ZXJ0ZXhMZW5ndGggPCBkaW1lbnNpb25zKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgcmVzdWx0W3N0YXJ0KytdID0gdmFsdWU7XG4gICAgICAgIHZlcnRleExlbmd0aCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBBZGQgYSB0aGlyZCBjb29yZGluYXRlIGlmIG5lZWRlZFxuICBpZiAodmVydGV4TGVuZ3RoID4gMCAmJiB2ZXJ0ZXhMZW5ndGggPCBkaW1lbnNpb25zKSB7XG4gICAgcmVzdWx0W3N0YXJ0KytdID0gMDtcbiAgfVxuICByZXR1cm4gc3RhcnQ7XG59XG4qL1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGliL3V0aWxzL2ZsYXR0ZW4uanNcbi8vIG1vZHVsZSBpZCA9IDEwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 103 */
/* unknown exports provided */
/* exports used: global */
/*!**********************************!*\
  !*** ./src/lib/utils/globals.js ***!
  \**********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {/* global window, global, document */\nmodule.exports = {\n  window: typeof window !== 'undefined' ? window : global,\n  global: typeof global !== 'undefined' ? global : window,\n  document: typeof document !== 'undefined' ? document : {}\n};\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../../../~/webpack/buildin/global.js */ 46)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi91dGlscy9nbG9iYWxzLmpzPzYyZmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIHdpbmRvdywgZ2xvYmFsLCBkb2N1bWVudCAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHdpbmRvdzogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwsXG4gIGdsb2JhbDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB3aW5kb3csXG4gIGRvY3VtZW50OiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiB7fVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xpYi91dGlscy9nbG9iYWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 104 */
/* exports provided: getUniformsFromViewport */
/* exports used: getUniformsFromViewport */
/*!**************************************!*\
  !*** ./src/lib/viewport-uniforms.js ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl__ = __webpack_require__(/*! luma.gl */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_assert__ = __webpack_require__(/*! assert */ 6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_assert__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constants__ = __webpack_require__(/*! ./constants */ 14);\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = getUniformsFromViewport;\n/* global window */\n\n\n\n\n\nfunction fp64ify(a) {\n  const hiPart = Math.fround(a);\n  const loPart = a - Math.fround(a);\n  return [hiPart, loPart];\n}\n\n// To quickly set a vector to zero\nconst ZERO_VECTOR = [0, 0, 0, 0];\n// 4x4 matrix that drops 4th component of vector\nconst VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];\n\nfunction calculateMatrixAndOffset({\n  projectionMode,\n  positionOrigin,\n  viewport,\n  modelMatrix\n}) {\n  const {viewMatrixUncentered, viewMatrix, projectionMatrix} = viewport;\n\n  let projectionCenter;\n  let modelViewMatrix;\n\n  switch (projectionMode) {\n\n  case __WEBPACK_IMPORTED_MODULE_2__constants__[\"a\" /* COORDINATE_SYSTEM */].IDENTITY:\n  case __WEBPACK_IMPORTED_MODULE_2__constants__[\"a\" /* COORDINATE_SYSTEM */].LNGLAT:\n    projectionCenter = ZERO_VECTOR;\n    modelViewMatrix = new __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"Matrix4\"](viewMatrix);\n    break;\n\n  // TODO: make lighitng work for meter offset mode\n  case __WEBPACK_IMPORTED_MODULE_2__constants__[\"a\" /* COORDINATE_SYSTEM */].METER_OFFSETS:\n    // Calculate transformed projectionCenter (in 64 bit precision)\n    // This is the key to offset mode precision (avoids doing this\n    // addition in 32 bit precision)\n    const positionPixels = viewport.projectFlat(positionOrigin);\n    const viewProjectionMatrix = new __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"Matrix4\"](projectionMatrix).multiplyRight(viewMatrix);\n    projectionCenter = viewProjectionMatrix\n      .transformVector([positionPixels[0], positionPixels[1], 0.0, 1.0]);\n\n    // Always apply uncentered projection matrix (shader adds center)\n    modelViewMatrix = new __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"Matrix4\"](viewMatrixUncentered)\n      // Zero out 4th coordinate (\"after\" model matrix) - avoids further translations\n      .multiplyRight(VECTOR_TO_POINT_MATRIX);\n    break;\n\n  default:\n    throw new Error('Unknown projection mode');\n  }\n\n  const viewMatrixInv = modelViewMatrix.clone().invert();\n\n  if (modelMatrix) {\n    // Apply model matrix if supplied\n    modelViewMatrix.multiplyRight(modelMatrix);\n  }\n\n  const modelViewProjectionMatrix = new __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"Matrix4\"](projectionMatrix).multiplyRight(modelViewMatrix);\n  const cameraPos = [viewMatrixInv[12], viewMatrixInv[13], viewMatrixInv[14]];\n\n  return {\n    modelViewMatrix,\n    modelViewProjectionMatrix,\n    projectionCenter,\n    cameraPos\n  };\n}\n\n/**\n * Returns uniforms for shaders based on current projection\n * includes: projection matrix suitable for shaders\n *\n * TODO - Ensure this works with any viewport, not just WebMercatorViewports\n *\n * @param {WebMercatorViewport} viewport -\n * @return {Float32Array} - 4x4 projection matrix that can be used in shaders\n */\nfunction getUniformsFromViewport(viewport, {\n  modelMatrix = null,\n  projectionMode = __WEBPACK_IMPORTED_MODULE_2__constants__[\"a\" /* COORDINATE_SYSTEM */].LNGLAT,\n  positionOrigin = [0, 0]\n} = {}) {\n  __WEBPACK_IMPORTED_MODULE_1_assert___default()(viewport.scale, 'Viewport scale missing');\n\n  const {projectionCenter, modelViewMatrix, modelViewProjectionMatrix, cameraPos} =\n    calculateMatrixAndOffset({projectionMode, positionOrigin, modelMatrix, viewport});\n\n  __WEBPACK_IMPORTED_MODULE_1_assert___default()(modelViewProjectionMatrix, 'Viewport missing modelViewProjectionMatrix');\n\n  // Calculate projection pixels per unit\n  const projectionPixelsPerUnit = viewport.getDistanceScales().pixelsPerMeter;\n  __WEBPACK_IMPORTED_MODULE_1_assert___default()(projectionPixelsPerUnit, 'Viewport missing pixelsPerMeter');\n\n  // calculate WebGL matrices\n\n  // Convert to Float32\n  const glProjectionMatrix = new Float32Array(modelViewProjectionMatrix);\n\n  // \"Float64Array\"\n  // Transpose the projection matrix to column major for GLSL.\n  const glProjectionMatrixFP64 = new Float32Array(32);\n  for (let i = 0; i < 4; ++i) {\n    for (let j = 0; j < 4; ++j) {\n      [\n        glProjectionMatrixFP64[(i * 4 + j) * 2],\n        glProjectionMatrixFP64[(i * 4 + j) * 2 + 1]\n      ] = fp64ify(modelViewProjectionMatrix[j * 4 + i]);\n    }\n  }\n\n  const devicePixelRatio = (window && window.devicePixelRatio) || 1;\n\n  return {\n    // Projection mode values\n    projectionMode,\n    projectionCenter,\n\n    // modelMatrix: modelMatrix || new Matrix4().identity(),\n    modelViewMatrix,\n\n    // Screen size\n    viewportSize: [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio],\n    devicePixelRatio,\n\n    // Main projection matrices\n    projectionMatrix: glProjectionMatrix,\n    projectionMatrixUncentered: glProjectionMatrix,\n    projectionFP64: glProjectionMatrixFP64,\n    projectionPixelsPerUnit,\n\n    // This is the mercator scale (2 ** zoom)\n    projectionScale: viewport.scale,\n\n    // Deprecated?\n    projectionScaleFP64: fp64ify(viewport.scale),\n\n    // This is for lighting calculations\n    cameraPos: new Float32Array(cameraPos)\n\n  };\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi92aWV3cG9ydC11bmlmb3Jtcy5qcz9lZWQxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbCB3aW5kb3cgKi9cbmltcG9ydCB7TWF0cml4NH0gZnJvbSAnbHVtYS5nbCc7XG5cbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCB7Q09PUkRJTkFURV9TWVNURU19IGZyb20gJy4vY29uc3RhbnRzJztcblxuZnVuY3Rpb24gZnA2NGlmeShhKSB7XG4gIGNvbnN0IGhpUGFydCA9IE1hdGguZnJvdW5kKGEpO1xuICBjb25zdCBsb1BhcnQgPSBhIC0gTWF0aC5mcm91bmQoYSk7XG4gIHJldHVybiBbaGlQYXJ0LCBsb1BhcnRdO1xufVxuXG4vLyBUbyBxdWlja2x5IHNldCBhIHZlY3RvciB0byB6ZXJvXG5jb25zdCBaRVJPX1ZFQ1RPUiA9IFswLCAwLCAwLCAwXTtcbi8vIDR4NCBtYXRyaXggdGhhdCBkcm9wcyA0dGggY29tcG9uZW50IG9mIHZlY3RvclxuY29uc3QgVkVDVE9SX1RPX1BPSU5UX01BVFJJWCA9IFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwXTtcblxuZnVuY3Rpb24gY2FsY3VsYXRlTWF0cml4QW5kT2Zmc2V0KHtcbiAgcHJvamVjdGlvbk1vZGUsXG4gIHBvc2l0aW9uT3JpZ2luLFxuICB2aWV3cG9ydCxcbiAgbW9kZWxNYXRyaXhcbn0pIHtcbiAgY29uc3Qge3ZpZXdNYXRyaXhVbmNlbnRlcmVkLCB2aWV3TWF0cml4LCBwcm9qZWN0aW9uTWF0cml4fSA9IHZpZXdwb3J0O1xuXG4gIGxldCBwcm9qZWN0aW9uQ2VudGVyO1xuICBsZXQgbW9kZWxWaWV3TWF0cml4O1xuXG4gIHN3aXRjaCAocHJvamVjdGlvbk1vZGUpIHtcblxuICBjYXNlIENPT1JESU5BVEVfU1lTVEVNLklERU5USVRZOlxuICBjYXNlIENPT1JESU5BVEVfU1lTVEVNLkxOR0xBVDpcbiAgICBwcm9qZWN0aW9uQ2VudGVyID0gWkVST19WRUNUT1I7XG4gICAgbW9kZWxWaWV3TWF0cml4ID0gbmV3IE1hdHJpeDQodmlld01hdHJpeCk7XG4gICAgYnJlYWs7XG5cbiAgLy8gVE9ETzogbWFrZSBsaWdoaXRuZyB3b3JrIGZvciBtZXRlciBvZmZzZXQgbW9kZVxuICBjYXNlIENPT1JESU5BVEVfU1lTVEVNLk1FVEVSX09GRlNFVFM6XG4gICAgLy8gQ2FsY3VsYXRlIHRyYW5zZm9ybWVkIHByb2plY3Rpb25DZW50ZXIgKGluIDY0IGJpdCBwcmVjaXNpb24pXG4gICAgLy8gVGhpcyBpcyB0aGUga2V5IHRvIG9mZnNldCBtb2RlIHByZWNpc2lvbiAoYXZvaWRzIGRvaW5nIHRoaXNcbiAgICAvLyBhZGRpdGlvbiBpbiAzMiBiaXQgcHJlY2lzaW9uKVxuICAgIGNvbnN0IHBvc2l0aW9uUGl4ZWxzID0gdmlld3BvcnQucHJvamVjdEZsYXQocG9zaXRpb25PcmlnaW4pO1xuICAgIGNvbnN0IHZpZXdQcm9qZWN0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQocHJvamVjdGlvbk1hdHJpeCkubXVsdGlwbHlSaWdodCh2aWV3TWF0cml4KTtcbiAgICBwcm9qZWN0aW9uQ2VudGVyID0gdmlld1Byb2plY3Rpb25NYXRyaXhcbiAgICAgIC50cmFuc2Zvcm1WZWN0b3IoW3Bvc2l0aW9uUGl4ZWxzWzBdLCBwb3NpdGlvblBpeGVsc1sxXSwgMC4wLCAxLjBdKTtcblxuICAgIC8vIEFsd2F5cyBhcHBseSB1bmNlbnRlcmVkIHByb2plY3Rpb24gbWF0cml4IChzaGFkZXIgYWRkcyBjZW50ZXIpXG4gICAgbW9kZWxWaWV3TWF0cml4ID0gbmV3IE1hdHJpeDQodmlld01hdHJpeFVuY2VudGVyZWQpXG4gICAgICAvLyBaZXJvIG91dCA0dGggY29vcmRpbmF0ZSAoXCJhZnRlclwiIG1vZGVsIG1hdHJpeCkgLSBhdm9pZHMgZnVydGhlciB0cmFuc2xhdGlvbnNcbiAgICAgIC5tdWx0aXBseVJpZ2h0KFZFQ1RPUl9UT19QT0lOVF9NQVRSSVgpO1xuICAgIGJyZWFrO1xuXG4gIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByb2plY3Rpb24gbW9kZScpO1xuICB9XG5cbiAgY29uc3Qgdmlld01hdHJpeEludiA9IG1vZGVsVmlld01hdHJpeC5jbG9uZSgpLmludmVydCgpO1xuXG4gIGlmIChtb2RlbE1hdHJpeCkge1xuICAgIC8vIEFwcGx5IG1vZGVsIG1hdHJpeCBpZiBzdXBwbGllZFxuICAgIG1vZGVsVmlld01hdHJpeC5tdWx0aXBseVJpZ2h0KG1vZGVsTWF0cml4KTtcbiAgfVxuXG4gIGNvbnN0IG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggPSBuZXcgTWF0cml4NChwcm9qZWN0aW9uTWF0cml4KS5tdWx0aXBseVJpZ2h0KG1vZGVsVmlld01hdHJpeCk7XG4gIGNvbnN0IGNhbWVyYVBvcyA9IFt2aWV3TWF0cml4SW52WzEyXSwgdmlld01hdHJpeEludlsxM10sIHZpZXdNYXRyaXhJbnZbMTRdXTtcblxuICByZXR1cm4ge1xuICAgIG1vZGVsVmlld01hdHJpeCxcbiAgICBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4LFxuICAgIHByb2plY3Rpb25DZW50ZXIsXG4gICAgY2FtZXJhUG9zXG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyB1bmlmb3JtcyBmb3Igc2hhZGVycyBiYXNlZCBvbiBjdXJyZW50IHByb2plY3Rpb25cbiAqIGluY2x1ZGVzOiBwcm9qZWN0aW9uIG1hdHJpeCBzdWl0YWJsZSBmb3Igc2hhZGVyc1xuICpcbiAqIFRPRE8gLSBFbnN1cmUgdGhpcyB3b3JrcyB3aXRoIGFueSB2aWV3cG9ydCwgbm90IGp1c3QgV2ViTWVyY2F0b3JWaWV3cG9ydHNcbiAqXG4gKiBAcGFyYW0ge1dlYk1lcmNhdG9yVmlld3BvcnR9IHZpZXdwb3J0IC1cbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gLSA0eDQgcHJvamVjdGlvbiBtYXRyaXggdGhhdCBjYW4gYmUgdXNlZCBpbiBzaGFkZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVbmlmb3Jtc0Zyb21WaWV3cG9ydCh2aWV3cG9ydCwge1xuICBtb2RlbE1hdHJpeCA9IG51bGwsXG4gIHByb2plY3Rpb25Nb2RlID0gQ09PUkRJTkFURV9TWVNURU0uTE5HTEFULFxuICBwb3NpdGlvbk9yaWdpbiA9IFswLCAwXVxufSA9IHt9KSB7XG4gIGFzc2VydCh2aWV3cG9ydC5zY2FsZSwgJ1ZpZXdwb3J0IHNjYWxlIG1pc3NpbmcnKTtcblxuICBjb25zdCB7cHJvamVjdGlvbkNlbnRlciwgbW9kZWxWaWV3TWF0cml4LCBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4LCBjYW1lcmFQb3N9ID1cbiAgICBjYWxjdWxhdGVNYXRyaXhBbmRPZmZzZXQoe3Byb2plY3Rpb25Nb2RlLCBwb3NpdGlvbk9yaWdpbiwgbW9kZWxNYXRyaXgsIHZpZXdwb3J0fSk7XG5cbiAgYXNzZXJ0KG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgsICdWaWV3cG9ydCBtaXNzaW5nIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgnKTtcblxuICAvLyBDYWxjdWxhdGUgcHJvamVjdGlvbiBwaXhlbHMgcGVyIHVuaXRcbiAgY29uc3QgcHJvamVjdGlvblBpeGVsc1BlclVuaXQgPSB2aWV3cG9ydC5nZXREaXN0YW5jZVNjYWxlcygpLnBpeGVsc1Blck1ldGVyO1xuICBhc3NlcnQocHJvamVjdGlvblBpeGVsc1BlclVuaXQsICdWaWV3cG9ydCBtaXNzaW5nIHBpeGVsc1Blck1ldGVyJyk7XG5cbiAgLy8gY2FsY3VsYXRlIFdlYkdMIG1hdHJpY2VzXG5cbiAgLy8gQ29udmVydCB0byBGbG9hdDMyXG4gIGNvbnN0IGdsUHJvamVjdGlvbk1hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkobW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCk7XG5cbiAgLy8gXCJGbG9hdDY0QXJyYXlcIlxuICAvLyBUcmFuc3Bvc2UgdGhlIHByb2plY3Rpb24gbWF0cml4IHRvIGNvbHVtbiBtYWpvciBmb3IgR0xTTC5cbiAgY29uc3QgZ2xQcm9qZWN0aW9uTWF0cml4RlA2NCA9IG5ldyBGbG9hdDMyQXJyYXkoMzIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgNDsgKytqKSB7XG4gICAgICBbXG4gICAgICAgIGdsUHJvamVjdGlvbk1hdHJpeEZQNjRbKGkgKiA0ICsgaikgKiAyXSxcbiAgICAgICAgZ2xQcm9qZWN0aW9uTWF0cml4RlA2NFsoaSAqIDQgKyBqKSAqIDIgKyAxXVxuICAgICAgXSA9IGZwNjRpZnkobW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeFtqICogNCArIGldKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gKHdpbmRvdyAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykgfHwgMTtcblxuICByZXR1cm4ge1xuICAgIC8vIFByb2plY3Rpb24gbW9kZSB2YWx1ZXNcbiAgICBwcm9qZWN0aW9uTW9kZSxcbiAgICBwcm9qZWN0aW9uQ2VudGVyLFxuXG4gICAgLy8gbW9kZWxNYXRyaXg6IG1vZGVsTWF0cml4IHx8IG5ldyBNYXRyaXg0KCkuaWRlbnRpdHkoKSxcbiAgICBtb2RlbFZpZXdNYXRyaXgsXG5cbiAgICAvLyBTY3JlZW4gc2l6ZVxuICAgIHZpZXdwb3J0U2l6ZTogW3ZpZXdwb3J0LndpZHRoICogZGV2aWNlUGl4ZWxSYXRpbywgdmlld3BvcnQuaGVpZ2h0ICogZGV2aWNlUGl4ZWxSYXRpb10sXG4gICAgZGV2aWNlUGl4ZWxSYXRpbyxcblxuICAgIC8vIE1haW4gcHJvamVjdGlvbiBtYXRyaWNlc1xuICAgIHByb2plY3Rpb25NYXRyaXg6IGdsUHJvamVjdGlvbk1hdHJpeCxcbiAgICBwcm9qZWN0aW9uTWF0cml4VW5jZW50ZXJlZDogZ2xQcm9qZWN0aW9uTWF0cml4LFxuICAgIHByb2plY3Rpb25GUDY0OiBnbFByb2plY3Rpb25NYXRyaXhGUDY0LFxuICAgIHByb2plY3Rpb25QaXhlbHNQZXJVbml0LFxuXG4gICAgLy8gVGhpcyBpcyB0aGUgbWVyY2F0b3Igc2NhbGUgKDIgKiogem9vbSlcbiAgICBwcm9qZWN0aW9uU2NhbGU6IHZpZXdwb3J0LnNjYWxlLFxuXG4gICAgLy8gRGVwcmVjYXRlZD9cbiAgICBwcm9qZWN0aW9uU2NhbGVGUDY0OiBmcDY0aWZ5KHZpZXdwb3J0LnNjYWxlKSxcblxuICAgIC8vIFRoaXMgaXMgZm9yIGxpZ2h0aW5nIGNhbGN1bGF0aW9uc1xuICAgIGNhbWVyYVBvczogbmV3IEZsb2F0MzJBcnJheShjYW1lcmFQb3MpXG5cbiAgfTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xpYi92aWV3cG9ydC11bmlmb3Jtcy5qc1xuLy8gbW9kdWxlIGlkID0gMTA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 105 */
/* exports provided: default */
/* exports used: default */
/*!*************************************!*\
  !*** ./src/react/webgl-renderer.js ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(/*! react */ 34);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__autobind__ = __webpack_require__(/*! ./autobind */ 29);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl__ = __webpack_require__(/*! luma.gl */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_luma_gl__);\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* global window */\n\n\n\n/* global requestAnimationFrame, cancelAnimationFrame */\n\nconst DEFAULT_PIXEL_RATIO =\n  (typeof window !== 'undefined' && window.devicePixelRatio) || 1;\n\nconst propTypes = {\n  id: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].string.isRequired,\n\n  width: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].number.isRequired,\n  height: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].number.isRequired,\n  style: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].object,\n\n  pixelRatio: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].number,\n  viewport: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].object.isRequired,\n  events: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].object,\n  gl: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].object,\n  glOptions: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].object,\n  debug: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].bool,\n\n  onInitializationFailed: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func,\n  onRendererInitialized: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func.isRequired,\n  onRenderFrame: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func,\n  onMouseMove: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func,\n  onClick: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func\n};\n\nconst defaultProps = {\n  style: {},\n  gl: null,\n  glOptions: {preserveDrawingBuffer: true},\n  debug: false,\n  pixelRatio: DEFAULT_PIXEL_RATIO,\n\n  onInitializationFailed: error => {\n    throw error;\n  },\n  onRendererInitialized: () => {},\n  onRenderFrame: () => {}\n};\n\nclass WebGLRenderer extends __WEBPACK_IMPORTED_MODULE_0_react___default.a.Component {\n  /**\n   * @classdesc\n   * Small react component that uses Luma.GL to initialize a WebGL context.\n   *\n   * Returns a canvas, creates a basic WebGL context\n   * sets up a renderloop, and registers some basic event handlers\n   *\n   * @class\n   * @param {Object} props - see propTypes documentation\n   */\n  constructor(props) {\n    super(props);\n    this.state = {};\n    this._animationFrame = null;\n    this.gl = null;\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__autobind__[\"a\" /* default */])(this);\n  }\n\n  componentDidMount() {\n    const canvas = this.refs.overlay;\n    this._initWebGL(canvas);\n    this._animationLoop();\n  }\n\n  componentWillUnmount() {\n    this._cancelAnimationLoop();\n  }\n\n  /**\n   * Initialize LumaGL library and through it WebGL\n   * @param {string} canvas\n   */\n  _initWebGL(canvas) {\n    const {debug, glOptions} = this.props;\n\n    // Create context if not supplied\n    let gl = this.props.gl;\n    if (!gl) {\n      try {\n        gl = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"createGLContext\"])(Object.assign({canvas, debug}, glOptions));\n      } catch (error) {\n        this.props.onInitializationFailed(error);\n        return;\n      }\n    }\n\n    this.gl = gl;\n\n    // Call callback last, in case it throws\n    this.props.onRendererInitialized({canvas, gl});\n  }\n\n  /**\n   * Main WebGL animation loop\n   */\n  _animationLoop() {\n    this._renderFrame();\n    // Keep registering ourselves for the next animation frame\n    if (typeof window !== 'undefined') {\n      this._animationFrame = requestAnimationFrame(this._animationLoop);\n    }\n  }\n\n  _cancelAnimationLoop() {\n    if (this._animationFrame) {\n      cancelAnimationFrame(this._animationFrame);\n    }\n  }\n\n  // Updates WebGL viewport to latest props\n  // for clean logging, only calls gl.viewport if props have changed\n  _updateGLViewport() {\n    let {viewport: {x, y, width: w, height: h}} = this.props;\n    const {pixelRatio: dpr} = this.props;\n    const {gl} = this;\n\n    x = x * dpr;\n    y = y * dpr;\n    w = w * dpr;\n    h = h * dpr;\n\n    if (x !== this.x || y !== this.y || w !== this.w || h !== this.h) {\n      gl.viewport(x, y, w, h);\n      this.x = x;\n      this.y = y;\n      this.w = w;\n      this.h = h;\n    }\n  }\n\n  _renderFrame() {\n    const {viewport: {width, height}} = this.props;\n    const {gl} = this;\n\n    // Check for reasons not to draw\n    if (!gl || !(width > 0) || !(height > 0)) {\n      return;\n    }\n\n    this._updateGLViewport();\n\n    // Call render callback\n    this.props.onRenderFrame({gl});\n\n    this.props.onAfterRender(this.refs.overlay);\n\n  }\n\n  render() {\n    const {id, width, height, pixelRatio, style} = this.props;\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_react__[\"createElement\"])('canvas', {\n      ref: 'overlay',\n      key: 'overlay',\n      id,\n      width: width * pixelRatio,\n      height: height * pixelRatio,\n      style: Object.assign({}, style, {width, height})\n    });\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = WebGLRenderer;\n\n\nWebGLRenderer.propTypes = propTypes;\nWebGLRenderer.defaultProps = defaultProps;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3JlYWN0L3dlYmdsLXJlbmRlcmVyLmpzPzRiZmQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLyogZ2xvYmFsIHdpbmRvdyAqL1xuaW1wb3J0IFJlYWN0LCB7UHJvcFR5cGVzLCBjcmVhdGVFbGVtZW50fSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgYXV0b2JpbmQgZnJvbSAnLi9hdXRvYmluZCc7XG5pbXBvcnQge2NyZWF0ZUdMQ29udGV4dH0gZnJvbSAnbHVtYS5nbCc7XG4vKiBnbG9iYWwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBjYW5jZWxBbmltYXRpb25GcmFtZSAqL1xuXG5jb25zdCBERUZBVUxUX1BJWEVMX1JBVElPID1cbiAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSB8fCAxO1xuXG5jb25zdCBwcm9wVHlwZXMgPSB7XG4gIGlkOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG5cbiAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIHN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIHBpeGVsUmF0aW86IFByb3BUeXBlcy5udW1iZXIsXG4gIHZpZXdwb3J0OiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIGV2ZW50czogUHJvcFR5cGVzLm9iamVjdCxcbiAgZ2w6IFByb3BUeXBlcy5vYmplY3QsXG4gIGdsT3B0aW9uczogUHJvcFR5cGVzLm9iamVjdCxcbiAgZGVidWc6IFByb3BUeXBlcy5ib29sLFxuXG4gIG9uSW5pdGlhbGl6YXRpb25GYWlsZWQ6IFByb3BUeXBlcy5mdW5jLFxuICBvblJlbmRlcmVySW5pdGlhbGl6ZWQ6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIG9uUmVuZGVyRnJhbWU6IFByb3BUeXBlcy5mdW5jLFxuICBvbk1vdXNlTW92ZTogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIHN0eWxlOiB7fSxcbiAgZ2w6IG51bGwsXG4gIGdsT3B0aW9uczoge3ByZXNlcnZlRHJhd2luZ0J1ZmZlcjogdHJ1ZX0sXG4gIGRlYnVnOiBmYWxzZSxcbiAgcGl4ZWxSYXRpbzogREVGQVVMVF9QSVhFTF9SQVRJTyxcblxuICBvbkluaXRpYWxpemF0aW9uRmFpbGVkOiBlcnJvciA9PiB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH0sXG4gIG9uUmVuZGVyZXJJbml0aWFsaXplZDogKCkgPT4ge30sXG4gIG9uUmVuZGVyRnJhbWU6ICgpID0+IHt9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJHTFJlbmRlcmVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogU21hbGwgcmVhY3QgY29tcG9uZW50IHRoYXQgdXNlcyBMdW1hLkdMIHRvIGluaXRpYWxpemUgYSBXZWJHTCBjb250ZXh0LlxuICAgKlxuICAgKiBSZXR1cm5zIGEgY2FudmFzLCBjcmVhdGVzIGEgYmFzaWMgV2ViR0wgY29udGV4dFxuICAgKiBzZXRzIHVwIGEgcmVuZGVybG9vcCwgYW5kIHJlZ2lzdGVycyBzb21lIGJhc2ljIGV2ZW50IGhhbmRsZXJzXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBzZWUgcHJvcFR5cGVzIGRvY3VtZW50YXRpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7fTtcbiAgICB0aGlzLl9hbmltYXRpb25GcmFtZSA9IG51bGw7XG4gICAgdGhpcy5nbCA9IG51bGw7XG4gICAgYXV0b2JpbmQodGhpcyk7XG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLnJlZnMub3ZlcmxheTtcbiAgICB0aGlzLl9pbml0V2ViR0woY2FudmFzKTtcbiAgICB0aGlzLl9hbmltYXRpb25Mb29wKCk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLl9jYW5jZWxBbmltYXRpb25Mb29wKCk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBMdW1hR0wgbGlicmFyeSBhbmQgdGhyb3VnaCBpdCBXZWJHTFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FudmFzXG4gICAqL1xuICBfaW5pdFdlYkdMKGNhbnZhcykge1xuICAgIGNvbnN0IHtkZWJ1ZywgZ2xPcHRpb25zfSA9IHRoaXMucHJvcHM7XG5cbiAgICAvLyBDcmVhdGUgY29udGV4dCBpZiBub3Qgc3VwcGxpZWRcbiAgICBsZXQgZ2wgPSB0aGlzLnByb3BzLmdsO1xuICAgIGlmICghZ2wpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGdsID0gY3JlYXRlR0xDb250ZXh0KE9iamVjdC5hc3NpZ24oe2NhbnZhcywgZGVidWd9LCBnbE9wdGlvbnMpKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25Jbml0aWFsaXphdGlvbkZhaWxlZChlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmdsID0gZ2w7XG5cbiAgICAvLyBDYWxsIGNhbGxiYWNrIGxhc3QsIGluIGNhc2UgaXQgdGhyb3dzXG4gICAgdGhpcy5wcm9wcy5vblJlbmRlcmVySW5pdGlhbGl6ZWQoe2NhbnZhcywgZ2x9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWluIFdlYkdMIGFuaW1hdGlvbiBsb29wXG4gICAqL1xuICBfYW5pbWF0aW9uTG9vcCgpIHtcbiAgICB0aGlzLl9yZW5kZXJGcmFtZSgpO1xuICAgIC8vIEtlZXAgcmVnaXN0ZXJpbmcgb3Vyc2VsdmVzIGZvciB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuX2FuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX2FuaW1hdGlvbkxvb3ApO1xuICAgIH1cbiAgfVxuXG4gIF9jYW5jZWxBbmltYXRpb25Mb29wKCkge1xuICAgIGlmICh0aGlzLl9hbmltYXRpb25GcmFtZSkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fYW5pbWF0aW9uRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVwZGF0ZXMgV2ViR0wgdmlld3BvcnQgdG8gbGF0ZXN0IHByb3BzXG4gIC8vIGZvciBjbGVhbiBsb2dnaW5nLCBvbmx5IGNhbGxzIGdsLnZpZXdwb3J0IGlmIHByb3BzIGhhdmUgY2hhbmdlZFxuICBfdXBkYXRlR0xWaWV3cG9ydCgpIHtcbiAgICBsZXQge3ZpZXdwb3J0OiB7eCwgeSwgd2lkdGg6IHcsIGhlaWdodDogaH19ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7cGl4ZWxSYXRpbzogZHByfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge2dsfSA9IHRoaXM7XG5cbiAgICB4ID0geCAqIGRwcjtcbiAgICB5ID0geSAqIGRwcjtcbiAgICB3ID0gdyAqIGRwcjtcbiAgICBoID0gaCAqIGRwcjtcblxuICAgIGlmICh4ICE9PSB0aGlzLnggfHwgeSAhPT0gdGhpcy55IHx8IHcgIT09IHRoaXMudyB8fCBoICE9PSB0aGlzLmgpIHtcbiAgICAgIGdsLnZpZXdwb3J0KHgsIHksIHcsIGgpO1xuICAgICAgdGhpcy54ID0geDtcbiAgICAgIHRoaXMueSA9IHk7XG4gICAgICB0aGlzLncgPSB3O1xuICAgICAgdGhpcy5oID0gaDtcbiAgICB9XG4gIH1cblxuICBfcmVuZGVyRnJhbWUoKSB7XG4gICAgY29uc3Qge3ZpZXdwb3J0OiB7d2lkdGgsIGhlaWdodH19ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7Z2x9ID0gdGhpcztcblxuICAgIC8vIENoZWNrIGZvciByZWFzb25zIG5vdCB0byBkcmF3XG4gICAgaWYgKCFnbCB8fCAhKHdpZHRoID4gMCkgfHwgIShoZWlnaHQgPiAwKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZUdMVmlld3BvcnQoKTtcblxuICAgIC8vIENhbGwgcmVuZGVyIGNhbGxiYWNrXG4gICAgdGhpcy5wcm9wcy5vblJlbmRlckZyYW1lKHtnbH0pO1xuXG4gICAgdGhpcy5wcm9wcy5vbkFmdGVyUmVuZGVyKHRoaXMucmVmcy5vdmVybGF5KTtcblxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtpZCwgd2lkdGgsIGhlaWdodCwgcGl4ZWxSYXRpbywgc3R5bGV9ID0gdGhpcy5wcm9wcztcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnY2FudmFzJywge1xuICAgICAgcmVmOiAnb3ZlcmxheScsXG4gICAgICBrZXk6ICdvdmVybGF5JyxcbiAgICAgIGlkLFxuICAgICAgd2lkdGg6IHdpZHRoICogcGl4ZWxSYXRpbyxcbiAgICAgIGhlaWdodDogaGVpZ2h0ICogcGl4ZWxSYXRpbyxcbiAgICAgIHN0eWxlOiBPYmplY3QuYXNzaWduKHt9LCBzdHlsZSwge3dpZHRoLCBoZWlnaHR9KVxuICAgIH0pO1xuICB9XG59XG5cbldlYkdMUmVuZGVyZXIucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuV2ViR0xSZW5kZXJlci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9yZWFjdC93ZWJnbC1yZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gMTA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 106 */
/* exports provided: checkRendererVendor, getPlatformShaderDefines, assembleShaders */
/* exports used: assembleShaders */
/*!**********************************************!*\
  !*** ./src/shader-utils/assemble-shaders.js ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl__ = __webpack_require__(/*! luma.gl */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_chunks__ = __webpack_require__(/*! ./shader-chunks */ 30);\n/* unused harmony export checkRendererVendor */\n/* unused harmony export getPlatformShaderDefines */\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = assembleShaders;\n\n\n// Load shader chunks\n// import SHADER_CHUNKS from '../../dist/shaderlib/shader-chunks';\n\n\nfunction checkRendererVendor(debugInfo, gpuVendor) {\n  const {vendor, renderer} = debugInfo;\n  let result;\n  switch (gpuVendor) {\n  case 'nvidia':\n    result = vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i);\n    break;\n  case 'intel':\n    result = vendor.match(/INTEL/i) || renderer.match(/INTEL/i);\n    break;\n  case 'amd':\n    result =\n      vendor.match(/AMD/i) || renderer.match(/AMD/i) ||\n      vendor.match(/ATI/i) || renderer.match(/ATI/i);\n    break;\n  default:\n    result = false;\n  }\n  return result;\n}\n\nfunction getPlatformShaderDefines(gl) {\n  /* eslint-disable */\n  let platformDefines = '';\n  const debugInfo = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"glGetDebugInfo\"])(gl);\n\n  if (checkRendererVendor(debugInfo, 'nvidia')) {\n    platformDefines += `\\\n#define NVIDIA_GPU\n#define NVIDIA_FP64_WORKAROUND 1\n#define NVIDIA_EQUATION_WORKAROUND 1\n`;\n  } else if (checkRendererVendor(debugInfo, 'intel')) {\n    platformDefines += `\\\n#define INTEL_GPU\n#define INTEL_FP64_WORKAROUND 1\n#define NVIDIA_EQUATION_WORKAROUND 1\\n \\\n#define INTEL_TAN_WORKAROUND 1\n`;\n  } else if (checkRendererVendor(debugInfo, 'amd')) {\n    platformDefines += `\\\n#define AMD_GPU\n`;\n  } else {\n    platformDefines += `\\\n#define DEFAULT_GPU\n`;\n  }\n\n  return platformDefines;\n}\n\nfunction assembleShader(gl, opts = {}) {\n  const {vs, project = true, project64 = false} = opts;\n  let {fp64 = false} = opts;\n  if (project64 === true) {\n    fp64 = true;\n  }\n  let source = `${getPlatformShaderDefines(gl)}\\n`;\n  opts = Object.assign({}, opts, {project, project64, fp64});\n  for (const chunkName of Object.keys(__WEBPACK_IMPORTED_MODULE_1__shader_chunks__)) {\n    if (opts[chunkName]) {\n      source += `${__WEBPACK_IMPORTED_MODULE_1__shader_chunks__[chunkName].source}\\n`;\n    }\n  }\n  for (const chunkName of opts.modules || []) {\n    if (__WEBPACK_IMPORTED_MODULE_1__shader_chunks__[chunkName]) {\n      source += `${__WEBPACK_IMPORTED_MODULE_1__shader_chunks__[chunkName].source}\\n`;\n    } else {\n      throw new Error(`Shader module ${chunkName} not found`);\n    }\n  }\n  source += vs;\n  return source;\n}\n\nfunction assembleShaders(gl, opts) {\n  return {\n    gl,\n    vs: assembleShader(gl, opts),\n    fs: opts.fs\n  };\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlci11dGlscy9hc3NlbWJsZS1zaGFkZXJzLmpzP2YyNzkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtnbEdldERlYnVnSW5mb30gZnJvbSAnbHVtYS5nbCc7XG5cbi8vIExvYWQgc2hhZGVyIGNodW5rc1xuLy8gaW1wb3J0IFNIQURFUl9DSFVOS1MgZnJvbSAnLi4vLi4vZGlzdC9zaGFkZXJsaWIvc2hhZGVyLWNodW5rcyc7XG5pbXBvcnQgKiBhcyBTSEFERVJfQ0hVTktTIGZyb20gJy4vc2hhZGVyLWNodW5rcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1JlbmRlcmVyVmVuZG9yKGRlYnVnSW5mbywgZ3B1VmVuZG9yKSB7XG4gIGNvbnN0IHt2ZW5kb3IsIHJlbmRlcmVyfSA9IGRlYnVnSW5mbztcbiAgbGV0IHJlc3VsdDtcbiAgc3dpdGNoIChncHVWZW5kb3IpIHtcbiAgY2FzZSAnbnZpZGlhJzpcbiAgICByZXN1bHQgPSB2ZW5kb3IubWF0Y2goL05WSURJQS9pKSB8fCByZW5kZXJlci5tYXRjaCgvTlZJRElBL2kpO1xuICAgIGJyZWFrO1xuICBjYXNlICdpbnRlbCc6XG4gICAgcmVzdWx0ID0gdmVuZG9yLm1hdGNoKC9JTlRFTC9pKSB8fCByZW5kZXJlci5tYXRjaCgvSU5URUwvaSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2FtZCc6XG4gICAgcmVzdWx0ID1cbiAgICAgIHZlbmRvci5tYXRjaCgvQU1EL2kpIHx8IHJlbmRlcmVyLm1hdGNoKC9BTUQvaSkgfHxcbiAgICAgIHZlbmRvci5tYXRjaCgvQVRJL2kpIHx8IHJlbmRlcmVyLm1hdGNoKC9BVEkvaSk7XG4gICAgYnJlYWs7XG4gIGRlZmF1bHQ6XG4gICAgcmVzdWx0ID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBsYXRmb3JtU2hhZGVyRGVmaW5lcyhnbCkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICBsZXQgcGxhdGZvcm1EZWZpbmVzID0gJyc7XG4gIGNvbnN0IGRlYnVnSW5mbyA9IGdsR2V0RGVidWdJbmZvKGdsKTtcblxuICBpZiAoY2hlY2tSZW5kZXJlclZlbmRvcihkZWJ1Z0luZm8sICdudmlkaWEnKSkge1xuICAgIHBsYXRmb3JtRGVmaW5lcyArPSBgXFxcbiNkZWZpbmUgTlZJRElBX0dQVVxuI2RlZmluZSBOVklESUFfRlA2NF9XT1JLQVJPVU5EIDFcbiNkZWZpbmUgTlZJRElBX0VRVUFUSU9OX1dPUktBUk9VTkQgMVxuYDtcbiAgfSBlbHNlIGlmIChjaGVja1JlbmRlcmVyVmVuZG9yKGRlYnVnSW5mbywgJ2ludGVsJykpIHtcbiAgICBwbGF0Zm9ybURlZmluZXMgKz0gYFxcXG4jZGVmaW5lIElOVEVMX0dQVVxuI2RlZmluZSBJTlRFTF9GUDY0X1dPUktBUk9VTkQgMVxuI2RlZmluZSBOVklESUFfRVFVQVRJT05fV09SS0FST1VORCAxXFxuIFxcXG4jZGVmaW5lIElOVEVMX1RBTl9XT1JLQVJPVU5EIDFcbmA7XG4gIH0gZWxzZSBpZiAoY2hlY2tSZW5kZXJlclZlbmRvcihkZWJ1Z0luZm8sICdhbWQnKSkge1xuICAgIHBsYXRmb3JtRGVmaW5lcyArPSBgXFxcbiNkZWZpbmUgQU1EX0dQVVxuYDtcbiAgfSBlbHNlIHtcbiAgICBwbGF0Zm9ybURlZmluZXMgKz0gYFxcXG4jZGVmaW5lIERFRkFVTFRfR1BVXG5gO1xuICB9XG5cbiAgcmV0dXJuIHBsYXRmb3JtRGVmaW5lcztcbn1cblxuZnVuY3Rpb24gYXNzZW1ibGVTaGFkZXIoZ2wsIG9wdHMgPSB7fSkge1xuICBjb25zdCB7dnMsIHByb2plY3QgPSB0cnVlLCBwcm9qZWN0NjQgPSBmYWxzZX0gPSBvcHRzO1xuICBsZXQge2ZwNjQgPSBmYWxzZX0gPSBvcHRzO1xuICBpZiAocHJvamVjdDY0ID09PSB0cnVlKSB7XG4gICAgZnA2NCA9IHRydWU7XG4gIH1cbiAgbGV0IHNvdXJjZSA9IGAke2dldFBsYXRmb3JtU2hhZGVyRGVmaW5lcyhnbCl9XFxuYDtcbiAgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHMsIHtwcm9qZWN0LCBwcm9qZWN0NjQsIGZwNjR9KTtcbiAgZm9yIChjb25zdCBjaHVua05hbWUgb2YgT2JqZWN0LmtleXMoU0hBREVSX0NIVU5LUykpIHtcbiAgICBpZiAob3B0c1tjaHVua05hbWVdKSB7XG4gICAgICBzb3VyY2UgKz0gYCR7U0hBREVSX0NIVU5LU1tjaHVua05hbWVdLnNvdXJjZX1cXG5gO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGNodW5rTmFtZSBvZiBvcHRzLm1vZHVsZXMgfHwgW10pIHtcbiAgICBpZiAoU0hBREVSX0NIVU5LU1tjaHVua05hbWVdKSB7XG4gICAgICBzb3VyY2UgKz0gYCR7U0hBREVSX0NIVU5LU1tjaHVua05hbWVdLnNvdXJjZX1cXG5gO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFNoYWRlciBtb2R1bGUgJHtjaHVua05hbWV9IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgfVxuICBzb3VyY2UgKz0gdnM7XG4gIHJldHVybiBzb3VyY2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlbWJsZVNoYWRlcnMoZ2wsIG9wdHMpIHtcbiAgcmV0dXJuIHtcbiAgICBnbCxcbiAgICB2czogYXNzZW1ibGVTaGFkZXIoZ2wsIG9wdHMpLFxuICAgIGZzOiBvcHRzLmZzXG4gIH07XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9zaGFkZXItdXRpbHMvYXNzZW1ibGUtc2hhZGVycy5qc1xuLy8gbW9kdWxlIGlkID0gMTA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 107 */
/* exports provided: fp64 */
/* exports used: fp64 */
/*!*************************************!*\
  !*** ./src/shaderlib/fp64/index.js ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_fp64_glsl__ = __webpack_require__(/*! ./math-fp64.glsl */ 108);\n\n\nconst fp64 = {\n  interface: 'fp64',\n  source: __WEBPACK_IMPORTED_MODULE_0__math_fp64_glsl__[\"a\" /* default */]\n};\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = fp64;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcmxpYi9mcDY0L2luZGV4LmpzPzU2N2EiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG1hdGhGcDY0IGZyb20gJy4vbWF0aC1mcDY0Lmdsc2wnO1xuXG5leHBvcnQgY29uc3QgZnA2NCA9IHtcbiAgaW50ZXJmYWNlOiAnZnA2NCcsXG4gIHNvdXJjZTogbWF0aEZwNjRcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9zaGFkZXJsaWIvZnA2NC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 108 */
/* exports provided: default */
/* exports used: default */
/*!**********************************************!*\
  !*** ./src/shaderlib/fp64/math-fp64.glsl.js ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\nuniform float ONE;\n\nconst vec2 E_FP64 = vec2(2.7182817459106445e+00, 8.254840366817007e-08);\nconst vec2 LOG2_FP64 = vec2(0.6931471824645996e+00, -1.9046542121259336e-09);\nconst vec2 PI_FP64 = vec2(3.1415927410125732, -8.742278012618954e-8);\nconst vec2 TWO_PI_FP64 = vec2(6.2831854820251465, -1.7484556025237907e-7);\nconst vec2 PI_2_FP64 = vec2(1.5707963705062866, -4.371139006309477e-8);\nconst vec2 PI_4_FP64 = vec2(0.7853981852531433, -2.1855695031547384e-8);\nconst vec2 PI_16_FP64 = vec2(0.19634954631328583, -5.463923757886846e-9);\nconst vec2 PI_16_2_FP64 = vec2(0.39269909262657166, -1.0927847515773692e-8);\nconst vec2 PI_16_3_FP64 = vec2(0.5890486240386963, -1.4906100798128818e-9);\nconst vec2 PI_180_FP64 = vec2(0.01745329238474369, 1.3519960498364902e-10);\n\nconst vec2 SIN_TABLE_0_FP64 = vec2(0.19509032368659973, -1.6704714833615242e-9);\nconst vec2 SIN_TABLE_1_FP64 = vec2(0.3826834261417389, 6.22335089017767e-9);\nconst vec2 SIN_TABLE_2_FP64 = vec2(0.5555702447891235, -1.1769521357507529e-8);\nconst vec2 SIN_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617041793133e-8);\n\nconst vec2 COS_TABLE_0_FP64 = vec2(0.9807852506637573, 2.9739473106360492e-8);\nconst vec2 COS_TABLE_1_FP64 = vec2(0.9238795042037964, 2.8307490351764386e-8);\nconst vec2 COS_TABLE_2_FP64 = vec2(0.8314695954322815, 1.6870263741530778e-8);\nconst vec2 COS_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617152815436e-8);\n\nconst vec2 INVERSE_FACTORIAL_3_FP64 = vec2(1.666666716337204e-01, -4.967053879312289e-09); // 1/3!\nconst vec2 INVERSE_FACTORIAL_4_FP64 = vec2(4.16666679084301e-02, -1.2417634698280722e-09); // 1/4!\nconst vec2 INVERSE_FACTORIAL_5_FP64 = vec2(8.333333767950535e-03, -4.34617203337595e-10); // 1/5!\nconst vec2 INVERSE_FACTORIAL_6_FP64 = vec2(1.3888889225199819e-03, -3.3631094437103215e-11); // 1/6!\nconst vec2 INVERSE_FACTORIAL_7_FP64 = vec2(1.9841270113829523e-04,  -2.725596874933456e-12); // 1/7!\nconst vec2 INVERSE_FACTORIAL_8_FP64 = vec2(2.4801587642286904e-05, -3.406996025904184e-13); // 1/8!\nconst vec2 INVERSE_FACTORIAL_9_FP64 = vec2(2.75573188446287533e-06, 3.7935713937038186e-14); // 1/9!\nconst vec2 INVERSE_FACTORIAL_10_FP64 = vec2(2.755731998149713e-07, -7.575112367869873e-15); // 1/10!\n\nfloat nint(float d) {\n    if (d == floor(d)) return d;\n    return floor(d + 0.5);\n}\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\nvec2 split(float a) {\n  const float SPLIT = 4097.0;\n  float t = a * SPLIT;\n  float a_hi = t * ONE - (t - a);\n  float a_lo = a * ONE - a_hi;\n  return vec2(a_hi, a_lo);\n}\n#else\nvec2 split(float a) {\n  const float SPLIT = 4097.0;\n  float t = a * SPLIT;\n  float a_hi = t - (t - a);\n  float a_lo = a - a_hi;\n  return vec2(a_hi, a_lo);\n}\n#endif\n\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\nvec2 quickTwoSum(float a, float b) {\n  float sum = (a + b) * ONE;\n  float err = b - (sum - a) * ONE;\n  return vec2(sum, err);\n}\n#else\nvec2 quickTwoSum(float a, float b) {\n  float sum = a + b;\n  float err = b - (sum - a);\n  return vec2(sum, err);\n}\n#endif\n\nvec2 nint_fp64(vec2 a) {\n    float hi = nint(a.x);\n    float lo;\n    vec2 tmp;\n    if (hi == a.x) {\n        lo = nint(a.y);\n        tmp = quickTwoSum(hi, lo);\n    } else {\n        lo = 0.0;\n        if (abs(hi - a.x) == 0.5 && a.y < 0.0) {\n            hi -= 1.0;\n        }\n        tmp = vec2(hi, lo);\n    }\n    return tmp;\n}\n\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\n\n/* The purpose of this workaround is to prevent compilers from\noptimizing away necessary arithmetic operations by swapping their sequences\nor transform the equation to some 'equivalent' from.\n\nThe method is to multiply an artifical variable, ONE, which will be known to\nthe compiler to be one only at the runtime. The whole expression is then represented\nas a polynomial with respective to ONE. In the coefficients of all terms, only one a\nand one b should appear\n\nerr = (a + b) * ONE^6 - a * ONE^5 - (a + b) * ONE^4 + a * ONE^3 - b - (a + b) * ONE^2 + a * ONE\n*/\n\nvec2 twoSum(float a, float b) {\n  float s = (a + b);\n  float v = (s * ONE - a) * ONE;\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);\n  return vec2(s, err);\n}\n#else\nvec2 twoSum(float a, float b) {\n  float s = a + b;\n  float v = s - a;\n  float err = (a - (s - v)) + (b - v);\n  return vec2(s, err);\n}\n#endif\n\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\n/* Same thing as in twoSum() */\nvec2 twoSub(float a, float b) {\n  float s = (a - b);\n  float v = (s * ONE - a) * ONE;\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);\n  return vec2(s, err);\n}\n#else\nvec2 twoSub(float a, float b) {\n  float s = a - b;\n  float v = s - a;\n  float err = (a - (s - v)) - (b + v);\n  return vec2(s, err);\n}\n#endif\n\nvec2 twoProd(float a, float b) {\n  float prod = a * b;\n  vec2 a_fp64 = split(a);\n  vec2 b_fp64 = split(b);\n  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +\n    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;\n  return vec2(prod, err);\n}\n\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\nvec2 twoSqr(float a) {\n  float prod = a * a;\n  vec2 a_fp64 = split(a);\n\n  float err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x *\n    a_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;\n  return vec2(prod, err);\n}\n#else\nvec2 twoSqr(float a) {\n  float prod = a * a;\n  vec2 a_fp64 = split(a);\n\n  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;\n  return vec2(prod, err);\n}\n#endif\n\nvec2 sum_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSum(a.x, b.x);\n  t = twoSum(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 sub_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSub(a.x, b.x);\n  t = twoSub(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 mul_fp64(vec2 a, vec2 b) {\n  vec2 prod = twoProd(a.x, b.x);\n  // y component is for the error\n  prod.y += a.x * b.y;\n  prod.y += a.y * b.x;\n  prod = quickTwoSum(prod.x, prod.y);\n  return prod;\n}\n\nvec2 div_fp64(vec2 a, vec2 b) {\n  float xn = 1.0 / b.x;\n  vec2 yn = a * xn;\n  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;\n  vec2 prod = twoProd(xn, diff);\n  return sum_fp64(yn, prod);\n}\n\nvec2 sqrt_fp64(vec2 a) {\n\n  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n\n  float x = 1.0 / sqrt(a.x);\n  float yn = a.x * x;\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  vec2 yn_sqr = twoSqr(yn) * ONE;\n#else\n  vec2 yn_sqr = twoSqr(yn);\n#endif\n  float diff = sub_fp64(a, yn_sqr).x;\n  vec2 prod = twoProd(x * 0.5, diff);\n  return sum_fp64(vec2(yn, 0.0), prod);\n}\n\n/* k_power controls how much range reduction we would like to have\nRange reduction uses the following method:\nassume a = k_power * r + m * log(2), k and m being integers.\nSet k_power = 4 (we can choose other k to trade accuracy with performance.\nwe only need to calculate exp(r) and using exp(a) = 2^m * exp(r)^k_power;\n*/\n\nvec2 exp_fp64(vec2 a) {\n  // We need to make sure these two numbers match\n  // as bit-wise shift is not available in GLSL 1.0\n  const int k_power = 4;\n  const float k = 16.0;\n\n  const float inv_k = 1.0 / k;\n\n  if (a.x <= -88.0) return vec2(0.0, 0.0);\n  if (a.x >= 88.0) return vec2(1.0 / 0.0, 1.0 / 0.0);\n  if (a.x == 0.0 && a.y == 0.0) return vec2(1.0, 0.0);\n  if (a.x == 1.0 && a.y == 0.0) return E_FP64;\n\n  float m = floor(a.x / LOG2_FP64.x + 0.5);\n  vec2 r = sub_fp64(a, mul_fp64(LOG2_FP64, vec2(m, 0.0))) * inv_k;\n  vec2 s, t, p;\n\n  p = mul_fp64(r, r);\n  s = sum_fp64(r, p * 0.5);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_3_FP64);\n\n  s = sum_fp64(s, t);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_4_FP64);\n\n  s = sum_fp64(s, t);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_5_FP64);\n\n  // s = sum_fp64(s, t);\n  // p = mul_fp64(p, r);\n  // t = mul_fp64(p, INVERSE_FACTORIAL_6_FP64);\n\n  // s = sum_fp64(s, t);\n  // p = mul_fp64(p, r);\n  // t = mul_fp64(p, INVERSE_FACTORIAL_7_FP64);\n\n  s = sum_fp64(s, t);\n\n\n  // At this point, s = exp(r) - 1; but after following 4 recursions, we will get exp(r) ^ 512 - 1.\n  for (int i = 0; i < k_power; i++) {\n    s = sum_fp64(s * 2.0, mul_fp64(s, s));\n  }\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s = sum_fp64(s, vec2(ONE, 0.0));\n#else\n  s = sum_fp64(s, vec2(1.0, 0.0));\n#endif\n\n  return s * pow(2.0, m);\n//   return r;\n}\n\nvec2 log_fp64(vec2 a)\n{\n  if (a.x == 1.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x <= 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n  vec2 x = vec2(log(a.x), 0.0);\n  vec2 s;\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s = vec2(ONE, 0.0);\n#else\n  s = vec2(1.0, 0.0);\n#endif\n\n  x = sub_fp64(sum_fp64(x, mul_fp64(a, exp_fp64(-x))), s);\n  return x;\n}\n\nvec2 sin_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x == 0.0 && a.y == 0.0) {\n    return vec2(0.0, 0.0);\n  }\n\n  x = -mul_fp64(a, a);\n  s = a;\n  r = a;\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_3_FP64);\n  s = sum_fp64(s, t);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_5_FP64);\n  s = sum_fp64(s, t);\n\n  /* keep the following commented code in case we need them\n  for extra accuracy from the Taylor expansion*/\n\n  // r = mul_fp64(r, x);\n  // t = mul_fp64(r, INVERSE_FACTORIAL_7_FP64);\n  // s = sum_fp64(s, t);\n\n  // r = mul_fp64(r, x);\n  // t = mul_fp64(r, INVERSE_FACTORIAL_9_FP64);\n  // s = sum_fp64(s, t);\n\n  return s;\n}\n\nvec2 cos_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x == 0.0 && a.y == 0.0) {\n    return vec2(1.0, 0.0);\n  }\n\n  x = -mul_fp64(a, a);\n  r = x;\n  s = sum_fp64(vec2(1.0, 0.0), r * 0.5);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_4_FP64);\n  s = sum_fp64(s, t);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_6_FP64);\n  s = sum_fp64(s, t);\n\n  /* keep the following commented code in case we need them\n  for extra accuracy from the Taylor expansion*/\n\n  // r = mul_fp64(r, x);\n  // t = mul_fp64(r, INVERSE_FACTORIAL_8_FP64);\n  // s = sum_fp64(s, t);\n\n  // r = mul_fp64(r, x);\n  // t = mul_fp64(r, INVERSE_FACTORIAL_10_FP64);\n  // s = sum_fp64(s, t);\n\n  return s;\n}\n\nvoid sincos_taylor_fp64(vec2 a, out vec2 sin_t, out vec2 cos_t) {\n  if (a.x == 0.0 && a.y == 0.0) {\n    sin_t = vec2(0.0, 0.0);\n    cos_t = vec2(1.0, 0.0);\n  }\n\n  sin_t = sin_taylor_fp64(a);\n  cos_t = sqrt_fp64(sub_fp64(vec2(1.0, 0.0), mul_fp64(sin_t, sin_t)));\n}\n\nvec2 sin_fp64(vec2 a) {\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(0.0, 0.0);\n    }\n\n    // 2pi range reduction\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n\n    if (k == 0) {\n        if (j == 0) {\n            return sin_taylor_fp64(t);\n        } else if (j == 1) {\n            return cos_taylor_fp64(t);\n        } else if (j == -1) {\n            return -cos_taylor_fp64(t);\n        } else {\n            return -sin_taylor_fp64(t);\n        }\n    }\n\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) < 0.5) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k == 1) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs_k == 2) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs_k == 3) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs_k == 4) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n\n\n    vec2 result = vec2(0.0, 0.0);\n    if (j == 0) {\n        if (k > 0) {\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else if (j == 1) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j == -1) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result = -sum_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        }\n    } else {\n        if (k > 0) {\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 cos_fp64(vec2 a) {\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(1.0, 0.0);\n    }\n\n    // 2pi range reduction\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n\n    if (k == 0) {\n        if (j == 0) {\n            return cos_taylor_fp64(t);\n        } else if (j == 1) {\n            return -sin_taylor_fp64(t);\n        } else if (j == -1) {\n            return sin_taylor_fp64(t);\n        } else {\n            return -cos_taylor_fp64(t);\n        }\n    }\n\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) < 0.5) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k == 1) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs_k == 2) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs_k == 3) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs_k == 4) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    vec2 result = vec2(0.0, 0.0);\n    if (j == 0) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j == 1) {\n        if (k > 0) {\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    } else if (j == -1) {\n        if (k > 0) {\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result = -sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 tan_fp64(vec2 a) {\n    vec2 sin_a;\n    vec2 cos_a;\n\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(0.0, 0.0);\n    }\n\n    // 2pi range reduction\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    // We just can't get PI/16 * 3.0 very accurately.\n    // so let's just store it\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n    vec2 sin_t, cos_t;\n    vec2 s, c;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0_FP64;\n            v = SIN_TABLE_0_FP64;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1_FP64;\n            v = SIN_TABLE_1_FP64;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2_FP64;\n            v = SIN_TABLE_2_FP64;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3_FP64;\n            v = SIN_TABLE_3_FP64;\n        }\n#else\n        if (abs_k == 1) {\n            u = COS_TABLE_0_FP64;\n            v = SIN_TABLE_0_FP64;\n        } else if (abs_k == 2) {\n            u = COS_TABLE_1_FP64;\n            v = SIN_TABLE_1_FP64;\n        } else if (abs_k == 3) {\n            u = COS_TABLE_2_FP64;\n            v = SIN_TABLE_2_FP64;\n        } else if (abs_k == 4) {\n            u = COS_TABLE_3_FP64;\n            v = SIN_TABLE_3_FP64;\n        }\n#endif\n        if (k > 0) {\n            s = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            s = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return div_fp64(sin_a, cos_a);\n}\n\nvec2 radians_fp64(vec2 degree) {\n  return mul_fp64(degree, PI_180_FP64);\n}\n\nvec2 mix_fp64(vec2 a, vec2 b, float x) {\n  vec2 range = sub_fp64(b, a);\n  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));\n}\n\n// Vector functions\n// vec2 functions\nvoid vec2_sum_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = sum_fp64(a[0], b[0]);\n    out_val[1] = sum_fp64(a[1], b[1]);\n}\n\nvoid vec2_sub_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = sub_fp64(a[0], b[0]);\n    out_val[1] = sub_fp64(a[1], b[1]);\n}\n\nvoid vec2_mul_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = mul_fp64(a[0], b[0]);\n    out_val[1] = mul_fp64(a[1], b[1]);\n}\n\nvoid vec2_div_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = div_fp64(a[0], b[0]);\n    out_val[1] = div_fp64(a[1], b[1]);\n}\n\nvoid vec2_mix_fp64(vec2 x[2], vec2 y[2], float a, out vec2 out_val[2]) {\n  vec2 range[2];\n  vec2_sub_fp64(y, x, range);\n  vec2 portion[2];\n  portion[0] = range[0] * a;\n  portion[1] = range[1] * a;\n  vec2_sum_fp64(x, portion, out_val);\n}\n\nvec2 vec2_length_fp64(vec2 x[2]) {\n  return sqrt_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])));\n}\n\nvoid vec2_normalize_fp64(vec2 x[2], out vec2 out_val[2]) {\n  vec2 length = vec2_length_fp64(x);\n  vec2 length_vec2[2];\n  length_vec2[0] = length;\n  length_vec2[1] = length;\n\n  vec2_div_fp64(x, length_vec2, out_val);\n}\n\nvec2 vec2_distance_fp64(vec2 x[2], vec2 y[2]) {\n  vec2 diff[2];\n  vec2_sub_fp64(x, y, diff);\n  return vec2_length_fp64(diff);\n}\n\nvec2 vec2_dot_fp64(vec2 a[2], vec2 b[2]) {\n  vec2 v[2];\n\n  v[0] = mul_fp64(a[0], b[0]);\n  v[1] = mul_fp64(a[1], b[1]);\n\n  return sum_fp64(v[0], v[1]);\n}\n\n// vec3 functions\nvoid vec3_sub_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i = 0; i < 3; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec3_sum_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i = 0; i < 3; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvec2 vec3_length_fp64(vec2 x[3]) {\n  return sqrt_fp64(sum_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])),\n    mul_fp64(x[2], x[2])));\n}\n\nvec2 vec3_distance_fp64(vec2 x[3], vec2 y[3]) {\n  vec2 diff[3];\n  vec3_sub_fp64(x, y, diff);\n  return vec3_length_fp64(diff);\n}\n\n// vec4 functions\nvoid vec4_fp64(vec4 a, out vec2 out_val[4]) {\n  out_val[0].x = a[0];\n  out_val[0].y = 0.0;\n\n  out_val[1].x = a[1];\n  out_val[1].y = 0.0;\n\n  out_val[2].x = a[2];\n  out_val[2].y = 0.0;\n\n  out_val[3].x = a[3];\n  out_val[3].y = 0.0;\n}\n\nvoid vec4_scalar_mul_fp64(vec2 a[4], vec2 b, out vec2 out_val[4]) {\n  out_val[0] = mul_fp64(a[0], b);\n  out_val[1] = mul_fp64(a[1], b);\n  out_val[2] = mul_fp64(a[2], b);\n  out_val[3] = mul_fp64(a[3], b);\n}\n\nvoid vec4_sum_fp64(vec2 a[4], vec2 b[4], out vec2 out_val[4]) {\n  for (int i = 0; i < 4; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec4_dot_fp64(vec2 a[4], vec2 b[4], out vec2 out_val) {\n  vec2 v[4];\n\n  v[0] = mul_fp64(a[0], b[0]);\n  v[1] = mul_fp64(a[1], b[1]);\n  v[2] = mul_fp64(a[2], b[2]);\n  v[3] = mul_fp64(a[3], b[3]);\n\n  out_val = sum_fp64(sum_fp64(v[0], v[1]), sum_fp64(v[2], v[3]));\n}\n\nvoid mat4_vec4_mul_fp64(vec2 b[16], vec2 a[4], out vec2 out_val[4]) {\n  vec2 tmp[4];\n\n  for (int i = 0; i < 4; i++)\n  {\n    for (int j = 0; j < 4; j++)\n    {\n      tmp[j] = b[j + i * 4];\n    }\n    vec4_dot_fp64(a, tmp, out_val[i]);\n  }\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcmxpYi9mcDY0L21hdGgtZnA2NC5nbHNsLmpzP2Q3NGUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE2IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuZXhwb3J0IGRlZmF1bHQgYFxcXG51bmlmb3JtIGZsb2F0IE9ORTtcblxuY29uc3QgdmVjMiBFX0ZQNjQgPSB2ZWMyKDIuNzE4MjgxNzQ1OTEwNjQ0NWUrMDAsIDguMjU0ODQwMzY2ODE3MDA3ZS0wOCk7XG5jb25zdCB2ZWMyIExPRzJfRlA2NCA9IHZlYzIoMC42OTMxNDcxODI0NjQ1OTk2ZSswMCwgLTEuOTA0NjU0MjEyMTI1OTMzNmUtMDkpO1xuY29uc3QgdmVjMiBQSV9GUDY0ID0gdmVjMigzLjE0MTU5Mjc0MTAxMjU3MzIsIC04Ljc0MjI3ODAxMjYxODk1NGUtOCk7XG5jb25zdCB2ZWMyIFRXT19QSV9GUDY0ID0gdmVjMig2LjI4MzE4NTQ4MjAyNTE0NjUsIC0xLjc0ODQ1NTYwMjUyMzc5MDdlLTcpO1xuY29uc3QgdmVjMiBQSV8yX0ZQNjQgPSB2ZWMyKDEuNTcwNzk2MzcwNTA2Mjg2NiwgLTQuMzcxMTM5MDA2MzA5NDc3ZS04KTtcbmNvbnN0IHZlYzIgUElfNF9GUDY0ID0gdmVjMigwLjc4NTM5ODE4NTI1MzE0MzMsIC0yLjE4NTU2OTUwMzE1NDczODRlLTgpO1xuY29uc3QgdmVjMiBQSV8xNl9GUDY0ID0gdmVjMigwLjE5NjM0OTU0NjMxMzI4NTgzLCAtNS40NjM5MjM3NTc4ODY4NDZlLTkpO1xuY29uc3QgdmVjMiBQSV8xNl8yX0ZQNjQgPSB2ZWMyKDAuMzkyNjk5MDkyNjI2NTcxNjYsIC0xLjA5Mjc4NDc1MTU3NzM2OTJlLTgpO1xuY29uc3QgdmVjMiBQSV8xNl8zX0ZQNjQgPSB2ZWMyKDAuNTg5MDQ4NjI0MDM4Njk2MywgLTEuNDkwNjEwMDc5ODEyODgxOGUtOSk7XG5jb25zdCB2ZWMyIFBJXzE4MF9GUDY0ID0gdmVjMigwLjAxNzQ1MzI5MjM4NDc0MzY5LCAxLjM1MTk5NjA0OTgzNjQ5MDJlLTEwKTtcblxuY29uc3QgdmVjMiBTSU5fVEFCTEVfMF9GUDY0ID0gdmVjMigwLjE5NTA5MDMyMzY4NjU5OTczLCAtMS42NzA0NzE0ODMzNjE1MjQyZS05KTtcbmNvbnN0IHZlYzIgU0lOX1RBQkxFXzFfRlA2NCA9IHZlYzIoMC4zODI2ODM0MjYxNDE3Mzg5LCA2LjIyMzM1MDg5MDE3NzY3ZS05KTtcbmNvbnN0IHZlYzIgU0lOX1RBQkxFXzJfRlA2NCA9IHZlYzIoMC41NTU1NzAyNDQ3ODkxMjM1LCAtMS4xNzY5NTIxMzU3NTA3NTI5ZS04KTtcbmNvbnN0IHZlYzIgU0lOX1RBQkxFXzNfRlA2NCA9IHZlYzIoMC43MDcxMDY3NjkwODQ5MzA0LCAxLjIxMDE2MTcwNDE3OTMxMzNlLTgpO1xuXG5jb25zdCB2ZWMyIENPU19UQUJMRV8wX0ZQNjQgPSB2ZWMyKDAuOTgwNzg1MjUwNjYzNzU3MywgMi45NzM5NDczMTA2MzYwNDkyZS04KTtcbmNvbnN0IHZlYzIgQ09TX1RBQkxFXzFfRlA2NCA9IHZlYzIoMC45MjM4Nzk1MDQyMDM3OTY0LCAyLjgzMDc0OTAzNTE3NjQzODZlLTgpO1xuY29uc3QgdmVjMiBDT1NfVEFCTEVfMl9GUDY0ID0gdmVjMigwLjgzMTQ2OTU5NTQzMjI4MTUsIDEuNjg3MDI2Mzc0MTUzMDc3OGUtOCk7XG5jb25zdCB2ZWMyIENPU19UQUJMRV8zX0ZQNjQgPSB2ZWMyKDAuNzA3MTA2NzY5MDg0OTMwNCwgMS4yMTAxNjE3MTUyODE1NDM2ZS04KTtcblxuY29uc3QgdmVjMiBJTlZFUlNFX0ZBQ1RPUklBTF8zX0ZQNjQgPSB2ZWMyKDEuNjY2NjY2NzE2MzM3MjA0ZS0wMSwgLTQuOTY3MDUzODc5MzEyMjg5ZS0wOSk7IC8vIDEvMyFcbmNvbnN0IHZlYzIgSU5WRVJTRV9GQUNUT1JJQUxfNF9GUDY0ID0gdmVjMig0LjE2NjY2Njc5MDg0MzAxZS0wMiwgLTEuMjQxNzYzNDY5ODI4MDcyMmUtMDkpOyAvLyAxLzQhXG5jb25zdCB2ZWMyIElOVkVSU0VfRkFDVE9SSUFMXzVfRlA2NCA9IHZlYzIoOC4zMzMzMzM3Njc5NTA1MzVlLTAzLCAtNC4zNDYxNzIwMzMzNzU5NWUtMTApOyAvLyAxLzUhXG5jb25zdCB2ZWMyIElOVkVSU0VfRkFDVE9SSUFMXzZfRlA2NCA9IHZlYzIoMS4zODg4ODg5MjI1MTk5ODE5ZS0wMywgLTMuMzYzMTA5NDQzNzEwMzIxNWUtMTEpOyAvLyAxLzYhXG5jb25zdCB2ZWMyIElOVkVSU0VfRkFDVE9SSUFMXzdfRlA2NCA9IHZlYzIoMS45ODQxMjcwMTEzODI5NTIzZS0wNCwgIC0yLjcyNTU5Njg3NDkzMzQ1NmUtMTIpOyAvLyAxLzchXG5jb25zdCB2ZWMyIElOVkVSU0VfRkFDVE9SSUFMXzhfRlA2NCA9IHZlYzIoMi40ODAxNTg3NjQyMjg2OTA0ZS0wNSwgLTMuNDA2OTk2MDI1OTA0MTg0ZS0xMyk7IC8vIDEvOCFcbmNvbnN0IHZlYzIgSU5WRVJTRV9GQUNUT1JJQUxfOV9GUDY0ID0gdmVjMigyLjc1NTczMTg4NDQ2Mjg3NTMzZS0wNiwgMy43OTM1NzEzOTM3MDM4MTg2ZS0xNCk7IC8vIDEvOSFcbmNvbnN0IHZlYzIgSU5WRVJTRV9GQUNUT1JJQUxfMTBfRlA2NCA9IHZlYzIoMi43NTU3MzE5OTgxNDk3MTNlLTA3LCAtNy41NzUxMTIzNjc4Njk4NzNlLTE1KTsgLy8gMS8xMCFcblxuZmxvYXQgbmludChmbG9hdCBkKSB7XG4gICAgaWYgKGQgPT0gZmxvb3IoZCkpIHJldHVybiBkO1xuICAgIHJldHVybiBmbG9vcihkICsgMC41KTtcbn1cblxuI2lmIGRlZmluZWQoTlZJRElBX0ZQNjRfV09SS0FST1VORCkgfHwgZGVmaW5lZChJTlRFTF9GUDY0X1dPUktBUk9VTkQpXG52ZWMyIHNwbGl0KGZsb2F0IGEpIHtcbiAgY29uc3QgZmxvYXQgU1BMSVQgPSA0MDk3LjA7XG4gIGZsb2F0IHQgPSBhICogU1BMSVQ7XG4gIGZsb2F0IGFfaGkgPSB0ICogT05FIC0gKHQgLSBhKTtcbiAgZmxvYXQgYV9sbyA9IGEgKiBPTkUgLSBhX2hpO1xuICByZXR1cm4gdmVjMihhX2hpLCBhX2xvKTtcbn1cbiNlbHNlXG52ZWMyIHNwbGl0KGZsb2F0IGEpIHtcbiAgY29uc3QgZmxvYXQgU1BMSVQgPSA0MDk3LjA7XG4gIGZsb2F0IHQgPSBhICogU1BMSVQ7XG4gIGZsb2F0IGFfaGkgPSB0IC0gKHQgLSBhKTtcbiAgZmxvYXQgYV9sbyA9IGEgLSBhX2hpO1xuICByZXR1cm4gdmVjMihhX2hpLCBhX2xvKTtcbn1cbiNlbmRpZlxuXG4jaWYgZGVmaW5lZChOVklESUFfRVFVQVRJT05fV09SS0FST1VORCkgfHwgZGVmaW5lZChJTlRFTF9FUVVBVElPTl9XT1JLQVJPVU5EKVxudmVjMiBxdWlja1R3b1N1bShmbG9hdCBhLCBmbG9hdCBiKSB7XG4gIGZsb2F0IHN1bSA9IChhICsgYikgKiBPTkU7XG4gIGZsb2F0IGVyciA9IGIgLSAoc3VtIC0gYSkgKiBPTkU7XG4gIHJldHVybiB2ZWMyKHN1bSwgZXJyKTtcbn1cbiNlbHNlXG52ZWMyIHF1aWNrVHdvU3VtKGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgZmxvYXQgc3VtID0gYSArIGI7XG4gIGZsb2F0IGVyciA9IGIgLSAoc3VtIC0gYSk7XG4gIHJldHVybiB2ZWMyKHN1bSwgZXJyKTtcbn1cbiNlbmRpZlxuXG52ZWMyIG5pbnRfZnA2NCh2ZWMyIGEpIHtcbiAgICBmbG9hdCBoaSA9IG5pbnQoYS54KTtcbiAgICBmbG9hdCBsbztcbiAgICB2ZWMyIHRtcDtcbiAgICBpZiAoaGkgPT0gYS54KSB7XG4gICAgICAgIGxvID0gbmludChhLnkpO1xuICAgICAgICB0bXAgPSBxdWlja1R3b1N1bShoaSwgbG8pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxvID0gMC4wO1xuICAgICAgICBpZiAoYWJzKGhpIC0gYS54KSA9PSAwLjUgJiYgYS55IDwgMC4wKSB7XG4gICAgICAgICAgICBoaSAtPSAxLjA7XG4gICAgICAgIH1cbiAgICAgICAgdG1wID0gdmVjMihoaSwgbG8pO1xuICAgIH1cbiAgICByZXR1cm4gdG1wO1xufVxuXG4jaWYgZGVmaW5lZChOVklESUFfRVFVQVRJT05fV09SS0FST1VORCkgfHwgZGVmaW5lZChJTlRFTF9FUVVBVElPTl9XT1JLQVJPVU5EKVxuXG4vKiBUaGUgcHVycG9zZSBvZiB0aGlzIHdvcmthcm91bmQgaXMgdG8gcHJldmVudCBjb21waWxlcnMgZnJvbVxub3B0aW1pemluZyBhd2F5IG5lY2Vzc2FyeSBhcml0aG1ldGljIG9wZXJhdGlvbnMgYnkgc3dhcHBpbmcgdGhlaXIgc2VxdWVuY2VzXG5vciB0cmFuc2Zvcm0gdGhlIGVxdWF0aW9uIHRvIHNvbWUgJ2VxdWl2YWxlbnQnIGZyb20uXG5cblRoZSBtZXRob2QgaXMgdG8gbXVsdGlwbHkgYW4gYXJ0aWZpY2FsIHZhcmlhYmxlLCBPTkUsIHdoaWNoIHdpbGwgYmUga25vd24gdG9cbnRoZSBjb21waWxlciB0byBiZSBvbmUgb25seSBhdCB0aGUgcnVudGltZS4gVGhlIHdob2xlIGV4cHJlc3Npb24gaXMgdGhlbiByZXByZXNlbnRlZFxuYXMgYSBwb2x5bm9taWFsIHdpdGggcmVzcGVjdGl2ZSB0byBPTkUuIEluIHRoZSBjb2VmZmljaWVudHMgb2YgYWxsIHRlcm1zLCBvbmx5IG9uZSBhXG5hbmQgb25lIGIgc2hvdWxkIGFwcGVhclxuXG5lcnIgPSAoYSArIGIpICogT05FXjYgLSBhICogT05FXjUgLSAoYSArIGIpICogT05FXjQgKyBhICogT05FXjMgLSBiIC0gKGEgKyBiKSAqIE9ORV4yICsgYSAqIE9ORVxuKi9cblxudmVjMiB0d29TdW0oZmxvYXQgYSwgZmxvYXQgYikge1xuICBmbG9hdCBzID0gKGEgKyBiKTtcbiAgZmxvYXQgdiA9IChzICogT05FIC0gYSkgKiBPTkU7XG4gIGZsb2F0IGVyciA9IChhIC0gKHMgLSB2KSAqIE9ORSkgKiBPTkUgKiBPTkUgKiBPTkUgKyAoYiAtIHYpO1xuICByZXR1cm4gdmVjMihzLCBlcnIpO1xufVxuI2Vsc2VcbnZlYzIgdHdvU3VtKGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgZmxvYXQgcyA9IGEgKyBiO1xuICBmbG9hdCB2ID0gcyAtIGE7XG4gIGZsb2F0IGVyciA9IChhIC0gKHMgLSB2KSkgKyAoYiAtIHYpO1xuICByZXR1cm4gdmVjMihzLCBlcnIpO1xufVxuI2VuZGlmXG5cbiNpZiBkZWZpbmVkKE5WSURJQV9FUVVBVElPTl9XT1JLQVJPVU5EKSB8fCBkZWZpbmVkKElOVEVMX0VRVUFUSU9OX1dPUktBUk9VTkQpXG4vKiBTYW1lIHRoaW5nIGFzIGluIHR3b1N1bSgpICovXG52ZWMyIHR3b1N1YihmbG9hdCBhLCBmbG9hdCBiKSB7XG4gIGZsb2F0IHMgPSAoYSAtIGIpO1xuICBmbG9hdCB2ID0gKHMgKiBPTkUgLSBhKSAqIE9ORTtcbiAgZmxvYXQgZXJyID0gKGEgLSAocyAtIHYpICogT05FKSAqIE9ORSAqIE9ORSAqIE9ORSAtIChiICsgdik7XG4gIHJldHVybiB2ZWMyKHMsIGVycik7XG59XG4jZWxzZVxudmVjMiB0d29TdWIoZmxvYXQgYSwgZmxvYXQgYikge1xuICBmbG9hdCBzID0gYSAtIGI7XG4gIGZsb2F0IHYgPSBzIC0gYTtcbiAgZmxvYXQgZXJyID0gKGEgLSAocyAtIHYpKSAtIChiICsgdik7XG4gIHJldHVybiB2ZWMyKHMsIGVycik7XG59XG4jZW5kaWZcblxudmVjMiB0d29Qcm9kKGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgZmxvYXQgcHJvZCA9IGEgKiBiO1xuICB2ZWMyIGFfZnA2NCA9IHNwbGl0KGEpO1xuICB2ZWMyIGJfZnA2NCA9IHNwbGl0KGIpO1xuICBmbG9hdCBlcnIgPSAoKGFfZnA2NC54ICogYl9mcDY0LnggLSBwcm9kKSArIGFfZnA2NC54ICogYl9mcDY0LnkgK1xuICAgIGFfZnA2NC55ICogYl9mcDY0LngpICsgYV9mcDY0LnkgKiBiX2ZwNjQueTtcbiAgcmV0dXJuIHZlYzIocHJvZCwgZXJyKTtcbn1cblxuI2lmIGRlZmluZWQoTlZJRElBX0VRVUFUSU9OX1dPUktBUk9VTkQpIHx8IGRlZmluZWQoSU5URUxfRVFVQVRJT05fV09SS0FST1VORClcbnZlYzIgdHdvU3FyKGZsb2F0IGEpIHtcbiAgZmxvYXQgcHJvZCA9IGEgKiBhO1xuICB2ZWMyIGFfZnA2NCA9IHNwbGl0KGEpO1xuXG4gIGZsb2F0IGVyciA9ICgoYV9mcDY0LnggKiBhX2ZwNjQueCAtIHByb2QpICogT05FICsgMi4wICogYV9mcDY0LnggKlxuICAgIGFfZnA2NC55ICogT05FICogT05FKSArIGFfZnA2NC55ICogYV9mcDY0LnkgKiBPTkUgKiBPTkUgKiBPTkU7XG4gIHJldHVybiB2ZWMyKHByb2QsIGVycik7XG59XG4jZWxzZVxudmVjMiB0d29TcXIoZmxvYXQgYSkge1xuICBmbG9hdCBwcm9kID0gYSAqIGE7XG4gIHZlYzIgYV9mcDY0ID0gc3BsaXQoYSk7XG5cbiAgZmxvYXQgZXJyID0gKChhX2ZwNjQueCAqIGFfZnA2NC54IC0gcHJvZCkgKyAyLjAgKiBhX2ZwNjQueCAqIGFfZnA2NC55KSArIGFfZnA2NC55ICogYV9mcDY0Lnk7XG4gIHJldHVybiB2ZWMyKHByb2QsIGVycik7XG59XG4jZW5kaWZcblxudmVjMiBzdW1fZnA2NCh2ZWMyIGEsIHZlYzIgYikge1xuICB2ZWMyIHMsIHQ7XG4gIHMgPSB0d29TdW0oYS54LCBiLngpO1xuICB0ID0gdHdvU3VtKGEueSwgYi55KTtcbiAgcy55ICs9IHQueDtcbiAgcyA9IHF1aWNrVHdvU3VtKHMueCwgcy55KTtcbiAgcy55ICs9IHQueTtcbiAgcyA9IHF1aWNrVHdvU3VtKHMueCwgcy55KTtcbiAgcmV0dXJuIHM7XG59XG5cbnZlYzIgc3ViX2ZwNjQodmVjMiBhLCB2ZWMyIGIpIHtcbiAgdmVjMiBzLCB0O1xuICBzID0gdHdvU3ViKGEueCwgYi54KTtcbiAgdCA9IHR3b1N1YihhLnksIGIueSk7XG4gIHMueSArPSB0Lng7XG4gIHMgPSBxdWlja1R3b1N1bShzLngsIHMueSk7XG4gIHMueSArPSB0Lnk7XG4gIHMgPSBxdWlja1R3b1N1bShzLngsIHMueSk7XG4gIHJldHVybiBzO1xufVxuXG52ZWMyIG11bF9mcDY0KHZlYzIgYSwgdmVjMiBiKSB7XG4gIHZlYzIgcHJvZCA9IHR3b1Byb2QoYS54LCBiLngpO1xuICAvLyB5IGNvbXBvbmVudCBpcyBmb3IgdGhlIGVycm9yXG4gIHByb2QueSArPSBhLnggKiBiLnk7XG4gIHByb2QueSArPSBhLnkgKiBiLng7XG4gIHByb2QgPSBxdWlja1R3b1N1bShwcm9kLngsIHByb2QueSk7XG4gIHJldHVybiBwcm9kO1xufVxuXG52ZWMyIGRpdl9mcDY0KHZlYzIgYSwgdmVjMiBiKSB7XG4gIGZsb2F0IHhuID0gMS4wIC8gYi54O1xuICB2ZWMyIHluID0gYSAqIHhuO1xuICBmbG9hdCBkaWZmID0gKHN1Yl9mcDY0KGEsIG11bF9mcDY0KGIsIHluKSkpLng7XG4gIHZlYzIgcHJvZCA9IHR3b1Byb2QoeG4sIGRpZmYpO1xuICByZXR1cm4gc3VtX2ZwNjQoeW4sIHByb2QpO1xufVxuXG52ZWMyIHNxcnRfZnA2NCh2ZWMyIGEpIHtcblxuICBpZiAoYS54ID09IDAuMCAmJiBhLnkgPT0gMC4wKSByZXR1cm4gdmVjMigwLjAsIDAuMCk7XG4gIGlmIChhLnggPCAwLjApIHJldHVybiB2ZWMyKDAuMCAvIDAuMCwgMC4wIC8gMC4wKTtcblxuICBmbG9hdCB4ID0gMS4wIC8gc3FydChhLngpO1xuICBmbG9hdCB5biA9IGEueCAqIHg7XG4jaWYgZGVmaW5lZChOVklESUFfRlA2NF9XT1JLQVJPVU5EKSB8fCBkZWZpbmVkKElOVEVMX0ZQNjRfV09SS0FST1VORClcbiAgdmVjMiB5bl9zcXIgPSB0d29TcXIoeW4pICogT05FO1xuI2Vsc2VcbiAgdmVjMiB5bl9zcXIgPSB0d29TcXIoeW4pO1xuI2VuZGlmXG4gIGZsb2F0IGRpZmYgPSBzdWJfZnA2NChhLCB5bl9zcXIpLng7XG4gIHZlYzIgcHJvZCA9IHR3b1Byb2QoeCAqIDAuNSwgZGlmZik7XG4gIHJldHVybiBzdW1fZnA2NCh2ZWMyKHluLCAwLjApLCBwcm9kKTtcbn1cblxuLyoga19wb3dlciBjb250cm9scyBob3cgbXVjaCByYW5nZSByZWR1Y3Rpb24gd2Ugd291bGQgbGlrZSB0byBoYXZlXG5SYW5nZSByZWR1Y3Rpb24gdXNlcyB0aGUgZm9sbG93aW5nIG1ldGhvZDpcbmFzc3VtZSBhID0ga19wb3dlciAqIHIgKyBtICogbG9nKDIpLCBrIGFuZCBtIGJlaW5nIGludGVnZXJzLlxuU2V0IGtfcG93ZXIgPSA0ICh3ZSBjYW4gY2hvb3NlIG90aGVyIGsgdG8gdHJhZGUgYWNjdXJhY3kgd2l0aCBwZXJmb3JtYW5jZS5cbndlIG9ubHkgbmVlZCB0byBjYWxjdWxhdGUgZXhwKHIpIGFuZCB1c2luZyBleHAoYSkgPSAyXm0gKiBleHAocilea19wb3dlcjtcbiovXG5cbnZlYzIgZXhwX2ZwNjQodmVjMiBhKSB7XG4gIC8vIFdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoZXNlIHR3byBudW1iZXJzIG1hdGNoXG4gIC8vIGFzIGJpdC13aXNlIHNoaWZ0IGlzIG5vdCBhdmFpbGFibGUgaW4gR0xTTCAxLjBcbiAgY29uc3QgaW50IGtfcG93ZXIgPSA0O1xuICBjb25zdCBmbG9hdCBrID0gMTYuMDtcblxuICBjb25zdCBmbG9hdCBpbnZfayA9IDEuMCAvIGs7XG5cbiAgaWYgKGEueCA8PSAtODguMCkgcmV0dXJuIHZlYzIoMC4wLCAwLjApO1xuICBpZiAoYS54ID49IDg4LjApIHJldHVybiB2ZWMyKDEuMCAvIDAuMCwgMS4wIC8gMC4wKTtcbiAgaWYgKGEueCA9PSAwLjAgJiYgYS55ID09IDAuMCkgcmV0dXJuIHZlYzIoMS4wLCAwLjApO1xuICBpZiAoYS54ID09IDEuMCAmJiBhLnkgPT0gMC4wKSByZXR1cm4gRV9GUDY0O1xuXG4gIGZsb2F0IG0gPSBmbG9vcihhLnggLyBMT0cyX0ZQNjQueCArIDAuNSk7XG4gIHZlYzIgciA9IHN1Yl9mcDY0KGEsIG11bF9mcDY0KExPRzJfRlA2NCwgdmVjMihtLCAwLjApKSkgKiBpbnZfaztcbiAgdmVjMiBzLCB0LCBwO1xuXG4gIHAgPSBtdWxfZnA2NChyLCByKTtcbiAgcyA9IHN1bV9mcDY0KHIsIHAgKiAwLjUpO1xuICBwID0gbXVsX2ZwNjQocCwgcik7XG4gIHQgPSBtdWxfZnA2NChwLCBJTlZFUlNFX0ZBQ1RPUklBTF8zX0ZQNjQpO1xuXG4gIHMgPSBzdW1fZnA2NChzLCB0KTtcbiAgcCA9IG11bF9mcDY0KHAsIHIpO1xuICB0ID0gbXVsX2ZwNjQocCwgSU5WRVJTRV9GQUNUT1JJQUxfNF9GUDY0KTtcblxuICBzID0gc3VtX2ZwNjQocywgdCk7XG4gIHAgPSBtdWxfZnA2NChwLCByKTtcbiAgdCA9IG11bF9mcDY0KHAsIElOVkVSU0VfRkFDVE9SSUFMXzVfRlA2NCk7XG5cbiAgLy8gcyA9IHN1bV9mcDY0KHMsIHQpO1xuICAvLyBwID0gbXVsX2ZwNjQocCwgcik7XG4gIC8vIHQgPSBtdWxfZnA2NChwLCBJTlZFUlNFX0ZBQ1RPUklBTF82X0ZQNjQpO1xuXG4gIC8vIHMgPSBzdW1fZnA2NChzLCB0KTtcbiAgLy8gcCA9IG11bF9mcDY0KHAsIHIpO1xuICAvLyB0ID0gbXVsX2ZwNjQocCwgSU5WRVJTRV9GQUNUT1JJQUxfN19GUDY0KTtcblxuICBzID0gc3VtX2ZwNjQocywgdCk7XG5cblxuICAvLyBBdCB0aGlzIHBvaW50LCBzID0gZXhwKHIpIC0gMTsgYnV0IGFmdGVyIGZvbGxvd2luZyA0IHJlY3Vyc2lvbnMsIHdlIHdpbGwgZ2V0IGV4cChyKSBeIDUxMiAtIDEuXG4gIGZvciAoaW50IGkgPSAwOyBpIDwga19wb3dlcjsgaSsrKSB7XG4gICAgcyA9IHN1bV9mcDY0KHMgKiAyLjAsIG11bF9mcDY0KHMsIHMpKTtcbiAgfVxuXG4jaWYgZGVmaW5lZChOVklESUFfRlA2NF9XT1JLQVJPVU5EKSB8fCBkZWZpbmVkKElOVEVMX0ZQNjRfV09SS0FST1VORClcbiAgcyA9IHN1bV9mcDY0KHMsIHZlYzIoT05FLCAwLjApKTtcbiNlbHNlXG4gIHMgPSBzdW1fZnA2NChzLCB2ZWMyKDEuMCwgMC4wKSk7XG4jZW5kaWZcblxuICByZXR1cm4gcyAqIHBvdygyLjAsIG0pO1xuLy8gICByZXR1cm4gcjtcbn1cblxudmVjMiBsb2dfZnA2NCh2ZWMyIGEpXG57XG4gIGlmIChhLnggPT0gMS4wICYmIGEueSA9PSAwLjApIHJldHVybiB2ZWMyKDAuMCwgMC4wKTtcbiAgaWYgKGEueCA8PSAwLjApIHJldHVybiB2ZWMyKDAuMCAvIDAuMCwgMC4wIC8gMC4wKTtcbiAgdmVjMiB4ID0gdmVjMihsb2coYS54KSwgMC4wKTtcbiAgdmVjMiBzO1xuI2lmIGRlZmluZWQoTlZJRElBX0ZQNjRfV09SS0FST1VORCkgfHwgZGVmaW5lZChJTlRFTF9GUDY0X1dPUktBUk9VTkQpXG4gIHMgPSB2ZWMyKE9ORSwgMC4wKTtcbiNlbHNlXG4gIHMgPSB2ZWMyKDEuMCwgMC4wKTtcbiNlbmRpZlxuXG4gIHggPSBzdWJfZnA2NChzdW1fZnA2NCh4LCBtdWxfZnA2NChhLCBleHBfZnA2NCgteCkpKSwgcyk7XG4gIHJldHVybiB4O1xufVxuXG52ZWMyIHNpbl90YXlsb3JfZnA2NCh2ZWMyIGEpIHtcbiAgdmVjMiByLCBzLCB0LCB4O1xuXG4gIGlmIChhLnggPT0gMC4wICYmIGEueSA9PSAwLjApIHtcbiAgICByZXR1cm4gdmVjMigwLjAsIDAuMCk7XG4gIH1cblxuICB4ID0gLW11bF9mcDY0KGEsIGEpO1xuICBzID0gYTtcbiAgciA9IGE7XG5cbiAgciA9IG11bF9mcDY0KHIsIHgpO1xuICB0ID0gbXVsX2ZwNjQociwgSU5WRVJTRV9GQUNUT1JJQUxfM19GUDY0KTtcbiAgcyA9IHN1bV9mcDY0KHMsIHQpO1xuXG4gIHIgPSBtdWxfZnA2NChyLCB4KTtcbiAgdCA9IG11bF9mcDY0KHIsIElOVkVSU0VfRkFDVE9SSUFMXzVfRlA2NCk7XG4gIHMgPSBzdW1fZnA2NChzLCB0KTtcblxuICAvKiBrZWVwIHRoZSBmb2xsb3dpbmcgY29tbWVudGVkIGNvZGUgaW4gY2FzZSB3ZSBuZWVkIHRoZW1cbiAgZm9yIGV4dHJhIGFjY3VyYWN5IGZyb20gdGhlIFRheWxvciBleHBhbnNpb24qL1xuXG4gIC8vIHIgPSBtdWxfZnA2NChyLCB4KTtcbiAgLy8gdCA9IG11bF9mcDY0KHIsIElOVkVSU0VfRkFDVE9SSUFMXzdfRlA2NCk7XG4gIC8vIHMgPSBzdW1fZnA2NChzLCB0KTtcblxuICAvLyByID0gbXVsX2ZwNjQociwgeCk7XG4gIC8vIHQgPSBtdWxfZnA2NChyLCBJTlZFUlNFX0ZBQ1RPUklBTF85X0ZQNjQpO1xuICAvLyBzID0gc3VtX2ZwNjQocywgdCk7XG5cbiAgcmV0dXJuIHM7XG59XG5cbnZlYzIgY29zX3RheWxvcl9mcDY0KHZlYzIgYSkge1xuICB2ZWMyIHIsIHMsIHQsIHg7XG5cbiAgaWYgKGEueCA9PSAwLjAgJiYgYS55ID09IDAuMCkge1xuICAgIHJldHVybiB2ZWMyKDEuMCwgMC4wKTtcbiAgfVxuXG4gIHggPSAtbXVsX2ZwNjQoYSwgYSk7XG4gIHIgPSB4O1xuICBzID0gc3VtX2ZwNjQodmVjMigxLjAsIDAuMCksIHIgKiAwLjUpO1xuXG4gIHIgPSBtdWxfZnA2NChyLCB4KTtcbiAgdCA9IG11bF9mcDY0KHIsIElOVkVSU0VfRkFDVE9SSUFMXzRfRlA2NCk7XG4gIHMgPSBzdW1fZnA2NChzLCB0KTtcblxuICByID0gbXVsX2ZwNjQociwgeCk7XG4gIHQgPSBtdWxfZnA2NChyLCBJTlZFUlNFX0ZBQ1RPUklBTF82X0ZQNjQpO1xuICBzID0gc3VtX2ZwNjQocywgdCk7XG5cbiAgLyoga2VlcCB0aGUgZm9sbG93aW5nIGNvbW1lbnRlZCBjb2RlIGluIGNhc2Ugd2UgbmVlZCB0aGVtXG4gIGZvciBleHRyYSBhY2N1cmFjeSBmcm9tIHRoZSBUYXlsb3IgZXhwYW5zaW9uKi9cblxuICAvLyByID0gbXVsX2ZwNjQociwgeCk7XG4gIC8vIHQgPSBtdWxfZnA2NChyLCBJTlZFUlNFX0ZBQ1RPUklBTF84X0ZQNjQpO1xuICAvLyBzID0gc3VtX2ZwNjQocywgdCk7XG5cbiAgLy8gciA9IG11bF9mcDY0KHIsIHgpO1xuICAvLyB0ID0gbXVsX2ZwNjQociwgSU5WRVJTRV9GQUNUT1JJQUxfMTBfRlA2NCk7XG4gIC8vIHMgPSBzdW1fZnA2NChzLCB0KTtcblxuICByZXR1cm4gcztcbn1cblxudm9pZCBzaW5jb3NfdGF5bG9yX2ZwNjQodmVjMiBhLCBvdXQgdmVjMiBzaW5fdCwgb3V0IHZlYzIgY29zX3QpIHtcbiAgaWYgKGEueCA9PSAwLjAgJiYgYS55ID09IDAuMCkge1xuICAgIHNpbl90ID0gdmVjMigwLjAsIDAuMCk7XG4gICAgY29zX3QgPSB2ZWMyKDEuMCwgMC4wKTtcbiAgfVxuXG4gIHNpbl90ID0gc2luX3RheWxvcl9mcDY0KGEpO1xuICBjb3NfdCA9IHNxcnRfZnA2NChzdWJfZnA2NCh2ZWMyKDEuMCwgMC4wKSwgbXVsX2ZwNjQoc2luX3QsIHNpbl90KSkpO1xufVxuXG52ZWMyIHNpbl9mcDY0KHZlYzIgYSkge1xuICAgIGlmIChhLnggPT0gMC4wICYmIGEueSA9PSAwLjApIHtcbiAgICAgICAgcmV0dXJuIHZlYzIoMC4wLCAwLjApO1xuICAgIH1cblxuICAgIC8vIDJwaSByYW5nZSByZWR1Y3Rpb25cbiAgICB2ZWMyIHogPSBuaW50X2ZwNjQoZGl2X2ZwNjQoYSwgVFdPX1BJX0ZQNjQpKTtcbiAgICB2ZWMyIHIgPSBzdWJfZnA2NChhLCBtdWxfZnA2NChUV09fUElfRlA2NCwgeikpO1xuXG4gICAgdmVjMiB0O1xuICAgIGZsb2F0IHEgPSBmbG9vcihyLnggLyBQSV8yX0ZQNjQueCArIDAuNSk7XG4gICAgaW50IGogPSBpbnQocSk7XG5cbiAgICBpZiAoaiA8IC0yIHx8IGogPiAyKSB7XG4gICAgICAgIHJldHVybiB2ZWMyKDAuMCAvIDAuMCwgMC4wIC8gMC4wKTtcbiAgICB9XG5cbiAgICB0ID0gc3ViX2ZwNjQociwgbXVsX2ZwNjQoUElfMl9GUDY0LCB2ZWMyKHEsIDAuMCkpKTtcblxuICAgIHEgPSBmbG9vcih0LnggLyBQSV8xNl9GUDY0LnggKyAwLjUpO1xuICAgIGludCBrID0gaW50KHEpO1xuXG4gICAgaWYgKGsgPT0gMCkge1xuICAgICAgICBpZiAoaiA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gc2luX3RheWxvcl9mcDY0KHQpO1xuICAgICAgICB9IGVsc2UgaWYgKGogPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvc190YXlsb3JfZnA2NCh0KTtcbiAgICAgICAgfSBlbHNlIGlmIChqID09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gLWNvc190YXlsb3JfZnA2NCh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtc2luX3RheWxvcl9mcDY0KHQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW50IGFic19rID0gaW50KGFicyhmbG9hdChrKSkpO1xuXG4gICAgaWYgKGFic19rID4gNCkge1xuICAgICAgICByZXR1cm4gdmVjMigwLjAgLyAwLjAsIDAuMCAvIDAuMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdCA9IHN1Yl9mcDY0KHQsIG11bF9mcDY0KFBJXzE2X0ZQNjQsIHZlYzIocSwgMC4wKSkpO1xuICAgIH1cblxuICAgIHZlYzIgdSA9IHZlYzIoMC4wLCAwLjApO1xuICAgIHZlYzIgdiA9IHZlYzIoMC4wLCAwLjApO1xuXG4jaWYgZGVmaW5lZChOVklESUFfRVFVQVRJT05fV09SS0FST1VORCkgfHwgZGVmaW5lZChJTlRFTF9FUVVBVElPTl9XT1JLQVJPVU5EKVxuICAgIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gMS4wKSA8IDAuNSkge1xuICAgICAgICB1ID0gQ09TX1RBQkxFXzBfRlA2NDtcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8wX0ZQNjQ7XG4gICAgfSBlbHNlIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gMi4wKSA8IDAuNSkge1xuICAgICAgICB1ID0gQ09TX1RBQkxFXzFfRlA2NDtcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8xX0ZQNjQ7XG4gICAgfSBlbHNlIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gMy4wKSA8IDAuNSkge1xuICAgICAgICB1ID0gQ09TX1RBQkxFXzJfRlA2NDtcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8yX0ZQNjQ7XG4gICAgfSBlbHNlIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gNC4wKSA8IDAuNSkge1xuICAgICAgICB1ID0gQ09TX1RBQkxFXzNfRlA2NDtcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8zX0ZQNjQ7XG4gICAgfVxuI2Vsc2VcbiAgICBpZiAoYWJzX2sgPT0gMSkge1xuICAgICAgICB1ID0gQ09TX1RBQkxFXzBfRlA2NDtcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8wX0ZQNjQ7XG4gICAgfSBlbHNlIGlmIChhYnNfayA9PSAyKSB7XG4gICAgICAgIHUgPSBDT1NfVEFCTEVfMV9GUDY0O1xuICAgICAgICB2ID0gU0lOX1RBQkxFXzFfRlA2NDtcbiAgICB9IGVsc2UgaWYgKGFic19rID09IDMpIHtcbiAgICAgICAgdSA9IENPU19UQUJMRV8yX0ZQNjQ7XG4gICAgICAgIHYgPSBTSU5fVEFCTEVfMl9GUDY0O1xuICAgIH0gZWxzZSBpZiAoYWJzX2sgPT0gNCkge1xuICAgICAgICB1ID0gQ09TX1RBQkxFXzNfRlA2NDtcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8zX0ZQNjQ7XG4gICAgfVxuI2VuZGlmXG5cbiAgICB2ZWMyIHNpbl90LCBjb3NfdDtcbiAgICBzaW5jb3NfdGF5bG9yX2ZwNjQodCwgc2luX3QsIGNvc190KTtcblxuXG5cbiAgICB2ZWMyIHJlc3VsdCA9IHZlYzIoMC4wLCAwLjApO1xuICAgIGlmIChqID09IDApIHtcbiAgICAgICAgaWYgKGsgPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzdW1fZnA2NChtdWxfZnA2NCh1LCBzaW5fdCksIG11bF9mcDY0KHYsIGNvc190KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzdWJfZnA2NChtdWxfZnA2NCh1LCBzaW5fdCksIG11bF9mcDY0KHYsIGNvc190KSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGogPT0gMSkge1xuICAgICAgICBpZiAoayA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHN1Yl9mcDY0KG11bF9mcDY0KHUsIGNvc190KSwgbXVsX2ZwNjQodiwgc2luX3QpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHN1bV9mcDY0KG11bF9mcDY0KHUsIGNvc190KSwgbXVsX2ZwNjQodiwgc2luX3QpKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaiA9PSAtMSkge1xuICAgICAgICBpZiAoayA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHN1Yl9mcDY0KG11bF9mcDY0KHYsIHNpbl90KSwgbXVsX2ZwNjQodSwgY29zX3QpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IC1zdW1fZnA2NChtdWxfZnA2NCh2LCBzaW5fdCksIG11bF9mcDY0KHUsIGNvc190KSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoayA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IC1zdW1fZnA2NChtdWxfZnA2NCh1LCBzaW5fdCksIG11bF9mcDY0KHYsIGNvc190KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzdWJfZnA2NChtdWxfZnA2NCh2LCBjb3NfdCksIG11bF9mcDY0KHUsIHNpbl90KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG52ZWMyIGNvc19mcDY0KHZlYzIgYSkge1xuICAgIGlmIChhLnggPT0gMC4wICYmIGEueSA9PSAwLjApIHtcbiAgICAgICAgcmV0dXJuIHZlYzIoMS4wLCAwLjApO1xuICAgIH1cblxuICAgIC8vIDJwaSByYW5nZSByZWR1Y3Rpb25cbiAgICB2ZWMyIHogPSBuaW50X2ZwNjQoZGl2X2ZwNjQoYSwgVFdPX1BJX0ZQNjQpKTtcbiAgICB2ZWMyIHIgPSBzdWJfZnA2NChhLCBtdWxfZnA2NChUV09fUElfRlA2NCwgeikpO1xuXG4gICAgdmVjMiB0O1xuICAgIGZsb2F0IHEgPSBmbG9vcihyLnggLyBQSV8yX0ZQNjQueCArIDAuNSk7XG4gICAgaW50IGogPSBpbnQocSk7XG5cbiAgICBpZiAoaiA8IC0yIHx8IGogPiAyKSB7XG4gICAgICAgIHJldHVybiB2ZWMyKDAuMCAvIDAuMCwgMC4wIC8gMC4wKTtcbiAgICB9XG5cbiAgICB0ID0gc3ViX2ZwNjQociwgbXVsX2ZwNjQoUElfMl9GUDY0LCB2ZWMyKHEsIDAuMCkpKTtcblxuICAgIHEgPSBmbG9vcih0LnggLyBQSV8xNl9GUDY0LnggKyAwLjUpO1xuICAgIGludCBrID0gaW50KHEpO1xuXG4gICAgaWYgKGsgPT0gMCkge1xuICAgICAgICBpZiAoaiA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY29zX3RheWxvcl9mcDY0KHQpO1xuICAgICAgICB9IGVsc2UgaWYgKGogPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIC1zaW5fdGF5bG9yX2ZwNjQodCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaiA9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpbl90YXlsb3JfZnA2NCh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtY29zX3RheWxvcl9mcDY0KHQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW50IGFic19rID0gaW50KGFicyhmbG9hdChrKSkpO1xuXG4gICAgaWYgKGFic19rID4gNCkge1xuICAgICAgICByZXR1cm4gdmVjMigwLjAgLyAwLjAsIDAuMCAvIDAuMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdCA9IHN1Yl9mcDY0KHQsIG11bF9mcDY0KFBJXzE2X0ZQNjQsIHZlYzIocSwgMC4wKSkpO1xuICAgIH1cblxuICAgIHZlYzIgdSA9IHZlYzIoMC4wLCAwLjApO1xuICAgIHZlYzIgdiA9IHZlYzIoMC4wLCAwLjApO1xuXG4jaWYgZGVmaW5lZChOVklESUFfRVFVQVRJT05fV09SS0FST1VORCkgfHwgZGVmaW5lZChJTlRFTF9FUVVBVElPTl9XT1JLQVJPVU5EKVxuICAgIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gMS4wKSA8IDAuNSkge1xuICAgICAgICB1ID0gQ09TX1RBQkxFXzBfRlA2NDtcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8wX0ZQNjQ7XG4gICAgfSBlbHNlIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gMi4wKSA8IDAuNSkge1xuICAgICAgICB1ID0gQ09TX1RBQkxFXzFfRlA2NDtcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8xX0ZQNjQ7XG4gICAgfSBlbHNlIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gMy4wKSA8IDAuNSkge1xuICAgICAgICB1ID0gQ09TX1RBQkxFXzJfRlA2NDtcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8yX0ZQNjQ7XG4gICAgfSBlbHNlIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gNC4wKSA8IDAuNSkge1xuICAgICAgICB1ID0gQ09TX1RBQkxFXzNfRlA2NDtcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8zX0ZQNjQ7XG4gICAgfVxuI2Vsc2VcbiAgICBpZiAoYWJzX2sgPT0gMSkge1xuICAgICAgICB1ID0gQ09TX1RBQkxFXzBfRlA2NDtcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8wX0ZQNjQ7XG4gICAgfSBlbHNlIGlmIChhYnNfayA9PSAyKSB7XG4gICAgICAgIHUgPSBDT1NfVEFCTEVfMV9GUDY0O1xuICAgICAgICB2ID0gU0lOX1RBQkxFXzFfRlA2NDtcbiAgICB9IGVsc2UgaWYgKGFic19rID09IDMpIHtcbiAgICAgICAgdSA9IENPU19UQUJMRV8yX0ZQNjQ7XG4gICAgICAgIHYgPSBTSU5fVEFCTEVfMl9GUDY0O1xuICAgIH0gZWxzZSBpZiAoYWJzX2sgPT0gNCkge1xuICAgICAgICB1ID0gQ09TX1RBQkxFXzNfRlA2NDtcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8zX0ZQNjQ7XG4gICAgfVxuI2VuZGlmXG5cbiAgICB2ZWMyIHNpbl90LCBjb3NfdDtcbiAgICBzaW5jb3NfdGF5bG9yX2ZwNjQodCwgc2luX3QsIGNvc190KTtcblxuICAgIHZlYzIgcmVzdWx0ID0gdmVjMigwLjAsIDAuMCk7XG4gICAgaWYgKGogPT0gMCkge1xuICAgICAgICBpZiAoayA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHN1Yl9mcDY0KG11bF9mcDY0KHUsIGNvc190KSwgbXVsX2ZwNjQodiwgc2luX3QpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHN1bV9mcDY0KG11bF9mcDY0KHUsIGNvc190KSwgbXVsX2ZwNjQodiwgc2luX3QpKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaiA9PSAxKSB7XG4gICAgICAgIGlmIChrID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gLXN1bV9mcDY0KG11bF9mcDY0KHUsIHNpbl90KSwgbXVsX2ZwNjQodiwgY29zX3QpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHN1Yl9mcDY0KG11bF9mcDY0KHYsIGNvc190KSwgbXVsX2ZwNjQodSwgc2luX3QpKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaiA9PSAtMSkge1xuICAgICAgICBpZiAoayA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHN1bV9mcDY0KG11bF9mcDY0KHUsIHNpbl90KSwgbXVsX2ZwNjQodiwgY29zX3QpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHN1Yl9mcDY0KG11bF9mcDY0KHUsIHNpbl90KSwgbXVsX2ZwNjQodiwgY29zX3QpKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChrID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gc3ViX2ZwNjQobXVsX2ZwNjQodiwgc2luX3QpLCBtdWxfZnA2NCh1LCBjb3NfdCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gLXN1bV9mcDY0KG11bF9mcDY0KHUsIGNvc190KSwgbXVsX2ZwNjQodiwgc2luX3QpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbnZlYzIgdGFuX2ZwNjQodmVjMiBhKSB7XG4gICAgdmVjMiBzaW5fYTtcbiAgICB2ZWMyIGNvc19hO1xuXG4gICAgaWYgKGEueCA9PSAwLjAgJiYgYS55ID09IDAuMCkge1xuICAgICAgICByZXR1cm4gdmVjMigwLjAsIDAuMCk7XG4gICAgfVxuXG4gICAgLy8gMnBpIHJhbmdlIHJlZHVjdGlvblxuICAgIHZlYzIgeiA9IG5pbnRfZnA2NChkaXZfZnA2NChhLCBUV09fUElfRlA2NCkpO1xuICAgIHZlYzIgciA9IHN1Yl9mcDY0KGEsIG11bF9mcDY0KFRXT19QSV9GUDY0LCB6KSk7XG5cbiAgICB2ZWMyIHQ7XG4gICAgZmxvYXQgcSA9IGZsb29yKHIueCAvIFBJXzJfRlA2NC54ICsgMC41KTtcbiAgICBpbnQgaiA9IGludChxKTtcblxuXG4gICAgaWYgKGogPCAtMiB8fCBqID4gMikge1xuICAgICAgICByZXR1cm4gdmVjMigwLjAgLyAwLjAsIDAuMCAvIDAuMCk7XG4gICAgfVxuXG4gICAgdCA9IHN1Yl9mcDY0KHIsIG11bF9mcDY0KFBJXzJfRlA2NCwgdmVjMihxLCAwLjApKSk7XG5cbiAgICBxID0gZmxvb3IodC54IC8gUElfMTZfRlA2NC54ICsgMC41KTtcbiAgICBpbnQgayA9IGludChxKTtcbiAgICBpbnQgYWJzX2sgPSBpbnQoYWJzKGZsb2F0KGspKSk7XG5cbiAgICAvLyBXZSBqdXN0IGNhbid0IGdldCBQSS8xNiAqIDMuMCB2ZXJ5IGFjY3VyYXRlbHkuXG4gICAgLy8gc28gbGV0J3MganVzdCBzdG9yZSBpdFxuICAgIGlmIChhYnNfayA+IDQpIHtcbiAgICAgICAgcmV0dXJuIHZlYzIoMC4wIC8gMC4wLCAwLjAgLyAwLjApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHQgPSBzdWJfZnA2NCh0LCBtdWxfZnA2NChQSV8xNl9GUDY0LCB2ZWMyKHEsIDAuMCkpKTtcbiAgICB9XG5cblxuICAgIHZlYzIgdSA9IHZlYzIoMC4wLCAwLjApO1xuICAgIHZlYzIgdiA9IHZlYzIoMC4wLCAwLjApO1xuXG4gICAgdmVjMiBzaW5fdCwgY29zX3Q7XG4gICAgdmVjMiBzLCBjO1xuICAgIHNpbmNvc190YXlsb3JfZnA2NCh0LCBzaW5fdCwgY29zX3QpO1xuXG4gICAgaWYgKGsgPT0gMCkge1xuICAgICAgICBzID0gc2luX3Q7XG4gICAgICAgIGMgPSBjb3NfdDtcbiAgICB9IGVsc2Uge1xuI2lmIGRlZmluZWQoTlZJRElBX0VRVUFUSU9OX1dPUktBUk9VTkQpIHx8IGRlZmluZWQoSU5URUxfRVFVQVRJT05fV09SS0FST1VORClcbiAgICAgICAgaWYgKGFicyhmbG9hdChhYnNfaykgLSAxLjApIDwgMC41KSB7XG4gICAgICAgICAgICB1ID0gQ09TX1RBQkxFXzBfRlA2NDtcbiAgICAgICAgICAgIHYgPSBTSU5fVEFCTEVfMF9GUDY0O1xuICAgICAgICB9IGVsc2UgaWYgKGFicyhmbG9hdChhYnNfaykgLSAyLjApIDwgMC41KSB7XG4gICAgICAgICAgICB1ID0gQ09TX1RBQkxFXzFfRlA2NDtcbiAgICAgICAgICAgIHYgPSBTSU5fVEFCTEVfMV9GUDY0O1xuICAgICAgICB9IGVsc2UgaWYgKGFicyhmbG9hdChhYnNfaykgLSAzLjApIDwgMC41KSB7XG4gICAgICAgICAgICB1ID0gQ09TX1RBQkxFXzJfRlA2NDtcbiAgICAgICAgICAgIHYgPSBTSU5fVEFCTEVfMl9GUDY0O1xuICAgICAgICB9IGVsc2UgaWYgKGFicyhmbG9hdChhYnNfaykgLSA0LjApIDwgMC41KSB7XG4gICAgICAgICAgICB1ID0gQ09TX1RBQkxFXzNfRlA2NDtcbiAgICAgICAgICAgIHYgPSBTSU5fVEFCTEVfM19GUDY0O1xuICAgICAgICB9XG4jZWxzZVxuICAgICAgICBpZiAoYWJzX2sgPT0gMSkge1xuICAgICAgICAgICAgdSA9IENPU19UQUJMRV8wX0ZQNjQ7XG4gICAgICAgICAgICB2ID0gU0lOX1RBQkxFXzBfRlA2NDtcbiAgICAgICAgfSBlbHNlIGlmIChhYnNfayA9PSAyKSB7XG4gICAgICAgICAgICB1ID0gQ09TX1RBQkxFXzFfRlA2NDtcbiAgICAgICAgICAgIHYgPSBTSU5fVEFCTEVfMV9GUDY0O1xuICAgICAgICB9IGVsc2UgaWYgKGFic19rID09IDMpIHtcbiAgICAgICAgICAgIHUgPSBDT1NfVEFCTEVfMl9GUDY0O1xuICAgICAgICAgICAgdiA9IFNJTl9UQUJMRV8yX0ZQNjQ7XG4gICAgICAgIH0gZWxzZSBpZiAoYWJzX2sgPT0gNCkge1xuICAgICAgICAgICAgdSA9IENPU19UQUJMRV8zX0ZQNjQ7XG4gICAgICAgICAgICB2ID0gU0lOX1RBQkxFXzNfRlA2NDtcbiAgICAgICAgfVxuI2VuZGlmXG4gICAgICAgIGlmIChrID4gMCkge1xuICAgICAgICAgICAgcyA9IHN1bV9mcDY0KG11bF9mcDY0KHUsIHNpbl90KSwgbXVsX2ZwNjQodiwgY29zX3QpKTtcbiAgICAgICAgICAgIGMgPSBzdWJfZnA2NChtdWxfZnA2NCh1LCBjb3NfdCksIG11bF9mcDY0KHYsIHNpbl90KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzID0gc3ViX2ZwNjQobXVsX2ZwNjQodSwgc2luX3QpLCBtdWxfZnA2NCh2LCBjb3NfdCkpO1xuICAgICAgICAgICAgYyA9IHN1bV9mcDY0KG11bF9mcDY0KHUsIGNvc190KSwgbXVsX2ZwNjQodiwgc2luX3QpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChqID09IDApIHtcbiAgICAgICAgc2luX2EgPSBzO1xuICAgICAgICBjb3NfYSA9IGM7XG4gICAgfSBlbHNlIGlmIChqID09IDEpIHtcbiAgICAgICAgc2luX2EgPSBjO1xuICAgICAgICBjb3NfYSA9IC1zO1xuICAgIH0gZWxzZSBpZiAoaiA9PSAtMSkge1xuICAgICAgICBzaW5fYSA9IC1jO1xuICAgICAgICBjb3NfYSA9IHM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2luX2EgPSAtcztcbiAgICAgICAgY29zX2EgPSAtYztcbiAgICB9XG4gICAgcmV0dXJuIGRpdl9mcDY0KHNpbl9hLCBjb3NfYSk7XG59XG5cbnZlYzIgcmFkaWFuc19mcDY0KHZlYzIgZGVncmVlKSB7XG4gIHJldHVybiBtdWxfZnA2NChkZWdyZWUsIFBJXzE4MF9GUDY0KTtcbn1cblxudmVjMiBtaXhfZnA2NCh2ZWMyIGEsIHZlYzIgYiwgZmxvYXQgeCkge1xuICB2ZWMyIHJhbmdlID0gc3ViX2ZwNjQoYiwgYSk7XG4gIHJldHVybiBzdW1fZnA2NChhLCBtdWxfZnA2NChyYW5nZSwgdmVjMih4LCAwLjApKSk7XG59XG5cbi8vIFZlY3RvciBmdW5jdGlvbnNcbi8vIHZlYzIgZnVuY3Rpb25zXG52b2lkIHZlYzJfc3VtX2ZwNjQodmVjMiBhWzJdLCB2ZWMyIGJbMl0sIG91dCB2ZWMyIG91dF92YWxbMl0pIHtcbiAgICBvdXRfdmFsWzBdID0gc3VtX2ZwNjQoYVswXSwgYlswXSk7XG4gICAgb3V0X3ZhbFsxXSA9IHN1bV9mcDY0KGFbMV0sIGJbMV0pO1xufVxuXG52b2lkIHZlYzJfc3ViX2ZwNjQodmVjMiBhWzJdLCB2ZWMyIGJbMl0sIG91dCB2ZWMyIG91dF92YWxbMl0pIHtcbiAgICBvdXRfdmFsWzBdID0gc3ViX2ZwNjQoYVswXSwgYlswXSk7XG4gICAgb3V0X3ZhbFsxXSA9IHN1Yl9mcDY0KGFbMV0sIGJbMV0pO1xufVxuXG52b2lkIHZlYzJfbXVsX2ZwNjQodmVjMiBhWzJdLCB2ZWMyIGJbMl0sIG91dCB2ZWMyIG91dF92YWxbMl0pIHtcbiAgICBvdXRfdmFsWzBdID0gbXVsX2ZwNjQoYVswXSwgYlswXSk7XG4gICAgb3V0X3ZhbFsxXSA9IG11bF9mcDY0KGFbMV0sIGJbMV0pO1xufVxuXG52b2lkIHZlYzJfZGl2X2ZwNjQodmVjMiBhWzJdLCB2ZWMyIGJbMl0sIG91dCB2ZWMyIG91dF92YWxbMl0pIHtcbiAgICBvdXRfdmFsWzBdID0gZGl2X2ZwNjQoYVswXSwgYlswXSk7XG4gICAgb3V0X3ZhbFsxXSA9IGRpdl9mcDY0KGFbMV0sIGJbMV0pO1xufVxuXG52b2lkIHZlYzJfbWl4X2ZwNjQodmVjMiB4WzJdLCB2ZWMyIHlbMl0sIGZsb2F0IGEsIG91dCB2ZWMyIG91dF92YWxbMl0pIHtcbiAgdmVjMiByYW5nZVsyXTtcbiAgdmVjMl9zdWJfZnA2NCh5LCB4LCByYW5nZSk7XG4gIHZlYzIgcG9ydGlvblsyXTtcbiAgcG9ydGlvblswXSA9IHJhbmdlWzBdICogYTtcbiAgcG9ydGlvblsxXSA9IHJhbmdlWzFdICogYTtcbiAgdmVjMl9zdW1fZnA2NCh4LCBwb3J0aW9uLCBvdXRfdmFsKTtcbn1cblxudmVjMiB2ZWMyX2xlbmd0aF9mcDY0KHZlYzIgeFsyXSkge1xuICByZXR1cm4gc3FydF9mcDY0KHN1bV9mcDY0KG11bF9mcDY0KHhbMF0sIHhbMF0pLCBtdWxfZnA2NCh4WzFdLCB4WzFdKSkpO1xufVxuXG52b2lkIHZlYzJfbm9ybWFsaXplX2ZwNjQodmVjMiB4WzJdLCBvdXQgdmVjMiBvdXRfdmFsWzJdKSB7XG4gIHZlYzIgbGVuZ3RoID0gdmVjMl9sZW5ndGhfZnA2NCh4KTtcbiAgdmVjMiBsZW5ndGhfdmVjMlsyXTtcbiAgbGVuZ3RoX3ZlYzJbMF0gPSBsZW5ndGg7XG4gIGxlbmd0aF92ZWMyWzFdID0gbGVuZ3RoO1xuXG4gIHZlYzJfZGl2X2ZwNjQoeCwgbGVuZ3RoX3ZlYzIsIG91dF92YWwpO1xufVxuXG52ZWMyIHZlYzJfZGlzdGFuY2VfZnA2NCh2ZWMyIHhbMl0sIHZlYzIgeVsyXSkge1xuICB2ZWMyIGRpZmZbMl07XG4gIHZlYzJfc3ViX2ZwNjQoeCwgeSwgZGlmZik7XG4gIHJldHVybiB2ZWMyX2xlbmd0aF9mcDY0KGRpZmYpO1xufVxuXG52ZWMyIHZlYzJfZG90X2ZwNjQodmVjMiBhWzJdLCB2ZWMyIGJbMl0pIHtcbiAgdmVjMiB2WzJdO1xuXG4gIHZbMF0gPSBtdWxfZnA2NChhWzBdLCBiWzBdKTtcbiAgdlsxXSA9IG11bF9mcDY0KGFbMV0sIGJbMV0pO1xuXG4gIHJldHVybiBzdW1fZnA2NCh2WzBdLCB2WzFdKTtcbn1cblxuLy8gdmVjMyBmdW5jdGlvbnNcbnZvaWQgdmVjM19zdWJfZnA2NCh2ZWMyIGFbM10sIHZlYzIgYlszXSwgb3V0IHZlYzIgb3V0X3ZhbFszXSkge1xuICBmb3IgKGludCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIG91dF92YWxbaV0gPSBzdW1fZnA2NChhW2ldLCBiW2ldKTtcbiAgfVxufVxuXG52b2lkIHZlYzNfc3VtX2ZwNjQodmVjMiBhWzNdLCB2ZWMyIGJbM10sIG91dCB2ZWMyIG91dF92YWxbM10pIHtcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICBvdXRfdmFsW2ldID0gc3VtX2ZwNjQoYVtpXSwgYltpXSk7XG4gIH1cbn1cblxudmVjMiB2ZWMzX2xlbmd0aF9mcDY0KHZlYzIgeFszXSkge1xuICByZXR1cm4gc3FydF9mcDY0KHN1bV9mcDY0KHN1bV9mcDY0KG11bF9mcDY0KHhbMF0sIHhbMF0pLCBtdWxfZnA2NCh4WzFdLCB4WzFdKSksXG4gICAgbXVsX2ZwNjQoeFsyXSwgeFsyXSkpKTtcbn1cblxudmVjMiB2ZWMzX2Rpc3RhbmNlX2ZwNjQodmVjMiB4WzNdLCB2ZWMyIHlbM10pIHtcbiAgdmVjMiBkaWZmWzNdO1xuICB2ZWMzX3N1Yl9mcDY0KHgsIHksIGRpZmYpO1xuICByZXR1cm4gdmVjM19sZW5ndGhfZnA2NChkaWZmKTtcbn1cblxuLy8gdmVjNCBmdW5jdGlvbnNcbnZvaWQgdmVjNF9mcDY0KHZlYzQgYSwgb3V0IHZlYzIgb3V0X3ZhbFs0XSkge1xuICBvdXRfdmFsWzBdLnggPSBhWzBdO1xuICBvdXRfdmFsWzBdLnkgPSAwLjA7XG5cbiAgb3V0X3ZhbFsxXS54ID0gYVsxXTtcbiAgb3V0X3ZhbFsxXS55ID0gMC4wO1xuXG4gIG91dF92YWxbMl0ueCA9IGFbMl07XG4gIG91dF92YWxbMl0ueSA9IDAuMDtcblxuICBvdXRfdmFsWzNdLnggPSBhWzNdO1xuICBvdXRfdmFsWzNdLnkgPSAwLjA7XG59XG5cbnZvaWQgdmVjNF9zY2FsYXJfbXVsX2ZwNjQodmVjMiBhWzRdLCB2ZWMyIGIsIG91dCB2ZWMyIG91dF92YWxbNF0pIHtcbiAgb3V0X3ZhbFswXSA9IG11bF9mcDY0KGFbMF0sIGIpO1xuICBvdXRfdmFsWzFdID0gbXVsX2ZwNjQoYVsxXSwgYik7XG4gIG91dF92YWxbMl0gPSBtdWxfZnA2NChhWzJdLCBiKTtcbiAgb3V0X3ZhbFszXSA9IG11bF9mcDY0KGFbM10sIGIpO1xufVxuXG52b2lkIHZlYzRfc3VtX2ZwNjQodmVjMiBhWzRdLCB2ZWMyIGJbNF0sIG91dCB2ZWMyIG91dF92YWxbNF0pIHtcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBvdXRfdmFsW2ldID0gc3VtX2ZwNjQoYVtpXSwgYltpXSk7XG4gIH1cbn1cblxudm9pZCB2ZWM0X2RvdF9mcDY0KHZlYzIgYVs0XSwgdmVjMiBiWzRdLCBvdXQgdmVjMiBvdXRfdmFsKSB7XG4gIHZlYzIgdls0XTtcblxuICB2WzBdID0gbXVsX2ZwNjQoYVswXSwgYlswXSk7XG4gIHZbMV0gPSBtdWxfZnA2NChhWzFdLCBiWzFdKTtcbiAgdlsyXSA9IG11bF9mcDY0KGFbMl0sIGJbMl0pO1xuICB2WzNdID0gbXVsX2ZwNjQoYVszXSwgYlszXSk7XG5cbiAgb3V0X3ZhbCA9IHN1bV9mcDY0KHN1bV9mcDY0KHZbMF0sIHZbMV0pLCBzdW1fZnA2NCh2WzJdLCB2WzNdKSk7XG59XG5cbnZvaWQgbWF0NF92ZWM0X211bF9mcDY0KHZlYzIgYlsxNl0sIHZlYzIgYVs0XSwgb3V0IHZlYzIgb3V0X3ZhbFs0XSkge1xuICB2ZWMyIHRtcFs0XTtcblxuICBmb3IgKGludCBpID0gMDsgaSA8IDQ7IGkrKylcbiAge1xuICAgIGZvciAoaW50IGogPSAwOyBqIDwgNDsgaisrKVxuICAgIHtcbiAgICAgIHRtcFtqXSA9IGJbaiArIGkgKiA0XTtcbiAgICB9XG4gICAgdmVjNF9kb3RfZnA2NChhLCB0bXAsIG91dF92YWxbaV0pO1xuICB9XG59XG5gO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvc2hhZGVybGliL2ZwNjQvbWF0aC1mcDY0Lmdsc2wuanNcbi8vIG1vZHVsZSBpZCA9IDEwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 109 */
/* exports provided: lighting */
/* exports used: lighting */
/*!*****************************************!*\
  !*** ./src/shaderlib/lighting/index.js ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lighting_glsl__ = __webpack_require__(/*! ./lighting.glsl */ 110);\n\n\nconst lighting = {\n  interface: 'lighting',\n  source: __WEBPACK_IMPORTED_MODULE_0__lighting_glsl__[\"a\" /* default */]\n};\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = lighting;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcmxpYi9saWdodGluZy9pbmRleC5qcz8zZTQ5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBsaWdodGluZ1NoYWRlciBmcm9tICcuL2xpZ2h0aW5nLmdsc2wnO1xuXG5leHBvcnQgY29uc3QgbGlnaHRpbmcgPSB7XG4gIGludGVyZmFjZTogJ2xpZ2h0aW5nJyxcbiAgc291cmNlOiBsaWdodGluZ1NoYWRlclxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3NoYWRlcmxpYi9saWdodGluZy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 110 */
/* exports provided: default */
/* exports used: default */
/*!*************************************************!*\
  !*** ./src/shaderlib/lighting/lighting.glsl.js ***!
  \*************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// lighting\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n#define NUM_OF_LIGHTS 2\nuniform vec3 cameraPos;\nuniform vec3 lightsPosition[16];\nuniform vec2 lightsStrength[16];\nuniform float ambientRatio;\nuniform float diffuseRatio;\nuniform float specularRatio;\n\nfloat getLightWeight(vec4 position_worldspace, vec3 normals_worldspace) {\n  float lightWeight = 0.0;\n\n  vec3 position_worldspace_vec3 = position_worldspace.xyz / position_worldspace.w;\n  vec3 normals_worldspace_vec3 = normals_worldspace.xzy;\n\n  vec3 camera_pos_worldspace = cameraPos;\n  vec3 view_direction = normalize(camera_pos_worldspace - position_worldspace_vec3);\n\n  for (int i = 0; i < NUM_OF_LIGHTS; i++) {\n    vec3 light_position_worldspace = project_position(lightsPosition[i]);\n    vec3 light_direction = normalize(light_position_worldspace - position_worldspace_vec3);\n\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normals_worldspace_vec3);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normals_worldspace_vec3, halfway_direction), 0.0);\n      specular = pow(specular_angle, 32.0);\n    }\n    lambertian = max(lambertian, 0.0);\n    lightWeight += (ambientRatio + lambertian * diffuseRatio + specular * specularRatio) *\n      lightsStrength[i].x;\n\n  }\n\n  return lightWeight;\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcmxpYi9saWdodGluZy9saWdodGluZy5nbHNsLmpzP2ViN2YiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLy8gbGlnaHRpbmdcblxuZXhwb3J0IGRlZmF1bHQgYFxcXG4jZGVmaW5lIE5VTV9PRl9MSUdIVFMgMlxudW5pZm9ybSB2ZWMzIGNhbWVyYVBvcztcbnVuaWZvcm0gdmVjMyBsaWdodHNQb3NpdGlvblsxNl07XG51bmlmb3JtIHZlYzIgbGlnaHRzU3RyZW5ndGhbMTZdO1xudW5pZm9ybSBmbG9hdCBhbWJpZW50UmF0aW87XG51bmlmb3JtIGZsb2F0IGRpZmZ1c2VSYXRpbztcbnVuaWZvcm0gZmxvYXQgc3BlY3VsYXJSYXRpbztcblxuZmxvYXQgZ2V0TGlnaHRXZWlnaHQodmVjNCBwb3NpdGlvbl93b3JsZHNwYWNlLCB2ZWMzIG5vcm1hbHNfd29ybGRzcGFjZSkge1xuICBmbG9hdCBsaWdodFdlaWdodCA9IDAuMDtcblxuICB2ZWMzIHBvc2l0aW9uX3dvcmxkc3BhY2VfdmVjMyA9IHBvc2l0aW9uX3dvcmxkc3BhY2UueHl6IC8gcG9zaXRpb25fd29ybGRzcGFjZS53O1xuICB2ZWMzIG5vcm1hbHNfd29ybGRzcGFjZV92ZWMzID0gbm9ybWFsc193b3JsZHNwYWNlLnh6eTtcblxuICB2ZWMzIGNhbWVyYV9wb3Nfd29ybGRzcGFjZSA9IGNhbWVyYVBvcztcbiAgdmVjMyB2aWV3X2RpcmVjdGlvbiA9IG5vcm1hbGl6ZShjYW1lcmFfcG9zX3dvcmxkc3BhY2UgLSBwb3NpdGlvbl93b3JsZHNwYWNlX3ZlYzMpO1xuXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgTlVNX09GX0xJR0hUUzsgaSsrKSB7XG4gICAgdmVjMyBsaWdodF9wb3NpdGlvbl93b3JsZHNwYWNlID0gcHJvamVjdF9wb3NpdGlvbihsaWdodHNQb3NpdGlvbltpXSk7XG4gICAgdmVjMyBsaWdodF9kaXJlY3Rpb24gPSBub3JtYWxpemUobGlnaHRfcG9zaXRpb25fd29ybGRzcGFjZSAtIHBvc2l0aW9uX3dvcmxkc3BhY2VfdmVjMyk7XG5cbiAgICB2ZWMzIGhhbGZ3YXlfZGlyZWN0aW9uID0gbm9ybWFsaXplKGxpZ2h0X2RpcmVjdGlvbiArIHZpZXdfZGlyZWN0aW9uKTtcbiAgICBmbG9hdCBsYW1iZXJ0aWFuID0gZG90KGxpZ2h0X2RpcmVjdGlvbiwgbm9ybWFsc193b3JsZHNwYWNlX3ZlYzMpO1xuICAgIGZsb2F0IHNwZWN1bGFyID0gMC4wO1xuICAgIGlmIChsYW1iZXJ0aWFuID4gMC4wKSB7XG4gICAgICBmbG9hdCBzcGVjdWxhcl9hbmdsZSA9IG1heChkb3Qobm9ybWFsc193b3JsZHNwYWNlX3ZlYzMsIGhhbGZ3YXlfZGlyZWN0aW9uKSwgMC4wKTtcbiAgICAgIHNwZWN1bGFyID0gcG93KHNwZWN1bGFyX2FuZ2xlLCAzMi4wKTtcbiAgICB9XG4gICAgbGFtYmVydGlhbiA9IG1heChsYW1iZXJ0aWFuLCAwLjApO1xuICAgIGxpZ2h0V2VpZ2h0ICs9IChhbWJpZW50UmF0aW8gKyBsYW1iZXJ0aWFuICogZGlmZnVzZVJhdGlvICsgc3BlY3VsYXIgKiBzcGVjdWxhclJhdGlvKSAqXG4gICAgICBsaWdodHNTdHJlbmd0aFtpXS54O1xuXG4gIH1cblxuICByZXR1cm4gbGlnaHRXZWlnaHQ7XG59XG5gO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvc2hhZGVybGliL2xpZ2h0aW5nL2xpZ2h0aW5nLmdsc2wuanNcbi8vIG1vZHVsZSBpZCA9IDExMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 111 */
/* exports provided: project */
/* exports used: project */
/*!****************************************!*\
  !*** ./src/shaderlib/project/index.js ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__project_glsl__ = __webpack_require__(/*! ./project.glsl */ 112);\n\n\nconst project = {\n  interface: 'project',\n  source: __WEBPACK_IMPORTED_MODULE_0__project_glsl__[\"a\" /* default */]\n};\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = project;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTExLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcmxpYi9wcm9qZWN0L2luZGV4LmpzPzYxMmUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHByb2plY3RTaGFkZXIgZnJvbSAnLi9wcm9qZWN0Lmdsc2wnO1xuXG5leHBvcnQgY29uc3QgcHJvamVjdCA9IHtcbiAgaW50ZXJmYWNlOiAncHJvamVjdCcsXG4gIHNvdXJjZTogcHJvamVjdFNoYWRlclxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3NoYWRlcmxpYi9wcm9qZWN0L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 112 */
/* exports provided: default */
/* exports used: default */
/*!***********************************************!*\
  !*** ./src/shaderlib/project/project.glsl.js ***!
  \***********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / (PI * 2.0);\n\n// ref: lib/constants.js\nconst float PROJECT_IDENTITY = 0.;\nconst float PROJECT_MERCATOR = 1.;\nconst float PROJECT_MERCATOR_OFFSETS = 2.;\n\nuniform float projectionMode;\nuniform float projectionScale;\nuniform vec4 projectionCenter;\nuniform vec3 projectionPixelsPerUnit;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 projectionMatrixUncentered;\n\n#ifdef INTEL_TAN_WORKAROUND\n\n// All these functions are for substituting tan() function from Intel GPU only\nconst float TWO_PI = 6.2831854820251465;\nconst float PI_2 = 1.5707963705062866;\nconst float PI_16 = 0.1963495463132858;\n\nconst float SIN_TABLE_0 = 0.19509032368659973;\nconst float SIN_TABLE_1 = 0.3826834261417389;\nconst float SIN_TABLE_2 = 0.5555702447891235;\nconst float SIN_TABLE_3 = 0.7071067690849304;\n\nconst float COS_TABLE_0 = 0.9807852506637573;\nconst float COS_TABLE_1 = 0.9238795042037964;\nconst float COS_TABLE_2 = 0.8314695954322815;\nconst float COS_TABLE_3 = 0.7071067690849304;\n\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01; // 1/3!\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03; // 1/5!\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04; // 1/7!\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06; // 1/9!\n\nfloat sin_taylor_fp32(float a) {\n  float r, s, t, x;\n\n  if (a == 0.0) {\n    return 0.0;\n  }\n\n  x = -a * a;\n  s = a;\n  r = a;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_3;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_5;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_7;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_9;\n  s = s + t;\n\n  return s;\n}\n\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\n  if (a == 0.0) {\n    sin_t = 0.0;\n    cos_t = 1.0;\n  }\n  sin_t = sin_taylor_fp32(a);\n  cos_t = sqrt(1.0 - sin_t * sin_t);\n}\n\nfloat tan_taylor_fp32(float a) {\n    float sin_a;\n    float cos_a;\n\n    if (a == 0.0) {\n        return 0.0;\n    }\n\n    // 2pi range reduction\n    float z = floor(a / TWO_PI);\n    float r = a - TWO_PI * z;\n\n    float t;\n    float q = floor(r / PI_2 + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return 0.0 / 0.0;\n    }\n\n    t = r - PI_2 * q;\n\n    q = floor(t / PI_16 + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return 0.0 / 0.0;\n    } else {\n        t = t - PI_16 * q;\n    }\n\n    float u = 0.0;\n    float v = 0.0;\n\n    float sin_t, cos_t;\n    float s, c;\n    sincos_taylor_fp32(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0;\n            v = SIN_TABLE_0;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1;\n            v = SIN_TABLE_1;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2;\n            v = SIN_TABLE_2;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3;\n            v = SIN_TABLE_3;\n        }\n        if (k > 0) {\n            s = u * sin_t + v * cos_t;\n            c = u * cos_t - v * sin_t;\n        } else {\n            s = u * sin_t - v * cos_t;\n            c = u * cos_t + v * sin_t;\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return sin_a / cos_a;\n}\n#endif\n\nfloat tan_fp32(float a) {\n#ifdef INTEL_TAN_WORKAROUND\n  return tan_taylor_fp32(a);\n#else\n  return tan(a);\n#endif\n}\n\n//\n// Scaling offsets\n//\n\nfloat project_scale(float meters) {\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\n    return meters;\n  } else {\n    return meters * projectionPixelsPerUnit.x;\n  }\n}\n\nvec2 project_scale(vec2 meters) {\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\n    return meters;\n  } else {\n    return vec2(\n      meters.x * projectionPixelsPerUnit.x,\n      meters.y * projectionPixelsPerUnit.x\n    );\n  }\n}\n\nvec3 project_scale(vec3 meters) {\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\n    return meters;\n  } else {\n    return vec3(\n      meters.x * projectionPixelsPerUnit.x,\n      meters.y * projectionPixelsPerUnit.x,\n      meters.z * projectionPixelsPerUnit.x\n    );\n  }\n}\n\nvec4 project_scale(vec4 meters) {\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\n    return meters;\n  } else {\n    return vec4(\n      meters.x * projectionPixelsPerUnit.x,\n      meters.y * projectionPixelsPerUnit.x,\n      meters.z * projectionPixelsPerUnit.x,\n      meters.w\n    );\n  }\n}\n\n//\n// Projecting positions\n//\n\n// non-linear projection: lnglats => unit tile [0-1, 0-1]\nvec2 project_mercator_(vec2 lnglat) {\n  return vec2(\n    radians(lnglat.x) + PI,\n    PI - log(tan_fp32(PI * 0.25 + radians(lnglat.y) * 0.5))\n  );\n}\n\nvec2 project_position(vec2 position) {\n  if (projectionMode == PROJECT_IDENTITY) {\n    return position;\n  }\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\n    return position;\n    return project_scale(position);\n  }\n  // Covers projectionMode == PROJECT_MERCATOR\n  return project_mercator_(position) * WORLD_SCALE * projectionScale;\n}\n\nvec3 project_position(vec3 position) {\n  return vec3(project_position(position.xy), project_scale(position.z));\n}\n\nvec4 project_position(vec4 position) {\n  return vec4(project_position(position.xyz), position.w);\n}\n\n//\n\nvec4 project_to_viewspace(vec4 position) {\n  return modelViewMatrix * position;\n}\n\nvec4 project_to_clipspace(vec4 position) {\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\n    position = position * projectionPixelsPerUnit.x;\n  }\n  return projectionMatrix * position + projectionCenter;\n}\n\n// Backwards compatibility\n\nfloat scale(float position) {\n  return project_scale(position);\n}\n\nvec2 scale(vec2 position) {\n  return project_scale(position);\n}\n\nvec3 scale(vec3 position) {\n  return project_scale(position);\n}\n\nvec4 scale(vec4 position) {\n  return project_scale(position);\n}\n\nvec2 preproject(vec2 position) {\n  return project_position(position);\n}\n\nvec3 preproject(vec3 position) {\n  return project_position(position);\n}\n\nvec4 preproject(vec4 position) {\n  return project_position(position);\n}\n\nvec4 project(vec4 position) {\n  return project_to_clipspace(position);\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcmxpYi9wcm9qZWN0L3Byb2plY3QuZ2xzbC5qcz8wZGVlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNiBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmV4cG9ydCBkZWZhdWx0IGBcXFxuY29uc3QgZmxvYXQgVElMRV9TSVpFID0gNTEyLjA7XG5jb25zdCBmbG9hdCBQSSA9IDMuMTQxNTkyNjUzNjtcbmNvbnN0IGZsb2F0IFdPUkxEX1NDQUxFID0gVElMRV9TSVpFIC8gKFBJICogMi4wKTtcblxuLy8gcmVmOiBsaWIvY29uc3RhbnRzLmpzXG5jb25zdCBmbG9hdCBQUk9KRUNUX0lERU5USVRZID0gMC47XG5jb25zdCBmbG9hdCBQUk9KRUNUX01FUkNBVE9SID0gMS47XG5jb25zdCBmbG9hdCBQUk9KRUNUX01FUkNBVE9SX09GRlNFVFMgPSAyLjtcblxudW5pZm9ybSBmbG9hdCBwcm9qZWN0aW9uTW9kZTtcbnVuaWZvcm0gZmxvYXQgcHJvamVjdGlvblNjYWxlO1xudW5pZm9ybSB2ZWM0IHByb2plY3Rpb25DZW50ZXI7XG51bmlmb3JtIHZlYzMgcHJvamVjdGlvblBpeGVsc1BlclVuaXQ7XG5cbnVuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7XG51bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDtcbnVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4VW5jZW50ZXJlZDtcblxuI2lmZGVmIElOVEVMX1RBTl9XT1JLQVJPVU5EXG5cbi8vIEFsbCB0aGVzZSBmdW5jdGlvbnMgYXJlIGZvciBzdWJzdGl0dXRpbmcgdGFuKCkgZnVuY3Rpb24gZnJvbSBJbnRlbCBHUFUgb25seVxuY29uc3QgZmxvYXQgVFdPX1BJID0gNi4yODMxODU0ODIwMjUxNDY1O1xuY29uc3QgZmxvYXQgUElfMiA9IDEuNTcwNzk2MzcwNTA2Mjg2NjtcbmNvbnN0IGZsb2F0IFBJXzE2ID0gMC4xOTYzNDk1NDYzMTMyODU4O1xuXG5jb25zdCBmbG9hdCBTSU5fVEFCTEVfMCA9IDAuMTk1MDkwMzIzNjg2NTk5NzM7XG5jb25zdCBmbG9hdCBTSU5fVEFCTEVfMSA9IDAuMzgyNjgzNDI2MTQxNzM4OTtcbmNvbnN0IGZsb2F0IFNJTl9UQUJMRV8yID0gMC41NTU1NzAyNDQ3ODkxMjM1O1xuY29uc3QgZmxvYXQgU0lOX1RBQkxFXzMgPSAwLjcwNzEwNjc2OTA4NDkzMDQ7XG5cbmNvbnN0IGZsb2F0IENPU19UQUJMRV8wID0gMC45ODA3ODUyNTA2NjM3NTczO1xuY29uc3QgZmxvYXQgQ09TX1RBQkxFXzEgPSAwLjkyMzg3OTUwNDIwMzc5NjQ7XG5jb25zdCBmbG9hdCBDT1NfVEFCTEVfMiA9IDAuODMxNDY5NTk1NDMyMjgxNTtcbmNvbnN0IGZsb2F0IENPU19UQUJMRV8zID0gMC43MDcxMDY3NjkwODQ5MzA0O1xuXG5jb25zdCBmbG9hdCBJTlZFUlNFX0ZBQ1RPUklBTF8zID0gMS42NjY2NjY3MTYzMzcyMDRlLTAxOyAvLyAxLzMhXG5jb25zdCBmbG9hdCBJTlZFUlNFX0ZBQ1RPUklBTF81ID0gOC4zMzMzMzM3Njc5NTA1MzVlLTAzOyAvLyAxLzUhXG5jb25zdCBmbG9hdCBJTlZFUlNFX0ZBQ1RPUklBTF83ID0gMS45ODQxMjcwMTEzODI5NTIzZS0wNDsgLy8gMS83IVxuY29uc3QgZmxvYXQgSU5WRVJTRV9GQUNUT1JJQUxfOSA9IDIuNzU1NzMxODg0NDYyODc1MzNlLTA2OyAvLyAxLzkhXG5cbmZsb2F0IHNpbl90YXlsb3JfZnAzMihmbG9hdCBhKSB7XG4gIGZsb2F0IHIsIHMsIHQsIHg7XG5cbiAgaWYgKGEgPT0gMC4wKSB7XG4gICAgcmV0dXJuIDAuMDtcbiAgfVxuXG4gIHggPSAtYSAqIGE7XG4gIHMgPSBhO1xuICByID0gYTtcblxuICByID0gciAqIHg7XG4gIHQgPSByICogSU5WRVJTRV9GQUNUT1JJQUxfMztcbiAgcyA9IHMgKyB0O1xuXG4gIHIgPSByICogeDtcbiAgdCA9IHIgKiBJTlZFUlNFX0ZBQ1RPUklBTF81O1xuICBzID0gcyArIHQ7XG5cbiAgciA9IHIgKiB4O1xuICB0ID0gciAqIElOVkVSU0VfRkFDVE9SSUFMXzc7XG4gIHMgPSBzICsgdDtcblxuICByID0gciAqIHg7XG4gIHQgPSByICogSU5WRVJTRV9GQUNUT1JJQUxfOTtcbiAgcyA9IHMgKyB0O1xuXG4gIHJldHVybiBzO1xufVxuXG52b2lkIHNpbmNvc190YXlsb3JfZnAzMihmbG9hdCBhLCBvdXQgZmxvYXQgc2luX3QsIG91dCBmbG9hdCBjb3NfdCkge1xuICBpZiAoYSA9PSAwLjApIHtcbiAgICBzaW5fdCA9IDAuMDtcbiAgICBjb3NfdCA9IDEuMDtcbiAgfVxuICBzaW5fdCA9IHNpbl90YXlsb3JfZnAzMihhKTtcbiAgY29zX3QgPSBzcXJ0KDEuMCAtIHNpbl90ICogc2luX3QpO1xufVxuXG5mbG9hdCB0YW5fdGF5bG9yX2ZwMzIoZmxvYXQgYSkge1xuICAgIGZsb2F0IHNpbl9hO1xuICAgIGZsb2F0IGNvc19hO1xuXG4gICAgaWYgKGEgPT0gMC4wKSB7XG4gICAgICAgIHJldHVybiAwLjA7XG4gICAgfVxuXG4gICAgLy8gMnBpIHJhbmdlIHJlZHVjdGlvblxuICAgIGZsb2F0IHogPSBmbG9vcihhIC8gVFdPX1BJKTtcbiAgICBmbG9hdCByID0gYSAtIFRXT19QSSAqIHo7XG5cbiAgICBmbG9hdCB0O1xuICAgIGZsb2F0IHEgPSBmbG9vcihyIC8gUElfMiArIDAuNSk7XG4gICAgaW50IGogPSBpbnQocSk7XG5cbiAgICBpZiAoaiA8IC0yIHx8IGogPiAyKSB7XG4gICAgICAgIHJldHVybiAwLjAgLyAwLjA7XG4gICAgfVxuXG4gICAgdCA9IHIgLSBQSV8yICogcTtcblxuICAgIHEgPSBmbG9vcih0IC8gUElfMTYgKyAwLjUpO1xuICAgIGludCBrID0gaW50KHEpO1xuICAgIGludCBhYnNfayA9IGludChhYnMoZmxvYXQoaykpKTtcblxuICAgIGlmIChhYnNfayA+IDQpIHtcbiAgICAgICAgcmV0dXJuIDAuMCAvIDAuMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0ID0gdCAtIFBJXzE2ICogcTtcbiAgICB9XG5cbiAgICBmbG9hdCB1ID0gMC4wO1xuICAgIGZsb2F0IHYgPSAwLjA7XG5cbiAgICBmbG9hdCBzaW5fdCwgY29zX3Q7XG4gICAgZmxvYXQgcywgYztcbiAgICBzaW5jb3NfdGF5bG9yX2ZwMzIodCwgc2luX3QsIGNvc190KTtcblxuICAgIGlmIChrID09IDApIHtcbiAgICAgICAgcyA9IHNpbl90O1xuICAgICAgICBjID0gY29zX3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGFicyhmbG9hdChhYnNfaykgLSAxLjApIDwgMC41KSB7XG4gICAgICAgICAgICB1ID0gQ09TX1RBQkxFXzA7XG4gICAgICAgICAgICB2ID0gU0lOX1RBQkxFXzA7XG4gICAgICAgIH0gZWxzZSBpZiAoYWJzKGZsb2F0KGFic19rKSAtIDIuMCkgPCAwLjUpIHtcbiAgICAgICAgICAgIHUgPSBDT1NfVEFCTEVfMTtcbiAgICAgICAgICAgIHYgPSBTSU5fVEFCTEVfMTtcbiAgICAgICAgfSBlbHNlIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gMy4wKSA8IDAuNSkge1xuICAgICAgICAgICAgdSA9IENPU19UQUJMRV8yO1xuICAgICAgICAgICAgdiA9IFNJTl9UQUJMRV8yO1xuICAgICAgICB9IGVsc2UgaWYgKGFicyhmbG9hdChhYnNfaykgLSA0LjApIDwgMC41KSB7XG4gICAgICAgICAgICB1ID0gQ09TX1RBQkxFXzM7XG4gICAgICAgICAgICB2ID0gU0lOX1RBQkxFXzM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGsgPiAwKSB7XG4gICAgICAgICAgICBzID0gdSAqIHNpbl90ICsgdiAqIGNvc190O1xuICAgICAgICAgICAgYyA9IHUgKiBjb3NfdCAtIHYgKiBzaW5fdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMgPSB1ICogc2luX3QgLSB2ICogY29zX3Q7XG4gICAgICAgICAgICBjID0gdSAqIGNvc190ICsgdiAqIHNpbl90O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGogPT0gMCkge1xuICAgICAgICBzaW5fYSA9IHM7XG4gICAgICAgIGNvc19hID0gYztcbiAgICB9IGVsc2UgaWYgKGogPT0gMSkge1xuICAgICAgICBzaW5fYSA9IGM7XG4gICAgICAgIGNvc19hID0gLXM7XG4gICAgfSBlbHNlIGlmIChqID09IC0xKSB7XG4gICAgICAgIHNpbl9hID0gLWM7XG4gICAgICAgIGNvc19hID0gcztcbiAgICB9IGVsc2Uge1xuICAgICAgICBzaW5fYSA9IC1zO1xuICAgICAgICBjb3NfYSA9IC1jO1xuICAgIH1cbiAgICByZXR1cm4gc2luX2EgLyBjb3NfYTtcbn1cbiNlbmRpZlxuXG5mbG9hdCB0YW5fZnAzMihmbG9hdCBhKSB7XG4jaWZkZWYgSU5URUxfVEFOX1dPUktBUk9VTkRcbiAgcmV0dXJuIHRhbl90YXlsb3JfZnAzMihhKTtcbiNlbHNlXG4gIHJldHVybiB0YW4oYSk7XG4jZW5kaWZcbn1cblxuLy9cbi8vIFNjYWxpbmcgb2Zmc2V0c1xuLy9cblxuZmxvYXQgcHJvamVjdF9zY2FsZShmbG9hdCBtZXRlcnMpIHtcbiAgaWYgKHByb2plY3Rpb25Nb2RlID09IFBST0pFQ1RfTUVSQ0FUT1JfT0ZGU0VUUykge1xuICAgIHJldHVybiBtZXRlcnM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1ldGVycyAqIHByb2plY3Rpb25QaXhlbHNQZXJVbml0Lng7XG4gIH1cbn1cblxudmVjMiBwcm9qZWN0X3NjYWxlKHZlYzIgbWV0ZXJzKSB7XG4gIGlmIChwcm9qZWN0aW9uTW9kZSA9PSBQUk9KRUNUX01FUkNBVE9SX09GRlNFVFMpIHtcbiAgICByZXR1cm4gbWV0ZXJzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2ZWMyKFxuICAgICAgbWV0ZXJzLnggKiBwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdC54LFxuICAgICAgbWV0ZXJzLnkgKiBwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdC54XG4gICAgKTtcbiAgfVxufVxuXG52ZWMzIHByb2plY3Rfc2NhbGUodmVjMyBtZXRlcnMpIHtcbiAgaWYgKHByb2plY3Rpb25Nb2RlID09IFBST0pFQ1RfTUVSQ0FUT1JfT0ZGU0VUUykge1xuICAgIHJldHVybiBtZXRlcnM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZlYzMoXG4gICAgICBtZXRlcnMueCAqIHByb2plY3Rpb25QaXhlbHNQZXJVbml0LngsXG4gICAgICBtZXRlcnMueSAqIHByb2plY3Rpb25QaXhlbHNQZXJVbml0LngsXG4gICAgICBtZXRlcnMueiAqIHByb2plY3Rpb25QaXhlbHNQZXJVbml0LnhcbiAgICApO1xuICB9XG59XG5cbnZlYzQgcHJvamVjdF9zY2FsZSh2ZWM0IG1ldGVycykge1xuICBpZiAocHJvamVjdGlvbk1vZGUgPT0gUFJPSkVDVF9NRVJDQVRPUl9PRkZTRVRTKSB7XG4gICAgcmV0dXJuIG1ldGVycztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmVjNChcbiAgICAgIG1ldGVycy54ICogcHJvamVjdGlvblBpeGVsc1BlclVuaXQueCxcbiAgICAgIG1ldGVycy55ICogcHJvamVjdGlvblBpeGVsc1BlclVuaXQueCxcbiAgICAgIG1ldGVycy56ICogcHJvamVjdGlvblBpeGVsc1BlclVuaXQueCxcbiAgICAgIG1ldGVycy53XG4gICAgKTtcbiAgfVxufVxuXG4vL1xuLy8gUHJvamVjdGluZyBwb3NpdGlvbnNcbi8vXG5cbi8vIG5vbi1saW5lYXIgcHJvamVjdGlvbjogbG5nbGF0cyA9PiB1bml0IHRpbGUgWzAtMSwgMC0xXVxudmVjMiBwcm9qZWN0X21lcmNhdG9yXyh2ZWMyIGxuZ2xhdCkge1xuICByZXR1cm4gdmVjMihcbiAgICByYWRpYW5zKGxuZ2xhdC54KSArIFBJLFxuICAgIFBJIC0gbG9nKHRhbl9mcDMyKFBJICogMC4yNSArIHJhZGlhbnMobG5nbGF0LnkpICogMC41KSlcbiAgKTtcbn1cblxudmVjMiBwcm9qZWN0X3Bvc2l0aW9uKHZlYzIgcG9zaXRpb24pIHtcbiAgaWYgKHByb2plY3Rpb25Nb2RlID09IFBST0pFQ1RfSURFTlRJVFkpIHtcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH1cbiAgaWYgKHByb2plY3Rpb25Nb2RlID09IFBST0pFQ1RfTUVSQ0FUT1JfT0ZGU0VUUykge1xuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICByZXR1cm4gcHJvamVjdF9zY2FsZShwb3NpdGlvbik7XG4gIH1cbiAgLy8gQ292ZXJzIHByb2plY3Rpb25Nb2RlID09IFBST0pFQ1RfTUVSQ0FUT1JcbiAgcmV0dXJuIHByb2plY3RfbWVyY2F0b3JfKHBvc2l0aW9uKSAqIFdPUkxEX1NDQUxFICogcHJvamVjdGlvblNjYWxlO1xufVxuXG52ZWMzIHByb2plY3RfcG9zaXRpb24odmVjMyBwb3NpdGlvbikge1xuICByZXR1cm4gdmVjMyhwcm9qZWN0X3Bvc2l0aW9uKHBvc2l0aW9uLnh5KSwgcHJvamVjdF9zY2FsZShwb3NpdGlvbi56KSk7XG59XG5cbnZlYzQgcHJvamVjdF9wb3NpdGlvbih2ZWM0IHBvc2l0aW9uKSB7XG4gIHJldHVybiB2ZWM0KHByb2plY3RfcG9zaXRpb24ocG9zaXRpb24ueHl6KSwgcG9zaXRpb24udyk7XG59XG5cbi8vXG5cbnZlYzQgcHJvamVjdF90b192aWV3c3BhY2UodmVjNCBwb3NpdGlvbikge1xuICByZXR1cm4gbW9kZWxWaWV3TWF0cml4ICogcG9zaXRpb247XG59XG5cbnZlYzQgcHJvamVjdF90b19jbGlwc3BhY2UodmVjNCBwb3NpdGlvbikge1xuICBpZiAocHJvamVjdGlvbk1vZGUgPT0gUFJPSkVDVF9NRVJDQVRPUl9PRkZTRVRTKSB7XG4gICAgcG9zaXRpb24gPSBwb3NpdGlvbiAqIHByb2plY3Rpb25QaXhlbHNQZXJVbml0Lng7XG4gIH1cbiAgcmV0dXJuIHByb2plY3Rpb25NYXRyaXggKiBwb3NpdGlvbiArIHByb2plY3Rpb25DZW50ZXI7XG59XG5cbi8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cbmZsb2F0IHNjYWxlKGZsb2F0IHBvc2l0aW9uKSB7XG4gIHJldHVybiBwcm9qZWN0X3NjYWxlKHBvc2l0aW9uKTtcbn1cblxudmVjMiBzY2FsZSh2ZWMyIHBvc2l0aW9uKSB7XG4gIHJldHVybiBwcm9qZWN0X3NjYWxlKHBvc2l0aW9uKTtcbn1cblxudmVjMyBzY2FsZSh2ZWMzIHBvc2l0aW9uKSB7XG4gIHJldHVybiBwcm9qZWN0X3NjYWxlKHBvc2l0aW9uKTtcbn1cblxudmVjNCBzY2FsZSh2ZWM0IHBvc2l0aW9uKSB7XG4gIHJldHVybiBwcm9qZWN0X3NjYWxlKHBvc2l0aW9uKTtcbn1cblxudmVjMiBwcmVwcm9qZWN0KHZlYzIgcG9zaXRpb24pIHtcbiAgcmV0dXJuIHByb2plY3RfcG9zaXRpb24ocG9zaXRpb24pO1xufVxuXG52ZWMzIHByZXByb2plY3QodmVjMyBwb3NpdGlvbikge1xuICByZXR1cm4gcHJvamVjdF9wb3NpdGlvbihwb3NpdGlvbik7XG59XG5cbnZlYzQgcHJlcHJvamVjdCh2ZWM0IHBvc2l0aW9uKSB7XG4gIHJldHVybiBwcm9qZWN0X3Bvc2l0aW9uKHBvc2l0aW9uKTtcbn1cblxudmVjNCBwcm9qZWN0KHZlYzQgcG9zaXRpb24pIHtcbiAgcmV0dXJuIHByb2plY3RfdG9fY2xpcHNwYWNlKHBvc2l0aW9uKTtcbn1cbmA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9zaGFkZXJsaWIvcHJvamVjdC9wcm9qZWN0Lmdsc2wuanNcbi8vIG1vZHVsZSBpZCA9IDExMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 113 */
/* exports provided: project64 */
/* exports used: project64 */
/*!******************************************!*\
  !*** ./src/shaderlib/project64/index.js ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__project64_glsl__ = __webpack_require__(/*! ./project64.glsl */ 114);\n\n\nconst project64 = {\n  interface: 'project64',\n  source: __WEBPACK_IMPORTED_MODULE_0__project64_glsl__[\"a\" /* default */]\n};\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = project64;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcmxpYi9wcm9qZWN0NjQvaW5kZXguanM/MTlkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcHJvamVjdDY0U2hhZGVyIGZyb20gJy4vcHJvamVjdDY0Lmdsc2wnO1xuXG5leHBvcnQgY29uc3QgcHJvamVjdDY0ID0ge1xuICBpbnRlcmZhY2U6ICdwcm9qZWN0NjQnLFxuICBzb3VyY2U6IHByb2plY3Q2NFNoYWRlclxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3NoYWRlcmxpYi9wcm9qZWN0NjQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDExM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 114 */
/* exports provided: default */
/* exports used: default */
/*!***************************************************!*\
  !*** ./src/shaderlib/project64/project64.glsl.js ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = `\\\n\nconst vec2 WORLD_SCALE_FP64 = vec2(81.4873275756836, 0.0000032873668232014097);\n\nuniform vec2 projectionScaleFP64;\nuniform vec2 projectionFP64[16];\n\n// longitude: lnglat_fp64.xy; latitude: lnglat_fp64.zw\nvoid mercatorProject_fp64(vec4 lnglat_fp64, out vec2 out_val[2]) {\n\n#if defined(NVIDIA_FP64_WORKAROUND)\n  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64 * ONE);\n#else\n  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64);\n#endif\n  out_val[1] = sub_fp64(PI_FP64,\n    log_fp64(tan_fp64(sum_fp64(PI_4_FP64, radians_fp64(lnglat_fp64.zw) / 2.0))));\n  return;\n}\n\nvoid project_position_fp64(vec4 position_fp64, out vec2 out_val[2]) {\n\n  vec2 pos_fp64[2];\n  mercatorProject_fp64(position_fp64, pos_fp64);\n  vec2 x_fp64 = mul_fp64(pos_fp64[0], projectionScaleFP64);\n  vec2 y_fp64 = mul_fp64(pos_fp64[1], projectionScaleFP64);\n  out_val[0] = mul_fp64(x_fp64, WORLD_SCALE_FP64);\n  out_val[1] = mul_fp64(y_fp64, WORLD_SCALE_FP64);\n\n  return;\n}\n\nvec4 project_to_clipspace_fp64(vec2 vertex_pos_modelspace[4]) {\n  vec2 vertex_pos_clipspace[4];\n  mat4_vec4_mul_fp64(projectionFP64, vertex_pos_modelspace, vertex_pos_clipspace);\n  return vec4(\n    vertex_pos_clipspace[0].x,\n    vertex_pos_clipspace[1].x,\n    vertex_pos_clipspace[2].x,\n    vertex_pos_clipspace[3].x\n    );\n}\n`;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcmxpYi9wcm9qZWN0NjQvcHJvamVjdDY0Lmdsc2wuanM/NjgyYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTYgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQgZGVmYXVsdCBgXFxcblxuY29uc3QgdmVjMiBXT1JMRF9TQ0FMRV9GUDY0ID0gdmVjMig4MS40ODczMjc1NzU2ODM2LCAwLjAwMDAwMzI4NzM2NjgyMzIwMTQwOTcpO1xuXG51bmlmb3JtIHZlYzIgcHJvamVjdGlvblNjYWxlRlA2NDtcbnVuaWZvcm0gdmVjMiBwcm9qZWN0aW9uRlA2NFsxNl07XG5cbi8vIGxvbmdpdHVkZTogbG5nbGF0X2ZwNjQueHk7IGxhdGl0dWRlOiBsbmdsYXRfZnA2NC56d1xudm9pZCBtZXJjYXRvclByb2plY3RfZnA2NCh2ZWM0IGxuZ2xhdF9mcDY0LCBvdXQgdmVjMiBvdXRfdmFsWzJdKSB7XG5cbiNpZiBkZWZpbmVkKE5WSURJQV9GUDY0X1dPUktBUk9VTkQpXG4gIG91dF92YWxbMF0gPSBzdW1fZnA2NChyYWRpYW5zX2ZwNjQobG5nbGF0X2ZwNjQueHkpLCBQSV9GUDY0ICogT05FKTtcbiNlbHNlXG4gIG91dF92YWxbMF0gPSBzdW1fZnA2NChyYWRpYW5zX2ZwNjQobG5nbGF0X2ZwNjQueHkpLCBQSV9GUDY0KTtcbiNlbmRpZlxuICBvdXRfdmFsWzFdID0gc3ViX2ZwNjQoUElfRlA2NCxcbiAgICBsb2dfZnA2NCh0YW5fZnA2NChzdW1fZnA2NChQSV80X0ZQNjQsIHJhZGlhbnNfZnA2NChsbmdsYXRfZnA2NC56dykgLyAyLjApKSkpO1xuICByZXR1cm47XG59XG5cbnZvaWQgcHJvamVjdF9wb3NpdGlvbl9mcDY0KHZlYzQgcG9zaXRpb25fZnA2NCwgb3V0IHZlYzIgb3V0X3ZhbFsyXSkge1xuXG4gIHZlYzIgcG9zX2ZwNjRbMl07XG4gIG1lcmNhdG9yUHJvamVjdF9mcDY0KHBvc2l0aW9uX2ZwNjQsIHBvc19mcDY0KTtcbiAgdmVjMiB4X2ZwNjQgPSBtdWxfZnA2NChwb3NfZnA2NFswXSwgcHJvamVjdGlvblNjYWxlRlA2NCk7XG4gIHZlYzIgeV9mcDY0ID0gbXVsX2ZwNjQocG9zX2ZwNjRbMV0sIHByb2plY3Rpb25TY2FsZUZQNjQpO1xuICBvdXRfdmFsWzBdID0gbXVsX2ZwNjQoeF9mcDY0LCBXT1JMRF9TQ0FMRV9GUDY0KTtcbiAgb3V0X3ZhbFsxXSA9IG11bF9mcDY0KHlfZnA2NCwgV09STERfU0NBTEVfRlA2NCk7XG5cbiAgcmV0dXJuO1xufVxuXG52ZWM0IHByb2plY3RfdG9fY2xpcHNwYWNlX2ZwNjQodmVjMiB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbNF0pIHtcbiAgdmVjMiB2ZXJ0ZXhfcG9zX2NsaXBzcGFjZVs0XTtcbiAgbWF0NF92ZWM0X211bF9mcDY0KHByb2plY3Rpb25GUDY0LCB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2UsIHZlcnRleF9wb3NfY2xpcHNwYWNlKTtcbiAgcmV0dXJuIHZlYzQoXG4gICAgdmVydGV4X3Bvc19jbGlwc3BhY2VbMF0ueCxcbiAgICB2ZXJ0ZXhfcG9zX2NsaXBzcGFjZVsxXS54LFxuICAgIHZlcnRleF9wb3NfY2xpcHNwYWNlWzJdLngsXG4gICAgdmVydGV4X3Bvc19jbGlwc3BhY2VbM10ueFxuICAgICk7XG59XG5gO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvc2hhZGVybGliL3Byb2plY3Q2NC9wcm9qZWN0NjQuZ2xzbC5qc1xuLy8gbW9kdWxlIGlkID0gMTE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 115 */
/* unknown exports provided */
/* exports used: log */
/*!********************!*\
  !*** external "." ***!
  \********************/
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_115__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiLlwiPzBmNDciXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzExNV9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiLlwiXG4vLyBtb2R1bGUgaWQgPSAxMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 116 */
/* unknown exports provided */
/* exports used: COORDINATE_SYSTEM */
/*!*********************!*\
  !*** external ".." ***!
  \*********************/
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_116__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiLi5cIj82MTUwIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xMTZfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcIi4uXCJcbi8vIG1vZHVsZSBpZCA9IDExNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 117 */
/* unknown exports provided */
/* exports used: hexbin */
/*!****************************!*\
  !*** external "d3-hexbin" ***!
  \****************************/
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_117__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZDMtaGV4YmluXCI/Njc5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMTE3X187XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJkMy1oZXhiaW5cIlxuLy8gbW9kdWxlIGlkID0gMTE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 118 */
/* exports provided: assembleShaders, Layer, CompositeLayer, LayerManager, AttributeManager, COORDINATE_SYSTEM, Viewport, PerspectiveViewport, OrthographicViewport, WebMercatorViewport, ArcLayer, IconLayer, LineLayer, PointCloudLayer, ScatterplotLayer, ScreenGridLayer, GridLayer, GridCellLayer, HexagonLayer, HexagonCellLayer, PathLayer, PolygonLayer, GeoJsonLayer, ChoroplethLayer, ChoroplethLayer64, ExtrudedChoroplethLayer64, DeckGL, default, experimental */
/* all exports used */
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_utils__ = __webpack_require__(/*! ./shader-utils */ 3);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"assembleShaders\", function() { return __WEBPACK_IMPORTED_MODULE_0__shader_utils__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib__ = __webpack_require__(/*! ./lib */ 0);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"Layer\", function() { return __WEBPACK_IMPORTED_MODULE_1__lib__[\"a\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"CompositeLayer\", function() { return __WEBPACK_IMPORTED_MODULE_1__lib__[\"b\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"LayerManager\", function() { return __WEBPACK_IMPORTED_MODULE_1__lib__[\"c\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"AttributeManager\", function() { return __WEBPACK_IMPORTED_MODULE_1__lib__[\"d\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"COORDINATE_SYSTEM\", function() { return __WEBPACK_IMPORTED_MODULE_1__lib__[\"e\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_viewports_viewport__ = __webpack_require__(/*! ./lib/viewports/viewport */ 5);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"Viewport\", function() { return __WEBPACK_IMPORTED_MODULE_2__lib_viewports_viewport__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_viewports_perspective_viewport__ = __webpack_require__(/*! ./lib/viewports/perspective-viewport */ 24);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"PerspectiveViewport\", function() { return __WEBPACK_IMPORTED_MODULE_3__lib_viewports_perspective_viewport__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__lib_viewports_orthographic_viewport__ = __webpack_require__(/*! ./lib/viewports/orthographic-viewport */ 23);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"OrthographicViewport\", function() { return __WEBPACK_IMPORTED_MODULE_4__lib_viewports_orthographic_viewport__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__lib_viewports_web_mercator_viewport__ = __webpack_require__(/*! ./lib/viewports/web-mercator-viewport */ 25);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"WebMercatorViewport\", function() { return __WEBPACK_IMPORTED_MODULE_5__lib_viewports_web_mercator_viewport__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__layers_core_arc_layer_arc_layer__ = __webpack_require__(/*! ./layers/core/arc-layer/arc-layer */ 35);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"ArcLayer\", function() { return __WEBPACK_IMPORTED_MODULE_6__layers_core_arc_layer_arc_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__layers_core_icon_layer_icon_layer__ = __webpack_require__(/*! ./layers/core/icon-layer/icon-layer */ 39);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"IconLayer\", function() { return __WEBPACK_IMPORTED_MODULE_7__layers_core_icon_layer_icon_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__layers_core_line_layer_line_layer__ = __webpack_require__(/*! ./layers/core/line-layer/line-layer */ 40);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"LineLayer\", function() { return __WEBPACK_IMPORTED_MODULE_8__layers_core_line_layer_line_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__layers_core_point_cloud_layer_point_cloud_layer__ = __webpack_require__(/*! ./layers/core/point-cloud-layer/point-cloud-layer */ 41);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"PointCloudLayer\", function() { return __WEBPACK_IMPORTED_MODULE_9__layers_core_point_cloud_layer_point_cloud_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__layers_core_scatterplot_layer_scatterplot_layer__ = __webpack_require__(/*! ./layers/core/scatterplot-layer/scatterplot-layer */ 20);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"ScatterplotLayer\", function() { return __WEBPACK_IMPORTED_MODULE_10__layers_core_scatterplot_layer_scatterplot_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__layers_core_screen_grid_layer_screen_grid_layer__ = __webpack_require__(/*! ./layers/core/screen-grid-layer/screen-grid-layer */ 43);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"ScreenGridLayer\", function() { return __WEBPACK_IMPORTED_MODULE_11__layers_core_screen_grid_layer_screen_grid_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__layers_core_grid_layer_grid_layer__ = __webpack_require__(/*! ./layers/core/grid-layer/grid-layer */ 37);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"GridLayer\", function() { return __WEBPACK_IMPORTED_MODULE_12__layers_core_grid_layer_grid_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__layers_core_grid_cell_layer_grid_cell_layer__ = __webpack_require__(/*! ./layers/core/grid-cell-layer/grid-cell-layer */ 18);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"GridCellLayer\", function() { return __WEBPACK_IMPORTED_MODULE_13__layers_core_grid_cell_layer_grid_cell_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__layers_core_hexagon_layer_hexagon_layer__ = __webpack_require__(/*! ./layers/core/hexagon-layer/hexagon-layer */ 38);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"HexagonLayer\", function() { return __WEBPACK_IMPORTED_MODULE_14__layers_core_hexagon_layer_hexagon_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__layers_core_hexagon_cell_layer_hexagon_cell_layer__ = __webpack_require__(/*! ./layers/core/hexagon-cell-layer/hexagon-cell-layer */ 19);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"HexagonCellLayer\", function() { return __WEBPACK_IMPORTED_MODULE_15__layers_core_hexagon_cell_layer_hexagon_cell_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__layers_core_path_layer_path_layer__ = __webpack_require__(/*! ./layers/core/path-layer/path-layer */ 10);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"PathLayer\", function() { return __WEBPACK_IMPORTED_MODULE_16__layers_core_path_layer_path_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__layers_core_polygon_layer_polygon_layer__ = __webpack_require__(/*! ./layers/core/polygon-layer/polygon-layer */ 42);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"PolygonLayer\", function() { return __WEBPACK_IMPORTED_MODULE_17__layers_core_polygon_layer_polygon_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__layers_core_geojson_layer_geojson_layer__ = __webpack_require__(/*! ./layers/core/geojson-layer/geojson-layer */ 36);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"GeoJsonLayer\", function() { return __WEBPACK_IMPORTED_MODULE_18__layers_core_geojson_layer_geojson_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__layers_deprecated_choropleth_layer_choropleth_layer__ = __webpack_require__(/*! ./layers/deprecated/choropleth-layer/choropleth-layer */ 21);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"ChoroplethLayer\", function() { return __WEBPACK_IMPORTED_MODULE_19__layers_deprecated_choropleth_layer_choropleth_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__layers_deprecated_choropleth_layer_64_choropleth_layer_64__ = __webpack_require__(/*! ./layers/deprecated/choropleth-layer-64/choropleth-layer-64 */ 44);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"ChoroplethLayer64\", function() { return __WEBPACK_IMPORTED_MODULE_20__layers_deprecated_choropleth_layer_64_choropleth_layer_64__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__layers_deprecated_extruded_choropleth_layer_64_extruded_choropleth_layer_64__ = __webpack_require__(/*! ./layers/deprecated/extruded-choropleth-layer-64/extruded-choropleth-layer-64 */ 45);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"ExtrudedChoroplethLayer64\", function() { return __WEBPACK_IMPORTED_MODULE_21__layers_deprecated_extruded_choropleth_layer_64_extruded_choropleth_layer_64__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__react_deckgl__ = __webpack_require__(/*! ./react/deckgl */ 12);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"DeckGL\", function() { return __WEBPACK_IMPORTED_MODULE_22__react_deckgl__[\"a\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return __WEBPACK_IMPORTED_MODULE_22__react_deckgl__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__lib_utils_get__ = __webpack_require__(/*! ./lib/utils/get */ 11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__lib_utils_count__ = __webpack_require__(/*! ./lib/utils/count */ 22);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__experimental_lib__ = __webpack_require__(/*! ./experimental/lib */ 9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__experimental_effects_reflection_effect__ = __webpack_require__(/*! ./experimental/effects/reflection-effect */ 17);\n\t// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n/* eslint-disable max-len */\n\n// Utilities\n\n\n// Lib\n\n\n// Viewports\n\n\n\n\n\n// Core Layers\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Deprecated Layers\n\n\n\n\n// React exports\n\n\n\n// Experimental Features (May change in minor version bumps, use at your own risk)\n\n\n\n\n\nconst experimental = {\n  get: __WEBPACK_IMPORTED_MODULE_23__lib_utils_get__[\"a\" /* get */],\n  count: __WEBPACK_IMPORTED_MODULE_24__lib_utils_count__[\"a\" /* count */],\n  EffectManager: __WEBPACK_IMPORTED_MODULE_25__experimental_lib__[\"a\" /* EffectManager */],\n  Effect: __WEBPACK_IMPORTED_MODULE_25__experimental_lib__[\"b\" /* Effect */],\n  ReflectionEffect: __WEBPACK_IMPORTED_MODULE_26__experimental_effects_reflection_effect__[\"a\" /* default */]\n};\n/* harmony export (immutable) */ __webpack_exports__[\"experimental\"] = experimental;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzPzk1NTIiXSwic291cmNlc0NvbnRlbnQiOlsiXHQvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vLyBVdGlsaXRpZXNcbmV4cG9ydCB7YXNzZW1ibGVTaGFkZXJzfSBmcm9tICcuL3NoYWRlci11dGlscyc7XG5cbi8vIExpYlxuZXhwb3J0IHtMYXllciwgQ29tcG9zaXRlTGF5ZXIsIExheWVyTWFuYWdlciwgQXR0cmlidXRlTWFuYWdlcn0gZnJvbSAnLi9saWInO1xuZXhwb3J0IHtDT09SRElOQVRFX1NZU1RFTX0gZnJvbSAnLi9saWInO1xuLy8gVmlld3BvcnRzXG5leHBvcnQge2RlZmF1bHQgYXMgVmlld3BvcnR9IGZyb20gJy4vbGliL3ZpZXdwb3J0cy92aWV3cG9ydCc7XG5leHBvcnQge2RlZmF1bHQgYXMgUGVyc3BlY3RpdmVWaWV3cG9ydH0gZnJvbSAnLi9saWIvdmlld3BvcnRzL3BlcnNwZWN0aXZlLXZpZXdwb3J0JztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBPcnRob2dyYXBoaWNWaWV3cG9ydH0gZnJvbSAnLi9saWIvdmlld3BvcnRzL29ydGhvZ3JhcGhpYy12aWV3cG9ydCc7XG5leHBvcnQge2RlZmF1bHQgYXMgV2ViTWVyY2F0b3JWaWV3cG9ydH0gZnJvbSAnLi9saWIvdmlld3BvcnRzL3dlYi1tZXJjYXRvci12aWV3cG9ydCc7XG5cbi8vIENvcmUgTGF5ZXJzXG5leHBvcnQge2RlZmF1bHQgYXMgQXJjTGF5ZXJ9IGZyb20gJy4vbGF5ZXJzL2NvcmUvYXJjLWxheWVyL2FyYy1sYXllcic7XG5leHBvcnQge2RlZmF1bHQgYXMgSWNvbkxheWVyfSBmcm9tICcuL2xheWVycy9jb3JlL2ljb24tbGF5ZXIvaWNvbi1sYXllcic7XG5leHBvcnQge2RlZmF1bHQgYXMgTGluZUxheWVyfSBmcm9tICcuL2xheWVycy9jb3JlL2xpbmUtbGF5ZXIvbGluZS1sYXllcic7XG5leHBvcnQge2RlZmF1bHQgYXMgUG9pbnRDbG91ZExheWVyfSBmcm9tICcuL2xheWVycy9jb3JlL3BvaW50LWNsb3VkLWxheWVyL3BvaW50LWNsb3VkLWxheWVyJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBTY2F0dGVycGxvdExheWVyfSBmcm9tICcuL2xheWVycy9jb3JlL3NjYXR0ZXJwbG90LWxheWVyL3NjYXR0ZXJwbG90LWxheWVyJztcblxuZXhwb3J0IHtkZWZhdWx0IGFzIFNjcmVlbkdyaWRMYXllcn0gZnJvbSAnLi9sYXllcnMvY29yZS9zY3JlZW4tZ3JpZC1sYXllci9zY3JlZW4tZ3JpZC1sYXllcic7XG5leHBvcnQge2RlZmF1bHQgYXMgR3JpZExheWVyfSBmcm9tICcuL2xheWVycy9jb3JlL2dyaWQtbGF5ZXIvZ3JpZC1sYXllcic7XG5leHBvcnQge2RlZmF1bHQgYXMgR3JpZENlbGxMYXllcn0gZnJvbSAnLi9sYXllcnMvY29yZS9ncmlkLWNlbGwtbGF5ZXIvZ3JpZC1jZWxsLWxheWVyJztcblxuZXhwb3J0IHtkZWZhdWx0IGFzIEhleGFnb25MYXllcn0gZnJvbSAnLi9sYXllcnMvY29yZS9oZXhhZ29uLWxheWVyL2hleGFnb24tbGF5ZXInO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEhleGFnb25DZWxsTGF5ZXJ9IGZyb20gJy4vbGF5ZXJzL2NvcmUvaGV4YWdvbi1jZWxsLWxheWVyL2hleGFnb24tY2VsbC1sYXllcic7XG5cbmV4cG9ydCB7ZGVmYXVsdCBhcyBQYXRoTGF5ZXJ9IGZyb20gJy4vbGF5ZXJzL2NvcmUvcGF0aC1sYXllci9wYXRoLWxheWVyJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBQb2x5Z29uTGF5ZXJ9IGZyb20gJy4vbGF5ZXJzL2NvcmUvcG9seWdvbi1sYXllci9wb2x5Z29uLWxheWVyJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBHZW9Kc29uTGF5ZXJ9IGZyb20gJy4vbGF5ZXJzL2NvcmUvZ2VvanNvbi1sYXllci9nZW9qc29uLWxheWVyJztcblxuLy8gRGVwcmVjYXRlZCBMYXllcnNcbmV4cG9ydCB7ZGVmYXVsdCBhcyBDaG9yb3BsZXRoTGF5ZXJ9IGZyb20gJy4vbGF5ZXJzL2RlcHJlY2F0ZWQvY2hvcm9wbGV0aC1sYXllci9jaG9yb3BsZXRoLWxheWVyJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBDaG9yb3BsZXRoTGF5ZXI2NH0gZnJvbSAnLi9sYXllcnMvZGVwcmVjYXRlZC9jaG9yb3BsZXRoLWxheWVyLTY0L2Nob3JvcGxldGgtbGF5ZXItNjQnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEV4dHJ1ZGVkQ2hvcm9wbGV0aExheWVyNjR9IGZyb20gJy4vbGF5ZXJzL2RlcHJlY2F0ZWQvZXh0cnVkZWQtY2hvcm9wbGV0aC1sYXllci02NC9leHRydWRlZC1jaG9yb3BsZXRoLWxheWVyLTY0JztcblxuLy8gUmVhY3QgZXhwb3J0c1xuZXhwb3J0IHtkZWZhdWx0IGFzIERlY2tHTH0gZnJvbSAnLi9yZWFjdC9kZWNrZ2wnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGRlZmF1bHR9IGZyb20gJy4vcmVhY3QvZGVja2dsJztcblxuLy8gRXhwZXJpbWVudGFsIEZlYXR1cmVzIChNYXkgY2hhbmdlIGluIG1pbm9yIHZlcnNpb24gYnVtcHMsIHVzZSBhdCB5b3VyIG93biByaXNrKVxuaW1wb3J0IHtnZXR9IGZyb20gJy4vbGliL3V0aWxzL2dldCc7XG5pbXBvcnQge2NvdW50fSBmcm9tICcuL2xpYi91dGlscy9jb3VudCc7XG5pbXBvcnQge0VmZmVjdE1hbmFnZXIsIEVmZmVjdH0gZnJvbSAnLi9leHBlcmltZW50YWwvbGliJztcbmltcG9ydCB7ZGVmYXVsdCBhcyBSZWZsZWN0aW9uRWZmZWN0fSBmcm9tICcuL2V4cGVyaW1lbnRhbC9lZmZlY3RzL3JlZmxlY3Rpb24tZWZmZWN0JztcblxuZXhwb3J0IGNvbnN0IGV4cGVyaW1lbnRhbCA9IHtcbiAgZ2V0LFxuICBjb3VudCxcbiAgRWZmZWN0TWFuYWdlcixcbiAgRWZmZWN0LFxuICBSZWZsZWN0aW9uRWZmZWN0XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDExOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ })
/******/ ]);
});