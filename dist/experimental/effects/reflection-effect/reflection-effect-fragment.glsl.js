"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
// Copyright (c) 2015 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

exports.default = "#define SHADER_NAME reflection-effect-fs\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform sampler2D reflectionTexture;\nuniform int reflectionTextureWidth;\nuniform int reflectionTextureHeight;\n\nuniform float reflectivity;\nuniform float blur;\n\n\nvarying vec2 uv;\n\n#define KERNEL_SIZE 7\n\n/*\n * Samples from tex with a gaussian-shaped patch, centered at uv and\n * with standard deviation sigma.  The size of the texture in\n * pixels must be specified by dim\n */\nvec4 sample_gaussian(sampler2D tex, vec2 dim, vec2 uv, float sigma) {\n  if (sigma == 0.0) {\n    return texture2D(tex, uv);\n  }\n\n  vec2 delta = 1.0 / dim;\n  vec2 top_left = uv - delta * float(KERNEL_SIZE+1) / 2.0;\n\n  vec4 color = vec4(0);\n  float sum = 0.0;\n  for (int i = 0; i <  KERNEL_SIZE; ++i) {\n    for (int j = 0; j < KERNEL_SIZE; ++j) {\n      vec2 uv2 = top_left + vec2(i, j) * delta;\n      float d = length((uv2 - uv) * dim);\n      float f = exp(-(d*d) / (2.0*sigma * sigma));\n      color += f * texture2D(tex, uv2);\n      sum += f;\n    }\n  }\n  return color / sum;\n}\n\nvoid main(void) {\n  //map blur in [0, 1] to sigma in [0, inf]\n  //alpha will determine the \"steepness\" of our curve.\n  //this was picked just to make the scale feel \"natural\"\n  //if our image is 1000 pixels wide, a blur of 0.5 should correspond\n  //to a sigma of 1 pixels\n  float alpha = 1000.0;\n  float sigma = blur / (alpha * (1.0 - blur));\n  //let this be our standard deviation in terms of screen-widths.\n  //rewrite this in terms of pixels.\n  sigma *= float(reflectionTextureWidth);\n\n\n  gl_FragColor = sample_gaussian(reflectionTexture, vec2(reflectionTextureWidth,\n    reflectionTextureHeight), vec2(uv.x, 1. - uv.y), sigma);\n  //because our canvas expects alphas to be pre-multiplied, we multiply by whole\n  //color vector by reflectivity, not just the alpha channel\n  gl_FragColor *= reflectivity;\n}\n";
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9leHBlcmltZW50YWwvZWZmZWN0cy9yZWZsZWN0aW9uLWVmZmVjdC9yZWZsZWN0aW9uLWVmZmVjdC1mcmFnbWVudC5nbHNsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoicmVmbGVjdGlvbi1lZmZlY3QtZnJhZ21lbnQuZ2xzbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmV4cG9ydCBkZWZhdWx0IGBcXFxuI2RlZmluZSBTSEFERVJfTkFNRSByZWZsZWN0aW9uLWVmZmVjdC1mc1xuXG4jaWZkZWYgR0xfRVNcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiNlbmRpZlxuXG51bmlmb3JtIHNhbXBsZXIyRCByZWZsZWN0aW9uVGV4dHVyZTtcbnVuaWZvcm0gaW50IHJlZmxlY3Rpb25UZXh0dXJlV2lkdGg7XG51bmlmb3JtIGludCByZWZsZWN0aW9uVGV4dHVyZUhlaWdodDtcblxudW5pZm9ybSBmbG9hdCByZWZsZWN0aXZpdHk7XG51bmlmb3JtIGZsb2F0IGJsdXI7XG5cblxudmFyeWluZyB2ZWMyIHV2O1xuXG4jZGVmaW5lIEtFUk5FTF9TSVpFIDdcblxuLypcbiAqIFNhbXBsZXMgZnJvbSB0ZXggd2l0aCBhIGdhdXNzaWFuLXNoYXBlZCBwYXRjaCwgY2VudGVyZWQgYXQgdXYgYW5kXG4gKiB3aXRoIHN0YW5kYXJkIGRldmlhdGlvbiBzaWdtYS4gIFRoZSBzaXplIG9mIHRoZSB0ZXh0dXJlIGluXG4gKiBwaXhlbHMgbXVzdCBiZSBzcGVjaWZpZWQgYnkgZGltXG4gKi9cbnZlYzQgc2FtcGxlX2dhdXNzaWFuKHNhbXBsZXIyRCB0ZXgsIHZlYzIgZGltLCB2ZWMyIHV2LCBmbG9hdCBzaWdtYSkge1xuICBpZiAoc2lnbWEgPT0gMC4wKSB7XG4gICAgcmV0dXJuIHRleHR1cmUyRCh0ZXgsIHV2KTtcbiAgfVxuXG4gIHZlYzIgZGVsdGEgPSAxLjAgLyBkaW07XG4gIHZlYzIgdG9wX2xlZnQgPSB1diAtIGRlbHRhICogZmxvYXQoS0VSTkVMX1NJWkUrMSkgLyAyLjA7XG5cbiAgdmVjNCBjb2xvciA9IHZlYzQoMCk7XG4gIGZsb2F0IHN1bSA9IDAuMDtcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCAgS0VSTkVMX1NJWkU7ICsraSkge1xuICAgIGZvciAoaW50IGogPSAwOyBqIDwgS0VSTkVMX1NJWkU7ICsraikge1xuICAgICAgdmVjMiB1djIgPSB0b3BfbGVmdCArIHZlYzIoaSwgaikgKiBkZWx0YTtcbiAgICAgIGZsb2F0IGQgPSBsZW5ndGgoKHV2MiAtIHV2KSAqIGRpbSk7XG4gICAgICBmbG9hdCBmID0gZXhwKC0oZCpkKSAvICgyLjAqc2lnbWEgKiBzaWdtYSkpO1xuICAgICAgY29sb3IgKz0gZiAqIHRleHR1cmUyRCh0ZXgsIHV2Mik7XG4gICAgICBzdW0gKz0gZjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbG9yIC8gc3VtO1xufVxuXG52b2lkIG1haW4odm9pZCkge1xuICAvL21hcCBibHVyIGluIFswLCAxXSB0byBzaWdtYSBpbiBbMCwgaW5mXVxuICAvL2FscGhhIHdpbGwgZGV0ZXJtaW5lIHRoZSBcInN0ZWVwbmVzc1wiIG9mIG91ciBjdXJ2ZS5cbiAgLy90aGlzIHdhcyBwaWNrZWQganVzdCB0byBtYWtlIHRoZSBzY2FsZSBmZWVsIFwibmF0dXJhbFwiXG4gIC8vaWYgb3VyIGltYWdlIGlzIDEwMDAgcGl4ZWxzIHdpZGUsIGEgYmx1ciBvZiAwLjUgc2hvdWxkIGNvcnJlc3BvbmRcbiAgLy90byBhIHNpZ21hIG9mIDEgcGl4ZWxzXG4gIGZsb2F0IGFscGhhID0gMTAwMC4wO1xuICBmbG9hdCBzaWdtYSA9IGJsdXIgLyAoYWxwaGEgKiAoMS4wIC0gYmx1cikpO1xuICAvL2xldCB0aGlzIGJlIG91ciBzdGFuZGFyZCBkZXZpYXRpb24gaW4gdGVybXMgb2Ygc2NyZWVuLXdpZHRocy5cbiAgLy9yZXdyaXRlIHRoaXMgaW4gdGVybXMgb2YgcGl4ZWxzLlxuICBzaWdtYSAqPSBmbG9hdChyZWZsZWN0aW9uVGV4dHVyZVdpZHRoKTtcblxuXG4gIGdsX0ZyYWdDb2xvciA9IHNhbXBsZV9nYXVzc2lhbihyZWZsZWN0aW9uVGV4dHVyZSwgdmVjMihyZWZsZWN0aW9uVGV4dHVyZVdpZHRoLFxuICAgIHJlZmxlY3Rpb25UZXh0dXJlSGVpZ2h0KSwgdmVjMih1di54LCAxLiAtIHV2LnkpLCBzaWdtYSk7XG4gIC8vYmVjYXVzZSBvdXIgY2FudmFzIGV4cGVjdHMgYWxwaGFzIHRvIGJlIHByZS1tdWx0aXBsaWVkLCB3ZSBtdWx0aXBseSBieSB3aG9sZVxuICAvL2NvbG9yIHZlY3RvciBieSByZWZsZWN0aXZpdHksIG5vdCBqdXN0IHRoZSBhbHBoYSBjaGFubmVsXG4gIGdsX0ZyYWdDb2xvciAqPSByZWZsZWN0aXZpdHk7XG59XG5gO1xuIl19